Index: src/viewport_func.h
===================================================================
--- src/viewport_func.h	(revision 24093)
+++ src/viewport_func.h	(working copy)
@@ -16,6 +16,7 @@
 #include "viewport_type.h"
 #include "window_type.h"
 #include "tile_type.h"
+#include "station_type.h"
 
 static const int TILE_HEIGHT_STEP = 50; ///< One Z unit tile height difference is displayed as 50m.
 
@@ -67,6 +68,8 @@
 bool ScrollWindowToTile(TileIndex tile, Window *w, bool instant = false);
 bool ScrollWindowTo(int x, int y, int z, Window *w, bool instant = false);
 
+void RebuildViewportOverlay(Window *w);
+
 bool ScrollMainWindowToTile(TileIndex tile, bool instant = false);
 bool ScrollMainWindowTo(int x, int y, int z = -1, bool instant = false);
 
@@ -76,4 +79,6 @@
 
 void MarkTileDirtyByTile(TileIndex tile);
 
+Point GetViewportStationMiddle(const ViewPort *vp, const Station *st);
+
 #endif /* VIEWPORT_FUNC_H */
Index: src/settings.cpp
===================================================================
--- src/settings.cpp	(revision 24093)
+++ src/settings.cpp	(working copy)
@@ -1715,7 +1715,7 @@
 	delete ini;
 }
 
-static const SettingDesc *GetSettingDescription(uint index)
+const SettingDesc *GetSettingDescription(uint index)
 {
 	if (index >= lengthof(_settings)) return NULL;
 	return &_settings[index];
Index: src/toolbar_gui.cpp
===================================================================
--- src/toolbar_gui.cpp	(revision 24093)
+++ src/toolbar_gui.cpp	(working copy)
@@ -38,6 +38,7 @@
 #include "smallmap_gui.h"
 #include "graph_gui.h"
 #include "textbuf_gui.h"
+#include "linkgraph_gui.h"
 #include "newgrf_debug.h"
 #include "hotkeys.h"
 #include "engine_base.h"
@@ -407,10 +408,11 @@
 enum MapMenuEntries {
 	MME_SHOW_SMALLMAP        = 0,
 	MME_SHOW_EXTRAVIEWPORTS,
+	MME_SHOW_LINKGRAPH,
 	MME_SHOW_SIGNLISTS,
 	MME_SHOW_TOWNDIRECTORY,    ///< This entry is only used in Editor mode
-	MME_MENUCOUNT_NORMAL     = 3,
-	MME_MENUCOUNT_EDITOR     = 4,
+	MME_MENUCOUNT_NORMAL     = 4,
+	MME_MENUCOUNT_EDITOR     = 5,
 };
 
 static CallBackFunction ToolbarMapClick(Window *w)
@@ -436,6 +438,7 @@
 	switch (index) {
 		case MME_SHOW_SMALLMAP:       ShowSmallMap();            break;
 		case MME_SHOW_EXTRAVIEWPORTS: ShowExtraViewPortWindow(); break;
+		case MME_SHOW_LINKGRAPH:      ShowLinkGraphLegend();     break;
 		case MME_SHOW_SIGNLISTS:      ShowSignList();            break;
 		case MME_SHOW_TOWNDIRECTORY:  if (_game_mode == GM_EDITOR) ShowTownDirectory(); break;
 	}
Index: src/train.h
===================================================================
--- src/train.h	(revision 24093)
+++ src/train.h	(working copy)
@@ -103,6 +103,9 @@
 	int GetDisplayImageWidth(Point *offset = NULL) const;
 	bool IsInDepot() const;
 	bool IsStoppedInDepot() const;
+	// MYGUI
+	Money CalculateCurrentOverallValue() const;
+	// ENDMYGUI
 	bool Tick();
 	void OnNewDay();
 	uint Crash(bool flooded = false);
@@ -146,6 +149,13 @@
 		return v;
 	}
 
+	// MYGUI
+	inline Train *GetLastUnit() {
+		Train *tmp = this;
+		while ( tmp->GetNextUnit() ) tmp = tmp->GetNextUnit();
+		return tmp;
+	}
+
 	/**
 	 * Calculate the offset from this vehicle's center to the following center taking the vehicle lengths into account.
 	 * @return Offset from center to center.
@@ -319,6 +329,16 @@
 	}
 };
 
+
+// TODO
+CommandCost CmdBuildRailVehicle(TileIndex, DoCommandFlag, const Engine *, uint16, Vehicle**);
+CommandCost CmdMoveRailVehicle(TileIndex, DoCommandFlag , uint32, uint32, const char *);
+CommandCost CmdMoveVirtualRailVehicle(TileIndex, DoCommandFlag, uint32, uint32, const char*);
+
+Train* CmdBuildVirtualRailWagon(const Engine*);
+Train* CmdBuildVirtualRailVehicle(EngineID);
+CommandCost CmdSellRailWagon(DoCommandFlag, Vehicle*, uint16, uint32);
+
 #define FOR_ALL_TRAINS(var) FOR_ALL_VEHICLES_OF_TYPE(Train, var)
 
 #endif /* TRAIN_H */
Index: src/viewport_type.h
===================================================================
--- src/viewport_type.h	(revision 24093)
+++ src/viewport_type.h	(working copy)
@@ -15,6 +15,8 @@
 #include "zoom_type.h"
 #include "strings_type.h"
 
+class LinkGraphOverlay;
+
 /**
  * Data structure for viewport, display of a part of the world
  */
@@ -30,6 +32,7 @@
 	int virtual_height;  ///< height << zoom
 
 	ZoomLevel zoom; ///< The zoom level of the viewport.
+	LinkGraphOverlay *overlay;
 };
 
 /** Margings for the viewport sign */
Index: src/lang/german.txt
===================================================================
--- src/lang/german.txt	(revision 24093)
+++ src/lang/german.txt	(working copy)
@@ -2728,7 +2728,7 @@
 
 STR_STATION_VIEW_RATINGS_BUTTON                                 :{BLACK}Bewertung
 STR_STATION_VIEW_RATINGS_TOOLTIP                                :{BLACK}Stationsbewertung anzeigen
-STR_STATION_VIEW_CARGO_RATINGS_TITLE                            :{BLACK}Örtliche Bewertung der Dienstleistungen:
+STR_STATION_VIEW_CARGO_RATINGS_TITLE                            :{BLACK}Monatliche Versorgung and örtlicher Anteil:
 STR_STATION_VIEW_CARGO_RATING                                   :{WHITE}{STRING}: {YELLOW}{STRING} ({COMMA}%)
 
 ############ range for rating starts
@@ -4481,3 +4481,65 @@
 STR_SHIP                                                        :{BLACK}{SHIP}
 
 STR_TOOLBAR_RAILTYPE_VELOCITY                                   :{STRING} ({VELOCITY})
+
+STR_TOOLTIP_GROUP_ORDER                                         :{BLACK}Gruppierung wählen
+STR_MAP_MENU_LINGRAPH_LEGEND                                    :Verbindungsanzeige
+STR_SMALLMAP_TYPE_ROUTEMAP                                      :Verbindungsstatistik
+STR_SMALLMAP_TOOLTIP_SHOW_LINK_STATS_ON_MAP                     :{BLACK}Zeige Verbindungsstatistik auf der Karte
+STR_SMALLMAP_TOOLTIP_CARGO_SELECTION                            :{BLACK}Klicke auf einen Frachttyp um seine Daten auf der Kate anzuzeigen.
+STR_SMALLMAP_LINKSTATS                                          :{TINY_FONT}{STRING}
+STR_SMALLMAP_TOOLTIP_DISABLE_ALL_CARGOS                         :{BLACK}Blendet alle Frachttypen auf der Karte aus
+STR_SMALLMAP_TOOLTIP_ENABLE_ALL_CARGOS                          :{BLACK}Zeigt alle Frachttypen auf der Karte
+STR_CONFIG_SETTING_LINKGRAPH_INTERVAL                           :{LTBLUE}Neuberechnung der Verbindungsanzeige alle: {ORANGE}{STRING} Tage
+STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC                       :symmetrisch
+STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC                      :asymmetrisch
+STR_CONFIG_SETTING_DISTRIBUTION_MANUAL                          :manuell
+STR_CONFIG_SETTING_DISTRIBUTION_PAX                             :{LTBLUE}Verteilungsschema für Passagiere: {ORANGE}{STRING}
+STR_CONFIG_SETTING_DISTRIBUTION_MAIL                            :{LTBLUE}Verteilungsschema für Post: {ORANGE}{STRING}
+STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED                        :{LTBLUE}Verteilungsschema für Werttransporte: {ORANGE}{STRING}
+STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT                         :{LTBLUE}Verteilungsschema für sonstige Frachtarten: {ORANGE}{STRING}
+STR_CONFIG_SETTING_LINKGRAPH_ACCURACY                           :{LTBLUE}Genauigkeit für die Berechnung der Verbindsanzeige: {ORANGE}{STRING}
+STR_CONFIG_SETTING_DEMAND_DISTANCE                              :{LTBLUE}Einfluss der Entfernung auf Transportnachfrage: {ORANGE}{STRING}%
+STR_CONFIG_SETTING_DEMAND_SIZE                                  :{LTBLUE}Einfluss der Beliebtheit der Zielhaltestelle auf die Transportnachfrage bei symmetrischen Verbindungen: {ORANGE}{STRING}%
+STR_CONFIG_SETTING_SHORT_PATH_SATURATION                        :{LTBLUE}Auslastung der kürzeren Verbindungenen bevor längere Verbindungen mit freien Kapazitäten gewählt werden: {ORANGE}{STRING}%
+
+STR_CONFIG_SETTING_LINKGRAPH                                    :{ORANGE}Warenverteilung
+# Linkgraph legend window
+STR_LINKGRAPH_LEGEND_CAPTION                                    :{BLACK}Verbindungslegende
+STR_LINKGRAPH_LEGEND_ALL                                        :{BLACK}Alle
+STR_LINKGRAPH_LEGEND_NONE                                       :{BLACK}Keine
+STR_LINKGRAPH_LEGEND_SELECT_COMPANIES                           :{BLACK}Ausgewählte Unternehmen anzeigen
+
+# Linkgraph legend window and linkgraph legend in smallmap
+STR_LINKGRAPH_LEGEND_UNUSED                                     :{TINY_FONT}{BLACK}ungenutzt
+STR_LINKGRAPH_LEGEND_SATURATED                                  :{TINY_FONT}{BLACK}ausgelastet
+STR_LINKGRAPH_LEGEND_OVERLOADED                                 :{TINY_FONT}{BLACK}überlastet
+
+STR_STATION_VIEW_CARGO_SUPPLY_RATING                            :{WHITE}{STRING}: {YELLOW}{COMMA} / {STRING} ({COMMA}%)
+
+STR_STATION_VIEW_GROUP                                          :{BLACK}Gruppieren nach
+STR_STATION_VIEW_WAITING_STATION                                :Station: Wartend
+STR_STATION_VIEW_WAITING_AMOUNT                                 :Menge: Wartend
+STR_STATION_VIEW_PLANNED_STATION                                :Station: Voraussichtlich
+STR_STATION_VIEW_PLANNED_AMOUNT                                 :Menge: Voraussichtlich
+STR_STATION_VIEW_FROM                                           :{YELLOW}{CARGO_SHORT} von {STATION}
+STR_STATION_VIEW_VIA                                            :{YELLOW}{CARGO_SHORT} via {STATION}
+STR_STATION_VIEW_TO                                             :{YELLOW}{CARGO_SHORT} nach {STATION}
+STR_STATION_VIEW_FROM_ANY                                       :{RED}{CARGO_SHORT} von unbekannter Haltestelle
+STR_STATION_VIEW_TO_ANY                                         :{RED}{CARGO_SHORT} zu beliebiger Haltestelle
+STR_STATION_VIEW_VIA_ANY                                        :{RED}{CARGO_SHORT} via beliebiger Haltestelle
+STR_STATION_VIEW_FROM_HERE                                      :{GREEN}{CARGO_SHORT} von hier
+STR_STATION_VIEW_VIA_HERE                                       :{GREEN}{CARGO_SHORT} hier anhaltend
+STR_STATION_VIEW_TO_HERE                                        :{GREEN}{CARGO_SHORT} nach hier
+STR_STATION_VIEW_NONSTOP                                        :{YELLOW}{CARGO_SHORT} direkt
+
+STR_STATION_VIEW_GROUP_S_V_D                                    :Start-Via-Ziel
+STR_STATION_VIEW_GROUP_S_D_V                                    :Start-Ziel-Via
+STR_STATION_VIEW_GROUP_V_S_D                                    :Via-Start-Ziel
+STR_STATION_VIEW_GROUP_V_D_S                                    :Via-Ziel-Start
+STR_STATION_VIEW_GROUP_D_S_V                                    :Ziel-Start-Via
+STR_STATION_VIEW_GROUP_D_V_S                                    :Ziel-Via-Start
+STR_FEEDER_INCOME_TINY                                          :{TINY_FONT}{YELLOW}Umladen: {CURRENCY_LONG}{WHITE} / {GREEN}Einnahmen: {CURRENCY_LONG}
+STR_FEEDER_INCOME                                               :{YELLOW}Umladen: {CURRENCY_LONG}{WHITE} / {GREEN}Einnahmen: {CURRENCY_LONG}
+STR_FEEDER_COST_TINY                                            :{TINY_FONT}{YELLOW}Umladen: {CURRENCY_LONG}{WHITE} / {RED}Kosten: {CURRENCY_LONG}
+STR_FEEDER_COST                                                 :{YELLOW}Umladen: {CURRENCY_LONG}{WHITE} / {RED}Kosten: {CURRENCY_LONG}
Index: src/lang/english.txt
===================================================================
--- src/lang/english.txt	(revision 24093)
+++ src/lang/english.txt	(working copy)
@@ -220,6 +220,7 @@
 STR_LIST_FILTER_OSKTITLE                                        :{BLACK}Enter filter string
 STR_LIST_FILTER_TOOLTIP                                         :{BLACK}Enter a keyword to filter the list for
 
+STR_TOOLTIP_GROUP_ORDER                                         :{BLACK}Select grouping order
 STR_TOOLTIP_SORT_ORDER                                          :{BLACK}Select sorting order (descending/ascending)
 STR_TOOLTIP_SORT_CRITERIA                                       :{BLACK}Select sorting criteria
 STR_TOOLTIP_FILTER_CRITERIA                                     :{BLACK}Select filtering criteria
@@ -374,6 +375,7 @@
 ############ range for map menu starts
 STR_MAP_MENU_MAP_OF_WORLD                                       :Map of world
 STR_MAP_MENU_EXTRA_VIEW_PORT                                    :Extra viewport
+STR_MAP_MENU_LINGRAPH_LEGEND                                    :Cargo Flow Legend
 STR_MAP_MENU_SIGN_LIST                                          :Sign list
 ############ range for town menu starts, yet the town directory is shown in the map menu in the scenario editor
 STR_TOWN_MENU_TOWN_DIRECTORY                                    :Town directory
@@ -660,17 +662,20 @@
 STR_SMALLMAP_TYPE_CONTOURS                                      :Contours
 STR_SMALLMAP_TYPE_VEHICLES                                      :Vehicles
 STR_SMALLMAP_TYPE_INDUSTRIES                                    :Industries
+STR_SMALLMAP_TYPE_ROUTEMAP                                      :Cargo Flow
 STR_SMALLMAP_TYPE_ROUTES                                        :Routes
 STR_SMALLMAP_TYPE_VEGETATION                                    :Vegetation
 STR_SMALLMAP_TYPE_OWNERS                                        :Owners
 STR_SMALLMAP_TOOLTIP_SHOW_LAND_CONTOURS_ON_MAP                  :{BLACK}Show land contours on map
 STR_SMALLMAP_TOOLTIP_SHOW_VEHICLES_ON_MAP                       :{BLACK}Show vehicles on map
 STR_SMALLMAP_TOOLTIP_SHOW_INDUSTRIES_ON_MAP                     :{BLACK}Show industries on map
+STR_SMALLMAP_TOOLTIP_SHOW_LINK_STATS_ON_MAP                     :{BLACK}Show cargo flow on map
 STR_SMALLMAP_TOOLTIP_SHOW_TRANSPORT_ROUTES_ON                   :{BLACK}Show transport routes on map
 STR_SMALLMAP_TOOLTIP_SHOW_VEGETATION_ON_MAP                     :{BLACK}Show vegetation on map
 STR_SMALLMAP_TOOLTIP_SHOW_LAND_OWNERS_ON_MAP                    :{BLACK}Show land owners on map
 STR_SMALLMAP_TOOLTIP_INDUSTRY_SELECTION                         :{BLACK}Click on an industry type to toggle displaying it. Ctrl+Click disables all types except the selected one. Ctrl+Click on it again to enable all industry types
 STR_SMALLMAP_TOOLTIP_COMPANY_SELECTION                          :{BLACK}Click on a company to toggle displaying its property. Ctrl+Click disables all companies except the selected one. Ctrl+Click on it again to enable all companies
+STR_SMALLMAP_TOOLTIP_CARGO_SELECTION                            :{BLACK}Click on a cargo to toggle displaying its property. Ctrl+Click disables all cargos except the selected one. Ctrl+Click on it again to enable all cargos
 
 STR_SMALLMAP_LEGENDA_ROADS                                      :{TINY_FONT}{BLACK}Roads
 STR_SMALLMAP_LEGENDA_RAILROADS                                  :{TINY_FONT}{BLACK}Railways
@@ -704,6 +709,7 @@
 STR_SMALLMAP_TOOLTIP_TOGGLE_TOWN_NAMES_ON_OFF                   :{BLACK}Toggle town names on/off on map
 STR_SMALLMAP_CENTER                                             :{BLACK}Centre the smallmap on the current position
 STR_SMALLMAP_INDUSTRY                                           :{TINY_FONT}{STRING} ({NUM})
+STR_SMALLMAP_LINKSTATS                                          :{TINY_FONT}{STRING}
 STR_SMALLMAP_COMPANY                                            :{TINY_FONT}{COMPANY}
 STR_SMALLMAP_TOWN                                               :{TINY_FONT}{WHITE}{TOWN}
 STR_SMALLMAP_DISABLE_ALL                                        :{BLACK}Disable all
@@ -714,6 +720,8 @@
 STR_SMALLMAP_TOOLTIP_SHOW_HEIGHT                                :{BLACK}Toggle display of heightmap
 STR_SMALLMAP_TOOLTIP_DISABLE_ALL_COMPANIES                      :{BLACK}Display no company property on the map
 STR_SMALLMAP_TOOLTIP_ENABLE_ALL_COMPANIES                       :{BLACK}Display all company property on the map
+STR_SMALLMAP_TOOLTIP_DISABLE_ALL_CARGOS                         :{BLACK}Display no cargos on the map
+STR_SMALLMAP_TOOLTIP_ENABLE_ALL_CARGOS                          :{BLACK}Display all cargos on the map
 
 # Status bar messages
 STR_STATUSBAR_TOOLTIP_SHOW_LAST_NEWS                            :{BLACK}Show last message or news report
@@ -1350,11 +1358,25 @@
 STR_CONFIG_SETTING_CITY_SIZE_MULTIPLIER                         :{LTBLUE}Initial city size multiplier: {ORANGE}{STRING1}
 STR_CONFIG_SETTING_MODIFIED_ROAD_REBUILD                        :{LTBLUE}Remove absurd road-elements during the road construction: {ORANGE}{STRING1}
 
+STR_CONFIG_SETTING_LINKGRAPH_INTERVAL                           :{LTBLUE}Update distribution graph every {ORANGE}{STRING1} days
+STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC                       :symmetric
+STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC                      :asymmetric
+STR_CONFIG_SETTING_DISTRIBUTION_MANUAL                          :manual
+STR_CONFIG_SETTING_DISTRIBUTION_PAX                             :{LTBLUE}Distribution for passengers: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_MAIL                            :{LTBLUE}Distribution for mail: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED                        :{LTBLUE}Distribution for the ARMOURED cargo class: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT                         :{LTBLUE}Distribution for other cargo classes: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_LINKGRAPH_ACCURACY                           :{LTBLUE}Distribution accuracy: {ORANGE}{STRING1}
+STR_CONFIG_SETTING_DEMAND_DISTANCE                              :{LTBLUE}Effect of distance on demands: {ORANGE}{STRING1}%
+STR_CONFIG_SETTING_DEMAND_SIZE                                  :{LTBLUE}Effect of remote station's popularity on symmetric demands: {ORANGE}{STRING1}%
+STR_CONFIG_SETTING_SHORT_PATH_SATURATION                        :{LTBLUE}Saturation of short paths before using capacious paths: {ORANGE}{STRING1}%
+
 STR_CONFIG_SETTING_GUI                                          :{ORANGE}Interface
 STR_CONFIG_SETTING_CONSTRUCTION                                 :{ORANGE}Construction
 STR_CONFIG_SETTING_VEHICLES                                     :{ORANGE}Vehicles
 STR_CONFIG_SETTING_STATIONS                                     :{ORANGE}Stations
 STR_CONFIG_SETTING_ECONOMY                                      :{ORANGE}Economy
+STR_CONFIG_SETTING_LINKGRAPH                                    :{ORANGE}Cargo Distribution
 STR_CONFIG_SETTING_AI                                           :{ORANGE}Competitors
 STR_CONFIG_SETTING_DISPLAY_OPTIONS                              :{ORANGE}Display options
 STR_CONFIG_SETTING_INTERACTION                                  :{ORANGE}Interaction
@@ -1941,6 +1963,17 @@
 STR_TRANSPARENT_LOADING_TOOLTIP                                 :{BLACK}Toggle transparency for loading indicators. Ctrl+Click to lock
 STR_TRANSPARENT_INVISIBLE_TOOLTIP                               :{BLACK}Set objects invisible instead of transparent
 
+# Linkgraph legend window
+STR_LINKGRAPH_LEGEND_CAPTION                                    :{BLACK}Cargo Flow Legend
+STR_LINKGRAPH_LEGEND_ALL                                        :{BLACK}All
+STR_LINKGRAPH_LEGEND_NONE                                       :{BLACK}None
+STR_LINKGRAPH_LEGEND_SELECT_COMPANIES                           :{BLACK}Select companies to be displayed
+
+# Linkgraph legend window and linkgraph legend in smallmap
+STR_LINKGRAPH_LEGEND_UNUSED                                     :{TINY_FONT}{BLACK}unused
+STR_LINKGRAPH_LEGEND_SATURATED                                  :{TINY_FONT}{BLACK}saturated
+STR_LINKGRAPH_LEGEND_OVERLOADED                                 :{TINY_FONT}{BLACK}overloaded
+
 # Base for station construction window(s)
 STR_STATION_BUILD_COVERAGE_AREA_TITLE                           :{BLACK}Coverage area highlight
 STR_STATION_BUILD_COVERAGE_OFF                                  :{BLACK}Off
@@ -2727,9 +2760,33 @@
 
 STR_STATION_VIEW_RATINGS_BUTTON                                 :{BLACK}Ratings
 STR_STATION_VIEW_RATINGS_TOOLTIP                                :{BLACK}Show station ratings
-STR_STATION_VIEW_CARGO_RATINGS_TITLE                            :{BLACK}Local rating of transport service:
+STR_STATION_VIEW_CARGO_RATINGS_TITLE                            :{BLACK}Monthly supply and local rating:
 STR_STATION_VIEW_CARGO_RATING                                   :{WHITE}{STRING}: {YELLOW}{STRING} ({COMMA}%)
+STR_STATION_VIEW_CARGO_SUPPLY_RATING                            :{WHITE}{STRING}: {YELLOW}{COMMA} / {STRING} ({COMMA}%)
 
+STR_STATION_VIEW_GROUP                                          :{BLACK}Group by
+STR_STATION_VIEW_WAITING_STATION                                :Station: Waiting
+STR_STATION_VIEW_WAITING_AMOUNT                                 :Amount: Waiting
+STR_STATION_VIEW_PLANNED_STATION                                :Station: Planned
+STR_STATION_VIEW_PLANNED_AMOUNT                                 :Amount: Planned
+STR_STATION_VIEW_FROM                                           :{YELLOW}{CARGO_SHORT} from {STATION}
+STR_STATION_VIEW_VIA                                            :{YELLOW}{CARGO_SHORT} via {STATION}
+STR_STATION_VIEW_TO                                             :{YELLOW}{CARGO_SHORT} to {STATION}
+STR_STATION_VIEW_FROM_ANY                                       :{RED}{CARGO_SHORT} from unknown station
+STR_STATION_VIEW_TO_ANY                                         :{RED}{CARGO_SHORT} to any station
+STR_STATION_VIEW_VIA_ANY                                        :{RED}{CARGO_SHORT} via any station
+STR_STATION_VIEW_FROM_HERE                                      :{GREEN}{CARGO_SHORT} from this station
+STR_STATION_VIEW_VIA_HERE                                       :{GREEN}{CARGO_SHORT} stopping at this station
+STR_STATION_VIEW_TO_HERE                                        :{GREEN}{CARGO_SHORT} to this station
+STR_STATION_VIEW_NONSTOP                                        :{YELLOW}{CARGO_SHORT} non-stop
+
+STR_STATION_VIEW_GROUP_S_V_D                                    :Source-Via-Destination
+STR_STATION_VIEW_GROUP_S_D_V                                    :Source-Destination-Via
+STR_STATION_VIEW_GROUP_V_S_D                                    :Via-Source-Destination
+STR_STATION_VIEW_GROUP_V_D_S                                    :Via-Destination-Source
+STR_STATION_VIEW_GROUP_D_S_V                                    :Destination-Source-Via
+STR_STATION_VIEW_GROUP_D_V_S                                    :Destination-Via-Source
+
 ############ range for rating starts
 STR_CARGO_RATING_APPALLING                                      :Appalling
 STR_CARGO_RATING_VERY_POOR                                      :Very Poor
@@ -3596,6 +3653,10 @@
 STR_INCOME_FLOAT_INCOME                                         :{GREEN}Income: {CURRENCY_LONG}
 STR_FEEDER_TINY                                                 :{TINY_FONT}{YELLOW}Transfer: {CURRENCY_LONG}
 STR_FEEDER                                                      :{YELLOW}Transfer: {CURRENCY_LONG}
+STR_FEEDER_INCOME_TINY                                          :{TINY_FONT}{YELLOW}Transfer: {CURRENCY_LONG}{WHITE} / {GREEN}Income: {CURRENCY_LONG}
+STR_FEEDER_INCOME                                               :{YELLOW}Transfer: {CURRENCY_LONG}{WHITE} / {GREEN}Income: {CURRENCY_LONG}
+STR_FEEDER_COST_TINY                                            :{TINY_FONT}{YELLOW}Transfer: {CURRENCY_LONG}{WHITE} / {RED}Cost: {CURRENCY_LONG}
+STR_FEEDER_COST                                                 :{YELLOW}Transfer: {CURRENCY_LONG}{WHITE} / {RED}Cost: {CURRENCY_LONG}
 STR_MESSAGE_ESTIMATED_COST                                      :{WHITE}Estimated Cost: {CURRENCY_LONG}
 STR_MESSAGE_ESTIMATED_INCOME                                    :{WHITE}Estimated Income: {CURRENCY_LONG}
 
@@ -4480,3 +4541,62 @@
 STR_SHIP                                                        :{BLACK}{SHIP}
 
 STR_TOOLBAR_RAILTYPE_VELOCITY                                   :{STRING} ({VELOCITY})
+
+STR_TMPL_RPL_TITLE												:{WHITE}Template Replacement
+STR_TMPL_TEMPLATE_REPLACEMENT									:Template Replacement
+STR_TMPL_TRAINS_IN_GROUP										:{BLACK}Trains in group
+STR_TMPL_AVAILABLE_TEMPLATES									:{BLACK}Available Templates
+STR_TMPL_DEFINE_TEMPLATE										:{BLACK}New
+STR_TMPL_EDIT_TEMPLATE											:{BLACK}Edit
+STR_TMPL_CREATE_CLONE_VEH										:{BLACK}Clone
+STR_TMPL_DELETE_TEMPLATE										:{BLACK}Delete
+STR_TMPL_RPL_ALL_TMPL											:{BLACK}Replace All Templates
+STR_TMPL_NEW_VEHICLE											:{BLACK}New Vehicle
+STR_TMPL_CONFIRM												:{BLACK}Ok
+STR_TMPL_CANCEL													:{BLACK}Cancel
+STR_TMPL_NEW													:{BLACK}New Template Vehicle
+STR_TMPL_REFIT													:{BLACK}Refit
+STR_TMPL_GROUP_INFO												:{BLACK}Group Info: {ORANGE}
+STR_TMPL_TEMPLATE_INFO											:{BLACK}Template Info: {ORANGE}
+STR_TMPL_RPL_START												:{BLACK}Start replacing
+STR_TMPL_RPL_STOP												:{BLACK}Stop replacing
+STR_TMPL_TRAIN_OVR_VALUE										:{TINY_FONT}{BLACK}Train Value: {CURRENCY_SHORT}
+STR_TMPL_TEMPLATE_OVR_VALUE										:{TINY_FONT}{BLACK}Buying Cost: {GOLD}{CURRENCY_LONG}
+STR_TMPL_TEMPLATE_OVR_VALUE_nogold								:{TINY_FONT}{BLACK}Buying Cost: {CURRENCY_LONG}
+STR_TMPL_TEMPLATE_OVR_VALUE_nogoldandcurrency					:{TINY_FONT}{BLACK}Buying Cost:
+STR_TMPL_TEMPLATE_OVR_VALUE_notinyfont							:{BLACK}Buying Cost: {GOLD}{CURRENCY_LONG}
+STR_TMPL_TEMPLATE_OVR_VALUE_notinyfontandblack					:Buying Cost: {GOLD}{CURRENCY_LONG}
+STR_TMPL_WARNING_FREE_WAGON										:{RED}Free Chain: not runnable!
+STR_TMPL_TEST													:{ORANGE}Test String: {RAW_STRING} {RAW_STRING}
+STR_TMPL_GROUP_USES_TEMPLATE									:{BLACK}Template in use: {NUM}
+STR_TMP_TEMPLATE_IN_USE											:Template is in use
+STR_TMPL_GROUP_NUM_TRAINS										:{BLACK}{NUM}
+STR_TMPL_CREATEGUI_TITLE										:{WHITE}Create/Edit Template Vehicle
+STR_TMPL_MAINGUI_DEFINEDGROUPS									:{BLACK}Defined Groups for Company
+STR_TMPL_TMPLRPL_EX_DIFF_RAILTYPE								:Uses Template of different rail type
+
+STR_TMPL_SET_USEDEPOT											:{BLACK}Use vehicles in depot
+STR_TMPL_SET_USEDEPOT_TIP										:{BLACK}Use vehicles inside the depot that are in a neutral and idle state to compose trains on template replacement in order to reduce buying costs
+STR_TMPL_SET_KEEPREMAINDERS										:{BLACK}Keep remainders
+STR_TMPL_SET_KEEPREMAINDERS_TIP									:{BLACK}After finishing template replacement keep all remaining vehicles from the old train in a neutral and idle state for later use
+STR_TMPL_SET_REFIT												:{BLACK}Use Refit
+STR_TMPL_SET_REFIT_TIP											:{BLACK}If set, the train will use exactly the cargo refit specified by the template. If not every wagon that is to be newly bought or retrieved from the depot, will *attempt* to be refitted as the old one was. Standard refit if this is impossible.
+
+STR_TMPL_CONFIG_USEDEPOT										:use depot
+STR_TMPL_CONFIG_KEEPREMAINDERS									:keep rem
+STR_TMPL_CONFIG_REFIT											:refit
+
+STR_TMPL_NUM_TRAINS_NEED_RPL									:# trains to replace:
+
+STR_TMPL_CARGO_SUMMARY											:{CARGO_LONG}
+STR_TMPL_CARGO_SUMMARY_MULTI									:{CARGO_LONG} (x{NUM})
+
+STR_TMPL_RPLALLGUI_TITLE										:{WHITE}Replace all Templace Vehicles
+STR_TMPL_RPLALLGUI_INSET_TOP									:{BLACK}Choose Vehicle Type and Replacement
+STR_TMPL_RPLALLGUI_INSET_TOP_1									:{BLACK}Template Engines
+STR_TMPL_RPLALLGUI_INSET_TOP_2									:{BLACK}Buyable Engines
+STR_TMPL_RPLALLGUI_INSET_BOTTOM									:{BLACK}Current Template List (updated only after replacement)
+STR_TMPL_RPLALLGUI_BUTTON_RPLALL								:{BLACK}Replace All
+STR_TMPL_RPLALLGUI_BUTTON_APPLY									:{BLACK}Apply
+STR_TMPL_RPLALLGUI_BUTTON_CANCEL								:{BLACK}Cancel
+STR_TMPL_RPLALLGUI_USE_TIP										:{BLACK}Select a vehicle type from each list and press 'Replace All'. If you are happy with the result displayed in the template list, press 'Apply' to actually apply these changes.
\ No newline at end of file
Index: src/lang/russian.txt
===================================================================
--- src/lang/russian.txt	(revision 24093)
+++ src/lang/russian.txt	(working copy)
@@ -4711,3 +4711,63 @@
 STR_SHIP                                                        :{BLACK}{SHIP}
 
 STR_TOOLBAR_RAILTYPE_VELOCITY                                   :{STRING} ({VELOCITY})
+
+
+STR_TOOLTIP_GROUP_ORDER                                         :{BLACK}Выбор порядка группировки
+STR_MAP_MENU_LINGRAPH_LEGEND                                    :Грузопотоки
+STR_SMALLMAP_TYPE_ROUTEMAP                                      :Грузопотоки
+STR_SMALLMAP_TOOLTIP_SHOW_LINK_STATS_ON_MAP                     :{BLACK}Показать грузопотоки на карте
+STR_SMALLMAP_TOOLTIP_CARGO_SELECTION                            :{BLACK}Щелчок по типу груза переключает отображение его на карте. Ctrl+щелчок отключает отображение всех грузов, кроме выбранной. Повторный Ctrl+щелчок включает отображение всех грузов.
+STR_SMALLMAP_TOOLTIP_DISABLE_ALL_CARGOS                         :{BLACK}Скрыть все виды грузов на карте
+STR_SMALLMAP_TOOLTIP_ENABLE_ALL_CARGOS                          :{BLACK}Показать все виды грузов на карте
+
+STR_CONFIG_SETTING_LINKGRAPH_INTERVAL                           :{LTBLUE}Обновлять граф распределения каждые {ORANGE}{STRING} дней
+STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC                       :симметричное
+STR_CONFIG_SETTING_DISTRIBUTION_ASYMMETRIC                      :несимметричное
+STR_CONFIG_SETTING_DISTRIBUTION_MANUAL                          :вручную
+STR_CONFIG_SETTING_DISTRIBUTION_PAX                             :{LTBLUE}Распределение пассажиров: {ORANGE}{STRING}
+STR_CONFIG_SETTING_DISTRIBUTION_MAIL                            :{LTBLUE}Распределение почты: {ORANGE}{STRING}
+STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED                        :{LTBLUE}Распределение ценных грузов: {ORANGE}{STRING}
+STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT                         :{LTBLUE}Распределение прочих грузов: {ORANGE}{STRING}
+STR_CONFIG_SETTING_LINKGRAPH_ACCURACY                           :{LTBLUE}Точность распределения: {ORANGE}{STRING}
+STR_CONFIG_SETTING_DEMAND_DISTANCE                              :{LTBLUE}Зависимость спроса от расстояния: {ORANGE}{STRING}%
+STR_CONFIG_SETTING_DEMAND_SIZE                                  :{LTBLUE}Зависимость симметричного спроса от популярности отдаленных станций: {ORANGE}{STRING}%
+STR_CONFIG_SETTING_SHORT_PATH_SATURATION                        :{LTBLUE}Насыщение коротких маршрутов перед использованием вместительных: {ORANGE}{STRING}%
+STR_CONFIG_SETTING_LINKGRAPH                                    :{ORANGE}Распределение грузов
+
+STR_LINKGRAPH_LEGEND_CAPTION                                    :{BLACK}Грузопотоки
+STR_LINKGRAPH_LEGEND_ALL                                        :{BLACK}Все
+STR_LINKGRAPH_LEGEND_NONE                                       :{BLACK}Нет
+STR_LINKGRAPH_LEGEND_SELECT_COMPANIES                           :{BLACK}Выбор компаний для отображения
+STR_LINKGRAPH_LEGEND_UNUSED                                     :{TINY_FONT}{BLACK}свободно
+STR_LINKGRAPH_LEGEND_SATURATED                                  :{TINY_FONT}{BLACK}насыщено
+STR_LINKGRAPH_LEGEND_OVERLOADED                                 :{TINY_FONT}{BLACK}перегружено
+
+STR_STATION_VIEW_GROUP                                          :{BLACK}Группировать
+STR_STATION_VIEW_WAITING_STATION                                :по станции (ожидающие)
+STR_STATION_VIEW_WAITING_AMOUNT                                 :по количеству (ожидающие)
+STR_STATION_VIEW_PLANNED_STATION                                :по станции (планируемые)
+STR_STATION_VIEW_PLANNED_AMOUNT                                 :по количеству (планируемые)
+STR_STATION_VIEW_FROM                                           :{YELLOW}{CARGO_SHORT} из {STATION}
+STR_STATION_VIEW_VIA                                            :{YELLOW}{CARGO_SHORT} через {STATION}
+STR_STATION_VIEW_TO                                             :{YELLOW}{CARGO_SHORT} в {STATION}
+STR_STATION_VIEW_FROM_ANY                                       :{RED}{CARGO_SHORT} с неизвестной станции
+STR_STATION_VIEW_TO_ANY                                         :{RED}{CARGO_SHORT} на любую станцию
+STR_STATION_VIEW_VIA_ANY                                        :{RED}{CARGO_SHORT} через любую станцию
+STR_STATION_VIEW_FROM_HERE                                      :{GREEN}{CARGO_SHORT} с этой станции
+STR_STATION_VIEW_VIA_HERE                                       :{GREEN}{CARGO_SHORT} через эту станцию
+STR_STATION_VIEW_TO_HERE                                        :{GREEN}{CARGO_SHORT} на эту станцию
+STR_STATION_VIEW_NONSTOP                                        :{YELLOW}{CARGO_SHORT} без пересадок
+
+STR_STATION_VIEW_GROUP_S_V_D                                    :Откуда - Через - Куда
+STR_STATION_VIEW_GROUP_S_D_V                                    :Откуда - Куда - Через
+STR_STATION_VIEW_GROUP_V_S_D                                    :Через - Откуда - Куда
+STR_STATION_VIEW_GROUP_V_D_S                                    :Через - Куда - Откуда
+STR_STATION_VIEW_GROUP_D_S_V                                    :Куда - Откуда - Через
+STR_STATION_VIEW_GROUP_D_V_S                                    :Куда - Через - Откуда
+
+STR_FEEDER_INCOME_TINY                                          :{TINY_FONT}{YELLOW}Трансфер: {CURRENCY_LONG}{WHITE} / {GREEN}Доход: {CURRENCY_LONG}
+STR_FEEDER_INCOME                                               :{YELLOW}Трансфер: {CURRENCY_LONG}{WHITE} / {GREEN}Доход: {CURRENCY_LONG}
+STR_FEEDER_COST_TINY                                            :{TINY_FONT}{YELLOW}Трансфер: {CURRENCY_LONG}{WHITE} / {RED}Расход: {CURRENCY_LONG}
+STR_FEEDER_COST                                                 :{YELLOW}Трансфер: {CURRENCY_LONG}{WHITE} / {RED}Расход: {CURRENCY_LONG}
+
Index: src/settings_gui.cpp
===================================================================
--- src/settings_gui.cpp	(revision 24093)
+++ src/settings_gui.cpp	(working copy)
@@ -1538,6 +1538,20 @@
 /** Economy sub-page */
 static SettingsPage _settings_economy_page = {_settings_economy, lengthof(_settings_economy)};
 
+static SettingEntry _settings_linkgraph[] = {
+	SettingEntry("linkgraph.recalc_interval"),
+	SettingEntry("linkgraph.distribution_pax"),
+	SettingEntry("linkgraph.distribution_mail"),
+	SettingEntry("linkgraph.distribution_armoured"),
+	SettingEntry("linkgraph.distribution_default"),
+	SettingEntry("linkgraph.accuracy"),
+	SettingEntry("linkgraph.demand_distance"),
+	SettingEntry("linkgraph.demand_size"),
+	SettingEntry("linkgraph.short_path_saturation"),
+};
+/** Linkgraph sub-page */
+static SettingsPage _settings_linkgraph_page = {_settings_linkgraph, lengthof(_settings_linkgraph)};
+
 static SettingEntry _settings_ai_npc[] = {
 	SettingEntry("ai.ai_in_multiplayer"),
 	SettingEntry("ai.ai_disable_veh_train"),
@@ -1629,6 +1643,7 @@
 	SettingEntry(&_settings_vehicles_page,     STR_CONFIG_SETTING_VEHICLES),
 	SettingEntry(&_settings_stations_page,     STR_CONFIG_SETTING_STATIONS),
 	SettingEntry(&_settings_economy_page,      STR_CONFIG_SETTING_ECONOMY),
+	SettingEntry(&_settings_linkgraph_page,    STR_CONFIG_SETTING_LINKGRAPH),
 	SettingEntry(&_settings_ai_page,           STR_CONFIG_SETTING_AI),
 };
 
Index: src/aaa_template_gui_create.cpp
===================================================================
--- src/aaa_template_gui_create.cpp	(revision 0)
+++ src/aaa_template_gui_create.cpp	(revision 0)
@@ -0,0 +1,460 @@
+#include "stdafx.h"
+
+#include "gfx_func.h"
+#include "direction_type.h"
+
+#include "strings_func.h"
+#include "window_func.h"
+#include "company_func.h"
+#include "window_gui.h"
+#include "settings_func.h"
+#include "core/geometry_func.hpp"
+#include "table/sprites.h"
+#include "table/strings.h"
+// since setobjtoplacewnd() TODO: del unnecessary
+#include "viewport_func.h"
+#include "window_func.h"
+#include "gui.h"
+#include "textbuf_gui.h"
+#include "command_func.h"
+#include "depot_base.h"
+#include "vehicle_gui.h"
+#include "spritecache.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "vehicle_func.h"
+#include "company_func.h"
+#include "tilehighlight_func.h"
+#include "window_gui.h"
+#include "vehiclelist.h"
+#include "order_backup.h"
+//
+#include "group.h"
+#include "company_base.h"
+
+#include "aaa_template_gui_create.h"
+#include "aaa_template_vehicle.h"
+#include "aaa_template_vehicle_func.h"
+
+#include "train.h"
+
+// TODO: rm
+
+//Company *_cme = Company::Get(0))
+
+class TemplateReplaceWindow;
+
+// some space in front of the virtual train in the matrix
+uint16 TRAIN_FRONT_SPACE = 16;
+
+enum TemplateReplaceWindowWidgets {
+	TCW_CAPTION,
+	TCW_MATRIX_NEW_TMPL,
+	TCW_INFO_PANEL,
+	TCW_SCROLLBAR_NEW_TMPL,
+	TCW_SELL_TMPL,
+	TCW_NEW,
+	TCW_OK,
+	TCW_CANCEL,
+	TCW_REFIT,
+	TCW_CLONE,
+};
+
+static const NWidgetPart _widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, TCW_CAPTION), SetDataTip(STR_TMPL_CREATEGUI_TITLE, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_MATRIX, COLOUR_GREY, TCW_MATRIX_NEW_TMPL), SetMinimalSize(216, 60), SetFill(1, 0), SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY), SetResize(1, 0), SetScrollbar(TCW_SCROLLBAR_NEW_TMPL),
+			NWidget(WWT_PANEL, COLOUR_GREY, TCW_INFO_PANEL), SetMinimalSize(216,80), SetResize(1,1), EndContainer(),
+			NWidget(NWID_HSCROLLBAR, COLOUR_GREY, TCW_SCROLLBAR_NEW_TMPL), SetResize(1,0),
+		EndContainer(),
+		NWidget(WWT_IMGBTN, COLOUR_GREY, TCW_SELL_TMPL), SetDataTip(0x0, STR_NULL), SetMinimalSize(23,23), SetResize(0, 1), SetFill(0, 1),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TCW_OK),		SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_CONFIRM, STR_TMPL_CONFIRM),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TCW_NEW),		SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_NEW,	 STR_TMPL_NEW),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, TCW_CLONE),	SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_CREATE_CLONE_VEH,	 STR_TMPL_CREATE_CLONE_VEH),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TCW_REFIT),	SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_REFIT,	 STR_TMPL_REFIT),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TCW_CANCEL),	SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_CANCEL,  STR_TMPL_CANCEL),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static const WindowDesc _template_create_window_desc(
+	WDP_AUTO, 456, 100,
+	WC_CREATE_TEMPLATE, WC_NONE,					// TODO change wc_replace_vehicle
+	WDF_UNCLICK_BUTTONS | WDF_CONSTRUCTION,
+	_widgets, lengthof(_widgets)
+);
+
+static void TrainDepotMoveVehicle(const Vehicle *wagon, VehicleID sel, const Vehicle *head)
+{
+	const Vehicle *v = Vehicle::Get(sel);
+
+	if (v == wagon) return;
+
+	if (wagon == NULL) {
+		if (head != NULL) wagon = head->Last();
+	} else {
+		wagon = wagon->Previous();
+		if (wagon == NULL) return;
+	}
+
+	if (wagon == v) return;
+
+	CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, (_ctrl_pressed ? 1:0)<<20 | (1<<21) | v->index, wagon == NULL ? INVALID_VEHICLE : wagon->index, 0);
+}
+
+class TemplateCreateWindow : public Window {
+private:
+	Scrollbar *hscroll;
+	int line_height;
+	Train* virtual_train;
+	bool editMode;
+	bool *noticeParent;
+	bool *createWindowOpen;			/// used to notify main window of progress (dummy way of disabling 'delete' while editing a template)
+	bool virtualTrainChangedNotice;
+	VehicleID sel;
+	VehicleID vehicle_over;
+	TemplateVehicle *editTemplate;
+
+public:
+	TemplateCreateWindow(const WindowDesc* _wdesc, TemplateVehicle *to_edit, bool *notice, bool *windowOpen, int step_h) : Window()
+	{
+		this->line_height = step_h;
+		this->CreateNestedTree(_wdesc);
+		this->hscroll = this->GetScrollbar(TCW_SCROLLBAR_NEW_TMPL);
+		this->FinishInitNested(_wdesc, VEH_TRAIN);
+		/* a sprite */
+		this->GetWidget<NWidgetCore>(TCW_SELL_TMPL)->widget_data = SPR_SELL_TRAIN;
+
+		this->owner = _local_company;
+
+		noticeParent = notice;
+		createWindowOpen = windowOpen;
+		virtualTrainChangedNotice = false;
+		this->editTemplate = to_edit;
+
+		if ( to_edit ) editMode = true;
+		else editMode = false;
+
+		this->sel = INVALID_VEHICLE;
+		this->vehicle_over = INVALID_VEHICLE;
+
+		this->virtual_train = VirtualTrainFromTemplateVehicle(to_edit);
+
+		this->resize.step_height = 1;
+	}
+	~TemplateCreateWindow()
+	{
+		if ( virtual_train )
+			delete virtual_train;
+
+		SetWindowClassesDirty(WC_TRAINS_LIST);
+
+		/* more cleanup */
+		*createWindowOpen = false;
+		DeleteWindowById(WC_BUILD_VIRTUAL_TRAIN, this->window_number);
+
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case TCW_MATRIX_NEW_TMPL:
+				size->height = 20;
+				break;
+		}
+	}
+	virtual void OnResize()
+	{
+		NWidgetCore *nwi = this->GetWidget<NWidgetCore>(TCW_MATRIX_NEW_TMPL);
+		this->hscroll->SetCapacity(nwi->current_x);
+		nwi->widget_data = (this->hscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		virtualTrainChangedNotice = true;
+	}
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch(widget) {
+			case TCW_MATRIX_NEW_TMPL: {
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(TCW_MATRIX_NEW_TMPL);
+				ClickedOnVehiclePanel(pt.x - nwi->pos_x-TRAIN_FRONT_SPACE, pt.y - nwi->pos_y);
+				break;
+			}
+			case TCW_NEW: {
+				ShowBuildVirtualTrainWindow(&virtual_train, &virtualTrainChangedNotice);
+				break;
+			}
+			case TCW_CLONE: {
+				this->SetWidgetDirty(TCW_CLONE);
+				this->ToggleWidgetLoweredState(TCW_CLONE);
+				if (this->IsWidgetLowered(TCW_CLONE)) {
+					static const CursorID clone_icon =	SPR_CURSOR_CLONE_TRAIN;
+					SetObjectToPlaceWnd(clone_icon, PAL_NONE, HT_VEHICLE, this);
+				} else {
+					ResetObjectToPlace();
+				}
+				break;
+			}
+			case TCW_OK: {
+				TemplateVehicle *tv = NULL;
+				if ( editMode )	tv = DeleteTemplateVehicle(editTemplate);
+				editTemplate = TemplateVehicleFromVirtualTrain(virtual_train);
+				if ( tv ) *noticeParent = true;
+				delete this;
+				break;
+			}
+			case TCW_CANCEL: {
+				delete this;
+				break;
+			}
+			case TCW_REFIT: {
+				ShowVehicleRefitWindow(virtual_train, INVALID_VEH_ORDER_ID, this, false, true);
+				break;
+			}
+		}
+	}
+	virtual bool OnVehicleSelect(const Vehicle *v)
+	{
+		// throw away the current virtual train
+		if ( virtual_train )
+			delete this->virtual_train;
+		// create a new one
+		this->virtual_train = CloneVirtualTrainFromTrain((const Train*)v);
+		this->ToggleWidgetLoweredState(TCW_CLONE);
+		ResetObjectToPlace();
+		this->SetDirty();
+
+		return true;
+	}
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch(widget) {
+			case TCW_MATRIX_NEW_TMPL: {
+				DrawTrainImage(virtual_train, r.left+TRAIN_FRONT_SPACE, r.right, r.top+2, this->sel, EIT_PURCHASE, this->hscroll->GetPosition(), this->vehicle_over);
+				SetDParam(0, CeilDiv(virtual_train->gcache.cached_total_length * 10, TILE_SIZE));
+				SetDParam(1, 1);
+				DrawString(r.left, r.right, r.top, STR_TINY_BLACK_DECIMAL, TC_BLACK, SA_RIGHT);
+				break;
+			}
+			case TCW_INFO_PANEL: {
+				if (virtual_train) {
+					/* Draw vehicle performance info */
+					const GroundVehicleCache *gcache = this->virtual_train->GetGroundVehicleCache();
+					SetDParam(2, this->virtual_train->GetDisplayMaxSpeed());
+					SetDParam(1, gcache->cached_power);
+					SetDParam(0, gcache->cached_weight);
+					SetDParam(3, gcache->cached_max_te / 1000);
+					DrawString(r.left+8, r.right, r.top+4, STR_VEHICLE_INFO_WEIGHT_POWER_MAX_SPEED_MAX_TE);
+					/* Draw cargo summary */
+					CargoArray cargo_caps;
+					for ( const Train *tmp=this->virtual_train; tmp; tmp=tmp->Next() )
+						cargo_caps[tmp->cargo_type] += tmp->cargo_cap;
+					int y = r.top+24;
+					for (CargoID i = 0; i < NUM_CARGO; i++) {
+						if ( cargo_caps[i] > 0 ) {
+							SetDParam(0, i);
+							SetDParam(1, cargo_caps[i]);
+							SetDParam(2, _settings_game.vehicle.freight_trains);
+							DrawString(r.left+8, r.right, y, STR_TMPL_CARGO_SUMMARY, TC_WHITE, SA_LEFT);
+							y += this->line_height/2;
+						}
+					}
+				}
+				break;
+			}
+			default:
+				break;
+		}
+	}
+	virtual void OnTick()
+	{
+		if ( virtualTrainChangedNotice ) {
+			this->SetDirty();
+			virtualTrainChangedNotice = false;
+		}
+	}
+	virtual void OnDragDrop(Point pt, int widget)
+	{
+		switch (widget) {
+			case TCW_MATRIX_NEW_TMPL: {
+				const Vehicle *v = NULL;
+				VehicleID sel;
+				if ( virtual_train ) sel = virtual_train->index;
+				else sel = INVALID_VEHICLE;
+
+				this->SetDirty();
+
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(TCW_MATRIX_NEW_TMPL);
+				GetDepotVehiclePtData gdvp = { NULL, NULL };
+
+				if (this->GetVehicleFromDepotWndPt(pt.x - nwi->pos_x, pt.y - nwi->pos_y, &v, &gdvp) == MODE_DRAG_VEHICLE && sel != INVALID_VEHICLE) {
+					if (gdvp.wagon == NULL || gdvp.wagon->index != sel) {
+						this->vehicle_over = INVALID_VEHICLE;
+						TrainDepotMoveVehicle(gdvp.wagon, sel, gdvp.head);
+						virtual_train = virtual_train->First();
+					}
+				}
+				break;
+			}
+			case TCW_SELL_TMPL: {
+				if (this->IsWidgetDisabled(widget)) return;
+				if (this->sel == INVALID_VEHICLE) return;
+
+				virtual_train = DeleteVirtualTrain(virtual_train, Train::Get(this->sel));
+
+				this->sel = INVALID_VEHICLE;
+
+				this->SetDirty();
+				break;
+			}
+			default:
+				this->sel = INVALID_VEHICLE;
+				this->SetDirty();
+		}
+		_cursor.vehchain = false;
+		this->sel = INVALID_VEHICLE;
+		this->SetDirty();
+	}
+	virtual void OnMouseDrag(Point pt, int widget)
+	{
+		if (this->sel == INVALID_VEHICLE) return;
+		/* A rail vehicle is dragged.. */
+		if (widget != TCW_MATRIX_NEW_TMPL) { // ..outside of the depot matrix.
+			if (this->vehicle_over != INVALID_VEHICLE) {
+				this->vehicle_over = INVALID_VEHICLE;
+				this->SetWidgetDirty(TCW_MATRIX_NEW_TMPL);
+			}
+			return;
+		}
+
+		NWidgetBase *matrix = this->GetWidget<NWidgetBase>(widget);
+		const Vehicle *v = NULL;
+		GetDepotVehiclePtData gdvp = {NULL, NULL};
+
+		if (this->GetVehicleFromDepotWndPt(pt.x - matrix->pos_x, pt.y - matrix->pos_y, &v, &gdvp) != MODE_DRAG_VEHICLE) return;
+		VehicleID new_vehicle_over = INVALID_VEHICLE;
+		if (gdvp.head != NULL) {
+			if (gdvp.wagon == NULL && gdvp.head->Last()->index != this->sel) { // ..at the end of the train.
+				/* NOTE: As a wagon can't be moved at the begin of a train, head index isn't used to mark a drag-and-drop
+				 * destination inside a train. This head index is then used to indicate that a wagon is inserted at
+				 * the end of the train.
+				 */
+				new_vehicle_over = gdvp.head->index;
+			} else if (gdvp.wagon != NULL && gdvp.head != gdvp.wagon &&
+					gdvp.wagon->index != this->sel &&
+					gdvp.wagon->Previous()->index != this->sel) { // ..over an existing wagon.
+				new_vehicle_over = gdvp.wagon->index;
+			}
+		}
+		if (this->vehicle_over == new_vehicle_over) return;
+
+		this->vehicle_over = new_vehicle_over;
+		this->SetWidgetDirty(widget);
+	}
+	virtual void OnPaint()
+	{
+		uint max_width = 32;
+		uint width = 0;
+		if ( virtual_train )
+			for (Train *v = virtual_train; v != NULL; v = v->Next())
+				width += v->GetDisplayImageWidth();
+
+		max_width = max(max_width, width);
+		this->hscroll->SetCount(max_width+25);
+
+		this->DrawWidgets();
+	}
+	struct GetDepotVehiclePtData {
+		const Vehicle *head;
+		const Vehicle *wagon;
+	};
+
+	enum DepotGUIAction {
+		MODE_ERROR,
+		MODE_DRAG_VEHICLE,
+		MODE_SHOW_VEHICLE,
+		MODE_START_STOP,
+	};
+
+	uint count_width;
+	uint header_width;
+ 	DepotGUIAction GetVehicleFromDepotWndPt(int x, int y, const Vehicle **veh, GetDepotVehiclePtData *d) const
+	{
+		const NWidgetCore *matrix_widget = this->GetWidget<NWidgetCore>(TCW_MATRIX_NEW_TMPL);
+		/* In case of RTL the widgets are swapped as a whole */
+		if (_current_text_dir == TD_RTL) x = matrix_widget->current_x - x;
+
+		uint xm = x;
+
+		bool wagon = false;
+
+		x += this->hscroll->GetPosition();
+		const Train *v = virtual_train;
+		d->head = d->wagon = v;
+
+		if (xm <= this->header_width) {
+
+			if (wagon) return MODE_ERROR;
+
+			return MODE_SHOW_VEHICLE;
+		}
+
+		/* Account for the header */
+		x -= this->header_width;
+
+		/* find the vehicle in this row that was clicked */
+		for (; v != NULL; v = v->Next()) {
+			x -= v->GetDisplayImageWidth();
+			if (x < 0) break;
+		}
+
+		d->wagon = (v != NULL ? v->GetFirstEnginePart() : NULL);
+
+		return MODE_DRAG_VEHICLE;
+	}
+
+	void ClickedOnVehiclePanel(int x, int y)
+	{
+		GetDepotVehiclePtData gdvp = { NULL, NULL };
+		const Vehicle *v = NULL;
+		DepotGUIAction mode = this->GetVehicleFromDepotWndPt(x, y, &v, &gdvp);
+
+		v = gdvp.wagon;
+
+		if (v != NULL && VehicleClicked(v)) return;
+		VehicleID sel = this->sel;
+
+		if (sel != INVALID_VEHICLE) {
+			this->sel = INVALID_VEHICLE;
+		} else if (v != NULL) {
+			int image = v->GetImage(_current_text_dir == TD_RTL ? DIR_E : DIR_W, EIT_PURCHASE);
+			SetObjectToPlaceWnd(image, GetVehiclePalette(v), HT_DRAG, this);
+
+			this->sel = v->index;
+			this->SetDirty();
+
+			_cursor.short_vehicle_offset = v->IsGroundVehicle() ? 16 - v->GetGroundVehicleCache()->cached_veh_length * 2 : 0;
+			_cursor.vehchain = _ctrl_pressed;
+		}
+	}
+
+};
+
+void ShowTemplateCreateWindow(TemplateVehicle *to_edit, bool *noticeParent, bool *createWindowOpen, int step_h)
+{
+	if ( BringWindowToFrontById(WC_CREATE_TEMPLATE, VEH_TRAIN) != NULL ) return;
+	new TemplateCreateWindow(&_template_create_window_desc, to_edit, noticeParent, createWindowOpen, step_h);
+}
+
+
Index: src/order_base.h
===================================================================
--- src/order_base.h	(revision 24093)
+++ src/order_base.h	(working copy)
@@ -176,6 +176,9 @@
 	inline void SetConditionValue(uint16 value) { SB(this->dest, 0, 11, value); }
 
 	bool ShouldStopAtStation(const Vehicle *v, StationID station) const;
+	bool CanLoadOrUnload() const;
+	bool CanLeaveWithCargo(bool has_cargo) const;
+
 	TileIndex GetLocation(const Vehicle *v, bool airport = false) const;
 
 	/** Checks if this order has travel_time and if needed wait_time set. */
@@ -206,6 +209,8 @@
 	friend void AfterLoadVehicles(bool part_of_load); ///< For instantiating the shared vehicle chain
 	friend const struct SaveLoad *GetOrderListDescription(); ///< Saving and loading of order lists.
 
+	const Order *GetBestLoadableNext(const Vehicle *v, const Order *o1, const Order *o2) const;
+
 	Order *first;                     ///< First order of the order list.
 	VehicleOrderID num_orders;        ///< NOSAVE: How many orders there are in the list.
 	VehicleOrderID num_manual_orders; ///< NOSAVE: How many manually added orders are there in the list.
@@ -247,6 +252,14 @@
 	inline Order *GetLastOrder() const { return this->GetOrderAt(this->num_orders - 1); }
 
 	/**
+	 * Get the order after the given one or the first one, if the given one is the
+	 * last one.
+	 * @param curr Order to find the next one for.
+	 * @return Next order.
+	 */
+	inline const Order *GetNext(const Order *curr) const { return (curr->next == NULL) ? this->GetFirstOrder() : curr->next; }
+
+	/**
 	 * Get number of orders in the order list.
 	 * @return number of orders in the chain.
 	 */
@@ -258,6 +271,9 @@
 	 */
 	inline VehicleOrderID GetNumManualOrders() const { return this->num_manual_orders; }
 
+	StationID GetNextStoppingStation(const Vehicle *v) const;
+	const Order *GetNextStoppingOrder(const Vehicle *v, const Order *next, uint hops, bool is_loading = false) const;
+
 	void InsertOrderAt(Order *new_order, int index);
 	void DeleteOrderAt(int index);
 	void MoveOrder(int from, int to);
Index: src/widgets/smallmap_widget.h
===================================================================
--- src/widgets/smallmap_widget.h	(revision 24093)
+++ src/widgets/smallmap_widget.h	(working copy)
@@ -18,11 +18,13 @@
 	WID_SM_MAP_BORDER,     ///< Border around the smallmap.
 	WID_SM_MAP,            ///< Panel containing the smallmap.
 	WID_SM_LEGEND,         ///< Bottom panel to display smallmap legends.
+	WID_SM_BLANK,          ///< Empty button as placeholder.
 	WID_SM_ZOOM_IN,        ///< Button to zoom in one step.
 	WID_SM_ZOOM_OUT,       ///< Button to zoom out one step.
 	WID_SM_CONTOUR,        ///< Button to select the contour view (height map).
 	WID_SM_VEHICLES,       ///< Button to select the vehicles view.
 	WID_SM_INDUSTRIES,     ///< Button to select the industries view.
+	WID_SM_LINKSTATS,      ///< Button to select the link stats view.
 	WID_SM_ROUTES,         ///< Button to select the routes view.
 	WID_SM_VEGETATION,     ///< Button to select the vegetation view.
 	WID_SM_OWNERS,         ///< Button to select the owners view.
Index: src/widgets/station_widget.h
===================================================================
--- src/widgets/station_widget.h	(revision 24093)
+++ src/widgets/station_widget.h	(working copy)
@@ -15,6 +15,10 @@
 /** Widgets of the #StationViewWindow class. */
 enum StationViewWidgets {
 	WID_SV_CAPTION,            ///< Caption of the window.
+	WID_SV_SORT_ORDER,         ///< 'Sort order' button
+	WID_SV_SORT_BY,            ///< 'Sort by' button
+	WID_SV_GROUP,              ///< label for "group by"
+	WID_SV_GROUP_BY,           ///< 'Group by' button
 	WID_SV_WAITING,            ///< List of waiting cargo.
 	WID_SV_SCROLLBAR,          ///< Scrollbar.
 	WID_SV_ACCEPT_RATING_LIST, ///< List of accepted cargoes / rating of cargoes.
Index: src/widgets/build_vehicle_widget.h
===================================================================
--- src/widgets/build_vehicle_widget.h	(revision 24093)
+++ src/widgets/build_vehicle_widget.h	(working copy)
@@ -24,6 +24,7 @@
 	WID_BV_BUILD,                     ///< Build panel.
 	WID_BV_BUILD_SEL,                 ///< Build button.
 	WID_BV_RENAME,                    ///< Rename button.
+	BUILD_VEHICLE_WIDGET_BUILD,		  /// TODO: own
 };
 
 #endif /* WIDGETS_BUILD_VEHICLE_WIDGET_H */
Index: src/aaa_template_vehicle_func.cpp
===================================================================
--- src/aaa_template_vehicle_func.cpp	(revision 0)
+++ src/aaa_template_vehicle_func.cpp	(revision 0)
@@ -0,0 +1,776 @@
+// template_vehicle_func.cpp
+
+#include "stdafx.h"
+#include "window_gui.h"
+#include "gfx_func.h"
+#include "window_func.h"
+#include "command_func.h"
+#include "vehicle_gui.h"
+#include "train.h"
+#include "strings_func.h"
+#include "vehicle_func.h"
+#include "core/geometry_type.hpp"
+#include "debug.h"
+
+#include "table/sprites.h"
+#include "table/strings.h"
+
+#include "train.h"
+#include "company_func.h"
+#include "newgrf.h"
+#include "spritecache.h"
+#include "articulated_vehicles.h"
+#include "autoreplace_func.h"
+
+#include "depot_base.h"
+
+#include "aaa_template_vehicle.h"
+#include "aaa_template_vehicle_func.h"
+
+#include <map>
+#include <stdio.h>
+
+Vehicle *vhead, *vtmp;
+static const uint MAX_ARTICULATED_PARTS = 100;
+
+
+// TODO
+void pat() {
+	TemplateVehicle *tv;
+	FOR_ALL_TEMPLATES(tv) {
+		if ( tv->Prev() ) continue;
+		ptv(tv);
+		printf("__________\n");
+	}
+}
+void pav() {
+	Train *t;
+	FOR_ALL_TRAINS(t) {
+		if ( t->Previous() ) continue;
+		pvt(t);
+		printf("__________\n");
+	}
+}
+void ptv(TemplateVehicle* tv) {
+	if (!tv) return;
+	while (tv->Next() ) {
+		printf("eid:%3d  st:%2d  tv:%x  next:%x  cargo: %d  cargo_sub: %d\n", tv->engine_type, tv->subtype, (uint32)tv, (uint32)tv->Next(), tv->cargo_type, tv->cargo_subtype);
+		tv = tv->Next();
+	}
+	printf("eid:%3d  st:%2d  tv:%x  next:%x  cargo: %d  cargo_sub: %d\n", tv->engine_type, tv->subtype, (uint32)tv, (uint32)tv->Next(),  tv->cargo_type, tv->cargo_subtype);
+}
+
+void pvt (const Train *printme) {
+	for ( const Train *tmp = printme; tmp; tmp=tmp->Next() ) {
+		if ( tmp->index <= 0 ) {
+			printf("train has weird index: %d %d %x\n", tmp->index, tmp->engine_type, tmp);
+			return;
+		}
+		printf("eid:%3d  index:%2d  subtype:%2d  vehstat: %d  cargo_t: %d   cargo_sub: %d  ref:%x\n", tmp->engine_type, tmp->index, tmp->subtype, tmp->vehstatus, tmp->cargo_type, tmp->cargo_subtype, (uint32)tmp);
+	}
+}
+
+// TODO: move this into main_gui.cpp
+void BuildTemplateGuiList(GUITemplateList *list, Scrollbar *vscroll, Owner oid, RailType railtype)
+{
+	//if (!list->NeedRebuild()) return; // TODO: reactivate ?
+	list->Clear();
+	const TemplateVehicle *tv;
+
+	FOR_ALL_TEMPLATES(tv) {
+		if (tv->owner == oid && (tv->IsPrimaryVehicle() || tv->IsFreeWagonChain()) && TemplateVehicleContainsEngineOfRailtype(tv, railtype))
+			*list->Append() = tv;
+
+	}
+
+	list->RebuildDone();
+	if (vscroll) vscroll->SetCount(list->Length());
+}
+
+Money CalculateOverallTemplateCost(const TemplateVehicle *tv)
+{
+	Money val = 0;
+
+	for (; tv; tv = tv->Next())
+		val += (Engine::Get(tv->engine_type))->GetCost();
+	return val;
+}
+
+void DrawTemplate(const TemplateVehicle *tv, int left, int right, int y)
+{
+	if ( !tv ) return;
+
+	const TemplateVehicle *t = tv;
+	int offset=left;
+
+	while (t) {
+		PaletteID pal = GetEnginePalette(t->engine_type, _current_company);
+		DrawSprite(t->cur_image, pal, offset, y+12);
+
+		offset += t->image_width;
+		t = t->Next();
+	}
+	//_cur_dpi = old_dpi;
+}
+
+// copy important stuff from the virtual vehicle to the template
+inline void SetupTemplateVehicleFromVirtual(TemplateVehicle *tmp, TemplateVehicle *prev, Train *virt)
+{
+	if (prev) {
+		prev->SetNext(tmp);
+		tmp->SetPrev(prev);
+		tmp->SetFirst(prev->First());
+	}
+	tmp->railtype = virt->railtype;
+	tmp->owner = virt->owner;
+	tmp->value = virt->value;
+
+	// set the subtype but also clear the virtual flag while doing it
+	tmp->subtype = virt->subtype & ~(1 << GVSF_VIRTUAL);
+	// set the cargo type and capacity
+	tmp->cargo_type = virt->cargo_type;
+	tmp->cargo_subtype = virt->cargo_subtype;
+	tmp->cargo_cap = virt->cargo_cap;
+
+	const GroundVehicleCache *gcache = virt->GetGroundVehicleCache();
+	tmp->max_speed = virt->GetDisplayMaxSpeed();
+	tmp->power = gcache->cached_power;
+	tmp->weight = gcache->cached_weight;
+	tmp->max_te = gcache->cached_max_te / 1000;
+
+	tmp->spritenum = virt->spritenum;
+	tmp->cur_image = virt->GetImage(DIR_W, EIT_PURCHASE);
+	Point *p = new Point();
+	tmp->image_width = virt->GetDisplayImageWidth(p);
+}
+
+// create a new virtual train as clone of a real train TODO
+Train* CloneVirtualTrainFromTrain(const Train *clicked)
+{
+	if ( !clicked ) return 0;
+	CommandCost c;
+	Train *tmp, *head, *tail;
+
+	head = CmdBuildVirtualRailVehicle(clicked->engine_type);
+	if ( !head ) return 0;
+
+	tail = head;
+	clicked = clicked->GetNextUnit();
+	while ( clicked ) {
+		tmp = CmdBuildVirtualRailVehicle(clicked->engine_type);
+		if ( tmp ) {
+			tmp->cargo_type = clicked->cargo_type;
+			tmp->cargo_subtype = clicked->cargo_subtype;
+			CmdMoveRailVehicle(0, DC_EXEC, (1<<21) | tmp->index, tail->index, 0);
+			tail = tmp;
+		}
+		clicked = clicked->GetNextUnit();
+	}
+	return head;
+}
+TemplateVehicle* CloneTemplateVehicleFromTrain(const Train *t)
+{
+	Train *clicked = Train::Get(t->index);
+	if ( !clicked )
+		return 0;
+
+	Train *init_clicked = clicked;
+
+	int len = CountVehiclesInChain(clicked);
+	if ( !TemplateVehicle::CanAllocateItem(len) )
+		// TODO: error message box ?
+		return 0;
+
+	TemplateVehicle *tmp, *prev=0;
+	for ( ; clicked; clicked=clicked->Next() ) {
+		tmp = new TemplateVehicle(clicked->engine_type);
+		SetupTemplateVehicleFromVirtual(tmp, prev, clicked);
+		prev = tmp;
+	}
+
+	tmp->First()->SetRealLength(CeilDiv(init_clicked->gcache.cached_total_length * 10, TILE_SIZE));
+	return tmp->First();
+}
+// create a full TemplateVehicle based train according to a virtual train
+TemplateVehicle* TemplateVehicleFromVirtualTrain(Train *virt)
+{
+	if ( !virt )
+		return 0;
+
+	Train *init_virt = virt;
+
+	int len = CountVehiclesInChain(virt);
+	if ( !TemplateVehicle::CanAllocateItem(len) )
+		// TODO: error message box ?
+		return 0;
+
+	TemplateVehicle *tmp, *prev=0;
+	for ( ; virt; virt=virt->Next() ) {
+		tmp = new TemplateVehicle(virt->engine_type);
+		SetupTemplateVehicleFromVirtual(tmp, prev, virt);
+		prev = tmp;
+	}
+
+	tmp->First()->SetRealLength(CeilDiv(init_virt->gcache.cached_total_length * 10, TILE_SIZE));
+	return tmp->First();
+}
+
+// attempt to buy a train after a given template vehicle
+// this might fail if the template e.g. deprecated and contains engines that are not sold anymore
+Train* VirtualTrainFromTemplateVehicle(TemplateVehicle *tv)
+{
+	if ( !tv ) return 0;
+	CommandCost c;
+	Train *tmp, *head, *tail;
+
+	head = CmdBuildVirtualRailVehicle(tv->engine_type);
+	if ( !head ) return 0;
+
+	tail = head;
+	tv = tv->GetNextUnit();
+	while ( tv ) {
+		tmp = CmdBuildVirtualRailVehicle(tv->engine_type);
+		if ( tmp ) {
+			tmp->cargo_type = tv->cargo_type;
+			tmp->cargo_subtype = tv->cargo_subtype;
+			CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, (1<<21) | tmp->index, tail->index, 0);
+			tail = tmp;
+		}
+		tv = tv->GetNextUnit();
+	}
+	return head;
+}
+
+// return last in a chain (really last, so even a singular articulated part of a vehicle if the last one is artic)
+inline TemplateVehicle* Last(TemplateVehicle *chain) {
+	if ( !chain ) return 0;
+	while ( chain->Next() ) chain = chain->Next();
+	return chain;
+}
+
+inline Train* Last(Train *chain) {
+	if ( !chain ) return 0;
+	while ( chain->GetNextUnit() ) chain = chain->GetNextUnit();
+	return chain;
+}
+
+// return: pointer to former vehicle
+TemplateVehicle *DeleteTemplateVehicle(TemplateVehicle *todel)
+{
+	if ( !todel )
+		return 0;
+	TemplateVehicle *cur = todel;
+	delete todel;
+	return cur;
+}
+
+Train* DeleteVirtualTrain(Train *chain, Train *to_del) {
+	if ( chain != to_del ) {
+		CommandCost sellc = CmdSellRailWagon(DC_EXEC, to_del, 0, 0);
+		return chain;
+	}
+	else {
+		chain = chain->GetNextUnit();
+		//CommandCost cost=CmdMoveRailVehicle(0, DC_EXEC, (1<<20) | (1<<21) | to_del->index, INVALID_VEHICLE, 0);
+		CommandCost sellc = CmdSellRailWagon(DC_EXEC, to_del, 0, 0);
+		return chain;
+	}
+}
+
+// retrieve template vehicle from templatereplacement that belongs to the given group
+TemplateVehicle* GetTemplateVehicleByGroupID(GroupID gid) {
+	TemplateReplacement *tr;
+	// first try to find a templatereplacement issued for the given groupid
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->Group() == gid )
+			return TemplateVehicle::GetIfValid(tr->Template());		// there can be only one
+	}
+	// if that didn't work, try to find a templatereplacement for ALL_GROUP
+	if ( gid != ALL_GROUP )
+		FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+			if ( tr->Group() == ALL_GROUP )
+				return TemplateVehicle::GetIfValid(tr->Template());
+		}
+	// if all failed, just return null
+	return 0;
+}
+
+/**
+ * Check a template consist whether it contains any engine of the given railtype
+ */
+bool TemplateVehicleContainsEngineOfRailtype(const TemplateVehicle *tv, RailType type)
+{
+	/* For standard rail engines, allow only those */
+	if ( type == RAILTYPE_BEGIN || type == RAILTYPE_RAIL ) {
+		while ( tv ) {
+		if ( tv->railtype != type )
+			return false;
+		tv = tv->GetNextUnit();
+		}
+		return true;
+	}
+	/* For electrified rail engines, standard wagons or engines are allowed to be included */
+	while ( tv ) {
+		if ( tv->railtype == type )
+			return true;
+		tv = tv->GetNextUnit();
+	}
+	return false;
+}
+
+//helper
+bool ChainContainsVehicle(Train *chain, Train *mem) {
+	for (; chain; chain=chain->Next())
+		if ( chain == mem )
+			return true;
+	return false;
+}
+
+// has O(n)
+Train* ChainContainsEngine(EngineID eid, Train *chain) {
+	for (; chain; chain=chain->GetNextUnit())
+		if (chain->engine_type == eid)
+			return chain;
+	return 0;
+}
+
+// has O(n^2)
+// TODO: switch to trains
+Train* DepotContainsEngine(TileIndex tile, EngineID eid, Train *not_in=0) {
+	Train *t;
+	FOR_ALL_TRAINS(t) {
+		// conditions: v is stopped in the given depot, has the right engine and if 'not_in' is given v must not be contained within 'not_in'
+ 		// if 'not_in' is NULL, no check is needed
+		if ( t->tile==tile
+				// If the veh belongs to a chain, wagons will not return true on IsStoppedInDepot(), only primary vehicles will
+				// in case of t not a primary veh, we demand it to be a free wagon to consider it for replacement
+				&& ((t->IsPrimaryVehicle() && t->IsStoppedInDepot()) || t->IsFreeWagon())
+				&& t->engine_type==eid
+				&& (not_in==0 || ChainContainsVehicle(not_in, t)==0))
+			return t;
+	}
+	return 0;
+}
+
+void CopyStatus(Train *from, Train *to) {
+	// TODO: remove ? used ?
+	//to->group_id = from->group_id;
+	DoCommand(to->tile, from->group_id, to->index, DC_EXEC, CMD_ADD_VEHICLE_GROUP);
+	to->cargo_type = from->cargo_type;
+	to->cargo_subtype = from->cargo_subtype;
+
+	//to->orders = from->orders;
+	//to->current_order = from->current_order;
+	//to->cur_implicit_order_index = from->cur_implicit_order_index;
+
+	// swap names
+	char *tmp = to->name;
+	to->name = from->name;
+	from->name = tmp;
+	/*if ( !from->name || !to->name ) {
+		int tmpind = from->index;
+		from->index = to->index;
+		to->index = tmpind;
+	}*/
+}
+void NeutralizeStatus(Train *t) {
+	DoCommand(t->tile, DEFAULT_GROUP, t->index, DC_EXEC, CMD_ADD_VEHICLE_GROUP);
+
+	//t->orders.list = 0;
+	//t->cur_implicit_order_index = 0;
+
+	t->name = 0;
+}
+bool TrainMatchesTemplate(const Train *t, TemplateVehicle *tv) {
+	while ( t && tv ) {
+		if ( t->engine_type != tv->engine_type )
+			return false;
+		t = t->GetNextUnit();
+		tv = tv->GetNextUnit();
+	}
+	if ( (t && !tv) || (!t && tv) )
+		return false;
+	return true;
+}
+
+
+bool TrainMatchesTemplateRefit(const Train *t, TemplateVehicle *tv)
+{
+	if ( !tv->refit_as_template )
+		return true;
+
+	while ( t && tv ) {
+		if ( t->cargo_type != tv->cargo_type || t->cargo_subtype != tv->cargo_subtype )
+			return false;
+		t = t->GetNextUnit();
+		tv = tv->GetNextUnit();
+	}
+	return true;
+}
+void BreakUpRemainders(Train *t) {
+	while ( t ) {
+		Train *move;
+		if ( HasBit(t->subtype, GVSF_ENGINE) ) {
+			move = t;
+			t = t->Next();
+			DoCommand(move->tile, move->index, INVALID_VEHICLE, DC_EXEC, CMD_MOVE_RAIL_VEHICLE);
+			NeutralizeStatus( move );
+		}
+		else
+			t = t->Next();
+	}
+}
+
+short CountEnginesInChain(Train *t)
+{
+	short count = 0;
+	for ( ; t; t=t->GetNextUnit() )
+		if ( HasBit(t->subtype, GVSF_ENGINE) )
+			count++;
+	return count;
+}
+
+int countOccurrencesInTrain(Train *t, EngineID eid) {
+	int count = 0;
+	Train *tmp = t;
+	for ( ; tmp; tmp=tmp->GetNextUnit() )
+		if ( tmp->engine_type == eid )
+			count++;
+	return count;
+}
+
+int countOccurrencesInTemplateVehicle(TemplateVehicle *contain, EngineID eid) {
+	int count = 0;
+	for ( ; contain; contain=contain->GetNextUnit() )
+		if ( contain->engine_type == eid )
+			count++;
+	return count;
+}
+
+int countOccurrencesInDepot(TileIndex tile, EngineID eid, Train *not_in=0) {
+	int count = 0;
+	Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		// conditions: v is stopped in the given depot, has the right engine and if 'not_in' is given v must not be contained within 'not_in'
+ 		// if 'not_in' is NULL, no check is needed
+		if ( v->tile==tile && v->IsStoppedInDepot() && v->engine_type==eid &&
+				(not_in==0 || ChainContainsVehicle(not_in, (Train*)v)==0))
+			count++;
+	}
+	return count;
+}
+
+// basically does the same steps as CmdTemplateReplaceVehicle but without actually moving things around
+CommandCost CalculateTemplateReplacementCost(Train *incoming) {
+	TileIndex tile = incoming->tile;
+	TemplateVehicle *tv = GetTemplateVehicleByGroupID(incoming->group_id);
+	CommandCost estimate(EXPENSES_NEW_VEHICLES);
+
+	// count for each different eid in the incoming train
+	std::map<EngineID, short> unique_eids;
+	for ( TemplateVehicle *tmp=tv; tmp; tmp=tmp->GetNextUnit() )
+		unique_eids[tmp->engine_type]++;
+	std::map<EngineID, short>::iterator it = unique_eids.begin();
+	for ( ; it!=unique_eids.end(); it++ ) {
+		it->second -= countOccurrencesInTrain(incoming, it->first);
+		it->second -= countOccurrencesInDepot(incoming->tile, it->first, incoming);
+		if ( it->second < 0 ) it->second = 0;
+	}
+
+	// get overall buying cost
+	for ( it=unique_eids.begin(); it!=unique_eids.end(); it++ ) {
+		for ( int j=0; j<it->second; j++ ) {
+			estimate.AddCost(DoCommand(tile, it->first, 0, DC_NONE, CMD_BUILD_VEHICLE));
+		}
+	}
+
+	return estimate;
+}
+
+// make sure the real train wagon has the right cargo
+void CopyWagonStatus(TemplateVehicle *from, Train *to) {
+	to->cargo_type = from->cargo_type;
+	to->cargo_subtype = from->cargo_subtype;
+}
+
+int NumTrainsNeedTemplateReplacement(GroupID g_id, TemplateVehicle *tv)
+{
+	int count = 0;
+	if ( !tv ) return count;
+
+	const Train *t;
+	FOR_ALL_TRAINS(t) {
+		if ( t->IsPrimaryVehicle() && t->group_id == g_id && (!TrainMatchesTemplate(t, tv) || !TrainMatchesTemplateRefit(t, tv)) )
+			count++;
+	}
+	return count;
+}
+// refit each vehicle in t as is in tv, assume t and tv contain the same types of vehicles
+static void RefitTrainFromTemplate(Train *t, TemplateVehicle *tv)
+{
+	while ( t && tv ) {
+		// refit t as tv
+		uint32 cb = GetCmdRefitVeh(t);
+
+		DoCommandP(t->tile, t->index, tv->cargo_type | tv->cargo_subtype << 8 | 1 << 16 , cb);
+		//CommandCost c = CmdRefitVehicle ( t->tile, DC_EXEC, t->index, tv->cargo_type | tv->cargo_subtype << 8 | 1 << 16, "" );
+
+		// next
+		t = t->GetNextUnit();
+		tv = tv->GetNextUnit();
+	}
+}
+
+/** using cmdtemplatereplacevehicle as test-function (i.e. with flag DC_NONE) is not a good idea as that function relies on
+ *  actually moving vehicles around to work properly.
+ *  We do this worst-cast test instead.
+ */
+CommandCost TestBuyAllTemplateVehiclesInChain(TemplateVehicle *tv, TileIndex tile)
+{
+	CommandCost cost(EXPENSES_NEW_VEHICLES);
+
+	for ( ; tv; tv=tv->GetNextUnit() )
+		cost.AddCost( DoCommand(tile, tv->engine_type, 0, DC_NONE, CMD_BUILD_VEHICLE) );
+
+	return cost;
+}
+
+
+void TransferCargoForTrain(Train *old_veh, Train *new_head, bool part_of_chain)
+{
+	assert(!part_of_chain || new_head->IsPrimaryVehicle());
+	/* Loop through source parts */
+	for (Train *src = old_veh; src != NULL; src = src->Next()) {
+		if (!part_of_chain &&  src != old_veh && src != old_veh->other_multiheaded_part && !src->IsArticulatedPart()) {
+			/* Skip vehicles, which do not belong to old_veh */
+			src = src->GetLastEnginePart();
+			continue;
+		}
+		if (src->cargo_type >= NUM_CARGO || src->cargo.Count() == 0) continue;
+
+		/* Find free space in the new chain */
+		for (Train *dest = new_head; dest != NULL && src->cargo.Count() > 0; dest = dest->Next()) {
+			if (!part_of_chain  && dest != new_head && dest != new_head->other_multiheaded_part && !dest->IsArticulatedPart()) {
+				/* Skip vehicles, which do not belong to new_head */
+				dest = dest->GetLastEnginePart();
+				continue;
+			}
+			if (dest->cargo_type != src->cargo_type) continue;
+
+			uint amount = min(src->cargo.Count(), dest->cargo_cap - dest->cargo.Count());
+			if (amount <= 0) continue;
+
+			src->cargo.MoveTo(&dest->cargo, amount);//, VehicleCargoList::MTA_UNLOAD, NULL);
+		}
+	}
+
+	/* Update train weight etc., the old vehicle will be sold anyway */
+	if (part_of_chain ) new_head->ConsistChanged(true);
+}
+
+// TODO: fit signature to regular cmd-structure
+//		 do something with move_cost, it is not used right now
+// if exec==DC_EXEC, test first and execute if sucessful
+CommandCost CmdTemplateReplaceVehicle(Train *incoming, bool stayInDepot, DoCommandFlag flags) {
+	Train	*new_chain=0,
+			*remainder_chain=0,
+			*tmp_chain=0;
+	TileIndex tile = incoming->tile;
+	TemplateVehicle *tv = GetTemplateVehicleByGroupID(incoming->group_id);
+	EngineID eid = tv->engine_type;
+
+	CommandCost buy(EXPENSES_NEW_VEHICLES);
+	CommandCost move_cost(EXPENSES_NEW_VEHICLES);
+	CommandCost tmp_result(EXPENSES_NEW_VEHICLES);
+
+
+	/* first some tests on necessity and sanity */
+	if ( !tv )
+		return buy;
+	bool need_replacement = !TrainMatchesTemplate(incoming, tv);
+	bool need_refit = !TrainMatchesTemplateRefit(incoming, tv);
+	bool use_refit = tv->refit_as_template;
+	CargoID store_refit_ct = CT_INVALID;
+	short store_refit_csubt = 0;
+	// if a train shall keep its old refit, store the refit setting of its first vehicle
+	if ( !use_refit ) {
+		for ( Train *getc=incoming; getc; getc=getc->GetNextUnit() )
+			if ( getc->cargo_type != CT_INVALID ) {
+				store_refit_ct = getc->cargo_type;
+				break;
+			}
+	}
+
+	// TODO: set result status to success/no success before returning
+	if ( !need_replacement ) {
+		if ( !need_refit || !use_refit ) {
+			/* before returning, release incoming train first if 2nd param says so */
+			if ( !stayInDepot ) incoming->vehstatus &= ~VS_STOPPED;
+			return buy;
+		}
+	} else {
+		CommandCost buyCost = TestBuyAllTemplateVehiclesInChain(tv, tile);
+		if ( !buyCost.Succeeded() || !CheckCompanyHasMoney(buyCost) ) {
+			if ( !stayInDepot ) incoming->vehstatus &= ~VS_STOPPED;
+			return buy;
+		}
+	}
+
+	/* define replacement behaviour */
+	bool reuseDepot = tv->IsSetReuseDepotVehicles();
+	bool keepRemainders = tv->IsSetKeepRemainingVehicles();
+
+	if ( need_replacement ) {
+		/// step 1: generate primary for newchain and generate remainder_chain
+			// 1. primary of incoming might already fit the template
+				// leave incoming's primary as is and move the rest to a free chain = remainder_chain
+			// 2. needed primary might be one of incoming's member vehicles
+			// 3. primary might be available as orphan vehicle in the depot
+			// 4. we need to buy a new engine for the primary
+			// all options other than 1. need to make sure to copy incoming's primary's status
+		if ( eid == incoming->engine_type ) {													// 1
+			new_chain = incoming;
+			remainder_chain = incoming->GetNextUnit();
+			if ( remainder_chain )
+				move_cost.AddCost(CmdMoveRailVehicle(tile, flags, remainder_chain->index|(1<<20), INVALID_VEHICLE, 0));
+		}
+		else if ( (tmp_chain = ChainContainsEngine(eid, incoming)) && tmp_chain!=NULL )	{		// 2
+			// new_chain is the needed engine, move it to an empty spot in the depot
+			new_chain = tmp_chain;
+			move_cost.AddCost(DoCommand(tile, new_chain->index, INVALID_VEHICLE, flags,CMD_MOVE_RAIL_VEHICLE));
+			remainder_chain = incoming;
+		}
+		else if ( reuseDepot && (tmp_chain = DepotContainsEngine(tile, eid, incoming)) && tmp_chain!=NULL ) {	// 3
+			new_chain = tmp_chain;
+			move_cost.AddCost(DoCommand(tile, new_chain->index, INVALID_VEHICLE, flags, CMD_MOVE_RAIL_VEHICLE));
+			remainder_chain = incoming;
+		}
+		else {																				// 4
+			tmp_result = DoCommand(tile, eid, 0, flags, CMD_BUILD_VEHICLE);
+			/* break up in case buying the vehicle didn't succeed */
+			if ( !tmp_result.Succeeded() )
+				return tmp_result;
+			buy.AddCost(tmp_result);
+			new_chain = Train::Get(_new_vehicle_id);
+			/* make sure the newly built engine is not attached to any free wagons inside the depot */
+			move_cost.AddCost ( DoCommand(tile, new_chain->index, INVALID_VEHICLE, flags, CMD_MOVE_RAIL_VEHICLE) );
+			/* prepare the remainder chain */
+			remainder_chain = incoming;
+		}
+		// If we bought a new engine or reused one from the depot, copy some parameters from the incoming primary engine
+		if ( incoming != new_chain && flags == DC_EXEC) {
+			CopyHeadSpecificThings(incoming, new_chain, flags);
+			NeutralizeStatus(incoming);
+			// additionally, if we don't want to use the template refit, refit as incoming
+			// the template refit will be set further down, if we use it at all
+			if ( !use_refit ) {
+				uint32 cb = GetCmdRefitVeh(new_chain);
+				DoCommandP(new_chain->tile, new_chain->index, store_refit_ct | store_refit_csubt << 8 | 1 << 16 , cb);
+			}
+
+		}
+
+		/// step 2: fill up newchain according to the template
+			// foreach member of template (after primary):
+				// 1. needed engine might be within remainder_chain already
+				// 2. needed engine might be orphaned within the depot (copy status)
+				// 3. we need to buy (again)						   (copy status)
+		TemplateVehicle *cur_tmpl = tv->GetNextUnit();
+		Train *last_veh = new_chain;
+		while (cur_tmpl) {
+			// 1. engine contained in remainder chain
+			if ( (tmp_chain = ChainContainsEngine(cur_tmpl->engine_type, remainder_chain)) && tmp_chain!=NULL )	{
+				// advance remainder_chain (if necessary) to not lose track of it
+				if ( tmp_chain == remainder_chain )
+					remainder_chain = remainder_chain->GetNextUnit();
+				move_cost.AddCost(CmdMoveRailVehicle(tile, flags, tmp_chain->index, last_veh->index, 0));
+			}
+			// 2. engine contained somewhere else in the depot
+			else if ( reuseDepot && (tmp_chain = DepotContainsEngine(tile, cur_tmpl->engine_type, new_chain)) && tmp_chain!=NULL ) {
+				move_cost.AddCost(CmdMoveRailVehicle(tile, flags, tmp_chain->index, last_veh->index, 0));
+			}
+			// 3. must buy new engine
+			else {
+				tmp_result = DoCommand(tile, cur_tmpl->engine_type, 0, flags, CMD_BUILD_VEHICLE);
+				if ( !tmp_result.Succeeded() )
+					return tmp_result;
+				buy.AddCost(tmp_result);
+				tmp_chain = Train::Get(_new_vehicle_id);
+				move_cost.AddCost(CmdMoveRailVehicle(tile, flags, tmp_chain->index, last_veh->index, 0));
+			}
+			if ( flags == DC_EXEC ) {
+				CopyWagonStatus(cur_tmpl, tmp_chain);
+				if ( !use_refit ) {
+					uint32 cb = GetCmdRefitVeh(tmp_chain);
+					DoCommandP(tmp_chain->tile, tmp_chain->index, store_refit_ct | store_refit_csubt << 8 | 1 << 16 , cb);
+				}
+			}
+			cur_tmpl = cur_tmpl->GetNextUnit();
+			last_veh = tmp_chain;
+		}
+	}
+	/* no replacement done */
+	else {
+		new_chain = incoming;
+	}
+	/// step 3: reorder and neutralize the remaining vehicles from incoming
+		// wagons remaining from remainder_chain should be filled up in as few freewagonchains as possible
+		// each locos might be left as singular in the depot
+		// neutralize each remaining engine's status
+
+	// refit, only if the template option is set so
+	if ( use_refit && (need_refit || need_replacement) ) {
+		RefitTrainFromTemplate(new_chain, tv);
+	}
+
+	if ( new_chain && remainder_chain )
+		for ( Train *ct=remainder_chain; ct; ct=ct->GetNextUnit() )
+			TransferCargoForTrain(ct, new_chain, true);
+
+	// point incoming to the newly created train so that starting/stopping from the calling function can be done
+	incoming = new_chain;
+	if ( !stayInDepot && flags == DC_EXEC )
+		new_chain->vehstatus &= ~VS_STOPPED;
+
+	if ( remainder_chain && keepRemainders && flags == DC_EXEC )
+		BreakUpRemainders(remainder_chain);
+	else if ( remainder_chain ) {
+		buy.AddCost(DoCommand(tile, remainder_chain->index | (1<<20), 0, flags, CMD_SELL_VEHICLE));
+	}
+	return buy;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Index: src/misc_gui.cpp
===================================================================
--- src/misc_gui.cpp	(revision 24093)
+++ src/misc_gui.cpp	(working copy)
@@ -544,17 +544,28 @@
 
 /**
  * Display animated feeder income.
- * @param x    World X position of the animation location.
- * @param y    World Y position of the animation location.
- * @param z    World Z position of the animation location.
- * @param cost Estimated feeder income.
+ * @param x        World X position of the animation location.
+ * @param y        World Y position of the animation location.
+ * @param z        World Z position of the animation location.
+ * @param transfer Estimated feeder income.
+ * @param income   Real income from goods being delivered to their final destination.
  */
-void ShowFeederIncomeAnimation(int x, int y, int z, Money cost)
+void ShowFeederIncomeAnimation(int x, int y, int z, Money transfer, Money income)
 {
 	Point pt = RemapCoords(x, y, z);
 
-	SetDParam(0, cost);
-	AddTextEffect(STR_FEEDER, pt.x, pt.y, DAY_TICKS, TE_RISING);
+	SetDParam(0, transfer);
+	if (income == 0) {
+		AddTextEffect(STR_FEEDER, pt.x, pt.y, DAY_TICKS, TE_RISING);
+	} else {
+		StringID msg = STR_FEEDER_COST;
+		if (income < 0) {
+			income = -income;
+			msg = STR_FEEDER_INCOME;
+		}
+		SetDParam(1, income);
+		AddTextEffect(msg, pt.x, pt.y, DAY_TICKS, TE_RISING);
+	}
 }
 
 /**
Index: src/smallmap_gui.cpp
===================================================================
--- src/smallmap_gui.cpp	(revision 24093)
+++ src/smallmap_gui.cpp	(working copy)
@@ -14,26 +14,26 @@
 #include "industry.h"
 #include "station_map.h"
 #include "landscape.h"
-#include "window_gui.h"
 #include "tree_map.h"
 #include "viewport_func.h"
 #include "town.h"
-#include "blitter/factory.hpp"
 #include "tunnelbridge_map.h"
-#include "strings_func.h"
 #include "core/endian_func.hpp"
 #include "vehicle_base.h"
 #include "sound_func.h"
 #include "window_func.h"
 #include "company_base.h"
+#include "smallmap_gui.h"
 
-#include "widgets/smallmap_widget.h"
-
 #include "table/strings.h"
 
 static int _smallmap_industry_count; ///< Number of used industries
 static int _smallmap_company_count;  ///< Number of entries in the owner legend.
+static int _smallmap_cargo_count;    ///< number of cargos in the link stats legend
 
+/** Link stat colours shown in legenda. */
+static uint8 _linkstat_colours_in_legenda[] = {0, 1, 3, 5, 7, 9, 11};
+
 static const int NUM_NO_COMPANY_ENTRIES = 4; ///< Number of entries in the owner legend that are not companies.
 
 static const uint8 PC_ROUGH_LAND      = 0x52; ///< Dark green palette colour for rough land.
@@ -64,18 +64,6 @@
  */
 #define MS(a, b) {a, b, INVALID_INDUSTRYTYPE, 0, INVALID_COMPANY, true, false, true}
 
-/** Structure for holding relevant data for legends in small map */
-struct LegendAndColour {
-	uint8 colour;              ///< Colour of the item on the map.
-	StringID legend;           ///< String corresponding to the coloured item.
-	IndustryType type;         ///< Type of industry. Only valid for industry entries.
-	uint8 height;              ///< Height in tiles. Only valid for height legend entries.
-	CompanyID company;         ///< Company to display. Only valid for company entries of the owner legend.
-	bool show_on_map;          ///< For filtering industries, if \c true, industry is shown on the map in colour.
-	bool end;                  ///< This is the end of the list.
-	bool col_break;            ///< Perform a column break and go further at the next column.
-};
-
 /** Legend text giving the colours to look for on the minimap */
 static LegendAndColour _legend_land_contours[] = {
 	/* The colours for the following values are set at BuildLandLegend() based on each colour scheme. */
@@ -149,6 +137,8 @@
 #undef MOEND
 #undef MKEND
 
+/** Legend entries for the link stats view. */
+static LegendAndColour _legend_linkstats[NUM_CARGO + lengthof(_linkstat_colours_in_legenda) + 1];
 /**
  * Allow room for all industries, plus a terminator entry
  * This is required in order to have the indutry slots all filled up
@@ -192,10 +182,44 @@
 	_smallmap_industry_count = j;
 }
 
+/**
+ * Populate legend table for the link stat view.
+ */
+void BuildLinkStatsLegend()
+{
+	/* Clear the legend */
+	memset(_legend_linkstats, 0, sizeof(_legend_linkstats));
+
+	uint i = 0;
+	for (; i < _sorted_cargo_specs_size; ++i) {
+		const CargoSpec *cs = _sorted_cargo_specs[i];
+
+		_legend_linkstats[i].legend = cs->name;
+		_legend_linkstats[i].colour = cs->legend_colour;
+		_legend_linkstats[i].type = cs->Index();
+		_legend_linkstats[i].show_on_map = true;
+	}
+
+	_legend_linkstats[i].col_break = true;
+	_smallmap_cargo_count = i;
+
+	for (; i < _smallmap_cargo_count + lengthof(_linkstat_colours_in_legenda); ++i) {
+		_legend_linkstats[i].legend = STR_EMPTY;
+		_legend_linkstats[i].colour = LinkGraphOverlay::LINK_COLOURS[_linkstat_colours_in_legenda[i - _smallmap_cargo_count]];
+		_legend_linkstats[i].show_on_map = true;
+	}
+
+	_legend_linkstats[_smallmap_cargo_count].legend = STR_LINKGRAPH_LEGEND_UNUSED;
+	_legend_linkstats[i - 1].legend = STR_LINKGRAPH_LEGEND_OVERLOADED;
+	_legend_linkstats[(_smallmap_cargo_count + i - 1) / 2].legend = STR_LINKGRAPH_LEGEND_SATURATED;
+	_legend_linkstats[i].end = true;
+}
+
 static const LegendAndColour * const _legend_table[] = {
 	_legend_land_contours,
 	_legend_vehicles,
 	_legend_from_industries,
+	_legend_linkstats,
 	_legend_routes,
 	_legend_vegetation,
 	_legend_land_owners,
@@ -486,6 +510,17 @@
 	return ApplyMask(cs->default_colour, &_smallmap_contours_andor[t]);
 }
 
+/**
+ * Return the colour a tile would be displayed with in the small map in mode "link stats".
+ *
+ * @param tile The tile of which we would like to get the colour.
+ * @param t    Effective tile type of the tile (see #GetEffectiveTileType).
+ * @return The colour of tile in the small map in mode "link stats"
+ */
+static inline uint32 GetSmallMapLinkStatsPixels(TileIndex tile, TileType t)
+{
+	return _smallmap_show_heightmap ? GetSmallMapContoursPixels(tile, t) : GetSmallMapRoutesPixels(tile, t);
+}
 
 static const uint32 _vegetation_clear_bits[] = {
 	MKCOLOUR_XXXX(PC_GRASS_LAND), ///< full grass
@@ -562,987 +597,984 @@
 	PC_RED, PC_YELLOW, PC_LIGHT_BLUE, PC_WHITE, PC_BLACK, PC_RED
 };
 
+inline Point SmallMapWindow::SmallmapRemapCoords(int x, int y) const
+{
+	Point pt;
+	pt.x = (y - x) * 2;
+	pt.y = y + x;
+	return pt;
+}
 
-/** Class managing the smallmap window. */
-class SmallMapWindow : public Window {
-	/** Types of legends in the #WID_SM_LEGEND widget. */
-	enum SmallMapType {
-		SMT_CONTOUR,
-		SMT_VEHICLES,
-		SMT_INDUSTRY,
-		SMT_ROUTES,
-		SMT_VEGETATION,
-		SMT_OWNER,
-	};
+/**
+ * Remap tile to location on this smallmap.
+ * @param tile_x X coordinate of the tile.
+ * @param tile_y Y coordinate of the tile.
+ * @return Position to draw on.
+ */
+inline Point SmallMapWindow::RemapTile(int tile_x, int tile_y) const
+{
+	int x_offset = tile_x - this->scroll_x / (int)TILE_SIZE;
+	int y_offset = tile_y - this->scroll_y / (int)TILE_SIZE;
 
-	/** Available kinds of zoomlevel changes. */
-	enum ZoomLevelChange {
-		ZLC_INITIALIZE, ///< Initialize zoom level.
-		ZLC_ZOOM_OUT,   ///< Zoom out.
-		ZLC_ZOOM_IN,    ///< Zoom in.
-	};
+	if (this->zoom == 1) return SmallmapRemapCoords(x_offset, y_offset);
 
-	static SmallMapType map_type; ///< Currently displayed legends.
-	static bool show_towns;       ///< Display town names in the smallmap.
+	/* For negative offsets, round towards -inf. */
+	if (x_offset < 0) x_offset -= this->zoom - 1;
+	if (y_offset < 0) y_offset -= this->zoom - 1;
 
-	static const uint LEGEND_BLOB_WIDTH = 8;              ///< Width of the coloured blob in front of a line text in the #WID_SM_LEGEND widget.
-	static const uint INDUSTRY_MIN_NUMBER_OF_COLUMNS = 2; ///< Minimal number of columns in the #WID_SM_LEGEND widget for the #SMT_INDUSTRY legend.
-	uint min_number_of_fixed_rows; ///< Minimal number of rows in the legends for the fixed layouts only (all except #SMT_INDUSTRY).
-	uint column_width;             ///< Width of a column in the #WID_SM_LEGEND widget.
+	return SmallmapRemapCoords(x_offset / this->zoom, y_offset / this->zoom);
+}
 
-	int32 scroll_x;  ///< Horizontal world coordinate of the base tile left of the top-left corner of the smallmap display.
-	int32 scroll_y;  ///< Vertical world coordinate of the base tile left of the top-left corner of the smallmap display.
-	int32 subscroll; ///< Number of pixels (0..3) between the right end of the base tile and the pixel at the top-left corner of the smallmap display.
-	int zoom;        ///< Zoom level. Bigger number means more zoom-out (further away).
+/**
+ * Determine the tile relative to the base tile of the smallmap, and the pixel position at
+ * that tile for a point in the smallmap.
+ * @param px       Horizontal coordinate of the pixel.
+ * @param py       Vertical coordinate of the pixel.
+ * @param sub[out] Pixel position at the tile (0..3).
+ * @param add_sub  Add current #subscroll to the position.
+ * @return Tile being displayed at the given position relative to #scroll_x and #scroll_y.
+ * @note The #subscroll offset is already accounted for.
+ */
+inline Point SmallMapWindow::PixelToTile(int px, int py, int *sub, bool add_sub) const
+{
+	if (add_sub) px += this->subscroll;  // Total horizontal offset.
 
-	static const uint8 FORCE_REFRESH_PERIOD = 0x1F; ///< map is redrawn after that many ticks
-	uint8 refresh; ///< refresh counter, zeroed every FORCE_REFRESH_PERIOD ticks
+	/* For each two rows down, add a x and a y tile, and
+	 * For each four pixels to the right, move a tile to the right. */
+	Point pt = {((py >> 1) - (px >> 2)) * this->zoom, ((py >> 1) + (px >> 2)) * this->zoom};
+	px &= 3;
 
-	inline Point SmallmapRemapCoords(int x, int y) const
-	{
-		Point pt;
-		pt.x = (y - x) * 2;
-		pt.y = y + x;
-		return pt;
+	if (py & 1) { // Odd number of rows, handle the 2 pixel shift.
+		if (px < 2) {
+			pt.x += this->zoom;
+			px += 2;
+		} else {
+			pt.y += this->zoom;
+			px -= 2;
+		}
 	}
 
-	/**
-	 * Remap tile to location on this smallmap.
-	 * @param tile_x X coordinate of the tile.
-	 * @param tile_y Y coordinate of the tile.
-	 * @return Position to draw on.
-	 */
-	inline Point RemapTile(int tile_x, int tile_y) const
-	{
-		int x_offset = tile_x - this->scroll_x / (int)TILE_SIZE;
-		int y_offset = tile_y - this->scroll_y / (int)TILE_SIZE;
+	*sub = px;
+	return pt;
+}
 
-		if (this->zoom == 1) return SmallmapRemapCoords(x_offset, y_offset);
+/**
+ * Compute base parameters of the smallmap such that tile (\a tx, \a ty) starts at pixel (\a x, \a y).
+ * @param tx        Tile x coordinate.
+ * @param ty        Tile y coordinate.
+ * @param x         Non-negative horizontal position in the display where the tile starts.
+ * @param y         Non-negative vertical position in the display where the tile starts.
+ * @param sub [out] Value of #subscroll needed.
+ * @return #scroll_x, #scroll_y values.
+ */
+Point SmallMapWindow::ComputeScroll(int tx, int ty, int x, int y, int *sub)
+{
+	assert(x >= 0 && y >= 0);
 
-		/* For negative offsets, round towards -inf. */
-		if (x_offset < 0) x_offset -= this->zoom - 1;
-		if (y_offset < 0) y_offset -= this->zoom - 1;
+	int new_sub;
+	Point tile_xy = PixelToTile(x, y, &new_sub, false);
+	tx -= tile_xy.x;
+	ty -= tile_xy.y;
 
-		return SmallmapRemapCoords(x_offset / this->zoom, y_offset / this->zoom);
+	Point scroll;
+	if (new_sub == 0) {
+		*sub = 0;
+		scroll.x = (tx + this->zoom) * TILE_SIZE;
+		scroll.y = (ty - this->zoom) * TILE_SIZE;
+	} else {
+		*sub = 4 - new_sub;
+		scroll.x = (tx + 2 * this->zoom) * TILE_SIZE;
+		scroll.y = (ty - 2 * this->zoom) * TILE_SIZE;
 	}
+	return scroll;
+}
 
-	/**
-	 * Determine the tile relative to the base tile of the smallmap, and the pixel position at
-	 * that tile for a point in the smallmap.
-	 * @param px       Horizontal coordinate of the pixel.
-	 * @param py       Vertical coordinate of the pixel.
-	 * @param sub[out] Pixel position at the tile (0..3).
-	 * @param add_sub  Add current #subscroll to the position.
-	 * @return Tile being displayed at the given position relative to #scroll_x and #scroll_y.
-	 * @note The #subscroll offset is already accounted for.
-	 */
-	inline Point PixelToTile(int px, int py, int *sub, bool add_sub = true) const
-	{
-		if (add_sub) px += this->subscroll;  // Total horizontal offset.
+/**
+ * Initialize or change the zoom level.
+ * @param change  Way to change the zoom level.
+ * @param zoom_pt Position to keep fixed while zooming.
+ * @pre \c *zoom_pt should contain a point in the smallmap display when zooming in or out.
+ */
+void SmallMapWindow::SetZoomLevel(ZoomLevelChange change, const Point *zoom_pt)
+{
+	static const int zoomlevels[] = {1, 2, 4, 6, 8}; // Available zoom levels. Bigger number means more zoom-out (further away).
+	static const int MIN_ZOOM_INDEX = 0;
+	static const int MAX_ZOOM_INDEX = lengthof(zoomlevels) - 1;
 
-		/* For each two rows down, add a x and a y tile, and
-		 * For each four pixels to the right, move a tile to the right. */
-		Point pt = {((py >> 1) - (px >> 2)) * this->zoom, ((py >> 1) + (px >> 2)) * this->zoom};
-		px &= 3;
+	int new_index, cur_index, sub;
+	Point tile;
+	switch (change) {
+		case ZLC_INITIALIZE:
+			cur_index = - 1; // Definitely different from new_index.
+			new_index = MIN_ZOOM_INDEX;
+			break;
 
-		if (py & 1) { // Odd number of rows, handle the 2 pixel shift.
-			if (px < 2) {
-				pt.x += this->zoom;
-				px += 2;
-			} else {
-				pt.y += this->zoom;
-				px -= 2;
+		case ZLC_ZOOM_IN:
+		case ZLC_ZOOM_OUT:
+			for (cur_index = MIN_ZOOM_INDEX; cur_index <= MAX_ZOOM_INDEX; cur_index++) {
+				if (this->zoom == zoomlevels[cur_index]) break;
 			}
-		}
+			assert(cur_index <= MAX_ZOOM_INDEX);
 
-		*sub = px;
-		return pt;
+			tile = this->PixelToTile(zoom_pt->x, zoom_pt->y, &sub);
+			new_index = Clamp(cur_index + ((change == ZLC_ZOOM_IN) ? -1 : 1), MIN_ZOOM_INDEX, MAX_ZOOM_INDEX);
+			break;
+
+		default: NOT_REACHED();
 	}
 
-	/**
-	 * Compute base parameters of the smallmap such that tile (\a tx, \a ty) starts at pixel (\a x, \a y).
-	 * @param tx        Tile x coordinate.
-	 * @param ty        Tile y coordinate.
-	 * @param x         Non-negative horizontal position in the display where the tile starts.
-	 * @param y         Non-negative vertical position in the display where the tile starts.
-	 * @param sub [out] Value of #subscroll needed.
-	 * @return #scroll_x, #scroll_y values.
-	 */
-	Point ComputeScroll(int tx, int ty, int x, int y, int *sub)
-	{
-		assert(x >= 0 && y >= 0);
-
-		int new_sub;
-		Point tile_xy = PixelToTile(x, y, &new_sub, false);
-		tx -= tile_xy.x;
-		ty -= tile_xy.y;
-
-		Point scroll;
-		if (new_sub == 0) {
-			*sub = 0;
-			scroll.x = (tx + this->zoom) * TILE_SIZE;
-			scroll.y = (ty - this->zoom) * TILE_SIZE;
-		} else {
-			*sub = 4 - new_sub;
-			scroll.x = (tx + 2 * this->zoom) * TILE_SIZE;
-			scroll.y = (ty - 2 * this->zoom) * TILE_SIZE;
+	if (new_index != cur_index) {
+		this->zoom = zoomlevels[new_index];
+		if (cur_index >= 0) {
+			Point new_tile = this->PixelToTile(zoom_pt->x, zoom_pt->y, &sub);
+			this->SetNewScroll(this->scroll_x + (tile.x - new_tile.x) * TILE_SIZE,
+					this->scroll_y + (tile.y - new_tile.y) * TILE_SIZE, sub);
+		} else if (this->map_type == SMT_LINKSTATS) {
+			this->overlay->RebuildCache();
 		}
-		return scroll;
+		this->SetWidgetDisabledState(WID_SM_ZOOM_IN,  this->zoom == zoomlevels[MIN_ZOOM_INDEX]);
+		this->SetWidgetDisabledState(WID_SM_ZOOM_OUT, this->zoom == zoomlevels[MAX_ZOOM_INDEX]);
+		this->SetDirty();
 	}
+}
 
-	/**
-	 * Initialize or change the zoom level.
-	 * @param change  Way to change the zoom level.
-	 * @param zoom_pt Position to keep fixed while zooming.
-	 * @pre \c *zoom_pt should contain a point in the smallmap display when zooming in or out.
-	 */
-	void SetZoomLevel(ZoomLevelChange change, const Point *zoom_pt)
-	{
-		static const int zoomlevels[] = {1, 2, 4, 6, 8}; // Available zoom levels. Bigger number means more zoom-out (further away).
-		static const int MIN_ZOOM_INDEX = 0;
-		static const int MAX_ZOOM_INDEX = lengthof(zoomlevels) - 1;
+/**
+ * Decide which colours to show to the user for a group of tiles.
+ * @param ta Tile area to investigate.
+ * @return Colours to display.
+ */
+inline uint32 SmallMapWindow::GetTileColours(const TileArea &ta) const
+{
+	int importance = 0;
+	TileIndex tile = INVALID_TILE; // Position of the most important tile.
+	TileType et = MP_VOID;         // Effective tile type at that position.
 
-		int new_index, cur_index, sub;
-		Point tile;
-		switch (change) {
-			case ZLC_INITIALIZE:
-				cur_index = - 1; // Definitely different from new_index.
-				new_index = MIN_ZOOM_INDEX;
-				break;
-
-			case ZLC_ZOOM_IN:
-			case ZLC_ZOOM_OUT:
-				for (cur_index = MIN_ZOOM_INDEX; cur_index <= MAX_ZOOM_INDEX; cur_index++) {
-					if (this->zoom == zoomlevels[cur_index]) break;
-				}
-				assert(cur_index <= MAX_ZOOM_INDEX);
-
-				tile = this->PixelToTile(zoom_pt->x, zoom_pt->y, &sub);
-				new_index = Clamp(cur_index + ((change == ZLC_ZOOM_IN) ? -1 : 1), MIN_ZOOM_INDEX, MAX_ZOOM_INDEX);
-				break;
-
-			default: NOT_REACHED();
+	TILE_AREA_LOOP(ti, ta) {
+		TileType ttype = GetEffectiveTileType(ti);
+		if (_tiletype_importance[ttype] > importance) {
+			importance = _tiletype_importance[ttype];
+			tile = ti;
+			et = ttype;
 		}
-
-		if (new_index != cur_index) {
-			this->zoom = zoomlevels[new_index];
-			if (cur_index >= 0) {
-				Point new_tile = this->PixelToTile(zoom_pt->x, zoom_pt->y, &sub);
-				this->SetNewScroll(this->scroll_x + (tile.x - new_tile.x) * TILE_SIZE,
-						this->scroll_y + (tile.y - new_tile.y) * TILE_SIZE, sub);
-			}
-			this->SetWidgetDisabledState(WID_SM_ZOOM_IN,  this->zoom == zoomlevels[MIN_ZOOM_INDEX]);
-			this->SetWidgetDisabledState(WID_SM_ZOOM_OUT, this->zoom == zoomlevels[MAX_ZOOM_INDEX]);
-			this->SetDirty();
-		}
 	}
 
-	/**
-	 * Decide which colours to show to the user for a group of tiles.
-	 * @param ta Tile area to investigate.
-	 * @return Colours to display.
-	 */
-	inline uint32 GetTileColours(const TileArea &ta) const
-	{
-		int importance = 0;
-		TileIndex tile = INVALID_TILE; // Position of the most important tile.
-		TileType et = MP_VOID;         // Effective tile type at that position.
+	switch (this->map_type) {
+		case SMT_CONTOUR:
+			return GetSmallMapContoursPixels(tile, et);
 
-		TILE_AREA_LOOP(ti, ta) {
-			TileType ttype = GetEffectiveTileType(ti);
-			if (_tiletype_importance[ttype] > importance) {
-				importance = _tiletype_importance[ttype];
-				tile = ti;
-				et = ttype;
-			}
-		}
+		case SMT_VEHICLES:
+			return GetSmallMapVehiclesPixels(tile, et);
 
-		switch (this->map_type) {
-			case SMT_CONTOUR:
-				return GetSmallMapContoursPixels(tile, et);
+		case SMT_INDUSTRY:
+			return GetSmallMapIndustriesPixels(tile, et);
 
-			case SMT_VEHICLES:
-				return GetSmallMapVehiclesPixels(tile, et);
+		case SMT_LINKSTATS:
+			return GetSmallMapLinkStatsPixels(tile, et);
 
-			case SMT_INDUSTRY:
-				return GetSmallMapIndustriesPixels(tile, et);
+		case SMT_ROUTES:
+			return GetSmallMapRoutesPixels(tile, et);
 
-			case SMT_ROUTES:
-				return GetSmallMapRoutesPixels(tile, et);
+		case SMT_VEGETATION:
+			return GetSmallMapVegetationPixels(tile, et);
 
-			case SMT_VEGETATION:
-				return GetSmallMapVegetationPixels(tile, et);
+		case SMT_OWNER:
+			return GetSmallMapOwnerPixels(tile, et);
 
-			case SMT_OWNER:
-				return GetSmallMapOwnerPixels(tile, et);
-
-			default: NOT_REACHED();
-		}
+		default: NOT_REACHED();
 	}
+}
 
-	/**
-	 * Draws one column of tiles of the small map in a certain mode onto the screen buffer, skipping the shifted rows in between.
-	 *
-	 * @param dst Pointer to a part of the screen buffer to write to.
-	 * @param xc The X coordinate of the first tile in the column.
-	 * @param yc The Y coordinate of the first tile in the column
-	 * @param pitch Number of pixels to advance in the screen buffer each time a pixel is written.
-	 * @param reps Number of lines to draw
-	 * @param start_pos Position of first pixel to draw.
-	 * @param end_pos Position of last pixel to draw (exclusive).
-	 * @param blitter current blitter
-	 * @note If pixel position is below \c 0, skip drawing.
-	 * @see GetSmallMapPixels(TileIndex)
-	 */
-	void DrawSmallMapColumn(void *dst, uint xc, uint yc, int pitch, int reps, int start_pos, int end_pos, Blitter *blitter) const
-	{
-		void *dst_ptr_abs_end = blitter->MoveTo(_screen.dst_ptr, 0, _screen.height);
-		uint min_xy = _settings_game.construction.freeform_edges ? 1 : 0;
+/**
+ * Draws one column of tiles of the small map in a certain mode onto the screen buffer, skipping the shifted rows in between.
+ *
+ * @param dst Pointer to a part of the screen buffer to write to.
+ * @param xc The X coordinate of the first tile in the column.
+ * @param yc The Y coordinate of the first tile in the column
+ * @param pitch Number of pixels to advance in the screen buffer each time a pixel is written.
+ * @param reps Number of lines to draw
+ * @param start_pos Position of first pixel to draw.
+ * @param end_pos Position of last pixel to draw (exclusive).
+ * @param blitter current blitter
+ * @note If pixel position is below \c 0, skip drawing.
+ * @see GetSmallMapPixels(TileIndex)
+ */
+void SmallMapWindow::DrawSmallMapColumn(void *dst, uint xc, uint yc, int pitch, int reps, int start_pos, int end_pos, Blitter *blitter) const
+{
+	void *dst_ptr_abs_end = blitter->MoveTo(_screen.dst_ptr, 0, _screen.height);
+	uint min_xy = _settings_game.construction.freeform_edges ? 1 : 0;
 
-		do {
-			/* Check if the tile (xc,yc) is within the map range */
-			if (xc >= MapMaxX() || yc >= MapMaxY()) continue;
+	do {
+		/* Check if the tile (xc,yc) is within the map range */
+		if (xc >= MapMaxX() || yc >= MapMaxY()) continue;
 
-			/* Check if the dst pointer points to a pixel inside the screen buffer */
-			if (dst < _screen.dst_ptr) continue;
-			if (dst >= dst_ptr_abs_end) continue;
+		/* Check if the dst pointer points to a pixel inside the screen buffer */
+		if (dst < _screen.dst_ptr) continue;
+		if (dst >= dst_ptr_abs_end) continue;
 
-			/* Construct tilearea covered by (xc, yc, xc + this->zoom, yc + this->zoom) such that it is within min_xy limits. */
-			TileArea ta;
-			if (min_xy == 1 && (xc == 0 || yc == 0)) {
-				if (this->zoom == 1) continue; // The tile area is empty, don't draw anything.
+		/* Construct tilearea covered by (xc, yc, xc + this->zoom, yc + this->zoom) such that it is within min_xy limits. */
+		TileArea ta;
+		if (min_xy == 1 && (xc == 0 || yc == 0)) {
+			if (this->zoom == 1) continue; // The tile area is empty, don't draw anything.
 
-				ta = TileArea(TileXY(max(min_xy, xc), max(min_xy, yc)), this->zoom - (xc == 0), this->zoom - (yc == 0));
-			} else {
-				ta = TileArea(TileXY(xc, yc), this->zoom, this->zoom);
-			}
-			ta.ClampToMap(); // Clamp to map boundaries (may contain MP_VOID tiles!).
+			ta = TileArea(TileXY(max(min_xy, xc), max(min_xy, yc)), this->zoom - (xc == 0), this->zoom - (yc == 0));
+		} else {
+			ta = TileArea(TileXY(xc, yc), this->zoom, this->zoom);
+		}
+		ta.ClampToMap(); // Clamp to map boundaries (may contain MP_VOID tiles!).
 
-			uint32 val = this->GetTileColours(ta);
-			uint8 *val8 = (uint8 *)&val;
-			int idx = max(0, -start_pos);
-			for (int pos = max(0, start_pos); pos < end_pos; pos++) {
-				blitter->SetPixel(dst, idx, 0, val8[idx]);
-				idx++;
-			}
-		/* Switch to next tile in the column */
-		} while (xc += this->zoom, yc += this->zoom, dst = blitter->MoveTo(dst, pitch, 0), --reps != 0);
-	}
+		uint32 val = this->GetTileColours(ta);
+		uint8 *val8 = (uint8 *)&val;
+		int idx = max(0, -start_pos);
+		for (int pos = max(0, start_pos); pos < end_pos; pos++) {
+			blitter->SetPixel(dst, idx, 0, val8[idx]);
+			idx++;
+		}
+	/* Switch to next tile in the column */
+	} while (xc += this->zoom, yc += this->zoom, dst = blitter->MoveTo(dst, pitch, 0), --reps != 0);
+}
 
-	/**
-	 * Adds vehicles to the smallmap.
-	 * @param dpi the part of the smallmap to be drawn into
-	 * @param blitter current blitter
-	 */
-	void DrawVehicles(const DrawPixelInfo *dpi, Blitter *blitter) const
-	{
-		const Vehicle *v;
-		FOR_ALL_VEHICLES(v) {
-			if (v->type == VEH_EFFECT) continue;
-			if (v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) continue;
+/**
+ * Adds vehicles to the smallmap.
+ * @param dpi the part of the smallmap to be drawn into
+ * @param blitter current blitter
+ */
+void SmallMapWindow::DrawVehicles(const DrawPixelInfo *dpi, Blitter *blitter) const
+{
+	const Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		if (v->type == VEH_EFFECT) continue;
+		if (v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) continue;
 
-			/* Remap into flat coordinates. */
-			Point pt = this->RemapTile(v->x_pos / TILE_SIZE, v->y_pos / TILE_SIZE);
+		/* Remap into flat coordinates. */
+		Point pt = this->RemapTile(v->x_pos / TILE_SIZE, v->y_pos / TILE_SIZE);
 
-			int y = pt.y - dpi->top;
-			if (!IsInsideMM(y, 0, dpi->height)) continue; // y is out of bounds.
+		int y = pt.y - dpi->top;
+		if (!IsInsideMM(y, 0, dpi->height)) continue; // y is out of bounds.
 
-			bool skip = false; // Default is to draw both pixels.
-			int x = pt.x - this->subscroll - 3 - dpi->left; // Offset X coordinate.
-			if (x < 0) {
-				/* if x+1 is 0, that means we're on the very left edge,
-				 * and should thus only draw a single pixel */
-				if (++x != 0) continue;
-				skip = true;
-			} else if (x >= dpi->width - 1) {
-				/* Check if we're at the very right edge, and if so draw only a single pixel */
-				if (x != dpi->width - 1) continue;
-				skip = true;
-			}
+		bool skip = false; // Default is to draw both pixels.
+		int x = pt.x - this->subscroll - 3 - dpi->left; // Offset X coordinate.
+		if (x < 0) {
+			/* if x+1 is 0, that means we're on the very left edge,
+			 * and should thus only draw a single pixel */
+			if (++x != 0) continue;
+			skip = true;
+		} else if (x >= dpi->width - 1) {
+			/* Check if we're at the very right edge, and if so draw only a single pixel */
+			if (x != dpi->width - 1) continue;
+			skip = true;
+		}
 
-			/* Calculate pointer to pixel and the colour */
-			byte colour = (this->map_type == SMT_VEHICLES) ? _vehicle_type_colours[v->type] : PC_WHITE;
+		/* Calculate pointer to pixel and the colour */
+		byte colour = (this->map_type == SMT_VEHICLES) ? _vehicle_type_colours[v->type] : PC_WHITE;
 
-			/* And draw either one or two pixels depending on clipping */
-			blitter->SetPixel(dpi->dst_ptr, x, y, colour);
-			if (!skip) blitter->SetPixel(dpi->dst_ptr, x + 1, y, colour);
-		}
+		/* And draw either one or two pixels depending on clipping */
+		blitter->SetPixel(dpi->dst_ptr, x, y, colour);
+		if (!skip) blitter->SetPixel(dpi->dst_ptr, x + 1, y, colour);
 	}
+}
 
-	/**
-	 * Adds town names to the smallmap.
-	 * @param dpi the part of the smallmap to be drawn into
-	 */
-	void DrawTowns(const DrawPixelInfo *dpi) const
-	{
-		const Town *t;
-		FOR_ALL_TOWNS(t) {
-			/* Remap the town coordinate */
-			Point pt = this->RemapTile(TileX(t->xy), TileY(t->xy));
-			int x = pt.x - this->subscroll - (t->sign.width_small >> 1);
-			int y = pt.y;
+/**
+ * Adds town names to the smallmap.
+ * @param dpi the part of the smallmap to be drawn into
+ */
+void SmallMapWindow::DrawTowns(const DrawPixelInfo *dpi) const
+{
+	const Town *t;
+	FOR_ALL_TOWNS(t) {
+		/* Remap the town coordinate */
+		Point pt = this->RemapTile(TileX(t->xy), TileY(t->xy));
+		int x = pt.x - this->subscroll - (t->sign.width_small >> 1);
+		int y = pt.y;
 
-			/* Check if the town sign is within bounds */
-			if (x + t->sign.width_small > dpi->left &&
-					x < dpi->left + dpi->width &&
-					y + FONT_HEIGHT_SMALL > dpi->top &&
-					y < dpi->top + dpi->height) {
-				/* And draw it. */
-				SetDParam(0, t->index);
-				DrawString(x, x + t->sign.width_small, y, STR_SMALLMAP_TOWN);
-			}
+		/* Check if the town sign is within bounds */
+		if (x + t->sign.width_small > dpi->left &&
+				x < dpi->left + dpi->width &&
+				y + FONT_HEIGHT_SMALL > dpi->top &&
+				y < dpi->top + dpi->height) {
+			/* And draw it. */
+			SetDParam(0, t->index);
+			DrawString(x, x + t->sign.width_small, y, STR_SMALLMAP_TOWN);
 		}
 	}
+}
 
-	/**
-	 * Draws vertical part of map indicator
-	 * @param x X coord of left/right border of main viewport
-	 * @param y Y coord of top border of main viewport
-	 * @param y2 Y coord of bottom border of main viewport
-	 */
-	static inline void DrawVertMapIndicator(int x, int y, int y2)
-	{
-		GfxFillRect(x, y,      x, y + 3, PC_VERY_LIGHT_YELLOW);
-		GfxFillRect(x, y2 - 3, x, y2,    PC_VERY_LIGHT_YELLOW);
-	}
+/**
+ * Adds map indicators to the smallmap.
+ */
+void SmallMapWindow::DrawMapIndicators() const
+{
+	/* Find main viewport. */
+	const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
 
-	/**
-	 * Draws horizontal part of map indicator
-	 * @param x X coord of left border of main viewport
-	 * @param x2 X coord of right border of main viewport
-	 * @param y Y coord of top/bottom border of main viewport
-	 */
-	static inline void DrawHorizMapIndicator(int x, int x2, int y)
-	{
-		GfxFillRect(x,      y, x + 3, y, PC_VERY_LIGHT_YELLOW);
-		GfxFillRect(x2 - 3, y, x2,    y, PC_VERY_LIGHT_YELLOW);
-	}
+	Point tile = InverseRemapCoords(vp->virtual_left, vp->virtual_top);
+	Point tl = this->RemapTile(tile.x >> 4, tile.y >> 4);
+	tl.x -= this->subscroll;
 
-	/**
-	 * Adds map indicators to the smallmap.
-	 */
-	void DrawMapIndicators() const
-	{
-		/* Find main viewport. */
-		const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
+	tile = InverseRemapCoords(vp->virtual_left + vp->virtual_width, vp->virtual_top + vp->virtual_height);
+	Point br = this->RemapTile(tile.x >> 4, tile.y >> 4);
+	br.x -= this->subscroll;
 
-		Point tile = InverseRemapCoords(vp->virtual_left, vp->virtual_top);
-		Point tl = this->RemapTile(tile.x >> 4, tile.y >> 4);
-		tl.x -= this->subscroll;
+	SmallMapWindow::DrawVertMapIndicator(tl.x, tl.y, br.y);
+	SmallMapWindow::DrawVertMapIndicator(br.x, tl.y, br.y);
 
-		tile = InverseRemapCoords(vp->virtual_left + vp->virtual_width, vp->virtual_top + vp->virtual_height);
-		Point br = this->RemapTile(tile.x >> 4, tile.y >> 4);
-		br.x -= this->subscroll;
+	SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, tl.y);
+	SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, br.y);
+}
 
-		SmallMapWindow::DrawVertMapIndicator(tl.x, tl.y, br.y);
-		SmallMapWindow::DrawVertMapIndicator(br.x, tl.y, br.y);
+/**
+ * Draws the small map.
+ *
+ * Basically, the small map is draw column of pixels by column of pixels. The pixels
+ * are drawn directly into the screen buffer. The final map is drawn in multiple passes.
+ * The passes are:
+ * <ol><li>The colours of tiles in the different modes.</li>
+ * <li>Town names (optional)</li></ol>
+ *
+ * @param dpi pointer to pixel to write onto
+ */
+void SmallMapWindow::DrawSmallMap(DrawPixelInfo *dpi) const
+{
+	Blitter *blitter = BlitterFactoryBase::GetCurrentBlitter();
+	DrawPixelInfo *old_dpi;
 
-		SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, tl.y);
-		SmallMapWindow::DrawHorizMapIndicator(tl.x, br.x, br.y);
-	}
+	old_dpi = _cur_dpi;
+	_cur_dpi = dpi;
 
-	/**
-	 * Draws the small map.
-	 *
-	 * Basically, the small map is draw column of pixels by column of pixels. The pixels
-	 * are drawn directly into the screen buffer. The final map is drawn in multiple passes.
-	 * The passes are:
-	 * <ol><li>The colours of tiles in the different modes.</li>
-	 * <li>Town names (optional)</li></ol>
-	 *
-	 * @param dpi pointer to pixel to write onto
-	 */
-	void DrawSmallMap(DrawPixelInfo *dpi) const
-	{
-		Blitter *blitter = BlitterFactoryBase::GetCurrentBlitter();
-		DrawPixelInfo *old_dpi;
+	/* Clear it */
+	GfxFillRect(dpi->left, dpi->top, dpi->left + dpi->width - 1, dpi->top + dpi->height - 1, PC_BLACK);
 
-		old_dpi = _cur_dpi;
-		_cur_dpi = dpi;
+	/* Which tile is displayed at (dpi->left, dpi->top)? */
+	int dx;
+	Point tile = this->PixelToTile(dpi->left, dpi->top, &dx);
+	int tile_x = this->scroll_x / (int)TILE_SIZE + tile.x;
+	int tile_y = this->scroll_y / (int)TILE_SIZE + tile.y;
 
-		/* Clear it */
-		GfxFillRect(dpi->left, dpi->top, dpi->left + dpi->width - 1, dpi->top + dpi->height - 1, PC_BLACK);
+	void *ptr = blitter->MoveTo(dpi->dst_ptr, -dx - 4, 0);
+	int x = - dx - 4;
+	int y = 0;
 
-		/* Which tile is displayed at (dpi->left, dpi->top)? */
-		int dx;
-		Point tile = this->PixelToTile(dpi->left, dpi->top, &dx);
-		int tile_x = this->scroll_x / (int)TILE_SIZE + tile.x;
-		int tile_y = this->scroll_y / (int)TILE_SIZE + tile.y;
+	for (;;) {
+		/* Distance from left edge */
+		if (x >= -3) {
+			if (x >= dpi->width) break; // Exit the loop.
 
-		void *ptr = blitter->MoveTo(dpi->dst_ptr, -dx - 4, 0);
-		int x = - dx - 4;
-		int y = 0;
-
-		for (;;) {
-			/* Distance from left edge */
-			if (x >= -3) {
-				if (x >= dpi->width) break; // Exit the loop.
-
-				int end_pos = min(dpi->width, x + 4);
-				int reps = (dpi->height - y + 1) / 2; // Number of lines.
-				if (reps > 0) {
-					this->DrawSmallMapColumn(ptr, tile_x, tile_y, dpi->pitch * 2, reps, x, end_pos, blitter);
-				}
+			int end_pos = min(dpi->width, x + 4);
+			int reps = (dpi->height - y + 1) / 2; // Number of lines.
+			if (reps > 0) {
+				this->DrawSmallMapColumn(ptr, tile_x, tile_y, dpi->pitch * 2, reps, x, end_pos, blitter);
 			}
+		}
 
-			if (y == 0) {
-				tile_y += this->zoom;
-				y++;
-				ptr = blitter->MoveTo(ptr, 0, 1);
-			} else {
-				tile_x -= this->zoom;
-				y--;
-				ptr = blitter->MoveTo(ptr, 0, -1);
-			}
-			ptr = blitter->MoveTo(ptr, 2, 0);
-			x += 2;
+		if (y == 0) {
+			tile_y += this->zoom;
+			y++;
+			ptr = blitter->MoveTo(ptr, 0, 1);
+		} else {
+			tile_x -= this->zoom;
+			y--;
+			ptr = blitter->MoveTo(ptr, 0, -1);
 		}
+		ptr = blitter->MoveTo(ptr, 2, 0);
+		x += 2;
+	}
 
-		/* Draw vehicles */
-		if (this->map_type == SMT_CONTOUR || this->map_type == SMT_VEHICLES) this->DrawVehicles(dpi, blitter);
+	/* Draw vehicles */
+	if (this->map_type == SMT_CONTOUR || this->map_type == SMT_VEHICLES) this->DrawVehicles(dpi, blitter);
 
-		/* Draw town names */
-		if (this->show_towns) this->DrawTowns(dpi);
+	/* Draw link stat overlay */
+	if (this->map_type == SMT_LINKSTATS) this->overlay->Draw(dpi);
 
-		/* Draw map indicators */
-		this->DrawMapIndicators();
+	/* Draw town names */
+	if (this->show_towns) this->DrawTowns(dpi);
 
-		_cur_dpi = old_dpi;
-	}
+	/* Draw map indicators */
+	this->DrawMapIndicators();
 
-	/**
-	 * Function to set up widgets depending on the information being shown on the smallmap.
-	 */
-	void SetupWidgetData()
-	{
-		StringID legend_tooltip;
-		StringID enable_all_tooltip;
-		StringID disable_all_tooltip;
-		int plane;
-		switch (this->map_type) {
-			case SMT_INDUSTRY:
-				legend_tooltip = STR_SMALLMAP_TOOLTIP_INDUSTRY_SELECTION;
-				enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_INDUSTRIES;
-				disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_INDUSTRIES;
-				plane = 0;
-				break;
+	_cur_dpi = old_dpi;
+}
 
-			case SMT_OWNER:
-				legend_tooltip = STR_SMALLMAP_TOOLTIP_COMPANY_SELECTION;
-				enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_COMPANIES;
-				disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_COMPANIES;
-				plane = 0;
-				break;
+/**
+ * Function to set up widgets depending on the information being shown on the smallmap.
+ */
+void SmallMapWindow::SetupWidgetData()
+{
+	StringID legend_tooltip;
+	StringID enable_all_tooltip;
+	StringID disable_all_tooltip;
+	int plane;
+	switch (this->map_type) {
+		case SMT_INDUSTRY:
+			legend_tooltip = STR_SMALLMAP_TOOLTIP_INDUSTRY_SELECTION;
+			enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_INDUSTRIES;
+			disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_INDUSTRIES;
+			plane = 0;
+			break;
 
-			default:
-				legend_tooltip = STR_NULL;
-				enable_all_tooltip = STR_NULL;
-				disable_all_tooltip = STR_NULL;
-				plane = 1;
-				break;
-		}
+		case SMT_OWNER:
+			legend_tooltip = STR_SMALLMAP_TOOLTIP_COMPANY_SELECTION;
+			enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_COMPANIES;
+			disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_COMPANIES;
+			plane = 0;
+			break;
 
-		this->GetWidget<NWidgetCore>(WID_SM_LEGEND)->SetDataTip(STR_NULL, legend_tooltip);
-		this->GetWidget<NWidgetCore>(WID_SM_ENABLE_ALL)->SetDataTip(STR_SMALLMAP_ENABLE_ALL, enable_all_tooltip);
-		this->GetWidget<NWidgetCore>(WID_SM_DISABLE_ALL)->SetDataTip(STR_SMALLMAP_DISABLE_ALL, disable_all_tooltip);
-		this->GetWidget<NWidgetStacked>(WID_SM_SELECT_BUTTONS)->SetDisplayedPlane(plane);
+		case SMT_LINKSTATS:
+			legend_tooltip = STR_SMALLMAP_TOOLTIP_CARGO_SELECTION;
+			enable_all_tooltip = STR_SMALLMAP_TOOLTIP_ENABLE_ALL_CARGOS;
+			disable_all_tooltip = STR_SMALLMAP_TOOLTIP_DISABLE_ALL_CARGOS;
+			plane = 0;
+			break;
+
+		default:
+			legend_tooltip = STR_NULL;
+			enable_all_tooltip = STR_NULL;
+			disable_all_tooltip = STR_NULL;
+			plane = 1;
+			break;
 	}
 
-public:
-	uint min_number_of_columns;    ///< Minimal number of columns in legends.
+	this->GetWidget<NWidgetCore>(WID_SM_LEGEND)->SetDataTip(STR_NULL, legend_tooltip);
+	this->GetWidget<NWidgetCore>(WID_SM_ENABLE_ALL)->SetDataTip(STR_SMALLMAP_ENABLE_ALL, enable_all_tooltip);
+	this->GetWidget<NWidgetCore>(WID_SM_DISABLE_ALL)->SetDataTip(STR_SMALLMAP_DISABLE_ALL, disable_all_tooltip);
+	this->GetWidget<NWidgetStacked>(WID_SM_SELECT_BUTTONS)->SetDisplayedPlane(plane);
+}
 
-	SmallMapWindow(const WindowDesc *desc, int window_number) : Window(), refresh(FORCE_REFRESH_PERIOD)
-	{
-		this->InitNested(desc, window_number);
-		this->LowerWidget(this->map_type + WID_SM_CONTOUR);
+SmallMapWindow::SmallMapWindow(const WindowDesc *desc, int window_number) :
+		Window(),
+		refresh(FORCE_REFRESH_PERIOD)
+{
+	this->overlay = new LinkGraphOverlay(this, WID_SM_MAP);
+	this->InitNested(desc, window_number);
+	this->LowerWidget(this->map_type + WID_SM_CONTOUR);
 
-		BuildLandLegend();
-		this->SetWidgetLoweredState(WID_SM_SHOW_HEIGHT, _smallmap_show_heightmap);
+	BuildLandLegend();
+	this->SetWidgetLoweredState(WID_SM_SHOW_HEIGHT, _smallmap_show_heightmap);
 
-		this->SetWidgetLoweredState(WID_SM_TOGGLETOWNNAME, this->show_towns);
+	this->SetWidgetLoweredState(WID_SM_TOGGLETOWNNAME, this->show_towns);
 
-		this->SetupWidgetData();
+	this->SetupWidgetData();
 
-		this->SetZoomLevel(ZLC_INITIALIZE, NULL);
-		this->SmallMapCenterOnCurrentPos();
-	}
+	this->SetZoomLevel(ZLC_INITIALIZE, NULL);
+	this->SmallMapCenterOnCurrentPos();
+}
 
-	/**
-	 * Compute minimal required width of the legends.
-	 * @return Minimally needed width for displaying the smallmap legends in pixels.
-	 */
-	inline uint GetMinLegendWidth() const
-	{
-		return WD_FRAMERECT_LEFT + this->min_number_of_columns * this->column_width;
+void SmallMapWindow::SetStringParameters(int widget) const
+{
+	switch (widget) {
+		case WID_SM_CAPTION:
+			SetDParam(0, STR_SMALLMAP_TYPE_CONTOURS + this->map_type);
+			break;
 	}
+}
 
-	/**
-	 * Return number of columns that can be displayed in \a width pixels.
-	 * @return Number of columns to display.
-	 */
-	inline uint GetNumberColumnsLegend(uint width) const
-	{
-		return width / this->column_width;
-	}
-
-	/**
-	 * Compute height given a number of columns.
-	 * @param num_columns Number of columns.
-	 * @return Needed height for displaying the smallmap legends in pixels.
-	 */
-	uint GetLegendHeight(uint num_columns) const
-	{
-		uint num_rows = max(this->min_number_of_fixed_rows, CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), num_columns));
-		return WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM + num_rows * FONT_HEIGHT_SMALL;
-	}
-
-	virtual void SetStringParameters(int widget) const
-	{
-		switch (widget) {
-			case WID_SM_CAPTION:
-				SetDParam(0, STR_SMALLMAP_TYPE_CONTOURS + this->map_type);
-				break;
-		}
-	}
-
-	virtual void OnInit()
-	{
-		uint min_width = 0;
-		this->min_number_of_columns = INDUSTRY_MIN_NUMBER_OF_COLUMNS;
-		this->min_number_of_fixed_rows = 0;
-		for (uint i = 0; i < lengthof(_legend_table); i++) {
-			uint height = 0;
-			uint num_columns = 1;
-			for (const LegendAndColour *tbl = _legend_table[i]; !tbl->end; ++tbl) {
-				StringID str;
-				if (i == SMT_INDUSTRY) {
-					SetDParam(0, tbl->legend);
-					SetDParam(1, IndustryPool::MAX_SIZE);
-					str = STR_SMALLMAP_INDUSTRY;
-				} else if (i == SMT_OWNER) {
-					if (tbl->company != INVALID_COMPANY) {
-						if (!Company::IsValidID(tbl->company)) {
-							/* Rebuild the owner legend. */
-							BuildOwnerLegend();
-							this->OnInit();
-							return;
-						}
-						/* Non-fixed legend entries for the owner view. */
-						SetDParam(0, tbl->company);
-						str = STR_SMALLMAP_COMPANY;
-					} else {
-						str = tbl->legend;
+void SmallMapWindow::OnInit()
+{
+	uint min_width = 0;
+	this->min_number_of_columns = INDUSTRY_MIN_NUMBER_OF_COLUMNS;
+	this->min_number_of_fixed_rows = lengthof(_linkstat_colours_in_legenda);
+	for (uint i = 0; i < lengthof(_legend_table); i++) {
+		uint height = 0;
+		uint num_columns = 1;
+		for (const LegendAndColour *tbl = _legend_table[i]; !tbl->end; ++tbl) {
+			StringID str;
+			if (i == SMT_INDUSTRY) {
+				SetDParam(0, tbl->legend);
+				SetDParam(1, IndustryPool::MAX_SIZE);
+				str = STR_SMALLMAP_INDUSTRY;
+			} else if (i == SMT_LINKSTATS) {
+				SetDParam(0, tbl->legend);
+				str = STR_SMALLMAP_LINKSTATS;
+			} else if (i == SMT_OWNER) {
+				if (tbl->company != INVALID_COMPANY) {
+					if (!Company::IsValidID(tbl->company)) {
+						/* Rebuild the owner legend. */
+						BuildOwnerLegend();
+						this->OnInit();
+						return;
 					}
+					/* Non-fixed legend entries for the owner view. */
+					SetDParam(0, tbl->company);
+					str = STR_SMALLMAP_COMPANY;
 				} else {
-					if (tbl->col_break) {
-						this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
-						height = 0;
-						num_columns++;
-					}
-					height++;
 					str = tbl->legend;
 				}
-				min_width = max(GetStringBoundingBox(str).width, min_width);
+			} else {
+				if (tbl->col_break) {
+					this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
+					height = 0;
+					num_columns++;
+				}
+				height++;
+				str = tbl->legend;
 			}
-			this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
-			this->min_number_of_columns = max(this->min_number_of_columns, num_columns);
+			min_width = max(GetStringBoundingBox(str).width, min_width);
 		}
-
-		/* The width of a column is the minimum width of all texts + the size of the blob + some spacing */
-		this->column_width = min_width + LEGEND_BLOB_WIDTH + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+		this->min_number_of_fixed_rows = max(this->min_number_of_fixed_rows, height);
+		this->min_number_of_columns = max(this->min_number_of_columns, num_columns);
 	}
 
-	virtual void OnPaint()
-	{
-		if (this->map_type == SMT_OWNER) {
-			for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
-				if (tbl->company != INVALID_COMPANY && !Company::IsValidID(tbl->company)) {
-					/* Rebuild the owner legend. */
-					BuildOwnerLegend();
-					this->InvalidateData(1);
-					break;
-				}
+	/* The width of a column is the minimum width of all texts + the size of the blob + some spacing */
+	this->column_width = min_width + LEGEND_BLOB_WIDTH + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+}
+
+void SmallMapWindow::OnPaint()
+{
+	if (this->map_type == SMT_OWNER) {
+		for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
+			if (tbl->company != INVALID_COMPANY && !Company::IsValidID(tbl->company)) {
+				/* Rebuild the owner legend. */
+				BuildOwnerLegend();
+				this->InvalidateData(1);
+				break;
 			}
 		}
-
-		this->DrawWidgets();
 	}
 
-	virtual void DrawWidget(const Rect &r, int widget) const
-	{
-		switch (widget) {
-			case WID_SM_MAP: {
-				DrawPixelInfo new_dpi;
-				if (!FillDrawPixelInfo(&new_dpi, r.left + 1, r.top + 1, r.right - r.left - 1, r.bottom - r.top - 1)) return;
-				this->DrawSmallMap(&new_dpi);
-				break;
-			}
+	this->DrawWidgets();
+}
 
-			case WID_SM_LEGEND: {
-				uint columns = this->GetNumberColumnsLegend(r.right - r.left + 1);
-				uint number_of_rows = max((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER) ? CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), columns) : 0, this->min_number_of_fixed_rows);
-				bool rtl = _current_text_dir == TD_RTL;
-				uint y_org = r.top + WD_FRAMERECT_TOP;
-				uint x = rtl ? r.right - this->column_width - WD_FRAMERECT_RIGHT : r.left + WD_FRAMERECT_LEFT;
-				uint y = y_org;
-				uint i = 0; // Row counter for industry legend.
-				uint row_height = FONT_HEIGHT_SMALL;
+void SmallMapWindow::DrawWidget(const Rect &r, int widget) const
+{
+	switch (widget) {
+		case WID_SM_MAP: {
+			DrawPixelInfo new_dpi;
+			if (!FillDrawPixelInfo(&new_dpi, r.left + 1, r.top + 1, r.right - r.left - 1, r.bottom - r.top - 1)) return;
+			this->DrawSmallMap(&new_dpi);
+			break;
+		}
 
-				uint text_left  = rtl ? 0 : LEGEND_BLOB_WIDTH + WD_FRAMERECT_LEFT;
-				uint text_right = this->column_width - 1 - (rtl ? LEGEND_BLOB_WIDTH + WD_FRAMERECT_RIGHT : 0);
-				uint blob_left  = rtl ? this->column_width - 1 - LEGEND_BLOB_WIDTH : 0;
-				uint blob_right = rtl ? this->column_width - 1 : LEGEND_BLOB_WIDTH;
+		case WID_SM_LEGEND: {
+			uint columns = this->GetNumberColumnsLegend(r.right - r.left + 1);
+			uint number_of_rows = this->GetNumberRowsLegend(columns);
+			bool rtl = _current_text_dir == TD_RTL;
+			uint y_org = r.top + WD_FRAMERECT_TOP;
+			uint x = rtl ? r.right - this->column_width - WD_FRAMERECT_RIGHT : r.left + WD_FRAMERECT_LEFT;
+			uint y = y_org;
+			uint i = 0; // Row counter for industry legend.
+			uint row_height = FONT_HEIGHT_SMALL;
 
-				for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
-					if (tbl->col_break || ((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER) && i++ >= number_of_rows)) {
-						/* Column break needed, continue at top, COLUMN_WIDTH pixels
-						 * (one "row") to the right. */
-						x += rtl ? -(int)this->column_width : this->column_width;
-						y = y_org;
-						i = 1;
-					}
+			uint text_left  = rtl ? 0 : LEGEND_BLOB_WIDTH + WD_FRAMERECT_LEFT;
+			uint text_right = this->column_width - 1 - (rtl ? LEGEND_BLOB_WIDTH + WD_FRAMERECT_RIGHT : 0);
+			uint blob_left  = rtl ? this->column_width - 1 - LEGEND_BLOB_WIDTH : 0;
+			uint blob_right = rtl ? this->column_width - 1 : LEGEND_BLOB_WIDTH;
 
-					if (this->map_type == SMT_INDUSTRY) {
+			StringID string = STR_NULL;
+			switch (this->map_type) {
+				case SMT_INDUSTRY:
+					string = STR_SMALLMAP_INDUSTRY;
+					break;
+				case SMT_LINKSTATS:
+					string = STR_SMALLMAP_LINKSTATS;
+					break;
+				case SMT_OWNER:
+					string = STR_SMALLMAP_COMPANY;
+					break;
+				default:
+					break;
+			}
+
+			for (const LegendAndColour *tbl = _legend_table[this->map_type]; !tbl->end; ++tbl) {
+				if (tbl->col_break || ((this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER || this->map_type == SMT_LINKSTATS) && i++ >= number_of_rows)) {
+					/* Column break needed, continue at top, COLUMN_WIDTH pixels
+					 * (one "row") to the right. */
+					x += rtl ? -(int)this->column_width : this->column_width;
+					y = y_org;
+					i = 1;
+				}
+
+				switch (this->map_type) {
+					case SMT_INDUSTRY:
 						/* Industry name must be formatted, since it's not in tiny font in the specs.
 						 * So, draw with a parameter and use the STR_SMALLMAP_INDUSTRY string, which is tiny font */
 						SetDParam(0, tbl->legend);
 						SetDParam(1, Industry::GetIndustryTypeCount(tbl->type));
-						if (!tbl->show_on_map) {
-							/* Simply draw the string, not the black border of the legend colour.
-							 * This will enforce the idea of the disabled item */
-							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_INDUSTRY, TC_GREY);
-						} else {
-							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_INDUSTRY, TC_BLACK);
-							GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, PC_BLACK); // Outer border of the legend colour
+						/* FALL THROUGH */
+					case SMT_LINKSTATS:
+						SetDParam(0, tbl->legend);
+						/* FALL_THROUGH */
+					case SMT_OWNER:
+						if (this->map_type != SMT_OWNER || tbl->company != INVALID_COMPANY) {
+							if (this->map_type == SMT_OWNER) SetDParam(0, tbl->company);
+							if (!tbl->show_on_map) {
+								/* Simply draw the string, not the black border of the legend colour.
+								 * This will enforce the idea of the disabled item */
+								DrawString(x + text_left, x + text_right, y, string, TC_GREY);
+							} else {
+								DrawString(x + text_left, x + text_right, y, string, TC_BLACK);
+								GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, PC_BLACK); // Outer border of the legend colour
+							}
+							break;
 						}
-					} else if (this->map_type == SMT_OWNER && tbl->company != INVALID_COMPANY) {
-						SetDParam(0, tbl->company);
-						if (!tbl->show_on_map) {
-							/* Simply draw the string, not the black border of the legend colour.
-							 * This will enforce the idea of the disabled item */
-							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_COMPANY, TC_GREY);
-						} else {
-							DrawString(x + text_left, x + text_right, y, STR_SMALLMAP_COMPANY, TC_BLACK);
-							GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, PC_BLACK); // Outer border of the legend colour
-						}
-					} else {
+						/* FALL_THROUGH */
+					default:
 						if (this->map_type == SMT_CONTOUR) SetDParam(0, tbl->height * TILE_HEIGHT_STEP);
-
 						/* Anything that is not an industry or a company is using normal process */
 						GfxFillRect(x + blob_left, y + 1, x + blob_right, y + row_height - 1, PC_BLACK);
 						DrawString(x + text_left, x + text_right, y, tbl->legend);
-					}
-					GfxFillRect(x + blob_left + 1, y + 2, x + blob_right - 1, y + row_height - 2, tbl->colour); // Legend colour
+						break;
+				}
 
-					y += row_height;
-				}
+				GfxFillRect(x + blob_left + 1, y + 2, x + blob_right - 1, y + row_height - 2, tbl->colour); // Legend colour
+
+				y += row_height;
 			}
 		}
 	}
+}
 
-	/**
-	 * Select a new map type.
-	 * @param map_type New map type.
-	 */
-	void SwitchMapType(SmallMapType map_type)
-	{
-		this->RaiseWidget(this->map_type + WID_SM_CONTOUR);
-		this->map_type = map_type;
-		this->LowerWidget(this->map_type + WID_SM_CONTOUR);
+/**
+ * Get the number of rows in the legend from the number of columns. Those
+ * are at least min_number_of_fixed_rows and possibly more if there are so
+ * many cargoes, industry types or companies that they won't fit in the
+ * available space.
+ * @param columns Number of columns in the legend.
+ * @return Number of rows needed for everything to fit in.
+ */
+inline uint SmallMapWindow::GetNumberRowsLegend(uint columns) const
+{
+	/* reserve one column for link colours */
+	uint num_rows_linkstats = CeilDiv(_smallmap_cargo_count, columns - 1);
+	uint num_rows_others = CeilDiv(max(_smallmap_industry_count,_smallmap_company_count), columns);
+	return max(this->min_number_of_fixed_rows, max(num_rows_linkstats, num_rows_others));
+}
 
-		this->SetupWidgetData();
+/**
+ * Select and toggle a legend item. When CTRL is pressed, disable all other
+ * items in the group defined by begin_legend_item and end_legend_item and
+ * keep the clicked one enabled even if it was already enabled before. If
+ * the other items in the group are all disabled already and CTRL is pressed
+ * enable them instead.
+ * @param click_pos the index of the item being selected
+ * @param legend the legend from which we select
+ * @param end_legend_item index one past the last item in the group to be inverted
+ * @param begin_legend_item index of the first item in the group to be inverted
+ */
+void SmallMapWindow::SelectLegendItem(int click_pos, LegendAndColour *legend, int end_legend_item, int begin_legend_item)
+{
+	if (_ctrl_pressed) {
+		/* Disable all, except the clicked one */
+		bool changes = false;
+		for (int i = begin_legend_item; i != end_legend_item; i++) {
+			bool new_state = (i == click_pos);
+			if (legend[i].show_on_map != new_state) {
+				changes = true;
+				legend[i].show_on_map = new_state;
+			}
+		}
+		if (!changes) {
+			/* Nothing changed? Then show all (again). */
+			for (int i = begin_legend_item; i != end_legend_item; i++) {
+				legend[i].show_on_map = true;
+			}
+		}
+	} else {
+		legend[click_pos].show_on_map = !legend[click_pos].show_on_map;
+	}
+	this->SetOverlayCargoMask();
+}
 
-		this->SetDirty();
+/**
+ * Set the link graph overlay cargo mask from the legend.
+ */
+void SmallMapWindow::SetOverlayCargoMask()
+{
+	if (this->map_type == SMT_LINKSTATS) {
+		uint32 cargo_mask = 0;
+		for (int i = 0; i != _smallmap_cargo_count; ++i) {
+			if (_legend_linkstats[i].show_on_map) SetBit(cargo_mask, _legend_linkstats[i].type);
+		}
+		this->overlay->SetCargoMask(cargo_mask);
+		this->overlay->RebuildCache();
 	}
+}
 
-	virtual void OnClick(Point pt, int widget, int click_count)
-	{
-		/* User clicked something, notify the industry chain window to stop sending newly selected industries. */
-		InvalidateWindowClassesData(WC_INDUSTRY_CARGOES, NUM_INDUSTRYTYPES);
+/**
+ * Select a new map type.
+ * @param map_type New map type.
+ */
+void SmallMapWindow::SwitchMapType(SmallMapType map_type)
+{
+	this->RaiseWidget(this->map_type + WID_SM_CONTOUR);
+	this->map_type = map_type;
+	this->LowerWidget(this->map_type + WID_SM_CONTOUR);
 
-		switch (widget) {
-			case WID_SM_MAP: { // Map window
-				/*
-				 * XXX: scrolling with the left mouse button is done by subsequently
-				 * clicking with the left mouse button; clicking once centers the
-				 * large map at the selected point. So by unclicking the left mouse
-				 * button here, it gets reclicked during the next inputloop, which
-				 * would make it look like the mouse is being dragged, while it is
-				 * actually being (virtually) clicked every inputloop.
-				 */
-				_left_button_clicked = false;
+	this->SetupWidgetData();
 
-				const NWidgetBase *wid = this->GetWidget<NWidgetBase>(WID_SM_MAP);
-				Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
-				int sub;
-				pt = this->PixelToTile(pt.x - wid->pos_x, pt.y - wid->pos_y, &sub);
-				pt = RemapCoords(this->scroll_x + pt.x * TILE_SIZE + this->zoom * (TILE_SIZE - sub * TILE_SIZE / 4),
-						this->scroll_y + pt.y * TILE_SIZE + sub * this->zoom * TILE_SIZE / 4, 0);
+	if (map_type == SMT_LINKSTATS) this->overlay->RebuildCache();
+	this->SetDirty();
+}
 
-				w->viewport->follow_vehicle = INVALID_VEHICLE;
-				w->viewport->dest_scrollpos_x = pt.x - (w->viewport->virtual_width  >> 1);
-				w->viewport->dest_scrollpos_y = pt.y - (w->viewport->virtual_height >> 1);
+void SmallMapWindow::OnClick(Point pt, int widget, int click_count)
+{
+	/* User clicked something, notify the industry chain window to stop sending newly selected industries. */
+	InvalidateWindowClassesData(WC_INDUSTRY_CARGOES, NUM_INDUSTRYTYPES);
 
-				this->SetDirty();
-				break;
-			}
+	switch (widget) {
+		case WID_SM_MAP: { // Map window
+			/*
+			 * XXX: scrolling with the left mouse button is done by subsequently
+			 * clicking with the left mouse button; clicking once centers the
+			 * large map at the selected point. So by unclicking the left mouse
+			 * button here, it gets reclicked during the next inputloop, which
+			 * would make it look like the mouse is being dragged, while it is
+			 * actually being (virtually) clicked every inputloop.
+			 */
+			_left_button_clicked = false;
 
-			case WID_SM_ZOOM_IN:
-			case WID_SM_ZOOM_OUT: {
-				const NWidgetBase *wid = this->GetWidget<NWidgetBase>(WID_SM_MAP);
-				Point pt = {wid->current_x / 2, wid->current_y / 2};
-				this->SetZoomLevel((widget == WID_SM_ZOOM_IN) ? ZLC_ZOOM_IN : ZLC_ZOOM_OUT, &pt);
-				SndPlayFx(SND_15_BEEP);
-				break;
-			}
+			const NWidgetBase *wid = this->GetWidget<NWidgetBase>(WID_SM_MAP);
+			Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
+			int sub;
+			pt = this->PixelToTile(pt.x - wid->pos_x, pt.y - wid->pos_y, &sub);
+			pt = RemapCoords(this->scroll_x + pt.x * TILE_SIZE + this->zoom * (TILE_SIZE - sub * TILE_SIZE / 4),
+					this->scroll_y + pt.y * TILE_SIZE + sub * this->zoom * TILE_SIZE / 4, 0);
 
-			case WID_SM_CONTOUR:    // Show land contours
-			case WID_SM_VEHICLES:   // Show vehicles
-			case WID_SM_INDUSTRIES: // Show industries
-			case WID_SM_ROUTES:     // Show transport routes
-			case WID_SM_VEGETATION: // Show vegetation
-			case WID_SM_OWNERS:     // Show land owners
-				this->SwitchMapType((SmallMapType)(widget - WID_SM_CONTOUR));
-				SndPlayFx(SND_15_BEEP);
-				break;
+			w->viewport->follow_vehicle = INVALID_VEHICLE;
+			w->viewport->dest_scrollpos_x = pt.x - (w->viewport->virtual_width  >> 1);
+			w->viewport->dest_scrollpos_y = pt.y - (w->viewport->virtual_height >> 1);
 
-			case WID_SM_CENTERMAP: // Center the smallmap again
-				this->SmallMapCenterOnCurrentPos();
-				this->HandleButtonClick(WID_SM_CENTERMAP);
-				SndPlayFx(SND_15_BEEP);
-				break;
+			this->SetDirty();
+			break;
+		}
 
-			case WID_SM_TOGGLETOWNNAME: // Toggle town names
-				this->show_towns = !this->show_towns;
-				this->SetWidgetLoweredState(WID_SM_TOGGLETOWNNAME, this->show_towns);
+		case WID_SM_ZOOM_IN:
+		case WID_SM_ZOOM_OUT: {
+			const NWidgetBase *wid = this->GetWidget<NWidgetBase>(WID_SM_MAP);
+			Point pt = {wid->current_x / 2, wid->current_y / 2};
+			this->SetZoomLevel((widget == WID_SM_ZOOM_IN) ? ZLC_ZOOM_IN : ZLC_ZOOM_OUT, &pt);
+			SndPlayFx(SND_15_BEEP);
+			break;
+		}
 
-				this->SetDirty();
-				SndPlayFx(SND_15_BEEP);
-				break;
+		case WID_SM_CONTOUR:    // Show land contours
+		case WID_SM_VEHICLES:   // Show vehicles
+		case WID_SM_INDUSTRIES: // Show industries
+		case WID_SM_LINKSTATS:  // Show route map
+		case WID_SM_ROUTES:     // Show transport routes
+		case WID_SM_VEGETATION: // Show vegetation
+		case WID_SM_OWNERS:     // Show land owners
+			this->SwitchMapType((SmallMapType)(widget - WID_SM_CONTOUR));
+			SndPlayFx(SND_15_BEEP);
+			break;
 
-			case WID_SM_LEGEND: // Legend
-				if (this->map_type == SMT_INDUSTRY || this->map_type == SMT_OWNER) {
-					const NWidgetBase *wi = this->GetWidget<NWidgetBase>(WID_SM_LEGEND); // Label panel
-					uint line = (pt.y - wi->pos_y - WD_FRAMERECT_TOP) / FONT_HEIGHT_SMALL;
-					uint columns = this->GetNumberColumnsLegend(wi->current_x);
-					uint number_of_rows = max(CeilDiv(max(_smallmap_company_count, _smallmap_industry_count), columns), this->min_number_of_fixed_rows);
-					if (line >= number_of_rows) break;
+		case WID_SM_CENTERMAP: // Center the smallmap again
+			this->SmallMapCenterOnCurrentPos();
+			this->HandleButtonClick(WID_SM_CENTERMAP);
+			SndPlayFx(SND_15_BEEP);
+			break;
 
-					bool rtl = _current_text_dir == TD_RTL;
-					int x = pt.x - wi->pos_x;
-					if (rtl) x = wi->current_x - x;
-					uint column = (x - WD_FRAMERECT_LEFT) / this->column_width;
+		case WID_SM_TOGGLETOWNNAME: // Toggle town names
+			this->show_towns = !this->show_towns;
+			this->SetWidgetLoweredState(WID_SM_TOGGLETOWNNAME, this->show_towns);
 
-					/* If industry type small map*/
-					if (this->map_type == SMT_INDUSTRY) {
-						/* If click on industries label, find right industry type and enable/disable it. */
-						int industry_pos = (column * number_of_rows) + line;
-						if (industry_pos < _smallmap_industry_count) {
-							if (_ctrl_pressed) {
-								/* Disable all, except the clicked one. */
-								bool changes = false;
-								for (int i = 0; i != _smallmap_industry_count; i++) {
-									bool new_state = i == industry_pos;
-									if (_legend_from_industries[i].show_on_map != new_state) {
-										changes = true;
-										_legend_from_industries[i].show_on_map = new_state;
-									}
-								}
-								if (!changes) {
-									/* Nothing changed? Then show all (again). */
-									for (int i = 0; i != _smallmap_industry_count; i++) {
-										_legend_from_industries[i].show_on_map = true;
-									}
-								}
-							} else {
-								_legend_from_industries[industry_pos].show_on_map = !_legend_from_industries[industry_pos].show_on_map;
-							}
-						}
-					} else if (this->map_type == SMT_OWNER) {
-						/* If click on companies label, find right company and enable/disable it. */
-						int company_pos = (column * number_of_rows) + line;
-						if (company_pos < NUM_NO_COMPANY_ENTRIES) break;
-						if (company_pos < _smallmap_company_count) {
-							if (_ctrl_pressed) {
-								/* Disable all, except the clicked one */
-								bool changes = false;
-								for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
-									bool new_state = i == company_pos;
-									if (_legend_land_owners[i].show_on_map != new_state) {
-										changes = true;
-										_legend_land_owners[i].show_on_map = new_state;
-									}
-								}
-								if (!changes) {
-									/* Nothing changed? Then show all (again). */
-									for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
-										_legend_land_owners[i].show_on_map = true;
-									}
-								}
-							} else {
-								_legend_land_owners[company_pos].show_on_map = !_legend_land_owners[company_pos].show_on_map;
-							}
-						}
-					}
-					this->SetDirty();
-				}
-				break;
+			this->SetDirty();
+			SndPlayFx(SND_15_BEEP);
+			break;
 
-			case WID_SM_ENABLE_ALL:
+		case WID_SM_LEGEND: // Legend
+			if (this->map_type == SMT_INDUSTRY || this->map_type == SMT_LINKSTATS || this->map_type == SMT_OWNER) {
+				/* If click on label, find right type and enable/disable it */
+				const NWidgetBase *wi = this->GetWidget<NWidgetBase>(WID_SM_LEGEND); // Label panel
+				uint line = (pt.y - wi->pos_y - WD_FRAMERECT_TOP) / FONT_HEIGHT_SMALL;
+				uint columns = this->GetNumberColumnsLegend(wi->current_x);
+				uint number_of_rows = this->GetNumberRowsLegend(columns);
+				if (line >= number_of_rows) break;
+
+				bool rtl = _current_text_dir == TD_RTL;
+				int x = pt.x - wi->pos_x;
+				if (rtl) x = wi->current_x - x;
+				uint column = (x - WD_FRAMERECT_LEFT) / this->column_width;
+
+				/* Check if click is on label*/
+				int click_pos = (column * number_of_rows) + line;
 				if (this->map_type == SMT_INDUSTRY) {
-					for (int i = 0; i != _smallmap_industry_count; i++) {
-						_legend_from_industries[i].show_on_map = true;
+					if (click_pos < _smallmap_industry_count) {
+						this->SelectLegendItem(click_pos, _legend_from_industries, _smallmap_industry_count);
 					}
+				} else if (this->map_type == SMT_LINKSTATS) {
+					if (click_pos < _smallmap_cargo_count) {
+						this->SelectLegendItem(click_pos, _legend_linkstats, _smallmap_cargo_count);
+					}
 				} else if (this->map_type == SMT_OWNER) {
-					for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
-						_legend_land_owners[i].show_on_map = true;
+					if (click_pos < _smallmap_company_count) {
+						this->SelectLegendItem(click_pos, _legend_land_owners, _smallmap_company_count, NUM_NO_COMPANY_ENTRIES);
 					}
 				}
 				this->SetDirty();
-				break;
+			}
+			break;
 
-			case WID_SM_DISABLE_ALL:
-				if (this->map_type == SMT_INDUSTRY) {
-					for (int i = 0; i != _smallmap_industry_count; i++) {
-						_legend_from_industries[i].show_on_map = false;
-					}
-				} else {
-					for (int i = NUM_NO_COMPANY_ENTRIES; i != _smallmap_company_count; i++) {
-						_legend_land_owners[i].show_on_map = false;
-					}
-				}
-				this->SetDirty();
-				break;
+		case WID_SM_ENABLE_ALL:
+			/* FALL THROUGH */
+		case WID_SM_DISABLE_ALL: {
+			LegendAndColour *tbl = NULL;
+			switch (this->map_type) {
+				case SMT_INDUSTRY:
+					tbl = _legend_from_industries;
+					break;
+				case SMT_OWNER:
+					tbl = &(_legend_land_owners[NUM_NO_COMPANY_ENTRIES]);
+					break;
+				case SMT_LINKSTATS:
+					tbl = _legend_linkstats;
+					break;
+				default:
+					NOT_REACHED();
+			}
+			for (;!tbl->end && tbl->legend != STR_LINKGRAPH_LEGEND_UNUSED; ++tbl) {
+				tbl->show_on_map = (widget == WID_SM_ENABLE_ALL);
+			}
+			this->SetOverlayCargoMask();
+			this->SetDirty();
+			break;
+		}
 
-			case WID_SM_SHOW_HEIGHT: // Enable/disable showing of heightmap.
-				_smallmap_show_heightmap = !_smallmap_show_heightmap;
-				this->SetWidgetLoweredState(WID_SM_SHOW_HEIGHT, _smallmap_show_heightmap);
-				this->SetDirty();
-				break;
-		}
+		case WID_SM_SHOW_HEIGHT: // Enable/disable showing of heightmap.
+			_smallmap_show_heightmap = !_smallmap_show_heightmap;
+			this->SetWidgetLoweredState(WID_SM_SHOW_HEIGHT, _smallmap_show_heightmap);
+			this->SetDirty();
+			break;
 	}
+}
 
-	/**
-	 * Some data on this window has become invalid.
-	 * @param data Information about the changed data.
-	 * - data = 0: Displayed industries at the industry chain window have changed.
-	 * - data = 1: Companies have changed.
-	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
-	 */
-	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
-	{
-		if (!gui_scope) return;
-		switch (data) {
-			case 1:
-				/* The owner legend has already been rebuilt. */
-				this->ReInit();
-				break;
+/**
+ * Some data on this window has become invalid.
+ * @param data Information about the changed data.
+ * - data = 0: Displayed industries at the industry chain window have changed.
+ * - data = 1: Companies have changed.
+ * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+ */
+void SmallMapWindow::OnInvalidateData(int data, bool gui_scope)
+{
+	if (!gui_scope) return;
+	switch (data) {
+		case 1:
+			/* The owner legend has already been rebuilt. */
+			this->ReInit();
+			break;
 
-			case 0: {
-				extern uint64 _displayed_industries;
-				if (this->map_type != SMT_INDUSTRY) this->SwitchMapType(SMT_INDUSTRY);
+		case 0: {
+			extern uint64 _displayed_industries;
+			if (this->map_type != SMT_INDUSTRY) this->SwitchMapType(SMT_INDUSTRY);
 
-				for (int i = 0; i != _smallmap_industry_count; i++) {
-					_legend_from_industries[i].show_on_map = HasBit(_displayed_industries, _legend_from_industries[i].type);
-				}
-				break;
+			for (int i = 0; i != _smallmap_industry_count; i++) {
+				_legend_from_industries[i].show_on_map = HasBit(_displayed_industries, _legend_from_industries[i].type);
 			}
+			break;
+		}
 
-			default: NOT_REACHED();
-		}
-		this->SetDirty();
+		default: NOT_REACHED();
 	}
+	this->SetDirty();
+}
 
-	virtual bool OnRightClick(Point pt, int widget)
-	{
-		if (widget != WID_SM_MAP || _scrolling_viewport) return false;
+bool SmallMapWindow::OnRightClick(Point pt, int widget)
+{
+	if (widget != WID_SM_MAP || _scrolling_viewport) return false;
 
-		_scrolling_viewport = true;
-		return true;
-	}
+	_scrolling_viewport = true;
+	return true;
+}
 
-	virtual void OnMouseWheel(int wheel)
-	{
-		if (_settings_client.gui.scrollwheel_scrolling == 0) {
-			const NWidgetBase *wid = this->GetWidget<NWidgetBase>(WID_SM_MAP);
-			int cursor_x = _cursor.pos.x - this->left - wid->pos_x;
-			int cursor_y = _cursor.pos.y - this->top  - wid->pos_y;
-			if (IsInsideMM(cursor_x, 0, wid->current_x) && IsInsideMM(cursor_y, 0, wid->current_y)) {
-				Point pt = {cursor_x, cursor_y};
-				this->SetZoomLevel((wheel < 0) ? ZLC_ZOOM_IN : ZLC_ZOOM_OUT, &pt);
-			}
+void SmallMapWindow::OnMouseWheel(int wheel)
+{
+	if (_settings_client.gui.scrollwheel_scrolling == 0) {
+		const NWidgetBase *wid = this->GetWidget<NWidgetBase>(WID_SM_MAP);
+		int cursor_x = _cursor.pos.x - this->left - wid->pos_x;
+		int cursor_y = _cursor.pos.y - this->top  - wid->pos_y;
+		if (IsInsideMM(cursor_x, 0, wid->current_x) && IsInsideMM(cursor_y, 0, wid->current_y)) {
+			Point pt = {cursor_x, cursor_y};
+			this->SetZoomLevel((wheel < 0) ? ZLC_ZOOM_IN : ZLC_ZOOM_OUT, &pt);
 		}
 	}
+}
 
-	virtual void OnTick()
-	{
-		/* Update the window every now and then */
-		if (--this->refresh != 0) return;
+void SmallMapWindow::OnTick()
+{
+	/* Update the window every now and then */
+	if (--this->refresh != 0) return;
 
-		this->refresh = FORCE_REFRESH_PERIOD;
-		this->SetDirty();
+	if (this->map_type == SMT_LINKSTATS) this->overlay->RebuildCache();
+	this->refresh = FORCE_REFRESH_PERIOD;
+	this->SetDirty();
+}
+
+/**
+ * Set new #scroll_x, #scroll_y, and #subscroll values after limiting them such that the center
+ * of the smallmap always contains a part of the map.
+ * @param sx  Proposed new #scroll_x
+ * @param sy  Proposed new #scroll_y
+ * @param sub Proposed new #subscroll
+ */
+void SmallMapWindow::SetNewScroll(int sx, int sy, int sub)
+{
+	const NWidgetBase *wi = this->GetWidget<NWidgetBase>(WID_SM_MAP);
+	Point hv = InverseRemapCoords(wi->current_x * ZOOM_LVL_BASE * TILE_SIZE / 2, wi->current_y * ZOOM_LVL_BASE * TILE_SIZE / 2);
+	hv.x *= this->zoom;
+	hv.y *= this->zoom;
+
+	if (sx < -hv.x) {
+		sx = -hv.x;
+		sub = 0;
 	}
+	if (sx > (int)(MapMaxX() * TILE_SIZE) - hv.x) {
+		sx = MapMaxX() * TILE_SIZE - hv.x;
+		sub = 0;
+	}
+	if (sy < -hv.y) {
+		sy = -hv.y;
+		sub = 0;
+	}
+	if (sy > (int)(MapMaxY() * TILE_SIZE) - hv.y) {
+		sy = MapMaxY() * TILE_SIZE - hv.y;
+		sub = 0;
+	}
 
-	/**
-	 * Set new #scroll_x, #scroll_y, and #subscroll values after limiting them such that the center
-	 * of the smallmap always contains a part of the map.
-	 * @param sx  Proposed new #scroll_x
-	 * @param sy  Proposed new #scroll_y
-	 * @param sub Proposed new #subscroll
-	 */
-	void SetNewScroll(int sx, int sy, int sub)
-	{
-		const NWidgetBase *wi = this->GetWidget<NWidgetBase>(WID_SM_MAP);
-		Point hv = InverseRemapCoords(wi->current_x * ZOOM_LVL_BASE * TILE_SIZE / 2, wi->current_y * ZOOM_LVL_BASE * TILE_SIZE / 2);
-		hv.x *= this->zoom;
-		hv.y *= this->zoom;
+	this->scroll_x = sx;
+	this->scroll_y = sy;
+	this->subscroll = sub;
+	if (this->map_type == SMT_LINKSTATS) this->overlay->RebuildCache();
+}
 
-		if (sx < -hv.x) {
-			sx = -hv.x;
-			sub = 0;
-		}
-		if (sx > (int)(MapMaxX() * TILE_SIZE) - hv.x) {
-			sx = MapMaxX() * TILE_SIZE - hv.x;
-			sub = 0;
-		}
-		if (sy < -hv.y) {
-			sy = -hv.y;
-			sub = 0;
-		}
-		if (sy > (int)(MapMaxY() * TILE_SIZE) - hv.y) {
-			sy = MapMaxY() * TILE_SIZE - hv.y;
-			sub = 0;
-		}
+void SmallMapWindow::OnScroll(Point delta)
+{
+	_cursor.fix_at = true;
 
-		this->scroll_x = sx;
-		this->scroll_y = sy;
-		this->subscroll = sub;
-	}
+	/* While tile is at (delta.x, delta.y)? */
+	int sub;
+	Point pt = this->PixelToTile(delta.x, delta.y, &sub);
+	this->SetNewScroll(this->scroll_x + pt.x * TILE_SIZE, this->scroll_y + pt.y * TILE_SIZE, sub);
 
-	virtual void OnScroll(Point delta)
-	{
-		_cursor.fix_at = true;
+	this->SetDirty();
+}
 
-		/* While tile is at (delta.x, delta.y)? */
-		int sub;
-		Point pt = this->PixelToTile(delta.x, delta.y, &sub);
-		this->SetNewScroll(this->scroll_x + pt.x * TILE_SIZE, this->scroll_y + pt.y * TILE_SIZE, sub);
+void SmallMapWindow::SmallMapCenterOnCurrentPos()
+{
+	const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
+	Point pt = InverseRemapCoords(vp->virtual_left + vp->virtual_width  / 2, vp->virtual_top  + vp->virtual_height / 2);
 
-		this->SetDirty();
-	}
+	int sub;
+	const NWidgetBase *wid = this->GetWidget<NWidgetBase>(WID_SM_MAP);
+	Point sxy = this->ComputeScroll(pt.x / TILE_SIZE, pt.y / TILE_SIZE, max(0, (int)wid->current_x / 2 - 2), wid->current_y / 2, &sub);
+	this->SetNewScroll(sxy.x, sxy.y, sub);
+	this->SetDirty();
+}
 
-	void SmallMapCenterOnCurrentPos()
-	{
-		const ViewPort *vp = FindWindowById(WC_MAIN_WINDOW, 0)->viewport;
-		Point pt = InverseRemapCoords(vp->virtual_left + vp->virtual_width  / 2, vp->virtual_top  + vp->virtual_height / 2);
+/**
+ * Get the center of the given station as point on the screen in the smallmap window.
+ * @param st Station to find in the smallmap.
+ * @return Point with coordinates of the station.
+ */
+Point SmallMapWindow::GetStationMiddle(const Station *st) const
+{
+	int x = (st->rect.right + st->rect.left + 1) / 2;
+	int y = (st->rect.bottom + st->rect.top + 1) / 2;
+	Point ret = this->RemapTile(x, y);
 
-		int sub;
-		const NWidgetBase *wid = this->GetWidget<NWidgetBase>(WID_SM_MAP);
-		Point sxy = this->ComputeScroll(pt.x / TILE_SIZE, pt.y / TILE_SIZE, max(0, (int)wid->current_x / 2 - 2), wid->current_y / 2, &sub);
-		this->SetNewScroll(sxy.x, sxy.y, sub);
-		this->SetDirty();
-	}
-};
+	/* Same magic 3 as in DrawVehicles; that's where I got it from.
+	 * No idea what it is, but without it the result looks bad.
+	 */
+	ret.x -= 3 + this->subscroll;
+	return ret;
+}
 
 SmallMapWindow::SmallMapType SmallMapWindow::map_type = SMT_CONTOUR;
 bool SmallMapWindow::show_towns = true;
@@ -1639,6 +1671,8 @@
 							SetDataTip(SPR_IMG_ZOOMIN, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_IN), SetFill(1, 1),
 					NWidget(WWT_PUSHIMGBTN, COLOUR_BROWN, WID_SM_CENTERMAP),
 							SetDataTip(SPR_IMG_SMALLMAP, STR_SMALLMAP_CENTER), SetFill(1, 1),
+					NWidget(WWT_IMGBTN, COLOUR_BROWN, WID_SM_BLANK),
+							SetDataTip(SPR_DOT_SMALL, STR_NULL), SetFill(1, 1),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, WID_SM_CONTOUR),
 							SetDataTip(SPR_IMG_SHOW_COUNTOURS, STR_SMALLMAP_TOOLTIP_SHOW_LAND_CONTOURS_ON_MAP), SetFill(1, 1),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, WID_SM_VEHICLES),
@@ -1652,6 +1686,8 @@
 							SetDataTip(SPR_IMG_ZOOMOUT, STR_TOOLBAR_TOOLTIP_ZOOM_THE_VIEW_OUT), SetFill(1, 1),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, WID_SM_TOGGLETOWNNAME),
 							SetDataTip(SPR_IMG_TOWN, STR_SMALLMAP_TOOLTIP_TOGGLE_TOWN_NAMES_ON_OFF), SetFill(1, 1),
+					NWidget(WWT_IMGBTN, COLOUR_BROWN, WID_SM_LINKSTATS),
+							SetDataTip(SPR_IMG_GRAPHS, STR_SMALLMAP_TOOLTIP_SHOW_LINK_STATS_ON_MAP), SetFill(1, 1),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, WID_SM_ROUTES),
 							SetDataTip(SPR_IMG_SHOW_ROUTES, STR_SMALLMAP_TOOLTIP_SHOW_TRANSPORT_ROUTES_ON), SetFill(1, 1),
 					NWidget(WWT_IMGBTN, COLOUR_BROWN, WID_SM_VEGETATION),
@@ -1703,7 +1739,7 @@
 };
 
 static const WindowDesc _smallmap_desc(
-	WDP_AUTO, 446, 314,
+	WDP_AUTO, 484, 314,
 	WC_SMALLMAP, WC_NONE,
 	WDF_UNCLICK_BUTTONS,
 	_nested_smallmap_widgets, lengthof(_nested_smallmap_widgets)
Index: src/texteff.hpp
===================================================================
--- src/texteff.hpp	(revision 24093)
+++ src/texteff.hpp	(working copy)
@@ -41,6 +41,6 @@
 void HideFillingPercent(TextEffectID *te_id);
 
 void ShowCostOrIncomeAnimation(int x, int y, int z, Money cost);
-void ShowFeederIncomeAnimation(int x, int y, int z, Money cost);
+void ShowFeederIncomeAnimation(int x, int y, int z, Money transfer, Money income);
 
 #endif /* TEXTEFF_HPP */
Index: src/group_cmd.cpp
===================================================================
--- src/group_cmd.cpp	(revision 24093)
+++ src/group_cmd.cpp	(working copy)
@@ -21,6 +21,7 @@
 #include "company_func.h"
 #include "core/pool_func.hpp"
 #include "order_backup.h"
+#include "aaa_template_vehicle.h"
 
 #include "table/strings.h"
 
@@ -135,6 +136,9 @@
  */
 /* static */ void GroupStatistics::CountVehicle(const Vehicle *v, int delta)
 {
+	/* make virtual trains group-neutral */
+	if ( HasBit(v->subtype, GVSF_VIRTUAL) ) return;
+
 	assert(delta == 1 || delta == -1);
 
 	GroupStatistics &stats_all = GroupStatistics::GetAllGroup(v);
@@ -330,6 +334,9 @@
 
 		VehicleType vt = g->vehicle_type;
 
+		/* Delete all template replacements using the just deleted group */
+		deleteIllegalTemplateReplacements(g->index);
+
 		/* Delete the Replace Vehicle Windows */
 		DeleteWindowById(WC_REPLACE_VEHICLE, g->vehicle_type);
 		delete g;
Index: src/station.cpp
===================================================================
--- src/station.cpp	(revision 24093)
+++ src/station.cpp	(working copy)
@@ -60,10 +60,16 @@
 	last_vehicle_type(VEH_INVALID)
 {
 	/* this->random_bits is set in Station::AddFacility() */
+
+	/* has to be done like this as we can't give arguments when constructing an array */
+	for (CargoID i = 0; i < NUM_CARGO; ++i) {
+		this->goods[i].cargo.AssignTo(this, i);
+	}
 }
 
 /**
- * Clean up a station by clearing vehicle orders and invalidating windows.
+ * Clean up a station by clearing vehicle orders, invalidating windows and
+ * removing link stats.
  * Aircraft-Hangar orders need special treatment here, as the hangars are
  * actually part of a station (tiletype is STATION), but the order type
  * is OT_GOTO_DEPOT.
@@ -87,12 +93,25 @@
 		if (a->targetairport == this->index) a->targetairport = INVALID_STATION;
 	}
 
+	Station *st;
+	FOR_ALL_STATIONS(st) {
+		for (CargoID c = 0; c < NUM_CARGO; ++c) {
+			GoodsEntry &ge = st->goods[c];
+			ge.link_stats.erase(this->index);
+			DeleteStaleFlows(st->index, c, this->index);
+			ge.cargo.RerouteStalePackets(this->index);
+		}
+	}
+
 	Vehicle *v;
 	FOR_ALL_VEHICLES(v) {
 		/* Forget about this station if this station is removed */
 		if (v->last_station_visited == this->index) {
 			v->last_station_visited = INVALID_STATION;
 		}
+		if (v->last_loading_station == this->index) {
+			v->last_loading_station = INVALID_STATION;
+		}
 	}
 
 	/* Clear the persistent storage. */
Index: src/aaa_template_gui_main.cpp
===================================================================
--- src/aaa_template_gui_main.cpp	(revision 0)
+++ src/aaa_template_gui_main.cpp	(revision 0)
@@ -0,0 +1,740 @@
+// mygui.c
+
+
+//#include "aaa_mygui.h"
+#include <iostream>
+#include <stdio.h>
+
+
+#include "stdafx.h"
+#include "command_func.h"
+#include "vehicle_gui.h"
+#include "newgrf_engine.h"
+#include "group.h"
+#include "rail.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "autoreplace_func.h"
+#include "company_func.h"
+#include "engine_base.h"
+#include "window_gui.h"
+#include "viewport_func.h"
+#include "tilehighlight_func.h"
+#include "engine_gui.h"
+#include "settings_func.h"
+#include "core/geometry_func.hpp"
+#include "rail_gui.h"
+
+#include "table/sprites.h"
+#include "table/strings.h"
+
+// test creating pool -> creating vehicles
+#include "core/pool_func.hpp"
+
+#include "vehicle_gui_base.h"
+#include "vehicle_base.h"
+#include "train.h"
+#include "vehicle_func.h"
+
+#include "gfx_type.h"
+
+#include "engine_func.h"
+
+// drawing the vehicle length based on occupied tiles
+#include "spritecache.h"
+
+#include "aaa_template_gui_main.h"
+#include "aaa_template_gui_create.h"
+#include "aaa_template_vehicle.h"
+//#include "aaa_template_vehicle_func.h"
+
+
+typedef GUIList<const Group*> GUIGroupList;
+
+
+/* template creation */
+void ShowTemplateCreationWindow(TileIndex);
+void ShowTestWindow();
+
+enum TemplateReplaceWindowWidgets {
+	TRW_CAPTION,
+
+	TRW_WIDGET_INSET_GROUPS,
+	TRW_WIDGET_TOP_MATRIX,
+	TRW_WIDGET_TOP_SCROLLBAR,
+
+	TRW_WIDGET_INSET_TEMPLATES,
+	TRW_WIDGET_BOTTOM_MATRIX,
+	TRW_WIDGET_BOTTOM_SCROLLBAR,
+
+	TRW_WIDGET_TMPL_INFO_INSET,
+	TRW_WIDGET_TMPL_INFO_PANEL,
+
+	TRW_WIDGET_TMPL_PRE_BUTTON_FLUFF,
+
+	TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REUSE,
+	TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_KEEP,
+	TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REFIT,
+	TRW_WIDGET_TMPL_BUTTONS_CONFIG_RIGHTPANEL,
+
+	TRW_WIDGET_TMPL_BUTTONS_DEFINE,
+	TRW_WIDGET_TMPL_BUTTONS_EDIT,
+	TRW_WIDGET_TMPL_BUTTONS_CLONE,
+	TRW_WIDGET_TMPL_BUTTONS_DELETE,
+	TRW_WIDGET_TMPL_BUTTONS_RPLALL,
+	TRW_WIDGET_TMPL_BUTTON_FLUFF,
+	TRW_WIDGET_TMPL_BUTTONS_EDIT_RIGHTPANEL,
+
+	TRW_WIDGET_TITLE_INFO_GROUP,
+	TRW_WIDGET_TITLE_INFO_TEMPLATE,
+
+	TRW_WIDGET_INFO_GROUP,
+ 	TRW_WIDGET_INFO_TEMPLATE,
+
+	TRW_WIDGET_TMPL_BUTTONS_SPACER,
+
+	TRW_WIDGET_START,
+	TRW_WIDGET_TRAIN_FLUFF_LEFT,
+	TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN,
+	TRW_WIDGET_TRAIN_FLUFF_RIGHT,
+	TRW_WIDGET_STOP,
+
+	TRW_WIDGET_SEL_TMPL_DISPLAY_CREATE,
+};
+
+
+static const NWidgetPart _widgets[] = {
+	// Title bar
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, TRW_CAPTION), SetDataTip(STR_TMPL_RPL_TITLE, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	//Top Matrix
+	NWidget(NWID_VERTICAL),
+		NWidget(WWT_INSET, COLOUR_GREY, TRW_WIDGET_INSET_GROUPS), SetMinimalSize(216,12), SetDataTip(STR_TMPL_MAINGUI_DEFINEDGROUPS, STR_TMPL_MAINGUI_DEFINEDGROUPS), SetResize(1, 0), EndContainer(),
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_MATRIX, COLOUR_GREY, TRW_WIDGET_TOP_MATRIX), SetMinimalSize(216, 0), SetFill(1, 1), SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY), SetResize(1, 0), SetScrollbar(TRW_WIDGET_TOP_SCROLLBAR),
+			NWidget(NWID_VSCROLLBAR, COLOUR_GREY, TRW_WIDGET_TOP_SCROLLBAR),
+		EndContainer(),
+	EndContainer(),
+	// Template Display
+	NWidget(NWID_VERTICAL),
+		NWidget(WWT_INSET, COLOUR_GREY, TRW_WIDGET_INSET_TEMPLATES), SetMinimalSize(216,12), SetDataTip(STR_TMPL_AVAILABLE_TEMPLATES, STR_TMPL_AVAILABLE_TEMPLATES), SetResize(1, 0), EndContainer(),
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_MATRIX, COLOUR_GREY, TRW_WIDGET_BOTTOM_MATRIX), SetMinimalSize(216, 0), SetFill(1, 1), SetDataTip(0x1, STR_REPLACE_HELP_RIGHT_ARRAY), SetResize(1, 1), SetScrollbar(TRW_WIDGET_BOTTOM_SCROLLBAR),
+			NWidget(NWID_VSCROLLBAR, COLOUR_GREY, TRW_WIDGET_BOTTOM_SCROLLBAR),
+		EndContainer(),
+	EndContainer(),
+	// Info Area
+	NWidget(NWID_VERTICAL),
+		NWidget(WWT_INSET, COLOUR_GREY, TRW_WIDGET_TMPL_INFO_INSET), SetMinimalSize(216,12), SetResize(1,0), SetDataTip(STR_TMPL_AVAILABLE_TEMPLATES, STR_TMPL_AVAILABLE_TEMPLATES), EndContainer(),
+		NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TMPL_INFO_PANEL), SetMinimalSize(216,50), SetResize(1,0), EndContainer(),
+	EndContainer(),
+	// Control Area
+	NWidget(NWID_VERTICAL),
+		// Spacing
+		NWidget(WWT_INSET, COLOUR_GREY, TRW_WIDGET_TMPL_PRE_BUTTON_FLUFF), SetMinimalSize(139, 12), SetResize(1,0), EndContainer(),
+		// Config buttons
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REUSE), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_SET_USEDEPOT, STR_TMPL_SET_USEDEPOT_TIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_KEEP), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_SET_KEEPREMAINDERS, STR_TMPL_SET_KEEPREMAINDERS_TIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REFIT), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_SET_REFIT, STR_TMPL_SET_REFIT_TIP),
+			NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CONFIG_RIGHTPANEL), SetMinimalSize(12,12), SetResize(1,0), EndContainer(),
+		EndContainer(),
+		// Edit buttons
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_DEFINE), SetMinimalSize(75,12), SetResize(0,0), SetDataTip(STR_TMPL_DEFINE_TEMPLATE, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_EDIT), SetMinimalSize(75,12), SetResize(0,0), SetDataTip(STR_TMPL_EDIT_TEMPLATE, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CLONE), SetMinimalSize(75,12), SetResize(0,0), SetDataTip(STR_TMPL_CREATE_CLONE_VEH, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_DELETE), SetMinimalSize(75,12), SetResize(0,0), SetDataTip(STR_TMPL_DELETE_TEMPLATE, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_RPLALL), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_RPL_ALL_TMPL, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_EDIT_RIGHTPANEL), SetMinimalSize(50,12), SetResize(1,0), EndContainer(),
+		EndContainer(),
+	EndContainer(),
+	// Start/Stop buttons
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_START), SetMinimalSize(150, 12), SetDataTip(STR_TMPL_RPL_START, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+		NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TRAIN_FLUFF_LEFT), SetMinimalSize(15, 12), EndContainer(),
+		NWidget(WWT_DROPDOWN, COLOUR_GREY, TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN), SetMinimalSize(150, 12), SetDataTip(0x0, STR_REPLACE_HELP_RAILTYPE), SetResize(1, 0),
+		NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TRAIN_FLUFF_RIGHT), SetMinimalSize(16, 12), EndContainer(),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_STOP), SetMinimalSize(150, 12), SetDataTip(STR_TMPL_RPL_STOP, STR_REPLACE_REMOVE_WAGON_HELP),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static const WindowDesc _replace_rail_vehicle_desc(
+	WDP_AUTO, 456, 156,
+	WC_TEMPLATEGUI_MAIN, WC_NONE,					// TODO change wc_replace_vehicle
+	WDF_UNCLICK_BUTTONS | WDF_CONSTRUCTION,
+	_widgets, lengthof(_widgets)
+);
+
+class TemplateReplaceWindow : public Window {
+private:
+
+	GUIGroupList groups;  		 ///< List of groups
+	byte unitnumber_digits;
+	//Own
+	short line_height;
+	short matrixContentLeftMargin;
+
+	// from AutoreplaceGUI
+	int details_height;           ///< Minimal needed height of the details panels (found so far).
+	RailType sel_railtype;        ///< Type of rail tracks selected.
+	Scrollbar *vscroll[2];
+	// listing/sorting continued
+	GUITemplateList templates;
+	GUITemplateList::SortFunction **template_sorter_funcs;
+
+	short selected_template_index;
+	short selected_group_index;
+
+	bool templateNotice;
+	bool editInProgress;
+
+public:
+	TemplateReplaceWindow(const WindowDesc *wdesc, byte dig, int step_h) : Window()
+	{
+		// listing/sorting
+		templates.SetSortFuncs(this->template_sorter_funcs);
+
+		// From BaseVehicleListWindow
+		this->unitnumber_digits = dig;
+
+		// from AutoreplaceGUI
+		this->sel_railtype = RAILTYPE_BEGIN;
+		this->details_height   = 10 * FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+
+		this->line_height = step_h;
+
+		this->CreateNestedTree(wdesc);
+		this->vscroll[0] = this->GetScrollbar(TRW_WIDGET_TOP_SCROLLBAR);
+		this->vscroll[1] = this->GetScrollbar(TRW_WIDGET_BOTTOM_SCROLLBAR);
+		this->vscroll[0]->SetStepSize(step_h / 2);
+		this->vscroll[1]->SetStepSize(step_h);
+		this->FinishInitNested(wdesc, VEH_TRAIN);
+
+		this->owner = _local_company;
+
+// 		this->groups = new GUIGroupList();
+		this->groups.ForceRebuild();
+		this->groups.NeedResort();
+ 		this->BuildGroupList(_local_company);
+		this->groups.Sort(&GroupNameSorter);
+
+
+		this->matrixContentLeftMargin = 40;
+		this->selected_template_index = -1;
+		this->selected_group_index = -1;
+
+		this->templateNotice = false;
+		this->editInProgress = false;
+
+		this->templates.ForceRebuild();
+
+		BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+
+		//CmdBuildVirtualRailVehicle(20);
+	}
+
+	~TemplateReplaceWindow() {
+		DeleteWindowById(WC_CREATE_TEMPLATE, this->window_number);
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case TRW_WIDGET_TOP_MATRIX:
+				resize->height = GetVehicleListHeight(VEH_TRAIN, FONT_HEIGHT_NORMAL + WD_MATRIX_TOP) / 2;
+				size->height = 8 * resize->height;
+				break;
+			case TRW_WIDGET_BOTTOM_MATRIX:
+				resize->height = GetVehicleListHeight(VEH_TRAIN, FONT_HEIGHT_NORMAL + WD_MATRIX_TOP);
+				size->height = 4 * resize->height;
+				break;
+			case TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN: {
+				Dimension d = {0, 0};
+				for (RailType rt = RAILTYPE_BEGIN; rt != RAILTYPE_END; rt++) {
+					const RailtypeInfo *rti = GetRailTypeInfo(rt);
+					// Skip rail type if it has no label
+					if (rti->label == 0) continue;
+					d = maxdim(d, GetStringBoundingBox(rti->strings.replace_text));
+				}
+				d.width += padding.width;
+				d.height += padding.height;
+				*size = maxdim(*size, d);
+				break;
+			}
+		}
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			// TODO: rm
+			case TRW_CAPTION:
+				SetDParam(0, STR_REPLACE_VEHICLE_TRAIN + this->window_number);
+				break;
+		}
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		// TODO: why -1 ??
+		deleteIllegalTemplateReplacements(-1);
+
+		switch (widget) {
+			case TRW_WIDGET_TOP_MATRIX: {
+				DrawAllGroupsFunction(this->line_height, r);
+				break;
+			}
+			case TRW_WIDGET_BOTTOM_MATRIX: {
+				DrawTemplateList(this->line_height, r);
+				break;
+			}
+			case TRW_WIDGET_TMPL_INFO_PANEL: {
+				DrawTemplateInfo(this->line_height, r);
+				break;
+			}
+		}
+	}
+
+	virtual void OnPaint()
+	{
+		// TODO: only temporary because of allreplacement
+		BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+
+		this->BuildGroupList(_local_company);
+		this->groups.Sort(&GroupNameSorter);
+
+		if ( templateNotice ) {
+			BuildTemplateGuiList(&this->templates, vscroll[1], _local_company, this->sel_railtype);
+			templateNotice = false;
+			this->SetDirty();
+		}
+		// TODO: rm if ?
+		if (this->window_number == VEH_TRAIN) {
+			/* sets the colour of that art thing */
+			// TODO: use stored company for colors
+			this->GetWidget<NWidgetCore>(TRW_WIDGET_TRAIN_FLUFF_LEFT)->colour  = _company_colours[_local_company];
+			this->GetWidget<NWidgetCore>(TRW_WIDGET_TRAIN_FLUFF_RIGHT)->colour = _company_colours[_local_company];
+
+			/* Show the selected railtype in the pulldown menu */
+			this->GetWidget<NWidgetCore>(TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN)->widget_data = GetRailTypeInfo(sel_railtype)->strings.replace_text;
+		}
+		this->DrawWidgets();
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		if ( this->editInProgress ) return;
+
+		switch (widget) {
+			case TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REUSE: {
+				if ( this->selected_template_index >= 0 ) {
+					//TemplateVehicle *sel = (TemplateVehicle*)(this->templates)[selected_template_index];
+					//const TemplateVehicle* ctv = ;
+					TemplateVehicle *sel = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					sel->ToggleReuseDepotVehicles();
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_KEEP: {
+				if ( this->selected_template_index >= 0 ) {
+					//TemplateVehicle *sel = (TemplateVehicle*)(this->templates)[selected_template_index];
+					TemplateVehicle *sel = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					sel->ToggleKeepRemainingVehicles();
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REFIT: {
+				if ( this->selected_template_index >= 0 ) {
+					//TemplateVehicle *sel = (TemplateVehicle*)(this->templates)[selected_template_index];
+					TemplateVehicle *sel = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					sel->ToggleRefitAsTemplate();
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_DEFINE:
+				ShowTemplateCreateWindow(0, &templateNotice, &editInProgress, this->line_height);
+				break;
+			case TRW_WIDGET_TMPL_BUTTONS_EDIT: {
+				if ( this->selected_template_index >= 0 ) {
+					editInProgress = true;
+					TemplateVehicle *sel = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					ShowTemplateCreateWindow(sel, &templateNotice, &editInProgress, this->line_height);
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_CLONE: {
+				this->SetWidgetDirty(TRW_WIDGET_TMPL_BUTTONS_CLONE);
+				this->ToggleWidgetLoweredState(TRW_WIDGET_TMPL_BUTTONS_CLONE);
+
+				if (this->IsWidgetLowered(TRW_WIDGET_TMPL_BUTTONS_CLONE)) {
+					static const CursorID clone_icon =	SPR_CURSOR_CLONE_TRAIN;
+					SetObjectToPlaceWnd(clone_icon, PAL_NONE, HT_VEHICLE, this);
+				} else {
+					ResetObjectToPlace();
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_DELETE:
+				if ( selected_template_index >= 0 && !editInProgress ) {
+					// identify template to delete
+					TemplateVehicle *del = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					// remove a corresponding template replacement if existing
+					TemplateReplacement *tr = GetTemplateReplacementByTemplateID(del->index);
+					if ( tr ) {
+						delete tr;
+					}
+					delete del;
+					BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+					selected_template_index = -1;
+				}
+				break;
+			case TRW_WIDGET_TMPL_BUTTONS_RPLALL: {
+				ShowTemplateReplaceAllGui();
+				//testfunc();
+				break;
+			}
+			case TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN: // Railtype selection dropdown menu
+				ShowDropDownList(this, GetRailTypeDropDownList(true), sel_railtype, TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN);
+				break;
+			case TRW_WIDGET_TOP_MATRIX: {
+ 				uint16 newindex = (uint16)((pt.y - this->nested_array[TRW_WIDGET_TOP_MATRIX]->pos_y) / (this->line_height/2) ) + this->vscroll[0]->GetPosition();
+				if ( newindex == this->selected_group_index || newindex >= this->groups.Length() ) {
+					this->selected_group_index = -1;
+				}
+				else if ( newindex < this->groups.Length() ) {
+					this->selected_group_index = newindex;
+				}
+				break;
+			}
+			case TRW_WIDGET_BOTTOM_MATRIX: {
+ 				uint16 newindex = (uint16)((pt.y - this->nested_array[TRW_WIDGET_BOTTOM_MATRIX]->pos_y) / this->line_height) + this->vscroll[1]->GetPosition();
+				if ( newindex == this->selected_template_index || newindex >= templates.Length() ) {
+					this->selected_template_index = -1;
+				}
+				else if ( newindex < templates.Length() ) {
+					this->selected_template_index = newindex;
+				}
+				break;
+			}
+			// TODO: start button dependent on selected template ?
+			case TRW_WIDGET_START: {
+				if ( this->selected_template_index >= 0 && this->selected_group_index >= 0) {
+					uint32 tv_index = ((this->templates)[selected_template_index])->index;
+					int current_group_index = (this->groups)[this->selected_group_index]->index;
+					IssueTemplateReplacement(current_group_index, tv_index);
+				}
+				break;
+			}
+			case TRW_WIDGET_STOP:
+				if ( this->selected_group_index == -1 )
+					return;
+				int current_group_index = (this->groups)[this->selected_group_index]->index;
+				TemplateReplacement *tr = GetTemplateReplacementByGroupID(current_group_index);
+				if ( tr )
+					delete tr;
+				break;
+		}
+		this->SetDirty();
+	}
+
+	virtual bool OnVehicleSelect(const Vehicle *v)
+	{
+		// create a new template from the clicked vehicle
+		TemplateVehicle *tv = CloneTemplateVehicleFromTrain((const Train*)v);
+		if ( !tv )	return false;
+
+		BuildTemplateGuiList(&this->templates, vscroll[1], _local_company, this->sel_railtype);
+		this->ToggleWidgetLoweredState(TRW_WIDGET_TMPL_BUTTONS_CLONE);
+		ResetObjectToPlace();
+		this->SetDirty();
+
+		return true;
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		RailType temp = (RailType)index;
+		if (temp == this->sel_railtype) return; // we didn't select a new one. No need to change anything
+		this->sel_railtype = temp;
+		/* Reset scrollbar positions */
+		this->vscroll[0]->SetPosition(0);
+		this->vscroll[1]->SetPosition(0);
+		BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+		this->SetDirty();
+	}
+
+	virtual void OnResize()
+	{
+		/* Top Matrix */
+		NWidgetCore *nwi = this->GetWidget<NWidgetCore>(TRW_WIDGET_TOP_MATRIX);
+		this->vscroll[0]->SetCapacityFromWidget(this, TRW_WIDGET_TOP_MATRIX);
+		nwi->widget_data = (this->vscroll[0]->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+		/* Bottom Matrix */
+		NWidgetCore *nwi2 = this->GetWidget<NWidgetCore>(TRW_WIDGET_BOTTOM_MATRIX);
+		this->vscroll[1]->SetCapacityFromWidget(this, TRW_WIDGET_BOTTOM_MATRIX);
+		nwi2->widget_data = (this->vscroll[1]->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+	virtual void OnTick()
+	{
+		if ( templateNotice ) {
+			BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+			this->SetDirty();
+			templateNotice = false;
+		}
+
+	}
+
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		this->groups.ForceRebuild();
+		this->templates.ForceRebuild();
+	}
+	void testfunc() {
+		// replace 764 by 775
+		TemplateVehicle *tmp = (TemplateVehicle*)this->templates[1];
+		Train *t = VirtualTrainFromTemplateVehicle(tmp);
+
+		for ( Train *tt = t; tt; ) {
+			if ( tt->engine_type == 764 ) {
+				Train *n = CmdBuildVirtualRailVehicle(775);
+				// move new after old
+				CommandCost cost = CmdMoveRailVehicle(0, DC_EXEC, n->index | (1<<21), tt->index, 0);
+				// move old away
+				CommandCost cost2 = CmdMoveRailVehicle(0, DC_EXEC, tt->index | (1<<21), INVALID_VEHICLE, 0);
+				tt = n;
+			}
+			else
+				tt = tt->GetNextUnit();
+		}
+
+		delete tmp;
+		TemplateVehicle *ntv = TemplateVehicleFromVirtualTrain(t);
+		BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+		this->SetDirty();
+
+		printf("finished\n");
+
+	}
+	/** For a given group (id) find the template that is issued for template replacement for this group and return this template's index
+	 *  from the gui list */
+	short FindTemplateIndexForGroup(short gid) const
+	{
+		TemplateReplacement *tr = GetTemplateReplacementByGroupID(gid);
+		if ( !tr )
+			return -1;
+
+		for ( uint32 i=0; i<this->templates.Length(); i++ )
+			if ( templates[i]->index == tr->sel_template )
+				return i;
+		return -1;
+	}
+
+		/** Sort the groups by their name */
+	static int CDECL GroupNameSorter(const Group * const *a, const Group * const *b)
+	{
+		static const Group *last_group[2] = { NULL, NULL };
+		static char         last_name[2][64] = { "", "" };
+
+		if (*a != last_group[0]) {
+			last_group[0] = *a;
+			SetDParam(0, (*a)->index);
+			GetString(last_name[0], STR_GROUP_NAME, lastof(last_name[0]));
+		}
+
+		if (*b != last_group[1]) {
+			last_group[1] = *b;
+			SetDParam(0, (*b)->index);
+			GetString(last_name[1], STR_GROUP_NAME, lastof(last_name[1]));
+		}
+
+		int r = strnatcmp(last_name[0], last_name[1]); // Sort by name (natural sorting).
+		if (r == 0) return (*a)->index - (*b)->index;
+		return r;
+	}
+
+	void BuildGroupList(Owner owner)
+	{
+		if (!this->groups.NeedRebuild()) {
+			return;
+		}
+		this->groups.Clear();
+
+		const Group *g;
+		FOR_ALL_GROUPS(g) {
+			if (g->owner == owner ) {
+				*this->groups.Append() = g;
+			}
+		}
+
+		this->groups.Compact();
+		this->groups.RebuildDone();
+		this->vscroll[0]->SetCount(groups.Length());
+	}
+
+	void DrawAllGroupsFunction(int line_height, const Rect &r) const
+	{
+		int left = r.left + WD_MATRIX_LEFT;
+		int right = r.right - WD_MATRIX_RIGHT;
+		int y = r.top;
+		int max = min(this->vscroll[0]->GetPosition() + this->vscroll[0]->GetCapacity(), this->groups.Length());
+
+		/* Then treat all groups defined by/for the current company */
+		for ( int i=this->vscroll[0]->GetPosition(); i<max; i++ ) {
+			const Group *g = (this->groups)[i];
+			short g_id = g->index;
+
+			/* Fill the background of the current cell in a darker tone for the currently selected template */
+			if ( this->selected_group_index == i ) {
+				GfxFillRect(left, y, right, y+(this->line_height)/2, _colour_gradient[COLOUR_GREY][3]);
+			}
+
+			SetDParam(0, g_id);
+			StringID str = STR_GROUP_NAME;
+			DrawString(left+30, right, y+2, str, TC_BLACK);
+
+			/* Draw the template in use for this group, if there is one */
+			short template_in_use = FindTemplateIndexForGroup(g_id);
+			if ( template_in_use >= 0 ) {
+				SetDParam(0, template_in_use);
+				DrawString ( left, right, y+2, STR_TMPL_GROUP_USES_TEMPLATE, TC_BLACK, SA_HOR_CENTER);
+			}
+			/* If there isn't a template applied from the current group, check if there is one for another rail type */
+			else if ( GetTemplateReplacementByGroupID(g_id) ) {
+				DrawString ( left, right, y+2, STR_TMPL_TMPLRPL_EX_DIFF_RAILTYPE, TC_SILVER, SA_HOR_CENTER);
+			}
+
+			/* Draw the number of trains that still need to be treated by the currently selected template replacement */
+			TemplateReplacement *tr = GetTemplateReplacementByGroupID(g_id);
+			if ( tr ) {
+				TemplateVehicle *tv = TemplateVehicle::Get(tr->sel_template);
+				int num_trains = NumTrainsNeedTemplateReplacement(g_id, tv);
+				// Draw text
+				TextColour color = TC_GREY;
+				if ( num_trains ) color = TC_BLACK;
+				DrawString(left, right-16, y+2, STR_TMPL_NUM_TRAINS_NEED_RPL, color, SA_RIGHT);
+				// Draw number
+				if ( num_trains ) color = TC_ORANGE;
+				else color = TC_GREY;
+				SetDParam(0, num_trains);
+				DrawString(left, right-4, y+2, STR_JUST_INT, color, SA_RIGHT);
+			}
+
+			y+=line_height / 2;
+		}
+	}
+
+	void DrawTemplateList(int line_height, const Rect &r) const
+	{
+		int left = r.left;
+		int right = r.right;
+		int y = r.top;
+
+		Scrollbar *draw_vscroll = vscroll[1];
+		uint max = min(draw_vscroll->GetPosition() + draw_vscroll->GetCapacity(), this->templates.Length());
+
+		const TemplateVehicle *v;
+		for ( uint i = draw_vscroll->GetPosition(); i < max; ++i) {
+
+			v = (this->templates)[i];
+
+			/* Fill the background of the current cell in a darker tone for the currently selected template */
+			if ( this->selected_template_index == i ) {
+				GfxFillRect(left, y, right, y+this->line_height, _colour_gradient[COLOUR_GREY][3]);
+			}
+
+			/* Draw a notification string for chains that are not runnable */
+			if ( v->IsFreeWagonChain() ) {
+				DrawString(left, right-2, y+line_height-FONT_HEIGHT_SMALL-WD_FRAMERECT_BOTTOM - 2, STR_TMPL_WARNING_FREE_WAGON, TC_RED, SA_RIGHT);
+			}
+
+			/* Draw the template's length in tile-units */
+			SetDParam(0, v->GetRealLength());
+			SetDParam(1, 1);
+			DrawString(left, right-4, y+2, STR_TINY_BLACK_DECIMAL, TC_BLACK, SA_RIGHT);
+
+			/* Draw the template */
+			DrawTemplate(v, left+50, right, y);
+
+			/* Buying cost */
+			SetDParam(0, CalculateOverallTemplateCost(v));
+			DrawString(left+35, right, y + line_height - FONT_HEIGHT_SMALL - WD_FRAMERECT_BOTTOM - 2, STR_TMPL_TEMPLATE_OVR_VALUE_notinyfont, TC_BLUE, SA_LEFT);
+
+			/* Index of current template vehicle in the list of all templates for its company */
+			SetDParam(0, i);
+			DrawString(left+5, left+25, y + line_height/2, STR_BLACK_INT, TC_BLACK, SA_RIGHT);
+
+			/* Draw whether the current template is in use by any group */
+			if ( v->NumGroupsUsingTemplate() > 0 ) {
+				DrawString(left+200, right, y + line_height - FONT_HEIGHT_SMALL - WD_FRAMERECT_BOTTOM - 2, STR_TMP_TEMPLATE_IN_USE, TC_GREEN, SA_LEFT);
+			}
+
+			/* Draw information about template configuration settings */
+			TextColour color;
+			if ( v->IsSetReuseDepotVehicles() ) color = TC_LIGHT_BLUE;
+			else color = TC_GREY;
+			DrawString(left+200, right, y+2, STR_TMPL_CONFIG_USEDEPOT, color, SA_LEFT);
+			if ( v->IsSetKeepRemainingVehicles() ) color = TC_LIGHT_BLUE;
+			else color = TC_GREY;
+			DrawString(left+275, right, y+2, STR_TMPL_CONFIG_KEEPREMAINDERS, color, SA_LEFT);
+			if ( v->IsSetRefitAsTemplate() ) color = TC_LIGHT_BLUE;
+			else color = TC_GREY;
+			DrawString(left+350, right, y+2, STR_TMPL_CONFIG_REFIT, color, SA_LEFT);
+
+			y += line_height;
+		}
+	}
+
+	void DrawTemplateInfo(int line_height, const Rect &r) const
+	{
+		if ( this->selected_template_index == -1 || (short)this->templates.Length() <= this->selected_template_index )
+			return;
+
+		const TemplateVehicle *tmp = this->templates[this->selected_template_index];
+
+		/* Draw vehicle performance info */
+		SetDParam(2, tmp->max_speed);
+		SetDParam(1, tmp->power);
+		SetDParam(0, tmp->weight);
+		SetDParam(3, tmp->max_te);
+		DrawString(r.left+8, r.right, r.top+4, STR_VEHICLE_INFO_WEIGHT_POWER_MAX_SPEED_MAX_TE);
+
+		/* Draw cargo summary */
+		short top = r.top + 24;
+		short left = r.left + 8;
+		short count_rows = 0;
+		short max_rows = 2;
+
+		CargoArray cargo_caps;
+		for ( ; tmp; tmp=tmp->Next() )
+			cargo_caps[tmp->cargo_type] += tmp->cargo_cap;
+		int y = top;
+		for (CargoID i = 0; i < NUM_CARGO; i++) {
+			if ( cargo_caps[i] > 0 ) {
+				count_rows++;
+				SetDParam(0, i);
+				SetDParam(1, cargo_caps[i]);
+				SetDParam(2, _settings_game.vehicle.freight_trains);
+				DrawString(left, r.right, y, FreightWagonMult(i) > 1 ? STR_TMPL_CARGO_SUMMARY_MULTI : STR_TMPL_CARGO_SUMMARY, TC_WHITE, SA_LEFT);
+				y += this->line_height/2;
+				if ( count_rows % max_rows == 0 ) {
+					y = top;
+					left += 150;
+				}
+			}
+		}
+	}
+};
+
+void ShowTemplateReplaceWindow(byte dig, int step_h)
+{
+
+	new TemplateReplaceWindow(&_replace_rail_vehicle_desc, dig, step_h);
+}
+
Index: src/newgrf.cpp
===================================================================
--- src/newgrf.cpp	(revision 24093)
+++ src/newgrf.cpp	(working copy)
@@ -9001,6 +9001,9 @@
 	/* Create dynamic list of industry legends for smallmap_gui.cpp */
 	BuildIndustriesLegend();
 
+	/* build the routemap legend, based on the available cargos */
+	BuildLinkStatsLegend();
+
 	/* Add all new airports to the airports array. */
 	FinaliseAirportsArray();
 	BindAirportSpecs();
Index: src/station_gui.h
===================================================================
--- src/station_gui.h	(revision 24093)
+++ src/station_gui.h	(working copy)
@@ -13,8 +13,11 @@
 #define STATION_GUI_H
 
 #include "command_type.h"
+#include "station_type.h"
 #include "tilearea_type.h"
 #include "window_type.h"
+#include "cargo_type.h"
+#include <set>
 
 
 /** Types of cargo to display for station coverage. */
@@ -30,4 +33,152 @@
 void ShowSelectStationIfNeeded(CommandContainer cmd, TileArea ta);
 void ShowSelectWaypointIfNeeded(CommandContainer cmd, TileArea ta);
 
+enum SortOrder {
+	SO_DESCENDING,
+	SO_ASCENDING
+};
+
+class CargoDataEntry;
+
+enum CargoSortType {
+	ST_AS_GROUPING,    ///< by the same principle the entries are being grouped
+	ST_COUNT,          ///< by amount of cargo
+	ST_STATION_STRING, ///< by station name
+	ST_STATION_ID,     ///< by station id
+	ST_CARGO_ID,       ///< by cargo id
+};
+
+class CargoSorter {
+public:
+	CargoSorter(CargoSortType t = ST_STATION_ID, SortOrder o = SO_ASCENDING) : type(t), order(o) {}
+	CargoSortType GetSortType() {return this->type;}
+	bool operator()(const CargoDataEntry *cd1, const CargoDataEntry *cd2) const;
+
+private:
+	CargoSortType type;
+	SortOrder order;
+
+	template<class ID>
+	bool SortId(ID st1, ID st2) const;
+	bool SortCount(const CargoDataEntry *cd1, const CargoDataEntry *cd2) const;
+	bool SortStation (StationID st1, StationID st2) const;
+};
+
+typedef std::set<CargoDataEntry *, CargoSorter> CargoDataSet;
+
+/**
+ * A cargo data entry representing one possible row in the station view window's
+ * top part. Cargo data entries form a tree where each entry can have several
+ * children. Parents keep track of the sums of their childrens' cargo counts.
+ */
+class CargoDataEntry {
+public:
+	CargoDataEntry();
+	~CargoDataEntry();
+
+	/**
+	 * Insert a new child or retrieve an existing child using a station ID as ID.
+	 * @param station ID of the station for which an entry shall be created or retrieved
+	 * @return a child entry associated with the given station.
+	 */
+	CargoDataEntry *InsertOrRetrieve(StationID station) {return this->InsertOrRetrieve<StationID>(station);}
+
+	/**
+	 * Insert a new child or retrieve an existing child using a cargo ID as ID.
+	 * @param cargo ID of the cargo for which an entry shall be created or retrieved
+	 * @return a child entry associated with the given cargo.
+	 */
+	CargoDataEntry *InsertOrRetrieve(CargoID cargo) {return this->InsertOrRetrieve<CargoID>(cargo);}
+
+	void Update(uint count);
+
+	/**
+	 * Remove a child associated with the given station.
+	 * @param station ID of the station for which the child should be removed.
+	 */
+	void Remove(StationID station) {CargoDataEntry t(station); this->Remove(&t);}
+
+	/**
+	 * Remove a child associated with the given cargo.
+	 * @param cargo ID of the cargo for which the child should be removed.
+	 */
+	void Remove(CargoID cargo) {CargoDataEntry t(cargo); this->Remove(&t);}
+
+	/**
+	 * Retrieve a child for the given station. Return NULL if it doesn't exist.
+	 * @param station ID of the station the child we're looking for is associated with.
+	 * @return a child entry for the given station or NULL.
+	 */
+	CargoDataEntry *Retrieve(StationID station) const {CargoDataEntry t(station); return this->Retrieve(this->children->find(&t));}
+
+	/**
+	 * Retrieve a child for the given cargo. Return NULL if it doesn't exist.
+	 * @param cargo ID of the cargo the child we're looking for is associated with.
+	 * @return a child entry for the given cargo or NULL.
+	 */
+	CargoDataEntry *Retrieve(CargoID cargo) const {CargoDataEntry t(cargo);return this->Retrieve(this->children->find(&t));}
+
+	void Resort(CargoSortType type, SortOrder order);
+
+	/**
+	 * Get the station ID for this entry.
+	 */
+	StationID GetStation() const {return this->station;}
+
+	/**
+	 * Get the cargo ID for this entry.
+	 */
+	CargoID GetCargo() const {return this->cargo;}
+
+	/**
+	 * Get the cargo count for this entry.
+	 */
+	uint GetCount() const {return this->count;}
+
+	/**
+	 * Get the parent entry for this entry.
+	 */
+	CargoDataEntry *GetParent() const {return this->parent;}
+
+	/**
+	 * Get the number of children for this entry.
+	 */
+	uint GetNumChildren() const {return this->num_children;}
+
+	/**
+	 * Get an iterator pointing to the begin of the set of children.
+	 */
+	CargoDataSet::iterator Begin() const {return this->children->begin();}
+
+	/**
+	 * Get an iterator pointing to the end of the set of children.
+	 */
+	CargoDataSet::iterator End() const {return this->children->end();}
+
+	void Clear();
+private:
+
+	CargoDataEntry(StationID st, uint c, CargoDataEntry *p);
+	CargoDataEntry(CargoID car, uint c, CargoDataEntry *p);
+	CargoDataEntry(StationID st);
+	CargoDataEntry(CargoID car);
+
+	CargoDataEntry *Retrieve(CargoDataSet::iterator i) const;
+
+	template<class ID>
+	CargoDataEntry *InsertOrRetrieve(ID s);
+
+	void Remove(CargoDataEntry *comp);
+	void IncrementSize();
+
+	CargoDataEntry *parent;   ///< the parent of this entry
+	const union {
+		StationID station;    ///< ID of the station this entry is associated with
+		CargoID cargo;        ///< ID of the cargo this entry is associated with
+	};
+	uint num_children;        ///< the number of subentries belonging to this entry
+	uint count;               ///< sum of counts of all children or amount of cargo for this entry
+	CargoDataSet *children;   ///< the children of this entry
+};
+
 #endif /* STATION_GUI_H */
Index: src/station_cmd.cpp
===================================================================
--- src/station_cmd.cpp	(revision 24093)
+++ src/station_cmd.cpp	(working copy)
@@ -45,6 +45,7 @@
 #include "debug.h"
 #include "core/random_func.hpp"
 #include "company_base.h"
+#include "moving_average.h"
 #include "table/airporttile_ids.h"
 #include "newgrf_airporttiles.h"
 #include "order_backup.h"
@@ -3159,6 +3160,19 @@
 			int rating = 0;
 			uint waiting = ge->cargo.Count();
 
+			/* num_dests is at least 1 if there is any cargo as
+			 * INVALID_STATION is also a destination.
+			 */
+			uint num_dests = (uint)ge->cargo.Packets()->MapSize();
+
+			/* Average amount of cargo per next hop, but prefer solitary stations
+			 * with only one or two next hops. They are allowed to have more
+			 * cargo waiting per next hop.
+			 * With manual cargo distribution waiting_avg = waiting / 2 as then
+			 * INVALID_STATION is the only destination.
+			 */
+			uint waiting_avg = waiting / (num_dests + 1);
+
 			if (HasBit(cs->callback_mask, CBM_CARGO_STATION_RATING_CALC)) {
 				/* Perform custom station rating. If it succeeds the speed, days in transit and
 				 * waiting cargo ratings must not be executed. */
@@ -3167,7 +3181,7 @@
 				uint last_speed = ge->last_speed;
 				if (last_speed == 0) last_speed = 0xFF;
 
-				uint32 var18 = min(ge->days_since_pickup, 0xFF) | (min(waiting, 0xFFFF) << 8) | (min(last_speed, 0xFF) << 24);
+				uint32 var18 = min(ge->days_since_pickup, 0xFF) | (min(ge->max_waiting_cargo, 0xFFFF) << 8) | (min(last_speed, 0xFF) << 24);
 				/* Convert to the 'old' vehicle types */
 				uint32 var10 = (st->last_vehicle_type == VEH_INVALID) ? 0x0 : (st->last_vehicle_type + 0x10);
 				uint16 callback = GetCargoCallback(CBID_CARGO_STATION_RATING_CALC, var10, var18, cs);
@@ -3192,11 +3206,11 @@
 				(rating += 45, days > 3) ||
 				(rating += 35, true);
 
-				(rating -= 90, waiting > 1500) ||
-				(rating += 55, waiting > 1000) ||
-				(rating += 35, waiting > 600) ||
-				(rating += 10, waiting > 300) ||
-				(rating += 20, waiting > 100) ||
+				(rating -= 90, ge->max_waiting_cargo > 1500) ||
+				(rating += 55, ge->max_waiting_cargo > 1000) ||
+				(rating += 35, ge->max_waiting_cargo > 600) ||
+				(rating += 10, ge->max_waiting_cargo > 300) ||
+				(rating += 20, ge->max_waiting_cargo > 100) ||
 				(rating += 10, true);
 			}
 
@@ -3214,12 +3228,12 @@
 				/* only modify rating in steps of -2, -1, 0, 1 or 2 */
 				ge->rating = rating = or_ + Clamp(Clamp(rating, 0, 255) - or_, -2, 2);
 
-				/* if rating is <= 64 and more than 200 items waiting,
+				/* if rating is <= 64 and more than 100 items waiting on average per destination,
 				 * remove some random amount of goods from the station */
-				if (rating <= 64 && waiting >= 200) {
+				if (rating <= 64 && waiting_avg >= 100) {
 					int dec = Random() & 0x1F;
-					if (waiting < 400) dec &= 7;
-					waiting -= dec + 1;
+					if (waiting_avg < 200) dec &= 7;
+					waiting -= (dec + 1) * num_dests;
 					waiting_changed = true;
 				}
 
@@ -3228,7 +3242,7 @@
 					uint32 r = Random();
 					if (rating <= (int)GB(r, 0, 7)) {
 						/* Need to have int, otherwise it will just overflow etc. */
-						waiting = max((int)waiting - (int)GB(r, 8, 2) - 1, 0);
+						waiting = max((int)waiting - (int)((GB(r, 8, 2) - 1) * num_dests), 0);
 						waiting_changed = true;
 					}
 				}
@@ -3248,7 +3262,28 @@
 					waiting_changed = true;
 				}
 
-				if (waiting_changed) ge->cargo.Truncate(waiting);
+				if (waiting_changed) {
+					/* feed back the exact own waiting cargo at this station for the
+					 * next rating calculation.
+					 */
+					ge->max_waiting_cargo = 0;
+
+					/* If truncating also punish the source stations' ratings to
+					 * decrease the flow of incoming cargo. */
+
+					StationCargoAmountMap waiting_per_source;
+					ge->cargo.CountAndTruncate(waiting, waiting_per_source);
+					for (StationCargoAmountMap::iterator i(waiting_per_source.begin()); i != waiting_per_source.end(); ++i) {
+						Station *source_station = Station::GetIfValid(i->first);
+						if (source_station == NULL) continue;
+
+						GoodsEntry &source_ge = source_station->goods[cs->Index()];
+						source_ge.max_waiting_cargo = max(source_ge.max_waiting_cargo, i->second);
+					}
+				} else {
+					/* if the average number per next hop is low, be more forgiving. */
+					ge->max_waiting_cargo = waiting_avg;
+				}
 			}
 		}
 	}
@@ -3261,6 +3296,111 @@
 	}
 }
 
+/**
+ * Delete all flows at a station for specific cargo and destination.
+ * @param at Station to delete flows from.
+ * @param c_id Cargo for which flows shall be deleted.
+ * @param to Remote station of flows to be deleted.
+ */
+void DeleteStaleFlows(StationID at, CargoID c_id, StationID to)
+{
+	FlowStatMap &flows = Station::Get(at)->goods[c_id].flows;
+	for (FlowStatMap::iterator f_it = flows.begin(); f_it != flows.end();) {
+		FlowStat &s_flows = f_it->second;
+		s_flows.EraseShare(to);
+		if (s_flows.GetShares()->empty()) {
+			flows.erase(f_it++);
+		} else {
+			++f_it;
+		}
+	}
+}
+
+/**
+ * Get the length of a moving average for a link between two stations.
+ * @param from Source station.
+ * @param to Destination station.
+ * @return Moving average length.
+ */
+uint GetMovingAverageLength(const Station *from, const Station *to)
+{
+	return LinkStat::MIN_AVERAGE_LENGTH + (DistanceManhattan(from->xy, to->xy) >> 2);
+}
+
+/**
+ * Run the moving average decrease function for all link stats.
+ */
+void Station::RunAverages()
+{
+	for (int goods_index = 0; goods_index < NUM_CARGO; ++goods_index) {
+		LinkStatMap &links = this->goods[goods_index].link_stats;
+		for (LinkStatMap::iterator i = links.begin(); i != links.end();) {
+			StationID id = i->first;
+			if (Station::IsValidID(id)) {
+				i->second.Decrease();
+				if (i->second.IsValid()) {
+					++i;
+				} else {
+					DeleteStaleFlows(this->index, goods_index, id);
+					this->goods[goods_index].cargo.RerouteStalePackets(id);
+					links.erase(i++);
+				}
+			} else {
+				this->goods[goods_index].cargo.RerouteStalePackets(id);
+				links.erase(i++);
+			}
+		}
+
+		if (_settings_game.linkgraph.GetDistributionType(goods_index) == DT_MANUAL) {
+			this->goods[goods_index].flows.clear();
+		}
+	}
+}
+
+/**
+ * Increase capacity for a link stat given by station cargo and next hop.
+ * @param st Station to get the link stats from.
+ * @param cargo Cargo to increase stat for.
+ * @param next_station_id Station the consist will be travelling to next.
+ * @param capacity Capacity to add to link stat.
+ * @param usage Usage to add to link stat. If UINT_MAX refresh the link instead of increasing.
+ */
+void IncreaseStats(Station *st, CargoID cargo, StationID next_station_id, uint capacity, uint usage)
+{
+	LinkStatMap &stats = st->goods[cargo].link_stats;
+	LinkStatMap::iterator i = stats.find(next_station_id);
+	if (i == stats.end()) {
+		assert(st->index != next_station_id);
+		stats.insert(std::make_pair(next_station_id, LinkStat(
+				GetMovingAverageLength(st,
+				Station::Get(next_station_id)), capacity,
+				usage == UINT_MAX ? 0 : usage)));
+	} else {
+		if (usage == UINT_MAX) {
+			i->second.Refresh(capacity);
+		} else {
+			assert(capacity >= usage);
+			i->second.Increase(capacity, usage);
+		}
+		assert(i->second.IsValid());
+	}
+}
+
+/**
+ * Increase capacity for all link stats associated with vehicles in the given consist.
+ * @param st Station to get the link stats from.
+ * @param front First vehicle in the consist.
+ * @param next_station_id Station the consist will be travelling to next.
+ */
+void IncreaseStats(Station *st, const Vehicle *front, StationID next_station_id)
+{
+	for (const Vehicle *v = front; v != NULL; v = v->Next()) {
+		if (v->refit_cap > 0) {
+			IncreaseStats(st, v->cargo_type, next_station_id, v->refit_cap, v->cargo.Count());
+		}
+	}
+}
+
 /* called for every station each tick */
 static void StationHandleSmallTick(BaseStation *st)
 {
@@ -3277,6 +3417,8 @@
 {
 	if (_game_mode == GM_EDITOR) return;
 
+	RunAverages<Station>();
+
 	BaseStation *st;
 	FOR_ALL_BASE_STATIONS(st) {
 		StationHandleSmallTick(st);
@@ -3303,6 +3445,8 @@
 			GoodsEntry *ge = &st->goods[i];
 			SB(ge->acceptance_pickup, GoodsEntry::GES_LAST_MONTH, 1, GB(ge->acceptance_pickup, GoodsEntry::GES_CURRENT_MONTH, 1));
 			ClrBit(ge->acceptance_pickup, GoodsEntry::GES_CURRENT_MONTH);
+			ge->supply = ge->supply_new;
+			ge->supply_new = 0;
 		}
 	}
 }
@@ -3340,8 +3484,11 @@
 	/* No new "real" cargo item yet. */
 	if (amount == 0) return 0;
 
-	ge.cargo.Append(new CargoPacket(st->index, st->xy, amount, source_type, source_id));
+	StationID next = ge.GetVia(st->index);
 
+	ge.cargo.Append(next, new CargoPacket(st->index, st->xy, amount, source_type, source_id));
+	ge.supply_new += amount;
+
 	if (!HasBit(ge.acceptance_pickup, GoodsEntry::GES_PICKUP)) {
 		InvalidateWindowData(WC_STATION_LIST, st->index);
 		SetBit(ge.acceptance_pickup, GoodsEntry::GES_PICKUP);
@@ -3777,7 +3924,87 @@
 	return DoCommand(tile, 0, 0, flags, CMD_LANDSCAPE_CLEAR);
 }
 
+/**
+ * Get flow for a station.
+ * @param st Station to get flow for.
+ * @return Flow for st.
+ */
+uint FlowStat::GetShare(StationID st) const
+{
+	uint32 prev = 0;
+	for (SharesMap::const_iterator it = this->shares.begin(); it != this->shares.end(); ++it) {
+		if (it->second == st) {
+			return it->first - prev;
+		} else {
+			prev = it->first;
+		}
+	}
+	return 0;
+}
 
+/**
+ * Get a station a package can be routed to, but exclude the given one.
+ * @param excluded StationID not to be selected.
+ * @return A station ID from the shares map.
+ */
+StationID FlowStat::GetVia(StationID excluded) const
+{
+	assert(!this->shares.empty());
+	uint max = (--this->shares.end())->first - 1;
+	SharesMap::const_iterator it = this->shares.upper_bound(RandomRange(max));
+	assert(it != this->shares.end());
+	if (it->second != excluded) {
+		return it->second;
+	} else {
+		uint end = it->first;
+		if (end - 1 == max) return INVALID_STATION; // only one station in the map
+		uint begin = (it == this->shares.begin() ? 0 : (--it)->first);
+		uint rand = RandomRange(max - (end - begin));
+		if (rand < begin) {
+			return this->shares.upper_bound(rand)->second;
+		} else {
+			return this->shares.upper_bound(rand + (end - begin))->second;
+		}
+	}
+}
+
+/**
+ * Erase shares for specified station.
+ * @param st Next Hop to be removed.
+ */
+void FlowStat::EraseShare(StationID st)
+{
+	uint32 removed_shares = 0;
+	uint32 last_share = 0;
+	SharesMap new_shares;
+	for (SharesMap::iterator it(this->shares.begin()); it != this->shares.end(); ++it) {
+		if (it->second == st) {
+			removed_shares += it->first - last_share;
+		} else {
+			new_shares[it->first - removed_shares] = it->second;
+		}
+		last_share = it->first;
+	}
+	this->shares.swap(new_shares);
+	for (SharesMap::iterator it(this->shares.begin()); it != this->shares.end(); ++it) {
+		assert(it->second != st);
+	}
+}
+
+/**
+ * Get the sum of flows via a specific station from this GoodsEntry.
+ * @param via Remote station to look for.
+ * @return a FlowStat with all flows for 'via' added up.
+ */
+uint GoodsEntry::GetSumFlowVia(StationID via) const
+{
+	uint ret = 0;
+	for (FlowStatMap::const_iterator i = this->flows.begin(); i != this->flows.end(); ++i) {
+		ret += i->second.GetShare(via);
+	}
+	return ret;
+}
+
 extern const TileTypeProcs _tile_type_station_procs = {
 	DrawTile_Station,           // draw_tile_proc
 	GetSlopePixelZ_Station,     // get_slope_z_proc
Index: src/table/settings.ini
===================================================================
--- src/table/settings.ini	(revision 24093)
+++ src/table/settings.ini	(working copy)
@@ -513,6 +513,115 @@
 def      = true
 str      = STR_CONFIG_SETTING_ALLOW_TOWN_LEVEL_CROSSINGS
 
+; link graph
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.recalc_interval
+type     = SLE_UINT16
+from     = SL_COMPONENTS
+def      = 16
+min      = 1
+max      = 4096
+interval = 1
+str      = STR_CONFIG_SETTING_LINKGRAPH_INTERVAL
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_pax
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_SYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_PAX
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_mail
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_SYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_MAIL
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_armoured
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_SYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_ARMOURED
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.distribution_default
+type     = SLE_UINT8
+from     = SL_COMPONENTS
+guiflags = SGF_MULTISTRING
+def      = DT_ASYMMETRIC
+min      = DT_BEGIN
+max      = DT_NUM-1
+interval = 1
+str      = STR_CONFIG_SETTING_DISTRIBUTION_DEFAULT
+strval   = STR_CONFIG_SETTING_DISTRIBUTION_SYMMETRIC
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.accuracy
+type     = SLE_UINT8
+from     = SL_DEMANDS
+def      = 16
+min      = 2
+max      = 64
+interval = 1
+str      = STR_CONFIG_SETTING_LINKGRAPH_ACCURACY
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.demand_distance
+type     = SLE_UINT8
+from     = SL_DEMANDS
+def      = 100
+min      = 0
+max      = 255
+interval = 5
+str      = STR_CONFIG_SETTING_DEMAND_DISTANCE
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.demand_size
+type     = SLE_UINT8
+from     = SL_DEMANDS
+def      = 100
+min      = 0
+max      = 100
+interval = 5
+str      = STR_CONFIG_SETTING_DEMAND_SIZE
+
+[SDT_VAR]
+base     = GameSettings
+var      = linkgraph.short_path_saturation
+type     = SLE_UINT8
+from     = SL_MCF
+def      = 80
+min      = 0
+max      = 250
+interval = 5
+str      = STR_CONFIG_SETTING_SHORT_PATH_SATURATION
+
 ; Vehicles
 
 [SDT_VAR]
@@ -2418,6 +2527,33 @@
 proc     = RedrawScreen
 
 [SDTC_VAR]
+var      = gui.station_gui_group_order
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = 0
+min      = 0
+max      = 5
+interval = 1
+
+[SDTC_VAR]
+var      = gui.station_gui_sort_by
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = 0
+min      = 0
+max      = 3
+interval = 1
+
+[SDTC_VAR]
+var      = gui.station_gui_sort_order
+type     = SLE_UINT8
+flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
+def      = 0
+min      = 0
+max      = 1
+interval = 1
+
+[SDTC_VAR]
 var      = gui.missing_strings_threshold
 type     = SLE_UINT8
 flags    = SLF_NOT_IN_SAVE | SLF_NO_NETWORK_SYNC
Index: src/vehiclelist.cpp
===================================================================
--- src/vehiclelist.cpp	(revision 24093)
+++ src/vehiclelist.cpp	(working copy)
@@ -141,7 +141,7 @@
 		case VL_GROUP_LIST:
 			if (vli.index != ALL_GROUP) {
 				FOR_ALL_VEHICLES(v) {
-					if (v->type == vli.vtype && v->IsPrimaryVehicle() &&
+					if (!HasBit(v->subtype, GVSF_VIRTUAL) && v->type == vli.vtype && v->IsPrimaryVehicle() &&	//MYGUI
 							v->owner == vli.company && v->group_id == vli.index) {
 						*list->Append() = v;
 					}
@@ -152,7 +152,7 @@
 
 		case VL_STANDARD:
 			FOR_ALL_VEHICLES(v) {
-				if (v->type == vli.vtype && v->owner == vli.company && v->IsPrimaryVehicle()) {
+				if (!HasBit(v->subtype, GVSF_VIRTUAL) && v->type == vli.vtype && v->owner == vli.company && v->IsPrimaryVehicle()) { //MYGUI
 					*list->Append() = v;
 				}
 			}
Index: src/smallmap_gui.h
===================================================================
--- src/smallmap_gui.h	(revision 24093)
+++ src/smallmap_gui.h	(working copy)
@@ -12,9 +12,164 @@
 #ifndef SMALLMAP_GUI_H
 #define SMALLMAP_GUI_H
 
+#include "industry_type.h"
+#include "window_gui.h"
+#include "strings_func.h"
+#include "blitter/factory.hpp"
+#include "linkgraph_gui.h"
+#include "widgets/smallmap_widget.h"
+
+/* set up the cargos to be displayed in the smallmap's route legend */
+void BuildLinkStatsLegend();
+
 void BuildIndustriesLegend();
 void ShowSmallMap();
 void BuildLandLegend();
 void BuildOwnerLegend();
 
+/** Structure for holding relevant data for legends in small map */
+struct LegendAndColour {
+	uint8 colour;              ///< Colour of the item on the map.
+	StringID legend;           ///< String corresponding to the coloured item.
+	IndustryType type;         ///< Type of industry. Only valid for industry entries.
+	uint8 height;              ///< Height in tiles. Only valid for height legend entries.
+	CompanyID company;         ///< Company to display. Only valid for company entries of the owner legend.
+	bool show_on_map;          ///< For filtering industries, if \c true, industry is shown on the map in colour.
+	bool end;                  ///< This is the end of the list.
+	bool col_break;            ///< Perform a column break and go further at the next column.
+};
+
+/** Class managing the smallmap window. */
+class SmallMapWindow : public Window {
+protected:
+	/** Types of legends in the #WID_SM_LEGEND widget. */
+	enum SmallMapType {
+		SMT_CONTOUR,
+		SMT_VEHICLES,
+		SMT_INDUSTRY,
+		SMT_LINKSTATS,
+		SMT_ROUTES,
+		SMT_VEGETATION,
+		SMT_OWNER,
+	};
+
+	/** Available kinds of zoomlevel changes. */
+	enum ZoomLevelChange {
+		ZLC_INITIALIZE, ///< Initialize zoom level.
+		ZLC_ZOOM_OUT,   ///< Zoom out.
+		ZLC_ZOOM_IN,    ///< Zoom in.
+	};
+
+	static SmallMapType map_type; ///< Currently displayed legends.
+	static bool show_towns;       ///< Display town names in the smallmap.
+
+	static const uint LEGEND_BLOB_WIDTH = 8;              ///< Width of the coloured blob in front of a line text in the #WID_SM_LEGEND widget.
+	static const uint INDUSTRY_MIN_NUMBER_OF_COLUMNS = 2; ///< Minimal number of columns in the #WID_SM_LEGEND widget for the #SMT_INDUSTRY legend.
+	static const uint8 FORCE_REFRESH_PERIOD = 0x1F; ///< map is redrawn after that many ticks
+
+	uint min_number_of_fixed_rows; ///< Minimal number of rows in the legends for the fixed layouts only (all except #SMT_INDUSTRY).
+	uint column_width;             ///< Width of a column in the #WID_SM_LEGEND widget.
+
+	int32 scroll_x;  ///< Horizontal world coordinate of the base tile left of the top-left corner of the smallmap display.
+	int32 scroll_y;  ///< Vertical world coordinate of the base tile left of the top-left corner of the smallmap display.
+	int32 subscroll; ///< Number of pixels (0..3) between the right end of the base tile and the pixel at the top-left corner of the smallmap display.
+	int zoom;        ///< Zoom level. Bigger number means more zoom-out (further away).
+
+	uint8 refresh;   ///< Refresh counter, zeroed every FORCE_REFRESH_PERIOD ticks.
+	LinkGraphOverlay *overlay;
+
+	Point SmallmapRemapCoords(int x, int y) const;
+
+	/**
+	 * Draws vertical part of map indicator
+	 * @param x X coord of left/right border of main viewport
+	 * @param y Y coord of top border of main viewport
+	 * @param y2 Y coord of bottom border of main viewport
+	 */
+	static inline void DrawVertMapIndicator(int x, int y, int y2)
+	{
+		GfxFillRect(x, y,      x, y + 3, PC_VERY_LIGHT_YELLOW);
+		GfxFillRect(x, y2 - 3, x, y2,    PC_VERY_LIGHT_YELLOW);
+	}
+
+	/**
+	 * Draws horizontal part of map indicator
+	 * @param x X coord of left border of main viewport
+	 * @param x2 X coord of right border of main viewport
+	 * @param y Y coord of top/bottom border of main viewport
+	 */
+	static inline void DrawHorizMapIndicator(int x, int x2, int y)
+	{
+		GfxFillRect(x,      y, x + 3, y, PC_VERY_LIGHT_YELLOW);
+		GfxFillRect(x2 - 3, y, x2,    y, PC_VERY_LIGHT_YELLOW);
+	}
+
+	void DrawMapIndicators() const;
+	void DrawSmallMapColumn(void *dst, uint xc, uint yc, int pitch, int reps, int start_pos, int end_pos, Blitter *blitter) const;
+	void DrawVehicles(const DrawPixelInfo *dpi, Blitter *blitter) const;
+	void DrawTowns(const DrawPixelInfo *dpi) const;
+	void DrawSmallMap(DrawPixelInfo *dpi) const;
+
+	Point RemapTile(int tile_x, int tile_y) const;
+	Point PixelToTile(int px, int py, int *sub, bool add_sub = true) const;
+	Point ComputeScroll(int tx, int ty, int x, int y, int *sub);
+	void SetZoomLevel(ZoomLevelChange change, const Point *zoom_pt);
+	void SetOverlayCargoMask();
+	void SetupWidgetData();
+	uint32 GetTileColours(const TileArea &ta) const;
+
+public:
+	uint min_number_of_columns;    ///< Minimal number of columns in legends.
+
+	SmallMapWindow(const WindowDesc *desc, int window_number);
+	virtual ~SmallMapWindow() {delete this->overlay;}
+
+	/**
+	 * Compute minimal required width of the legends.
+	 * @return Minimally needed width for displaying the smallmap legends in pixels.
+	 */
+	inline uint GetMinLegendWidth() const
+	{
+		return WD_FRAMERECT_LEFT + this->min_number_of_columns * this->column_width;
+	}
+
+	/**
+	 * Return number of columns that can be displayed in \a width pixels.
+	 * @return Number of columns to display.
+	 */
+	inline uint GetNumberColumnsLegend(uint width) const
+	{
+		return width / this->column_width;
+	}
+
+	/**
+	 * Compute height given a number of columns.
+	 * @param num_columns Number of columns.
+	 * @return Needed height for displaying the smallmap legends in pixels.
+	 */
+	inline uint GetLegendHeight(uint num_columns) const
+	{
+		return WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM +
+				this->GetNumberRowsLegend(num_columns) * FONT_HEIGHT_SMALL;
+	}
+
+	uint GetNumberRowsLegend(uint columns) const;
+	Point GetStationMiddle(const Station *st) const;
+	void SwitchMapType(SmallMapType map_type);
+	void SetNewScroll(int sx, int sy, int sub);
+	void SelectLegendItem(int click_pos, LegendAndColour *legend, int end_legend_item, int begin_legend_item = 0);
+	void SmallMapCenterOnCurrentPos();
+
+	virtual void SetStringParameters(int widget) const;
+	virtual void OnInit();
+	virtual void OnPaint();
+	virtual void DrawWidget(const Rect &r, int widget) const;
+	virtual void OnClick(Point pt, int widget, int click_count);
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true);
+	virtual bool OnRightClick(Point pt, int widget);
+	virtual void OnMouseWheel(int wheel);
+	virtual void OnTick();
+	virtual void OnScroll(Point delta);
+};
+
 #endif /* SMALLMAP_GUI_H */
Index: src/ship_cmd.cpp
===================================================================
--- src/ship_cmd.cpp	(revision 24093)
+++ src/ship_cmd.cpp	(working copy)
@@ -657,6 +657,7 @@
 		v->cargo_cap = svi->capacity;
 
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 		v->engine_type = e->index;
 
 		v->reliability = e->reliability;
Index: src/order_cmd.cpp
===================================================================
--- src/order_cmd.cpp	(revision 24093)
+++ src/order_cmd.cpp	(working copy)
@@ -20,6 +20,7 @@
 #include "vehicle_func.h"
 #include "depot_base.h"
 #include "core/pool_func.hpp"
+#include "core/random_func.hpp"
 #include "aircraft.h"
 #include "roadveh.h"
 #include "station_base.h"
@@ -355,6 +356,135 @@
 }
 
 /**
+ * Choose between the two possible next orders so that the given consist can
+ * load most cargo.
+ * @param v Head of the consist.
+ * @param o1 First order to choose from.
+ * @param o2 Second order to choose from.
+ * @return Either o1 or o2, depending on the amounts of cargo waiting at the
+ *	vehicle's current station for each.
+ */
+const Order *OrderList::GetBestLoadableNext(const Vehicle *v, const Order *o2, const Order *o1) const
+{
+	SmallMap<CargoID, uint> capacities;
+	v->GetConsistFreeCapacities(capacities);
+	uint loadable1 = 0;
+	uint loadable2 = 0;
+	StationID st1 = o1->GetDestination();
+	StationID st2 = o2->GetDestination();
+	const Station *cur_station = Station::Get(v->last_station_visited);
+	for (SmallPair<CargoID, uint> *i = capacities.Begin(); i != capacities.End(); ++i) {
+		const StationCargoPacketMap *loadable_packets = cur_station->goods[i->first].cargo.Packets();
+		uint loadable_cargo = 0;
+		std::pair<StationCargoPacketMap::const_iterator, StationCargoPacketMap::const_iterator> p =
+			loadable_packets->equal_range(st1);
+		for (StationCargoPacketMap::const_iterator j = p.first; j != p.second; ++j) {
+			loadable_cargo = (*j)->Count();
+		}
+		loadable1 += min(i->second, loadable_cargo);
+
+		loadable_cargo = 0;
+		p = loadable_packets->equal_range(st2);
+		for (StationCargoPacketMap::const_iterator j = p.first; j != p.second; ++j) {
+			loadable_cargo = (*j)->Count();
+		}
+		loadable2 += min(i->second, loadable_cargo);
+	}
+	if (loadable1 == loadable2) return RandomRange(2) == 0 ? o1 : o2;
+	return loadable1 > loadable2 ? o1 : o2;
+}
+
+/**
+ * Get the next order which will make the given vehicle stop at a station
+ * or refit at a depot if its state doesn't change.
+ * @param v The vehicle in question.
+ * @param next The order to start looking at.
+ * @param hops The number of orders we have already looked at.
+ * @param is_loading If the vehicle is loading. This triggers a different
+ * behaviour on conditional orders based on load percentage.
+ * @return Either an order or NULL if the vehicle won't stop anymore.
+ * @see OrderList::GetBestLoadableNext
+ */
+const Order *OrderList::GetNextStoppingOrder(const Vehicle *v, const Order *next, uint hops, bool is_loading) const
+{
+	if (hops > this->GetNumOrders() || next == NULL) return NULL;
+
+	if (next->IsType(OT_CONDITIONAL)) {
+		if (is_loading && next->GetConditionVariable() == OCV_LOAD_PERCENTAGE) {
+			/* If the condition is based on load percentage we can't
+			 * tell what it will do. So we choose randomly.
+			 */
+			const Order *skip_to = this->GetNextStoppingOrder(v,
+					this->GetOrderAt(next->GetConditionSkipToOrder()),
+					hops + 1);
+			const Order *advance = this->GetNextStoppingOrder(v,
+					this->GetNext(next), hops + 1);
+			if (advance == NULL) {
+				return skip_to;
+			} else if (skip_to == NULL) {
+				return advance;
+			} else {
+				return this->GetBestLoadableNext(v, skip_to, advance);
+			}
+		} else {
+			/* Otherwise we're optimistic and expect that the
+			 * condition value won't change until it's evaluated.
+			 */
+			VehicleOrderID skip_to = ProcessConditionalOrder(next, v);
+			if (skip_to != INVALID_VEH_ORDER_ID) {
+				return this->GetNextStoppingOrder(v,
+						this->GetOrderAt(skip_to), hops + 1);
+			} else {
+				return this->GetNextStoppingOrder(v,
+						this->GetNext(next), hops + 1);
+			}
+		}
+	}
+
+	if (next->IsType(OT_GOTO_DEPOT)) {
+		if (next->GetDepotActionType() == ODATFB_HALT) return NULL;
+		if (next->IsRefit()) return next;
+	}
+
+	if (!next->CanLoadOrUnload()) {
+		return this->GetNextStoppingOrder(v, this->GetNext(next), hops + 1);
+	}
+
+	return next;
+}
+
+/**
+ * Recursively determine the next deterministic station to stop at.
+ * @param v The vehicle we're looking at.
+ * @return Next stoppping station or INVALID_STATION.
+ * @pre The vehicle is currently loading and v->last_station_visited is meaningful.
+ * @note This function may draw a random number. Don't use it from the GUI.
+ */
+StationID OrderList::GetNextStoppingStation(const Vehicle *v) const
+{
+
+	const Order *next = this->GetOrderAt(v->cur_implicit_order_index);
+	if (next == NULL) {
+		next = this->GetFirstOrder();
+		if (next == NULL) return INVALID_STATION;
+	} else {
+		next = this->GetNext(next);
+	}
+
+	uint hops = 0;
+	do {
+		next = this->GetNextStoppingOrder(v, next, ++hops, true);
+		/* Don't return a next stop if the vehicle has to unload everything. */
+		if (next == NULL || (next->GetDestination() == v->last_station_visited &&
+				(next->GetUnloadType() & (OUFB_TRANSFER | OUFB_UNLOAD)) == 0)) {
+			return INVALID_STATION;
+		}
+	} while (next->IsType(OT_GOTO_DEPOT) || next->GetDestination() == v->last_station_visited);
+
+	return next->GetDestination();
+}
+
+/**
  * Insert a new order into the order chain.
  * @param new_order is the order to insert into the chain.
  * @param index is the position where the order is supposed to be inserted.
@@ -916,6 +1046,7 @@
 	if (flags & DC_EXEC) {
 		DeleteVehicleOrders(dst);
 		InvalidateVehicleOrder(dst, -1);
+
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(dst->type), 0);
 	}
 	return CommandCost();
@@ -1049,11 +1180,11 @@
 	if (ret.Failed()) return ret;
 
 	if (flags & DC_EXEC) {
+		if (v->current_order.IsType(OT_LOADING)) v->LeaveStation();
+
 		v->cur_implicit_order_index = v->cur_real_order_index = sel_ord;
 		v->UpdateRealOrderIndex();
 
-		if (v->current_order.IsType(OT_LOADING)) v->LeaveStation();
-
 		InvalidateVehicleOrder(v, -2);
 	}
 
@@ -2126,3 +2257,23 @@
 			/* Finally do stop when there is no non-stop flag set for this type of station. */
 			!(this->GetNonStopType() & (is_dest_station ? ONSF_NO_STOP_AT_DESTINATION_STATION : ONSF_NO_STOP_AT_INTERMEDIATE_STATIONS));
 }
+
+bool Order::CanLoadOrUnload() const
+{
+	return (this->IsType(OT_GOTO_STATION) || this->IsType(OT_IMPLICIT)) &&
+			(this->GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION) == 0 &&
+			((this->GetLoadType() & OLFB_NO_LOAD) == 0 ||
+			(this->GetUnloadType() & OUFB_NO_UNLOAD) == 0);
+}
+
+/**
+ * A vehicle can leave the current station with cargo if:
+ * 1. it can load cargo here OR
+ * 2a. it could leave the last station with cargo AND
+ * 2b. it doesn't have to unload all cargo here.
+ */
+bool Order::CanLeaveWithCargo(bool has_cargo) const
+{
+	return (this->GetLoadType() & OLFB_NO_LOAD) == 0 || (has_cargo &&
+			(this->GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) == 0);
+}
Index: src/window_type.h
===================================================================
--- src/window_type.h	(revision 24093)
+++ src/window_type.h	(working copy)
@@ -668,6 +668,18 @@
 	 */
 	WC_SPRITE_ALIGNER,
 
+	/**
+	 * Linkgraph legend; Window numbers:
+	 *   - 0 = #LinkGraphWidgets
+	 */
+	WC_LINKGRAPH_LEGEND,
+
+	WC_TEMPLATEGUI_MAIN,
+	WC_TEMPLATEGUI_RPLALL,
+	WC_BUILD_VIRTUAL_TRAIN,
+	WC_CREATE_TEMPLATE,
+
+
 	WC_INVALID = 0xFFFF, ///< Invalid window.
 };
 
Index: src/autoreplace_func.h
===================================================================
--- src/autoreplace_func.h	(revision 24093)
+++ src/autoreplace_func.h	(working copy)
@@ -83,4 +83,7 @@
 
 bool CheckAutoreplaceValidity(EngineID from, EngineID to, CompanyID company);
 
+// MYGUI
+CommandCost CopyHeadSpecificThings(Vehicle*, Vehicle*, DoCommandFlag);
+
 #endif /* AUTOREPLACE_FUNC_H */
Index: src/company_cmd.cpp
===================================================================
--- src/company_cmd.cpp	(revision 24093)
+++ src/company_cmd.cpp	(working copy)
@@ -81,6 +81,7 @@
 	InvalidateWindowData(WC_GRAPH_LEGEND, 0, (int)index);
 	InvalidateWindowData(WC_PERFORMANCE_DETAIL, 0, (int)index);
 	InvalidateWindowData(WC_COMPANY_LEAGUE, 0, 0);
+	InvalidateWindowData(WC_LINKGRAPH_LEGEND, 0);
 	/* If the currently shown error message has this company in it, then close it. */
 	InvalidateWindowData(WC_ERRMSG, 0);
 }
@@ -557,6 +558,7 @@
 	SetWindowDirty(WC_GRAPH_LEGEND, 0);
 	SetWindowClassesDirty(WC_CLIENT_LIST_POPUP);
 	SetWindowDirty(WC_CLIENT_LIST, 0);
+	InvalidateWindowData(WC_LINKGRAPH_LEGEND, 0);
 	BuildOwnerLegend();
 	InvalidateWindowData(WC_SMALLMAP, 0, 1);
 
@@ -1050,6 +1052,7 @@
 		InvalidateWindowData(WC_DELIVERED_CARGO, 0);
 		InvalidateWindowData(WC_PERFORMANCE_HISTORY, 0);
 		InvalidateWindowData(WC_COMPANY_VALUE, 0);
+		InvalidateWindowData(WC_LINKGRAPH_LEGEND, 0);
 		/* The smallmap owner view also stores the company colours. */
 		BuildOwnerLegend();
 		InvalidateWindowData(WC_SMALLMAP, 0, 1);
Index: src/misc.cpp
===================================================================
--- src/misc.cpp	(revision 24093)
+++ src/misc.cpp	(working copy)
@@ -47,6 +47,7 @@
 void InitializeCheats();
 void InitializeNPF();
 void InitializeOldNames();
+void InitializeLinkGraphs();
 
 void InitializeGame(uint size_x, uint size_y, bool reset_date, bool reset_settings)
 {
@@ -103,6 +104,7 @@
 #endif /* ENABLE_NETWORK */
 	InitializeAnimatedTiles();
 
+	InitializeLinkGraphs();
 	InitializeEconomy();
 
 	ResetObjectToPlace();
Index: src/vehicle_cmd.cpp
===================================================================
--- src/vehicle_cmd.cpp	(revision 24093)
+++ src/vehicle_cmd.cpp	(working copy)
@@ -385,12 +385,14 @@
 		/* Store the result */
 		for (RefitResult *result = refit_result.Begin(); result != refit_result.End(); result++) {
 			Vehicle *u = result->v;
-			u->cargo.Truncate((u->cargo_type == new_cid) ? result->capacity : 0);
+			u->refit_cap = (u->cargo_type == new_cid) ? min(result->capacity, u->cargo_cap) : 0;
+			u->cargo.Truncate(u->refit_cap);
 			u->cargo_type = new_cid;
 			u->cargo_cap = result->capacity;
 			u->cargo_subtype = new_subtype;
 			if (u->type == VEH_AIRCRAFT) {
 				Vehicle *w = u->Next();
+				w->refit_cap = min(w->cargo_cap, result->mail_capacity);
 				w->cargo_cap = result->mail_capacity;
 				w->cargo.Truncate(result->mail_capacity);
 			}
@@ -411,6 +413,7 @@
  * @param p2 various bitstuffed elements
  * - p2 = (bit 0-4)   - New cargo type to refit to.
  * - p2 = (bit 6)     - Automatic refitting.
+ * - p2 = (bit 5)	  - Is a virtual train (used by template replacement to allow refitting without stopped-in-depot checks)
  * - p2 = (bit 7)     - Refit only this vehicle. Used only for cloning vehicles.
  * - p2 = (bit 8-15)  - New cargo subtype to refit to.
  * - p2 = (bit 16-23) - Number of vehicles to refit (not counting articulated parts). Zero means all vehicles.
@@ -433,12 +436,15 @@
 	if (ret.Failed()) return ret;
 
 	bool auto_refit = HasBit(p2, 6);
+	bool is_virtual_train = HasBit(p2, 5);
 
 	/* Don't allow shadows and such to be refitted. */
 	if (v != front && (v->type == VEH_SHIP || v->type == VEH_AIRCRAFT)) return CMD_ERROR;
 	/* Allow auto-refitting only during loading and normal refitting only in a depot. */
-	if ((!auto_refit || !front->current_order.IsType(OT_LOADING)) && !front->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAIN_MUST_BE_STOPPED_INSIDE_DEPOT + front->type);
-	if (front->vehstatus & VS_CRASHED) return_cmd_error(STR_ERROR_VEHICLE_IS_DESTROYED);
+	if ( ! is_virtual_train ) {
+		if ((!auto_refit || !front->current_order.IsType(OT_LOADING)) && !front->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAIN_MUST_BE_STOPPED_INSIDE_DEPOT + front->type);
+		if (front->vehstatus & VS_CRASHED) return_cmd_error(STR_ERROR_VEHICLE_IS_DESTROYED);
+	}
 
 	/* Check cargo */
 	CargoID new_cid = GB(p2, 0, 5);
@@ -478,7 +484,11 @@
 		}
 
 		InvalidateWindowData(WC_VEHICLE_DETAILS, front->index);
-		SetWindowDirty(WC_VEHICLE_DEPOT, front->tile);
+		/* virtual vehicles get their cargo changed by the TemplateCreateWindow, so set this dirty instead of a depot window */
+		//if ( HasBit(v->subtype, GVSF_VIRTUAL) ) SetWindowDirty(WC_CREATE_TEMPLATE, -1); // MYGUI
+		if ( HasBit(v->subtype, GVSF_VIRTUAL) ) SetWindowClassesDirty(WC_CREATE_TEMPLATE);
+		else SetWindowDirty(WC_VEHICLE_DEPOT, front->tile);
+
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 0);
 	} else {
 		/* Always invalidate the cache; querycost might have filled it. */
Index: src/aaa_template_gui_replaceall.h
===================================================================
--- src/aaa_template_gui_replaceall.h	(revision 0)
+++ src/aaa_template_gui_replaceall.h	(revision 0)
@@ -0,0 +1,27 @@
+#ifndef TMPL_RPLALL_GUI
+#define TMPL_RPLALL_GUI
+
+
+
+#include "stdafx.h"
+#include "window_gui.h"
+#include "window_func.h"
+
+#include "company_func.h"
+#include "engine_base.h"
+#include "engine_func.h"
+#include "engine_gui.h"
+#include "train.h"
+#include "strings_func.h"
+#include "vehicle_base.h"
+#include "vehicle_func.h"
+
+#include "aaa_template_vehicle.h"
+#include "aaa_template_vehicle_func.h"
+
+#include "core/math_func.hpp"
+#include "table/strings.h"
+
+void ShowTemplateReplaceAllGui();
+
+#endif
\ No newline at end of file
Index: src/train_cmd.cpp
===================================================================
--- src/train_cmd.cpp	(revision 24093)
+++ src/train_cmd.cpp	(working copy)
@@ -38,6 +38,8 @@
 #include "table/strings.h"
 #include "table/train_cmd.h"
 
+#include "engine_func.h" //MYGUI
+
 static Track ChooseTrainTrack(Train *v, TileIndex tile, DiagDirection enterdir, TrackBits tracks, bool force_res, bool *got_reservation, bool mark_stuck);
 static bool TrainCheckIfLineEnds(Train *v, bool reverse = true);
 bool TrainController(Train *v, Vehicle *nomove, bool reverse = true); // Also used in vehicle_sl.cpp.
@@ -239,7 +241,7 @@
 
 	if (this->IsFrontEngine()) {
 		this->UpdateAcceleration();
-		SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
+		if ( !HasBit(this->subtype, GVSF_VIRTUAL) ) SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
 		InvalidateWindowData(WC_VEHICLE_REFIT, this->index);
 	}
 }
@@ -439,6 +441,7 @@
 		offset->x = reference_width / 2;
 		offset->y = vehicle_pitch;
 	}
+	//printf("  refwid:%d  gdiw.cachedvehlen(%d):%d  ", reference_width, this->engine_type, this->gcache.cached_veh_length);
 	return this->gcache.cached_veh_length * reference_width / VEHICLE_LENGTH;
 }
 
@@ -685,6 +688,7 @@
 		v->cargo_type = e->GetDefaultCargoType();
 		v->cargo_cap = rvi->capacity;
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 
 		v->engine_type = e->index;
 		v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
@@ -1114,6 +1118,7 @@
  * @param p1 various bitstuffed elements
  * - p1 (bit  0 - 19) source vehicle index
  * - p1 (bit      20) move all vehicles following the source vehicle
+ * - p1 (bit	  21) this is a virtual vehicle (for creating TemplateVehicles) MYGUI
  * @param p2 what wagon to put the source wagon AFTER, XXX - INVALID_VEHICLE to make a new line
  * @param text unused
  * @return the cost of this operation or an error
@@ -1178,10 +1183,14 @@
 	if (!move_chain && dst != NULL && dst->IsRearDualheaded() && src == dst->other_multiheaded_part) return CommandCost();
 
 	/* Check if all vehicles in the source train are stopped inside a depot. */
-	if (!src_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
+	/* Do this check only if the vehicle to be moved is non-virtual */ //MYGUI
+	if ( !HasBit(p1, 21) )
+		if (!src_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
 
 	/* Check if all vehicles in the destination train are stopped inside a depot. */
-	if (dst_head != NULL && !dst_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
+	/* Do this check only if the destination vehicle is non-virtual */ //MYGUI
+	if ( !HasBit(p1, 21) )
+		if (dst_head != NULL && !dst_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
 
 	/* First make a backup of the order of the trains. That way we can do
 	 * whatever we want with the order and later on easily revert. */
@@ -1284,8 +1293,11 @@
 		}
 
 		/* We are undoubtedly changing something in the depot and train list. */
-		InvalidateWindowData(WC_VEHICLE_DEPOT, src->tile);
-		InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+		/* But only if the moved vehicle is not virtual */ // MYGUI
+		if ( !HasBit(src->subtype, GVSF_VIRTUAL) ) {
+			InvalidateWindowData(WC_VEHICLE_DEPOT, src->tile);
+			InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+		}
 	} else {
 		/* We don't want to execute what we're just tried. */
 		RestoreTrainBackup(original_src);
@@ -1372,8 +1384,11 @@
 		NormaliseTrainHead(new_head);
 
 		/* We are undoubtedly changing something in the depot and train list. */
-		InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
-		InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+		/* Unless its a virtual train */ //MYGUI
+		if ( !HasBit(v->subtype, GVSF_VIRTUAL) ) {
+			InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
+			InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+		}
 
 		/* Actually delete the sold 'goods' */
 		delete sell_head;
@@ -3696,6 +3711,17 @@
 	return true;
 }
 
+// MYGUI
+Money Train::CalculateCurrentOverallValue() const
+{
+	Money ovr_value = 0;
+	const Train *v = this;
+	do {
+		ovr_value += v->value;
+	} while ( (v=v->GetNextVehicle()) != NULL );
+	return ovr_value;
+}
+// ENDMYGUI
 
 static bool TrainLocoHandler(Train *v, bool mode)
 {
@@ -3994,3 +4020,176 @@
 
 	return TrackDirectionToTrackdir(FindFirstTrack(this->track), this->direction);
 }
+
+// MYGUI inserted as global functions (previously only member funcitons)
+/*SpriteID GetImage(Train *t)
+{
+	Direction direction = DIR_W;
+	uint8 spritenum = t->spritenum;
+	SpriteID sprite;
+
+	if (HasBit(t->flags, VRF_REVERSE_DIRECTION)) direction = ReverseDir(direction);
+
+	if (is_custom_sprite(spritenum)) {
+		sprite = GetCustomVehicleSprite(t, (Direction)(direction + 4 * IS_CUSTOM_SECONDHEAD_SPRITE(spritenum)));
+		if (sprite != 0) return sprite;
+
+		spritenum = Engine::Get(t->engine_type)->original_image_index;
+	}
+
+	sprite = GetDefaultTrainSprite(spritenum, direction);
+
+	if (t->cargo.Count() >= t->cargo_cap / 2U) sprite += _wagon_full_adder[spritenum];
+
+	return sprite;
+}*/
+int GetDisplayImageWidth(Train *t, Point *offset)
+{
+	int reference_width = TRAININFO_DEFAULT_VEHICLE_WIDTH;
+	int vehicle_pitch = 0;
+
+	const Engine *e = Engine::Get(t->engine_type);
+	if (e->grf_prop.grffile != NULL && is_custom_sprite(e->u.rail.image_index)) {
+		reference_width = e->grf_prop.grffile->traininfo_vehicle_width;
+		vehicle_pitch = e->grf_prop.grffile->traininfo_vehicle_pitch;
+	}
+
+	if (offset != NULL) {
+		offset->x = reference_width / 2;
+		offset->y = vehicle_pitch;
+	}
+	//printf("  refwid:%d  gdiw.cachedvehlen(%d):%d  ", reference_width, this->engine_type, this->gcache.cached_veh_length);
+	return t->gcache.cached_veh_length * reference_width / VEHICLE_LENGTH;
+}
+
+Train* CmdBuildVirtualRailWagon(const Engine *e)
+{
+	const RailVehicleInfo *rvi = &e->u.rail;
+
+	Train *v = new Train();
+
+	v->x_pos = 0;
+	v->y_pos = 0;
+
+	v->spritenum = rvi->image_index;
+
+	v->engine_type = e->index;
+	v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
+
+	v->direction = DIR_W;
+	v->tile = 0;//INVALID_TILE;
+
+	v->owner = _current_company;
+	v->track = TRACK_BIT_DEPOT;
+	v->vehstatus = VS_HIDDEN | VS_DEFPAL;
+
+	v->SetWagon();
+	v->SetFreeWagon();
+
+	v->cargo_type = e->GetDefaultCargoType();
+	v->cargo_cap = rvi->capacity;
+
+	v->railtype = rvi->railtype;
+
+	v->build_year = _cur_year;
+	v->cur_image = SPR_IMG_QUERY;
+	v->random_bits = VehicleRandomBits();
+
+	v->group_id = DEFAULT_GROUP;
+
+	AddArticulatedParts(v);
+
+	_new_vehicle_id = v->index;
+
+	// from revision r22xxx
+	// VehicleMove(v, false);
+	// new
+	VehicleUpdateViewport(v, false);
+
+	v->First()->ConsistChanged(false);
+	//UpdateTrainGroupID(v->First());
+
+	CheckConsistencyOfArticulatedVehicle(v);
+
+	/* The GVSF_VIRTUAL flag is used to prevent depot-tile sanity checks */
+	SetBit(v->subtype, GVSF_VIRTUAL);
+
+// 	GroupStatistics::CountVehicle( v, -1 );
+
+	return v;
+}
+
+/**
+ * Build a railroad vehicle.
+ * @param tile     tile of the depot where rail-vehicle is built.
+ * @param flags    type of operation.
+ * @param e        the engine to build.
+ * @param data     bit 0 prevents any free cars from being added to the train.
+ * @param ret[out] the vehicle that has been built.
+ * @return the cost of this operation or an error.
+ */
+Train* CmdBuildVirtualRailVehicle(EngineID eid)
+{
+	if ( !IsEngineBuildable(eid, VEH_TRAIN, _current_company) ) return 0;
+	const Engine* e = Engine::Get(eid);
+	const RailVehicleInfo *rvi = &e->u.rail;
+
+	int num_vehicles = (e->u.rail.railveh_type == RAILVEH_MULTIHEAD ? 2 : 1) + CountArticulatedParts(eid, false);
+	if ( !Train::CanAllocateItem(num_vehicles) ) return 0;
+	if (rvi->railveh_type == RAILVEH_WAGON) return CmdBuildVirtualRailWagon(e);
+
+	Train *v = new Train();
+
+	v->x_pos = 0;
+	v->y_pos = 0;
+
+	v->direction = DIR_W;
+	v->tile = 0;//INVALID_TILE;
+	v->owner = _current_company;
+	v->track = TRACK_BIT_DEPOT;
+	v->vehstatus = VS_HIDDEN | VS_STOPPED | VS_DEFPAL;
+	v->spritenum = rvi->image_index;
+	v->cargo_type = e->GetDefaultCargoType();
+	v->cargo_cap = rvi->capacity;
+	v->last_station_visited = INVALID_STATION;
+
+	v->engine_type = e->index;
+	v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
+
+	v->reliability = e->reliability;
+	v->reliability_spd_dec = e->reliability_spd_dec;
+	v->max_age = e->GetLifeLengthInDays();
+
+	v->railtype = rvi->railtype;
+	_new_vehicle_id = v->index;
+
+	v->cur_image = SPR_IMG_QUERY;
+	v->random_bits = VehicleRandomBits();
+
+	v->group_id = DEFAULT_GROUP;
+
+	v->SetFrontEngine();
+	v->SetEngine();
+
+	// from revision r22xxx
+//	VehicleMove(v, false);
+	//	new
+	VehicleUpdateViewport(v, false);
+
+	if (rvi->railveh_type == RAILVEH_MULTIHEAD) {
+		AddRearEngineToMultiheadedTrain(v);
+	} else {
+		AddArticulatedParts(v);
+	}
+
+	v->ConsistChanged(false);
+	//UpdateTrainGroupID(v);
+
+	CheckConsistencyOfArticulatedVehicle(v);
+
+	SetBit(v->subtype, GVSF_VIRTUAL);
+
+// 	GroupStatistics::CountVehicle( v, -1 );
+
+	return v;
+}
Index: src/core/math_func.cpp
===================================================================
--- src/core/math_func.cpp	(revision 24093)
+++ src/core/math_func.cpp	(working copy)
@@ -48,6 +48,27 @@
 }
 
 /**
+ * Deterministic approximate division.
+ * Cancels out division errors stemming from the integer nature of the division over multiple runs.
+ * @param a Dividend.
+ * @param b Divisor.
+ * @return a/b or (a/b)+1.
+ */
+int DivideApprox(int a, int b)
+{
+	int random_like = ((a + b) * (a - b)) % b;
+
+	int remainder = a % b;
+
+	int ret = a / b;
+	if (abs(random_like) < abs(remainder)) {
+		ret += ((a < 0) ^ (b < 0)) ? -1 : 1;
+	}
+
+	return ret;
+}
+
+/**
  * Compute the integer square root.
  * @param num Radicand.
  * @return Rounded integer square root.
Index: src/core/math_func.hpp
===================================================================
--- src/core/math_func.hpp	(revision 24093)
+++ src/core/math_func.hpp	(working copy)
@@ -317,6 +317,7 @@
 
 int LeastCommonMultiple(int a, int b);
 int GreatestCommonDivisor(int a, int b);
+int DivideApprox(int a, int b);
 
 /**
  * Computes ceil(a / b) for non-negative a and b.
Index: src/aaa_template_gui_create_virtualtrain.cpp
===================================================================
--- src/aaa_template_gui_create_virtualtrain.cpp	(revision 0)
+++ src/aaa_template_gui_create_virtualtrain.cpp	(revision 0)
@@ -0,0 +1,839 @@
+/* $Id: build_vehicle_gui.cpp 23792 2012-01-12 19:23:00Z yexo $ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file build_vehicle_gui.cpp GUI for building vehicles. */
+
+#include "stdafx.h"
+#include "engine_base.h"
+#include "engine_func.h"
+#include "station_base.h"
+#include "articulated_vehicles.h"
+#include "textbuf_gui.h"
+#include "command_func.h"
+#include "company_func.h"
+#include "vehicle_gui.h"
+#include "newgrf_engine.h"
+#include "newgrf_text.h"
+#include "group.h"
+#include "string_func.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "date_func.h"
+#include "vehicle_func.h"
+#include "widgets/dropdown_func.h"
+#include "engine_gui.h"
+#include "cargotype.h"
+#include "core/geometry_func.hpp"
+
+#include "widgets/build_vehicle_widget.h"
+
+#include "table/strings.h"
+
+// MYGUI
+#include "aaa_template_gui_create_virtualtrain.h"
+#include "vehicle_gui.h"
+
+/**
+ * Get the height of a single 'entry' in the engine lists.
+ * @param type the vehicle type to get the height of
+ * @return the height for the entry
+ */
+static uint GetEngineListHeight(VehicleType type)
+{
+	return max<uint>(FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM, GetVehicleHeight(type));
+}
+
+static const NWidgetPart _nested_build_vehicle_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_BV_CAPTION), SetDataTip(STR_WHITE_STRING, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY),
+		NWidget(NWID_HORIZONTAL),
+			NWidget(NWID_VERTICAL),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_BV_SORT_ASSENDING_DESCENDING), SetDataTip(STR_BUTTON_SORT_BY, STR_TOOLTIP_SORT_ORDER), SetFill(1, 0),
+				NWidget(NWID_SPACER), SetFill(1, 1),
+			EndContainer(),
+			NWidget(NWID_VERTICAL),
+				NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_BV_SORT_DROPDOWN), SetResize(1, 0), SetFill(1, 0), SetDataTip(STR_JUST_STRING, STR_TOOLTIP_SORT_CRITERIA),
+				NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_BV_CARGO_FILTER_DROPDOWN), SetResize(1, 0), SetFill(1, 0), SetDataTip(STR_JUST_STRING, STR_TOOLTIP_FILTER_CRITERIA),
+			EndContainer(),
+		EndContainer(),
+	EndContainer(),
+	/* Vehicle list. */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, WID_BV_LIST), SetResize(1, 1), SetFill(1, 0), SetDataTip(0x101, STR_NULL), SetScrollbar(WID_BV_SCROLLBAR),
+		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_BV_SCROLLBAR),
+	EndContainer(),
+	/* Panel with details. */
+	NWidget(WWT_PANEL, COLOUR_GREY, WID_BV_PANEL), SetMinimalSize(240, 122), SetResize(1, 0), EndContainer(),
+	/* Build/rename buttons, resize button. */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_BV_BUILD), SetResize(1, 0), SetFill(1, 0), SetDataTip(STR_TMPL_CONFIRM, STR_TMPL_CONFIRM),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_BV_RENAME), SetResize(1, 0), SetFill(1, 0),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+/** Special cargo filter criteria */
+static const CargoID CF_ANY  = CT_NO_REFIT; ///< Show all vehicles independent of carried cargo (i.e. no filtering)
+static const CargoID CF_NONE = CT_INVALID;  ///< Show only vehicles which do not carry cargo (e.g. train engines)
+
+static bool _internal_sort_order;           ///< false = descending, true = ascending
+static byte _last_sort_criteria[]      = {0, 0, 0, 0};
+static bool _last_sort_order[]         = {false, false, false, false};
+static CargoID _last_filter_criteria[] = {CF_ANY, CF_ANY, CF_ANY, CF_ANY};
+
+/**
+ * Determines order of engines by engineID
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineNumberSorter(const EngineID *a, const EngineID *b)
+{
+	int r = ListPositionOfEngine(*a) - ListPositionOfEngine(*b);
+
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by introduction date
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineIntroDateSorter(const EngineID *a, const EngineID *b)
+{
+	const int va = Engine::Get(*a)->intro_date;
+	const int vb = Engine::Get(*b)->intro_date;
+	const int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by name
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineNameSorter(const EngineID *a, const EngineID *b)
+{
+	static EngineID last_engine[2] = { INVALID_ENGINE, INVALID_ENGINE };
+	static char     last_name[2][64] = { "\0", "\0" };
+
+	const EngineID va = *a;
+	const EngineID vb = *b;
+
+	if (va != last_engine[0]) {
+		last_engine[0] = va;
+		SetDParam(0, va);
+		GetString(last_name[0], STR_ENGINE_NAME, lastof(last_name[0]));
+	}
+
+	if (vb != last_engine[1]) {
+		last_engine[1] = vb;
+		SetDParam(0, vb);
+		GetString(last_name[1], STR_ENGINE_NAME, lastof(last_name[1]));
+	}
+
+	int r = strnatcmp(last_name[0], last_name[1]); // Sort by name (natural sorting).
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by reliability
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineReliabilitySorter(const EngineID *a, const EngineID *b)
+{
+	const int va = Engine::Get(*a)->reliability;
+	const int vb = Engine::Get(*b)->reliability;
+	const int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by purchase cost
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineCostSorter(const EngineID *a, const EngineID *b)
+{
+	Money va = Engine::Get(*a)->GetCost();
+	Money vb = Engine::Get(*b)->GetCost();
+	int r = ClampToI32(va - vb);
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by speed
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineSpeedSorter(const EngineID *a, const EngineID *b)
+{
+	int va = Engine::Get(*a)->GetDisplayMaxSpeed();
+	int vb = Engine::Get(*b)->GetDisplayMaxSpeed();
+	int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by power
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EnginePowerSorter(const EngineID *a, const EngineID *b)
+{
+	int va = Engine::Get(*a)->GetPower();
+	int vb = Engine::Get(*b)->GetPower();
+	int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by tractive effort
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineTractiveEffortSorter(const EngineID *a, const EngineID *b)
+{
+	int va = Engine::Get(*a)->GetDisplayMaxTractiveEffort();
+	int vb = Engine::Get(*b)->GetDisplayMaxTractiveEffort();
+	int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by running costs
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineRunningCostSorter(const EngineID *a, const EngineID *b)
+{
+	Money va = Engine::Get(*a)->GetRunningCost();
+	Money vb = Engine::Get(*b)->GetRunningCost();
+	int r = ClampToI32(va - vb);
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by running costs
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EnginePowerVsRunningCostSorter(const EngineID *a, const EngineID *b)
+{
+	const Engine *e_a = Engine::Get(*a);
+	const Engine *e_b = Engine::Get(*b);
+
+	/* Here we are using a few tricks to get the right sort.
+	 * We want power/running cost, but since we usually got higher running cost than power and we store the result in an int,
+	 * we will actually calculate cunning cost/power (to make it more than 1).
+	 * Because of this, the return value have to be reversed as well and we return b - a instead of a - b.
+	 * Another thing is that both power and running costs should be doubled for multiheaded engines.
+	 * Since it would be multipling with 2 in both numerator and denumerator, it will even themselves out and we skip checking for multiheaded. */
+	Money va = (e_a->GetRunningCost()) / max(1U, (uint)e_a->GetPower());
+	Money vb = (e_b->GetRunningCost()) / max(1U, (uint)e_b->GetPower());
+	int r = ClampToI32(vb - va);
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/* Train sorting functions */
+
+/**
+ * Determines order of train engines by capacity
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL TrainEngineCapacitySorter(const EngineID *a, const EngineID *b)
+{
+	const RailVehicleInfo *rvi_a = RailVehInfo(*a);
+	const RailVehicleInfo *rvi_b = RailVehInfo(*b);
+
+	int va = GetTotalCapacityOfArticulatedParts(*a) * (rvi_a->railveh_type == RAILVEH_MULTIHEAD ? 2 : 1);
+	int vb = GetTotalCapacityOfArticulatedParts(*b) * (rvi_b->railveh_type == RAILVEH_MULTIHEAD ? 2 : 1);
+	int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of train engines by engine / wagon
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL TrainEnginesThenWagonsSorter(const EngineID *a, const EngineID *b)
+{
+	int val_a = (RailVehInfo(*a)->railveh_type == RAILVEH_WAGON ? 1 : 0);
+	int val_b = (RailVehInfo(*b)->railveh_type == RAILVEH_WAGON ? 1 : 0);
+	int r = val_a - val_b;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+// TODO: make this single-dim
+
+static EngList_SortTypeFunction * const _sorter[][11] = {{
+	/* Trains */
+	&EngineNumberSorter,
+	&EngineCostSorter,
+	&EngineSpeedSorter,
+	&EnginePowerSorter,
+	&EngineTractiveEffortSorter,
+	&EngineIntroDateSorter,
+	&EngineNameSorter,
+	&EngineRunningCostSorter,
+	&EnginePowerVsRunningCostSorter,
+	&EngineReliabilitySorter,
+	&TrainEngineCapacitySorter,
+}};
+
+static const StringID _sort_listing[][12] = {{
+	/* Trains */
+	STR_SORT_BY_ENGINE_ID,
+	STR_SORT_BY_COST,
+	STR_SORT_BY_MAX_SPEED,
+	STR_SORT_BY_POWER,
+	STR_SORT_BY_TRACTIVE_EFFORT,
+	STR_SORT_BY_INTRO_DATE,
+	STR_SORT_BY_NAME,
+	STR_SORT_BY_RUNNING_COST,
+	STR_SORT_BY_POWER_VS_RUNNING_COST,
+	STR_SORT_BY_RELIABILITY,
+	STR_SORT_BY_CARGO_CAPACITY,
+	INVALID_STRING_ID
+}};
+
+/** Cargo filter functions */
+static bool CDECL CargoFilter(const EngineID *eid, const CargoID cid)
+{
+	if (cid == CF_ANY) return true;
+	uint32 refit_mask = GetUnionOfArticulatedRefitMasks(*eid, true);
+	return (cid == CF_NONE ? refit_mask == 0 : HasBit(refit_mask, cid));
+}
+
+static GUIEngineList::FilterFunction * const _filter_funcs[] = {
+	&CargoFilter,
+};
+
+/**
+ * Engine drawing loop
+ * @param type Type of vehicle (VEH_*)
+ * @param l The left most location of the list
+ * @param r The right most location of the list
+ * @param y The top most location of the list
+ * @param eng_list What engines to draw
+ * @param min where to start in the list
+ * @param max where in the list to end
+ * @param selected_id what engine to highlight as selected, if any
+ * @param show_count Whether to show the amount of engines or not
+ * @param selected_group the group to list the engines of
+ */
+static void DrawEngineList(VehicleType type, int l, int r, int y, const GUIEngineList *eng_list, uint16 min, uint16 max, EngineID selected_id, bool show_count, GroupID selected_group)
+{
+	static const int sprite_widths[]  = { 60, 60, 76, 67 };
+	static const int sprite_y_offsets[] = { -1, -1, -2, -2 };
+
+	/* Obligatory sanity checks! */
+	assert((uint)type < lengthof(sprite_widths));
+	assert_compile(lengthof(sprite_y_offsets) == lengthof(sprite_widths));
+	assert(max <= eng_list->Length());
+
+	bool rtl = _current_text_dir == TD_RTL;
+	int step_size = GetEngineListHeight(type);
+	int sprite_width = sprite_widths[type];
+
+	int sprite_x        = (rtl ? r - sprite_width / 2 : l + sprite_width / 2) - 1;
+	int sprite_y_offset = sprite_y_offsets[type] + step_size / 2;
+
+	int text_left  = l + (rtl ? WD_FRAMERECT_LEFT : sprite_width);
+	int text_right = r - (rtl ? sprite_width : WD_FRAMERECT_RIGHT);
+
+	int normal_text_y_offset = (step_size - FONT_HEIGHT_NORMAL) / 2;
+	int small_text_y_offset  = step_size - FONT_HEIGHT_SMALL - WD_FRAMERECT_BOTTOM - 1;
+
+	for (; min < max; min++, y += step_size) {
+		const EngineID engine = (*eng_list)[min];
+		/* Note: num_engines is only used in the autoreplace GUI, so it is correct to use _local_company here. */
+		const uint num_engines = GetGroupNumEngines(_local_company, selected_group, engine);
+
+		SetDParam(0, engine);
+		DrawString(text_left, text_right, y + normal_text_y_offset, STR_ENGINE_NAME, engine == selected_id ? TC_WHITE : TC_BLACK);
+		DrawVehicleEngine(l, r, sprite_x, y + sprite_y_offset, engine, (show_count && num_engines == 0) ? PALETTE_CRASH : GetEnginePalette(engine, _local_company), EIT_PURCHASE);
+		if (show_count) {
+			SetDParam(0, num_engines);
+			DrawString(text_left, text_right, y + small_text_y_offset, STR_TINY_BLACK_COMA, TC_FROMSTRING, SA_RIGHT);
+		}
+	}
+}
+
+
+struct BuildVirtualTrainWindow : Window {
+	VehicleType vehicle_type;
+	union {
+		RailTypeByte railtype;
+		RoadTypes roadtypes;
+	} filter;
+	bool descending_sort_order;
+	byte sort_criteria;
+	bool listview_mode;
+	EngineID sel_engine;
+	EngineID rename_engine;
+	GUIEngineList eng_list;
+	CargoID cargo_filter[NUM_CARGO + 2];        ///< Available cargo filters; CargoID or CF_ANY or CF_NONE
+	StringID cargo_filter_texts[NUM_CARGO + 3]; ///< Texts for filter_cargo, terminated by INVALID_STRING_ID
+	byte cargo_filter_criteria;                 ///< Selected cargo filter
+	int details_height;                         ///< Minimal needed height of the details panels (found so far).
+	Scrollbar *vscroll;
+	// MYGUI
+	Train **virtual_train;
+	bool *noticeParent;
+
+	BuildVirtualTrainWindow(const WindowDesc *desc, Train **vt, bool *notice) : Window()
+	{
+		this->vehicle_type = VEH_TRAIN; // TODO change type to VEH_TRAIN everywhere
+		this->window_number = 0;//tile == INVALID_TILE ? (int)type : tile;
+
+		this->sel_engine      = INVALID_ENGINE;
+
+		this->sort_criteria         = _last_sort_criteria[VEH_TRAIN];
+		this->descending_sort_order = _last_sort_order[VEH_TRAIN];
+
+		this->filter.railtype = RAILTYPE_END;
+
+		this->listview_mode = (this->window_number <= VEH_END);
+
+		this->CreateNestedTree(desc);
+
+		this->vscroll = this->GetScrollbar(WID_BV_SCROLLBAR);
+
+		NWidgetCore *widget = this->GetWidget<NWidgetCore>(WID_BV_LIST);
+
+		widget = this->GetWidget<NWidgetCore>(WID_BV_BUILD);
+
+		widget = this->GetWidget<NWidgetCore>(WID_BV_RENAME);
+		widget->widget_data = STR_BUY_VEHICLE_TRAIN_RENAME_BUTTON + VEH_TRAIN;
+		widget->tool_tip    = STR_BUY_VEHICLE_TRAIN_RENAME_TOOLTIP + VEH_TRAIN;
+
+		this->details_height = ((this->vehicle_type == VEH_TRAIN) ? 10 : 9) * FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+
+		this->FinishInitNested(desc, VEH_TRAIN);
+
+		this->owner = _local_company;
+
+		this->eng_list.ForceRebuild();
+		this->GenerateBuildList();
+
+		if (this->eng_list.Length() > 0) this->sel_engine = this->eng_list[0];
+
+		this->virtual_train = vt;
+		this->noticeParent = notice;
+	}
+
+	/** Populate the filter list and set the cargo filter criteria. */
+	void SetCargoFilterArray()
+	{
+		uint filter_items = 0;
+
+		/* Add item for disabling filtering. */
+		this->cargo_filter[filter_items] = CF_ANY;
+		this->cargo_filter_texts[filter_items] = STR_PURCHASE_INFO_ALL_TYPES;
+		filter_items++;
+
+		/* Add item for vehicles not carrying anything, e.g. train engines.
+		 * This could also be useful for eyecandy vehicles of other types, but is likely too confusing for joe, */
+		if (this->vehicle_type == VEH_TRAIN) {
+			this->cargo_filter[filter_items] = CF_NONE;
+			this->cargo_filter_texts[filter_items] = STR_LAND_AREA_INFORMATION_LOCAL_AUTHORITY_NONE;
+			filter_items++;
+		}
+
+		/* Collect available cargo types for filtering. */
+		const CargoSpec *cs;
+		FOR_ALL_SORTED_STANDARD_CARGOSPECS(cs) {
+			this->cargo_filter[filter_items] = cs->Index();
+			this->cargo_filter_texts[filter_items] = cs->name;
+			filter_items++;
+		}
+
+		/* Terminate the filter list. */
+		this->cargo_filter_texts[filter_items] = INVALID_STRING_ID;
+
+		/* If not found, the cargo criteria will be set to all cargoes. */
+		this->cargo_filter_criteria = 0;
+
+		/* Find the last cargo filter criteria. */
+		for (uint i = 0; i < filter_items; i++) {
+			if (this->cargo_filter[i] == _last_filter_criteria[this->vehicle_type]) {
+				this->cargo_filter_criteria = i;
+				break;
+			}
+		}
+
+		this->eng_list.SetFilterFuncs(_filter_funcs);
+		this->eng_list.SetFilterState(this->cargo_filter[this->cargo_filter_criteria] != CF_ANY);
+	}
+
+	void OnInit()
+	{
+		this->SetCargoFilterArray();
+	}
+
+	/** Filter the engine list against the currently selected cargo filter */
+	void FilterEngineList()
+	{
+		this->eng_list.Filter(this->cargo_filter[this->cargo_filter_criteria]);
+		if (0 == this->eng_list.Length()) { // no engine passed through the filter, invalidate the previously selected engine
+			this->sel_engine = INVALID_ENGINE;
+		} else if (!this->eng_list.Contains(this->sel_engine)) { // previously selected engine didn't pass the filter, select the first engine of the list
+			this->sel_engine = this->eng_list[0];
+		}
+	}
+
+	/** Filter a single engine */
+	bool FilterSingleEngine(EngineID eid)
+	{
+		CargoID filter_type = this->cargo_filter[this->cargo_filter_criteria];
+		return (filter_type == CF_ANY || CargoFilter(&eid, filter_type));
+	}
+
+	/* Figure out what train EngineIDs to put in the list */
+	void GenerateBuildTrainList()
+	{
+		EngineID sel_id = INVALID_ENGINE;
+		int num_engines = 0;
+		int num_wagons  = 0;
+
+		this->filter.railtype = (this->listview_mode) ? RAILTYPE_END : GetRailType(this->window_number);
+
+		this->eng_list.Clear();
+
+		/* Make list of all available train engines and wagons.
+		 * Also check to see if the previously selected engine is still available,
+		 * and if not, reset selection to INVALID_ENGINE. This could be the case
+		 * when engines become obsolete and are removed */
+		const Engine *e;
+		FOR_ALL_ENGINES_OF_TYPE(e, VEH_TRAIN) {
+			EngineID eid = e->index;
+			const RailVehicleInfo *rvi = &e->u.rail;
+
+			if (this->filter.railtype != RAILTYPE_END && !HasPowerOnRail(rvi->railtype, this->filter.railtype)) continue;
+			if (!IsEngineBuildable(eid, VEH_TRAIN, _local_company)) continue;
+
+			/* Filter now! So num_engines and num_wagons is valid */
+			if (!FilterSingleEngine(eid)) continue;
+
+			*this->eng_list.Append() = eid;
+
+			if (rvi->railveh_type != RAILVEH_WAGON) {
+				num_engines++;
+			} else {
+				num_wagons++;
+			}
+
+			if (eid == this->sel_engine) sel_id = eid;
+		}
+
+		this->sel_engine = sel_id;
+
+		/* make engines first, and then wagons, sorted by ListPositionOfEngine() */
+		_internal_sort_order = false;
+		EngList_Sort(&this->eng_list, TrainEnginesThenWagonsSorter);
+
+		/* and then sort engines */
+		_internal_sort_order = this->descending_sort_order;
+		EngList_SortPartial(&this->eng_list, _sorter[0][this->sort_criteria], 0, num_engines);
+
+		/* and finally sort wagons */
+		EngList_SortPartial(&this->eng_list, _sorter[0][this->sort_criteria], num_engines, num_wagons);
+	}
+
+	// TODO: cleanup this func
+	/* Generate the list of vehicles */
+	void GenerateBuildList()
+	{
+		if (!this->eng_list.NeedRebuild()) return;
+
+		this->GenerateBuildTrainList();
+		this->eng_list.Compact();
+		this->eng_list.RebuildDone();
+		return; // trains should not reach the last sorting
+
+
+		this->FilterEngineList();
+
+		_internal_sort_order = this->descending_sort_order;
+		EngList_Sort(&this->eng_list, _sorter[this->vehicle_type][this->sort_criteria]);
+
+		this->eng_list.Compact();
+		this->eng_list.RebuildDone();
+	}
+
+	virtual	void OnClick(Point pt, int widget, int click_count)
+	{
+		switch (widget) {
+			case WID_BV_SORT_ASSENDING_DESCENDING:
+				this->descending_sort_order ^= true;
+				_last_sort_order[this->vehicle_type] = this->descending_sort_order;
+				this->eng_list.ForceRebuild();
+				this->SetDirty();
+				break;
+
+			case WID_BV_LIST: {
+				uint i = this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_BV_LIST);
+				size_t num_items = this->eng_list.Length();
+				this->sel_engine = (i < num_items) ? this->eng_list[i] : INVALID_ENGINE;
+				this->SetDirty();
+				if (click_count > 1 && !this->listview_mode) this->OnClick(pt, WID_BV_BUILD, 1);
+				break;
+			}
+			case WID_BV_SORT_DROPDOWN: { // Select sorting criteria dropdown menu
+				uint32 hidden_mask = 0;
+				/* Disable sorting by power or tractive effort when the original acceleration model for road vehicles is being used. */
+				if (this->vehicle_type == VEH_ROAD &&
+						_settings_game.vehicle.roadveh_acceleration_model == AM_ORIGINAL) {
+					SetBit(hidden_mask, 3); // power
+					SetBit(hidden_mask, 4); // tractive effort
+					SetBit(hidden_mask, 8); // power by running costs
+				}
+				/* Disable sorting by tractive effort when the original acceleration model for trains is being used. */
+				if (this->vehicle_type == VEH_TRAIN &&
+						_settings_game.vehicle.train_acceleration_model == AM_ORIGINAL) {
+					SetBit(hidden_mask, 4); // tractive effort
+				}
+				ShowDropDownMenu(this, _sort_listing[this->vehicle_type], this->sort_criteria, WID_BV_SORT_DROPDOWN, 0, hidden_mask);
+				break;
+			}
+
+			case WID_BV_CARGO_FILTER_DROPDOWN: // Select cargo filtering criteria dropdown menu
+				ShowDropDownMenu(this, this->cargo_filter_texts, this->cargo_filter_criteria, WID_BV_CARGO_FILTER_DROPDOWN, 0, 0);
+				break;
+
+			case WID_BV_BUILD: {
+				EngineID sel_eng = this->sel_engine;
+				if (sel_eng != INVALID_ENGINE) {
+					Train *tmp = CmdBuildVirtualRailVehicle(sel_eng);
+					if (tmp) AddVirtualEngine(tmp);
+				}
+				break;
+			}
+		}
+	}
+
+	/**
+	 * Some data on this window has become invalid.
+	 * @param data Information about the changed data.
+	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+	 */
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		if (!gui_scope) return;
+		/* When switching to original acceleration model for road vehicles, clear the selected sort criteria if it is not available now. */
+		if (this->vehicle_type == VEH_ROAD &&
+				_settings_game.vehicle.roadveh_acceleration_model == AM_ORIGINAL &&
+				this->sort_criteria > 7) {
+			this->sort_criteria = 0;
+			_last_sort_criteria[VEH_ROAD] = 0;
+		}
+		this->eng_list.ForceRebuild();
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			case WID_BV_CAPTION:
+				if (this->vehicle_type == VEH_TRAIN && !this->listview_mode) {
+					const RailtypeInfo *rti = GetRailTypeInfo(this->filter.railtype);
+					SetDParam(0, rti->strings.build_caption);
+				} else {
+					SetDParam(0, (this->listview_mode ? STR_VEHICLE_LIST_AVAILABLE_TRAINS : STR_BUY_VEHICLE_TRAIN_ALL_CAPTION) + this->vehicle_type);
+				}
+				break;
+
+			case WID_BV_SORT_DROPDOWN:
+				SetDParam(0, _sort_listing[this->vehicle_type][this->sort_criteria]);
+				break;
+
+			case WID_BV_CARGO_FILTER_DROPDOWN:
+				SetDParam(0, this->cargo_filter_texts[this->cargo_filter_criteria]);
+		}
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case WID_BV_LIST:
+				resize->height = GetEngineListHeight(this->vehicle_type);
+				size->height = 3 * resize->height;
+				break;
+
+			case WID_BV_PANEL:
+				size->height = this->details_height;
+				break;
+
+			case WID_BV_SORT_ASSENDING_DESCENDING: {
+				Dimension d = GetStringBoundingBox(this->GetWidget<NWidgetCore>(widget)->widget_data);
+				d.width += padding.width + WD_SORTBUTTON_ARROW_WIDTH * 2; // Doubled since the string is centred and it also looks better.
+				d.height += padding.height;
+				*size = maxdim(*size, d);
+				break;
+			}
+		}
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch (widget) {
+			case WID_BV_LIST:
+				DrawEngineList(this->vehicle_type, r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, &this->eng_list, this->vscroll->GetPosition(), min(this->vscroll->GetPosition() + this->vscroll->GetCapacity(), this->eng_list.Length()), this->sel_engine, false, DEFAULT_GROUP);
+				break;
+
+			case WID_BV_SORT_ASSENDING_DESCENDING:
+				this->DrawSortButtonState(WID_BV_SORT_ASSENDING_DESCENDING, this->descending_sort_order ? SBS_DOWN : SBS_UP);
+				break;
+		}
+	}
+
+	virtual void OnPaint()
+	{
+		this->GenerateBuildList();
+		this->vscroll->SetCount(this->eng_list.Length());
+
+		this->DrawWidgets();
+
+		if (!this->IsShaded()) {
+			int needed_height = this->details_height;
+			/* Draw details panels. */
+			if (this->sel_engine != INVALID_ENGINE) {
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(WID_BV_PANEL);
+				int text_end = DrawVehiclePurchaseInfo(nwi->pos_x + WD_FRAMETEXT_LEFT, nwi->pos_x + nwi->current_x - WD_FRAMETEXT_RIGHT,
+						nwi->pos_y + WD_FRAMERECT_TOP, this->sel_engine);
+				needed_height = max(needed_height, text_end - (int)nwi->pos_y + WD_FRAMERECT_BOTTOM);
+			}
+			if (needed_height != this->details_height) { // Details window are not high enough, enlarge them.
+				int resize = needed_height - this->details_height;
+				this->details_height = needed_height;
+				this->ReInit(0, resize);
+				return;
+			}
+		}
+	}
+
+	virtual void OnQueryTextFinished(char *str)
+	{
+		if (str == NULL) return;
+
+		DoCommandP(0, this->rename_engine, 0, CMD_RENAME_ENGINE | CMD_MSG(STR_ERROR_CAN_T_RENAME_TRAIN_TYPE + this->vehicle_type), NULL, str);
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		switch (widget) {
+			case WID_BV_SORT_DROPDOWN:
+				if (this->sort_criteria != index) {
+					this->sort_criteria = index;
+					_last_sort_criteria[this->vehicle_type] = this->sort_criteria;
+					this->eng_list.ForceRebuild();
+				}
+				break;
+
+			case WID_BV_CARGO_FILTER_DROPDOWN: // Select a cargo filter criteria
+				if (this->cargo_filter_criteria != index) {
+					this->cargo_filter_criteria = index;
+					_last_filter_criteria[this->vehicle_type] = this->cargo_filter[this->cargo_filter_criteria];
+					/* deactivate filter if criteria is 'Show All', activate it otherwise */
+					this->eng_list.SetFilterState(this->cargo_filter[this->cargo_filter_criteria] != CF_ANY);
+					this->eng_list.ForceRebuild();
+				}
+				break;
+		}
+		this->SetDirty();
+	}
+
+	virtual void OnResize()
+	{
+		this->vscroll->SetCapacityFromWidget(this, WID_BV_LIST);
+		this->GetWidget<NWidgetCore>(WID_BV_LIST)->widget_data = (this->vscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+	void AddVirtualEngine(Train *toadd)
+	{
+		if ( !*virtual_train ) {
+			*virtual_train = toadd;
+		}
+		else {
+			VehicleID target = (*(this->virtual_train))->GetLastUnit()->index;
+			CommandCost movec;
+			movec = CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, (1<<21) | toadd->index, target, 0);
+		}
+		*noticeParent = true;
+	}
+};
+
+static const WindowDesc _build_vehicle_desc(
+	WDP_AUTO, 240, 268,
+	WC_BUILD_VIRTUAL_TRAIN, WC_NONE,
+	WDF_UNCLICK_BUTTONS | WDF_CONSTRUCTION,
+	_nested_build_vehicle_widgets, lengthof(_nested_build_vehicle_widgets)
+);
+
+void ShowBuildVirtualTrainWindow(Train **vt, bool *noticeParent)
+{
+	// '0' as in VEH_TRAIN = Tile=0
+	assert(IsCompanyBuildableVehicleType(VEH_TRAIN));
+
+	DeleteWindowById(WC_BUILD_VEHICLE, 0);
+
+	new BuildVirtualTrainWindow(&_build_vehicle_desc, vt, noticeParent);
+}
Index: src/group_gui.cpp
===================================================================
--- src/group_gui.cpp	(revision 24093)
+++ src/group_gui.cpp	(working copy)
@@ -30,6 +30,9 @@
 
 #include "table/sprites.h"
 
+// MYGUI_NOEND
+#include "aaa_template_gui_main.h"
+
 typedef GUIList<const Group*> GUIGroupList;
 
 static const NWidgetPart _nested_group_widgets[] = {
@@ -570,6 +573,7 @@
 				this->vli.index = ALL_GROUP;
 
 				DoCommandP(0, group, 0, CMD_DELETE_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_DELETE));
+				InvalidateWindowData(WC_TEMPLATEGUI_MAIN, 0, 0, 0);
 				break;
 			}
 
@@ -648,6 +652,7 @@
 	virtual void OnQueryTextFinished(char *str)
 	{
 		if (str != NULL) DoCommandP(0, this->group_rename, 0, CMD_RENAME_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_RENAME), NULL, str);
+		InvalidateWindowData(WC_TEMPLATEGUI_MAIN, 0, 0, 0);
 		this->group_rename = INVALID_GROUP;
 	}
 
@@ -673,6 +678,11 @@
 				assert(this->vehicles.Length() != 0);
 
 				switch (index) {
+					case ADI_TEMPLATE_REPLACE: // TemplateReplace Window
+						if ( vli.vtype == VEH_TRAIN )
+							// TODO before we used vli.company in the main gui, maybe retrieve it here and pass it as param to the gui ?
+							ShowTemplateReplaceWindow(this->unitnumber_digits, this->resize.step_height);
+						break;
 					case ADI_REPLACE: // Replace window
 						ShowReplaceGroupVehicleWindow(this->vli.index, this->vli.vtype);
 						break;
Index: src/settings_type.h
===================================================================
--- src/settings_type.h	(revision 24093)
+++ src/settings_type.h	(working copy)
@@ -17,6 +17,8 @@
 #include "transport_type.h"
 #include "network/core/config.h"
 #include "company_type.h"
+#include "cargotype.h"
+#include "linkgraph/linkgraph_type.h"
 #include "zoom_type.h"
 #include "openttd.h"
 
@@ -119,6 +121,10 @@
 
 	uint16 console_backlog_timeout;          ///< the minimum amount of time items should be in the console backlog before they will be removed in ~3 seconds granularity.
 	uint16 console_backlog_length;           ///< the minimum amount of items in the console backlog before items will be removed.
+
+	uint8  station_gui_group_order;          ///< the order of grouping cargo entries in the station gui
+	uint8  station_gui_sort_by;              ///< sort cargo entries in the station gui by station name or amount
+	uint8  station_gui_sort_order;           ///< the sort order of entries in the station gui - ascending or descending
 #ifdef ENABLE_NETWORK
 	uint16 network_chat_box_width;           ///< width of the chat box in pixels
 	uint8  network_chat_box_height;          ///< height of the chat box in lines
@@ -424,6 +430,30 @@
 	bool   infrastructure_maintenance;       ///< enable monthly maintenance fee for owner infrastructure
 };
 
+struct LinkGraphSettings {
+	uint16 recalc_interval;                     ///< minimum interval (in days) between subsequent calculations of components in the same link graph
+	DistributionTypeByte distribution_pax;      ///< distribution type for passengers
+	DistributionTypeByte distribution_mail;     ///< distribution type for mail
+	DistributionTypeByte distribution_armoured; ///< distribution type for armoured cargo class
+	DistributionTypeByte distribution_default;  ///< distribution type for all other goods
+	uint8 accuracy;                             ///< accuracy when calculating things on the link graph. low accuracy => low running time
+	uint8 demand_size;                          ///< influence of supply ("station size") on the demand function
+	uint8 demand_distance;                      ///< influence of distance between stations on the demand function
+	uint8 short_path_saturation;                ///< percentage up to which short paths are saturated before saturating most capacious paths
+
+	inline DistributionType GetDistributionType(CargoID cargo) const {
+		if (IsCargoInClass(cargo, CC_PASSENGERS)) {
+			return this->distribution_pax;
+		} else if (IsCargoInClass(cargo, CC_MAIL)) {
+			return this->distribution_mail;
+		} else if (IsCargoInClass(cargo, CC_ARMOURED)) {
+			return this->distribution_armoured;
+		} else {
+			return this->distribution_default;
+		}
+	}
+};
+
 /** Settings related to stations. */
 struct StationSettings {
 	bool   modified_catchment;               ///< different-size catchment areas
@@ -464,6 +494,7 @@
 	OrderSettings        order;              ///< settings related to orders
 	VehicleSettings      vehicle;            ///< options for vehicles
 	EconomySettings      economy;            ///< settings to change the economy
+	LinkGraphSettings    linkgraph;          ///< settings for link graph calculations
 	StationSettings      station;            ///< settings related to station management
 	LocaleSettings       locale;             ///< settings related to used currency/unit system in the current game
 };
Index: src/depot_gui.cpp
===================================================================
--- src/depot_gui.cpp	(revision 24093)
+++ src/depot_gui.cpp	(working copy)
@@ -840,6 +840,7 @@
 
 	virtual void OnMouseDrag(Point pt, int widget)
 	{
+
 		if (this->type != VEH_TRAIN || this->sel == INVALID_VEHICLE) return;
 
 		/* A rail vehicle is dragged.. */
@@ -894,6 +895,7 @@
 
 					if (this->GetVehicleFromDepotWndPt(pt.x - nwi->pos_x, pt.y - nwi->pos_y, &v, &gdvp) == MODE_DRAG_VEHICLE && sel != INVALID_VEHICLE) {
 						if (gdvp.wagon != NULL && gdvp.wagon->index == sel && _ctrl_pressed) {
+
 							DoCommandP(Vehicle::Get(sel)->tile, Vehicle::Get(sel)->index, true,
 									CMD_REVERSE_TRAIN_DIRECTION | CMD_MSG(STR_ERROR_CAN_T_REVERSE_DIRECTION_RAIL_VEHICLE));
 						} else if (gdvp.wagon == NULL || gdvp.wagon->index != sel) {
Index: src/vehicle_gui_base.h
===================================================================
--- src/vehicle_gui_base.h	(revision 24093)
+++ src/vehicle_gui_base.h	(working copy)
@@ -27,6 +27,7 @@
 	VehicleListIdentifier vli; ///< Identifier of the vehicle list we want to currently show.
 
 	enum ActionDropdownItem {
+		ADI_TEMPLATE_REPLACE,
 		ADI_REPLACE,
 		ADI_SERVICE,
 		ADI_DEPOT,
Index: src/newgrf_engine.h
===================================================================
--- src/newgrf_engine.h	(revision 24093)
+++ src/newgrf_engine.h	(working copy)
@@ -67,6 +67,9 @@
 void AlterVehicleListOrder(EngineID engine, EngineID target);
 void CommitVehicleListOrderChanges();
 
+struct ResolverObject;
+void NewVehicleResolverWrapper(ResolverObject*, EngineID);
+
 EngineID GetNewEngineID(const GRFFile *file, VehicleType type, uint16 internal_id);
 
 #endif /* NEWGRF_ENGINE_H */
Index: src/articulated_vehicles.cpp
===================================================================
--- src/articulated_vehicles.cpp	(revision 24093)
+++ src/articulated_vehicles.cpp	(working copy)
@@ -323,6 +323,7 @@
 	Vehicle *v = first;
 	for (uint i = 1; i < MAX_ARTICULATED_PARTS; i++) {
 		bool flip_image;
+		EngineID eid = GetNextArticulatedPart(i, first->engine_type);
 		EngineID engine_type = GetNextArticulatedPart(i, first->engine_type, first, &flip_image);
 		if (engine_type == INVALID_ENGINE) return;
 
Index: src/station_gui.cpp
===================================================================
--- src/station_gui.cpp	(revision 24093)
+++ src/station_gui.cpp	(working copy)
@@ -34,6 +34,8 @@
 
 #include "table/strings.h"
 
+#include <vector>
+
 /**
  * Calculates and draws the accepted or supplied cargo around the selected tile(s)
  * @param left x position where the string is to be drawn
@@ -758,10 +760,18 @@
 		NWidget(WWT_STICKYBOX, COLOUR_GREY),
 	EndContainer(),
 	NWidget(NWID_HORIZONTAL),
-		NWidget(WWT_PANEL, COLOUR_GREY, WID_SV_WAITING), SetMinimalSize(237, 52), SetResize(1, 10), SetScrollbar(WID_SV_SCROLLBAR), EndContainer(),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_SORT_ORDER), SetMinimalSize(81, 12), SetFill(1, 1), SetDataTip(STR_BUTTON_SORT_BY, STR_TOOLTIP_SORT_ORDER),
+		NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_SV_SORT_BY), SetMinimalSize(168, 12), SetResize(1, 0), SetFill(0, 1), SetDataTip(0x0, STR_TOOLTIP_SORT_CRITERIA),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_SV_GROUP), SetMinimalSize(81, 12), SetFill(1, 1), SetDataTip(STR_STATION_VIEW_GROUP, 0x0),
+		NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_SV_GROUP_BY), SetMinimalSize(168, 12), SetResize(1, 0), SetFill(0, 1), SetDataTip(0x0, STR_TOOLTIP_GROUP_ORDER),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY, WID_SV_WAITING), SetMinimalSize(237, 44), SetResize(1, 10), SetScrollbar(WID_SV_SCROLLBAR), EndContainer(),
 		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_SV_SCROLLBAR),
 	EndContainer(),
-	NWidget(WWT_PANEL, COLOUR_GREY, WID_SV_ACCEPT_RATING_LIST), SetMinimalSize(249, 32), SetResize(1, 0), EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY, WID_SV_ACCEPT_RATING_LIST), SetMinimalSize(249, 23), SetResize(1, 0), EndContainer(),
 	NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
 		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_SV_LOCATION), SetMinimalSize(60, 12), SetResize(1, 0), SetFill(1, 1),
 				SetDataTip(STR_BUTTON_LOCATION, STR_STATION_VIEW_CENTER_TOOLTIP),
@@ -794,33 +804,270 @@
 
 	SpriteID sprite = CargoSpec::Get(i)->GetCargoIcon();
 
-	int x = _current_text_dir == TD_RTL ? right - num * 10 : left;
+	int x = _current_text_dir == TD_RTL ? left : right - num * 10;
 	do {
 		DrawSprite(sprite, PAL_NONE, x, y);
 		x += 10;
 	} while (--num);
 }
 
-struct CargoData {
-	CargoID cargo;
-	StationID source;
-	uint count;
+CargoDataEntry::CargoDataEntry() :
+	parent(NULL),
+	station(INVALID_STATION),
+	num_children(0),
+	count(0),
+	children(new CargoDataSet(CargoSorter(ST_CARGO_ID)))
+{}
 
-	CargoData(CargoID cargo, StationID source, uint count) :
-		cargo(cargo),
-		source(source),
-		count(count)
-	{ }
-};
+CargoDataEntry::CargoDataEntry(CargoID cargo, uint count, CargoDataEntry *parent) :
+	parent(parent),
+	cargo(cargo),
+	num_children(0),
+	count(count),
+	children(new CargoDataSet)
+{}
 
-typedef std::list<CargoData> CargoDataList;
+CargoDataEntry::CargoDataEntry(StationID station, uint count, CargoDataEntry *parent) :
+	parent(parent),
+	station(station),
+	num_children(0),
+	count(count),
+	children(new CargoDataSet)
+{}
 
+CargoDataEntry::CargoDataEntry(StationID station) :
+	parent(NULL),
+	station(station),
+	num_children(0),
+	count(0),
+	children(NULL)
+{}
+
+CargoDataEntry::CargoDataEntry(CargoID cargo) :
+	parent(NULL),
+	cargo(cargo),
+	num_children(0),
+	count(0),
+	children(NULL)
+{}
+
+CargoDataEntry::~CargoDataEntry()
+{
+	this->Clear();
+	delete this->children;
+}
+
 /**
+ * Delete all subentries, reset count and num_children and adapt parent's count.
+ */
+void CargoDataEntry::Clear()
+{
+	if (this->children != NULL) {
+		for (CargoDataSet::iterator i = this->children->begin(); i != this->children->end(); ++i) {
+			assert(*i != this);
+			delete *i;
+		}
+		this->children->clear();
+	}
+	if (this->parent != NULL) this->parent->count -= this->count;
+	this->count = 0;
+	this->num_children = 0;
+}
+
+/**
+ * Remove a subentry from this one and delete it.
+ * @param child the entry to be removed. This may also be a synthetic entry
+ * which only contains the ID of the entry to be removed. In this case child is
+ * not deleted.
+ */
+void CargoDataEntry::Remove(CargoDataEntry *child)
+{
+	CargoDataSet::iterator i = this->children->find(child);
+	if (i != this->children->end()) {
+		delete *i;
+		this->children->erase(i);
+	}
+}
+
+/**
+ * Retrieve a subentry or insert it if it doesn't exist, yet.
+ * @tparam ID type of ID: either StationID or CargoID
+ * @param child_id ID of the child to be inserted or retrieved.
+ * @return the new or retrieved subentry
+ */
+template<class ID>
+CargoDataEntry *CargoDataEntry::InsertOrRetrieve(ID child_id)
+{
+	CargoDataEntry tmp(child_id);
+	CargoDataSet::iterator i = this->children->find(&tmp);
+	if (i == this->children->end()) {
+		IncrementSize();
+		return *(this->children->insert(new CargoDataEntry(child_id, 0, this)).first);
+	} else {
+		CargoDataEntry *ret = *i;
+		assert(this->children->value_comp().GetSortType() != ST_COUNT);
+		return ret;
+	}
+}
+
+/**
+ * Update the count for this entry and propagate the change to the parent entry
+ * if there is one.
+ * @param count the amount to be added to this entry
+ */
+void CargoDataEntry::Update(uint count)
+{
+	this->count += count;
+	if (this->parent != NULL) this->parent->Update(count);
+}
+
+/**
+ * Increment
+ */
+void CargoDataEntry::IncrementSize()
+{
+	 ++this->num_children;
+	 if (this->parent != NULL) this->parent->IncrementSize();
+}
+
+void CargoDataEntry::Resort(CargoSortType type, SortOrder order)
+{
+	CargoDataSet *new_subs = new CargoDataSet(this->children->begin(), this->children->end(), CargoSorter(type, order));
+	delete this->children;
+	this->children = new_subs;
+}
+
+CargoDataEntry *CargoDataEntry::Retrieve(CargoDataSet::iterator i) const
+{
+	if (i == this->children->end()) {
+		return NULL;
+	} else {
+		assert(this->children->value_comp().GetSortType() != ST_COUNT);
+		return *i;
+	}
+}
+
+bool CargoSorter::operator()(const CargoDataEntry *cd1, const CargoDataEntry *cd2) const
+{
+	switch (this->type) {
+		case ST_STATION_ID:
+			return this->SortId<StationID>(cd1->GetStation(), cd2->GetStation());
+			break;
+		case ST_CARGO_ID:
+			return this->SortId<CargoID>(cd1->GetCargo(), cd2->GetCargo());
+			break;
+		case ST_COUNT:
+			return this->SortCount(cd1, cd2);
+			break;
+		case ST_STATION_STRING:
+			return this->SortStation(cd1->GetStation(), cd2->GetStation());
+			break;
+		default:
+			NOT_REACHED();
+	}
+}
+
+template<class ID>
+bool CargoSorter::SortId(ID st1, ID st2) const
+{
+	return (this->order == SO_ASCENDING) ? st1 < st2 : st2 < st1;
+}
+
+bool CargoSorter::SortCount(const CargoDataEntry *cd1, const CargoDataEntry *cd2) const
+{
+	uint c1 = cd1->GetCount();
+	uint c2 = cd2->GetCount();
+	if (c1 == c2) {
+		return this->SortStation(cd1->GetStation(), cd2->GetStation());
+	} else if (this->order == SO_ASCENDING) {
+		return c1 < c2;
+	} else {
+		return c2 < c1;
+	}
+}
+
+bool CargoSorter::SortStation(StationID st1, StationID st2) const
+{
+	static char buf1[MAX_LENGTH_STATION_NAME_CHARS];
+	static char buf2[MAX_LENGTH_STATION_NAME_CHARS];
+
+	if (!Station::IsValidID(st1)) {
+		return Station::IsValidID(st2) ? this->order == SO_ASCENDING : this->SortId(st1, st2);
+	} else if (!Station::IsValidID(st2)) {
+		return order == SO_DESCENDING;
+	}
+
+	SetDParam(0, st1);
+	GetString(buf1, STR_STATION_NAME, lastof(buf1));
+	SetDParam(0, st2);
+	GetString(buf2, STR_STATION_NAME, lastof(buf2));
+
+	int res = strcmp(buf1, buf2);
+	if (res == 0) {
+		return this->SortId(st1, st2);
+	} else {
+		return (this->order == SO_ASCENDING) ? res < 0 : res > 0;
+	}
+}
+
+/**
  * The StationView window
  */
 struct StationViewWindow : public Window {
-	uint32 cargo;                 ///< Bitmask of cargo types to expand
-	uint16 cargo_rows[NUM_CARGO]; ///< Header row for each cargo type
+	/**
+	 * A row being displayed in the cargo view (as opposed to being "hidden" behind a plus sign).
+	 */
+	struct RowDisplay {
+		RowDisplay(CargoDataEntry *f, StationID n) : filter(f), next_station(n) {}
+		RowDisplay(CargoDataEntry *f, CargoID n) : filter(f), next_cargo(n) {}
+
+		/**
+		 * Parent of the cargo entry belonging to the row.
+		 */
+		CargoDataEntry *filter;
+		union {
+			/**
+			 * ID of the station belonging to the entry actually displayed if it's to/from/via.
+			 */
+			StationID next_station;
+
+			/**
+			 * ID of the cargo belonging to the entry actually displayed if it's cargo.
+			 */
+			CargoID next_cargo;
+		};
+	};
+
+	typedef std::vector<RowDisplay> CargoDataVector;
+
+	static const int NUM_COLUMNS = 4; ///< Number of "columns" in the cargo view: cargo, from, via, to
+
+	/**
+	 * Type of data invalidation.
+	 */
+	enum Invalidation {
+		INV_FLOWS = 0x100, ///< The planned flows have been recalculated and everything has to be updated.
+		INV_CARGO = 0x200  ///< Some cargo has been added or removed.
+	};
+
+	/**
+	 * Type of grouping used in each of the "columns".
+	 */
+	enum Grouping {
+		GR_SOURCE,      ///< Group by source of cargo ("from").
+		GR_NEXT,        ///< Group by next station ("via").
+		GR_DESTINATION, ///< Group by estimated final destination ("to").
+		GR_CARGO,       ///< Group by cargo type.
+	};
+
+	/**
+	 * Display mode of the cargo view.
+	 */
+	enum Mode {
+		MODE_WAITING, ///< Show cargo waiting at the station.
+		MODE_PLANNED  ///< Show cargo planned to pass through the station.
+	};
+
 	uint expand_shrink_width;     ///< The width allocated to the expand/shrink 'button'
 	int rating_lines;             ///< Number of lines in the cargo ratings view.
 	int accepts_lines;            ///< Number of lines in the accepted cargo view.
@@ -832,7 +1079,31 @@
 		ALH_ACCEPTS = 3,  ///< Height of the accepted cargo view.
 	};
 
-	StationViewWindow(const WindowDesc *desc, WindowNumber window_number) : Window()
+	static const StringID _sort_names[];  ///< Names of the sorting options in the dropdown.
+	static const StringID _group_names[]; ///< Names of the grouping options in the dropdown.
+
+	/**
+	 * Sort types of the different 'columns'.
+	 * In fact only ST_COUNT and ST_AS_GROUPING are active and you can only
+	 * sort all the columns in the same way. The other options haven't been
+	 * included in the GUI due to lack of space.
+	 */
+	CargoSortType sortings[NUM_COLUMNS];
+
+	/** Sort order (ascending/descending) for the 'columns'. */
+	SortOrder sort_orders[NUM_COLUMNS];
+
+	int scroll_to_row;                  ///< If set, scroll the main viewport to the station pointed to by this row.
+	int grouping_index;                 ///< Currently selected entry in the grouping drop down.
+	Mode current_mode;                  ///< Currently selected display mode of cargo view.
+	Grouping groupings[NUM_COLUMNS];    ///< Grouping modes for the different columns.
+
+	CargoDataEntry expanded_rows;       ///< Parent entry of currently expanded rows.
+	CargoDataEntry cached_destinations; ///< Cache for the flows passing through this station.
+	CargoDataVector displayed_rows;     ///< Parent entry of currently displayed rows (including collapsed ones).
+
+	StationViewWindow(const WindowDesc *desc, WindowNumber window_number) : Window(),
+		scroll_to_row(INT_MAX), grouping_index(0)
 	{
 		this->rating_lines  = ALH_RATING;
 		this->accepts_lines = ALH_ACCEPTS;
@@ -842,6 +1113,12 @@
 		/* Nested widget tree creation is done in two steps to ensure that this->GetWidget<NWidgetCore>(WID_SV_ACCEPTS_RATINGS) exists in UpdateWidgetSize(). */
 		this->FinishInitNested(desc, window_number);
 
+		this->groupings[0] = GR_CARGO;
+		this->sortings[0] = ST_AS_GROUPING;
+		this->SelectGroupBy(_settings_client.gui.station_gui_group_order);
+		this->SelectSortBy(_settings_client.gui.station_gui_sort_by);
+		this->sort_orders[0] = SO_ASCENDING;
+		this->SelectSortOrder((SortOrder)_settings_client.gui.station_gui_sort_order);
 		Owner owner = Station::Get(window_number)->owner;
 		if (owner != OWNER_NONE) this->owner = owner;
 	}
@@ -857,12 +1134,50 @@
 		DeleteWindowById(WC_AIRCRAFT_LIST, VehicleListIdentifier(VL_STATION_LIST, VEH_AIRCRAFT, owner, this->window_number).Pack(), false);
 	}
 
+	/**
+	 * Show a certain cargo entry characterized by source/next/dest station, cargo ID and amount of cargo at the
+	 * right place in the cargo view. I.e. update as many rows as are expanded following that characterization.
+	 * @param data Root entry of the tree.
+	 * @param cargo Cargo ID of the entry to be shown.
+	 * @param source Source station of the entry to be shown.
+	 * @param next Next station the cargo to be shown will visit.
+	 * @param dest Final destination of the cargo to be shown.
+	 * @param count Amount of cargo to be shown.
+	 */
+	void ShowCargo(CargoDataEntry *data, CargoID cargo, StationID source, StationID next, StationID dest, uint count)
+	{
+		if (count == 0) return;
+		const CargoDataEntry *expand = &this->expanded_rows;
+		for (int i = 0; i < NUM_COLUMNS && expand != NULL; ++i) {
+			switch (groupings[i]) {
+				case GR_CARGO:
+					assert(i == 0);
+					data = data->InsertOrRetrieve(cargo);
+					expand = expand->Retrieve(cargo);
+					break;
+				case GR_SOURCE:
+					data = data->InsertOrRetrieve(source);
+					expand = expand->Retrieve(source);
+					break;
+				case GR_NEXT:
+					data = data->InsertOrRetrieve(next);
+					expand = expand->Retrieve(next);
+					break;
+				case GR_DESTINATION:
+					data = data->InsertOrRetrieve(dest);
+					expand = expand->Retrieve(dest);
+					break;
+			}
+		}
+		data->Update(count);
+	}
+
 	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
 	{
 		switch (widget) {
 			case WID_SV_WAITING:
 				resize->height = FONT_HEIGHT_NORMAL;
-				size->height = WD_FRAMERECT_TOP + 5 * resize->height + WD_FRAMERECT_BOTTOM;
+				size->height = WD_FRAMERECT_TOP + 4 * resize->height + WD_FRAMERECT_BOTTOM;
 				this->expand_shrink_width = max(GetStringBoundingBox("-").width, GetStringBoundingBox("+").width) + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
 				break;
 
@@ -874,20 +1189,21 @@
 
 	virtual void OnPaint()
 	{
-		CargoDataList cargolist;
-		uint32 transfers = 0;
-		this->OrderWaitingCargo(&cargolist, &transfers);
+		const Station *st = Station::Get(this->window_number);
+		CargoDataEntry cargo;
+		BuildCargoList(&cargo, st);
 
-		this->vscroll->SetCount((int)cargolist.size() + 1); // update scrollbar
+		this->vscroll->SetCount(cargo.GetNumChildren()); // update scrollbar
 
 		/* disable some buttons */
-		const Station *st = Station::Get(this->window_number);
 		this->SetWidgetDisabledState(WID_SV_RENAME,   st->owner != _local_company);
 		this->SetWidgetDisabledState(WID_SV_TRAINS,   !(st->facilities & FACIL_TRAIN));
 		this->SetWidgetDisabledState(WID_SV_ROADVEHS, !(st->facilities & FACIL_TRUCK_STOP) && !(st->facilities & FACIL_BUS_STOP));
 		this->SetWidgetDisabledState(WID_SV_SHIPS,    !(st->facilities & FACIL_DOCK));
 		this->SetWidgetDisabledState(WID_SV_PLANES,   !(st->facilities & FACIL_AIRPORT));
 
+		SetDParam(0, st->index);
+		SetDParam(1, st->facilities);
 		this->DrawWidgets();
 
 		if (!this->IsShaded()) {
@@ -910,10 +1226,20 @@
 				}
 			}
 
+			/* draw arrow pointing up/down for ascending/descending sorting */
+			this->DrawSortButtonState(WID_SV_SORT_ORDER, sort_orders[1] == SO_ASCENDING ? SBS_UP : SBS_DOWN);
+
+			int pos = this->vscroll->GetPosition();
+
+			int maxrows = this->vscroll->GetCapacity();
+
+			displayed_rows.clear();
+
 			/* Draw waiting cargo. */
 			NWidgetBase *nwi = this->GetWidget<NWidgetBase>(WID_SV_WAITING);
 			Rect waiting_rect = {nwi->pos_x, nwi->pos_y, nwi->pos_x + nwi->current_x - 1, nwi->pos_y + nwi->current_y - 1};
-			this->DrawWaitingCargo(waiting_rect, cargolist, transfers);
+			this->DrawEntries(&cargo, waiting_rect, pos, maxrows, 0);
+			scroll_to_row = INT_MAX;
 		}
 	}
 
@@ -927,119 +1253,337 @@
 	}
 
 	/**
-	 * Order waiting cargo by type and destination.
-	 * @param cargolist [out] Ordered cargo.
-	 * @param transfers [out] Bitmask for cargoes being transfered.
-	 * @pre \c *cargolist must be empty.
+	 * Rebuild the cache for estimated destinations which is used to quickly show the "destination" entries
+	 * even if we actually don't know the destination of a certain packet from just looking at it.
+	 * @param i Cargo to recalculate the cache for.
 	 */
-	void OrderWaitingCargo(CargoDataList *cargolist, uint32 *transfers)
+	void RecalcDestinations(CargoID i)
 	{
-		assert(cargolist->size() == 0);
-		*transfers = 0;
+		const Station *st = Station::Get(this->window_number);
+		CargoDataEntry *cargo_entry = cached_destinations.InsertOrRetrieve(i);
+		cargo_entry->Clear();
 
-		StationID station_id = this->window_number;
-		const Station *st = Station::Get(station_id);
+		const FlowStatMap &flows = st->goods[i].flows;
+		for (FlowStatMap::const_iterator it = flows.begin(); it != flows.end(); ++it) {
+			StationID from = it->first;
+			CargoDataEntry *source_entry = cargo_entry->InsertOrRetrieve(from);
+			const FlowStat::SharesMap *shares = it->second.GetShares();
+			uint32 prev_count = 0;
+			for (FlowStat::SharesMap::const_iterator flow_it = shares->begin(); flow_it != shares->end(); ++flow_it) {
+				StationID via = flow_it->second;
+				CargoDataEntry *via_entry = source_entry->InsertOrRetrieve(via);
+				if (via == this->window_number) {
+					via_entry->InsertOrRetrieve(via)->Update(flow_it->first - prev_count);
+				} else {
+					EstimateDestinations(i, from, via, flow_it->first - prev_count, via_entry);
+				}
+				prev_count = flow_it->first;
+			}
+		}
+	}
 
-		/* count types of cargoes waiting in station */
+	/**
+	 * Estimate the amounts of cargo per final destination for a given cargo, source station and next hop and
+	 * save the result as children of the given CargoDataEntry.
+	 * @param cargo ID of the cargo to estimate destinations for.
+	 * @param source Source station of the given batch of cargo.
+	 * @param next Intermediate hop to start the calculation at ("next hop").
+	 * @param count Size of the batch of cargo.
+	 * @param dest CargoDataEntry to save the results in.
+	 */
+	void EstimateDestinations(CargoID cargo, StationID source, StationID next, uint count, CargoDataEntry *dest)
+	{
+		if (Station::IsValidID(next) && Station::IsValidID(source)) {
+			CargoDataEntry tmp;
+			const FlowStatMap &flowmap = Station::Get(next)->goods[cargo].flows;
+			FlowStatMap::const_iterator map_it = flowmap.find(source);
+			if (map_it != flowmap.end()) {
+				const FlowStat::SharesMap *shares = map_it->second.GetShares();
+				uint32 prev_count = 0;
+				for (FlowStat::SharesMap::const_iterator i = shares->begin(); i != shares->end(); ++i) {
+					tmp.InsertOrRetrieve(i->second)->Update(i->first - prev_count);
+					prev_count = i->first;
+				}
+			}
+
+			if (tmp.GetCount() == 0) {
+				dest->InsertOrRetrieve(INVALID_STATION)->Update(count);
+			} else {
+				uint sum_estimated = 0;
+				while (sum_estimated < count) {
+					for (CargoDataSet::iterator i = tmp.Begin(); i != tmp.End() && sum_estimated < count; ++i) {
+						CargoDataEntry *child = *i;
+						uint estimate = DivideApprox(child->GetCount() * count, tmp.GetCount());
+						if (estimate == 0) estimate = 1;
+
+						sum_estimated += estimate;
+						if (sum_estimated > count) {
+							estimate -= sum_estimated - count;
+							sum_estimated = count;
+						}
+
+						if (estimate > 0) {
+							if (child->GetStation() == next) {
+								dest->InsertOrRetrieve(next)->Update(estimate);
+							} else {
+								EstimateDestinations(cargo, source, child->GetStation(), estimate, dest);
+							}
+						}
+					}
+
+				}
+			}
+		} else {
+			dest->InsertOrRetrieve(INVALID_STATION)->Update(count);
+		}
+	}
+
+	/**
+	 * Build up the cargo view for PLANNED mode and a specific cargo.
+	 * @param i Cargo to show.
+	 * @param flows The current station's flows for that cargo.
+	 * @param cargo The CargoDataEntry to save the results in.
+	 */
+	void BuildFlowList(CargoID i, const FlowStatMap &flows, CargoDataEntry *cargo)
+	{
+		const CargoDataEntry *source_dest = this->cached_destinations.Retrieve(i);
+		for (FlowStatMap::const_iterator it = flows.begin(); it != flows.end(); ++it) {
+			StationID from = it->first;
+			const CargoDataEntry *source_entry = source_dest->Retrieve(from);
+			const FlowStat::SharesMap *shares = it->second.GetShares();
+			for (FlowStat::SharesMap::const_iterator flow_it = shares->begin(); flow_it != shares->end(); ++flow_it) {
+				const CargoDataEntry *via_entry = source_entry->Retrieve(flow_it->second);
+				for (CargoDataSet::iterator dest_it = via_entry->Begin(); dest_it != via_entry->End(); ++dest_it) {
+					CargoDataEntry *dest_entry = *dest_it;
+					ShowCargo(cargo, i, from, flow_it->second, dest_entry->GetStation(), dest_entry->GetCount());
+				}
+			}
+		}
+	}
+
+	/**
+	 * Build up the cargo view for WAITING mode and a specific cargo.
+	 * @param i Cargo to show.
+	 * @param packets The current station's cargo list for that cargo.
+	 * @param cargo The CargoDataEntry to save the result in.
+	 */
+	void BuildCargoList(CargoID i, const StationCargoList &packets, CargoDataEntry *cargo)
+	{
+		const CargoDataEntry *source_dest = this->cached_destinations.Retrieve(i);
+		for (StationCargoList::ConstIterator it = packets.Packets()->begin(); it != packets.Packets()->end(); it++) {
+			const CargoPacket *cp = *it;
+			StationID next = it.GetKey();
+
+			const CargoDataEntry *source_entry = source_dest->Retrieve(cp->SourceStation());
+			if (source_entry == NULL) {
+				ShowCargo(cargo, i, cp->SourceStation(), next, INVALID_STATION, cp->Count());
+				continue;
+			}
+
+			const CargoDataEntry *via_entry = source_entry->Retrieve(next);
+			if (via_entry == NULL) {
+				ShowCargo(cargo, i, cp->SourceStation(), next, INVALID_STATION, cp->Count());
+				continue;
+			}
+
+			for (CargoDataSet::iterator dest_it = via_entry->Begin(); dest_it != via_entry->End(); ++dest_it) {
+				CargoDataEntry *dest_entry = *dest_it;
+				uint val = DivideApprox(cp->Count() * dest_entry->GetCount(), via_entry->GetCount());
+				ShowCargo(cargo, i, cp->SourceStation(), next, dest_entry->GetStation(), val);
+			}
+		}
+	}
+
+	/**
+	 * Build up the cargo view for all cargoes.
+	 * @param cargo The root cargo entry to save all results in.
+	 * @param st The station to calculate the cargo view from.
+	 */
+	void BuildCargoList(CargoDataEntry *cargo, const Station *st)
+	{
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
-			if (st->goods[i].cargo.Empty()) {
-				this->cargo_rows[i] = 0;
+
+			if (this->cached_destinations.Retrieve(i) == NULL) {
+				this->RecalcDestinations(i);
+			}
+
+			if (this->current_mode == MODE_WAITING) {
+				BuildCargoList(i, st->goods[i].cargo, cargo);
 			} else {
-				/* Add an entry for total amount of cargo of this type waiting. */
-				cargolist->push_back(CargoData(i, INVALID_STATION, st->goods[i].cargo.Count()));
+				BuildFlowList(i, st->goods[i].flows, cargo);
+			}
+		}
+	}
 
-				/* Set the row for this cargo entry for the expand/hide button */
-				this->cargo_rows[i] = (uint16)cargolist->size();
+	/**
+	 * Mark a specific row, characterized by its CargoDataEntry, as expanded.
+	 * @param data The row to be marked as expanded.
+	 */
+	void SetDisplayedRow(const CargoDataEntry *data)
+	{
+		std::list<StationID> stations;
+		const CargoDataEntry *parent = data->GetParent();
+		if (parent->GetParent() == NULL) {
+			this->displayed_rows.push_back(RowDisplay(&this->expanded_rows, data->GetCargo()));
+			return;
+		}
 
-				/* Add an entry for each distinct cargo source. */
-				const StationCargoList::List *packets = st->goods[i].cargo.Packets();
-				for (StationCargoList::ConstIterator it(packets->begin()); it != packets->end(); it++) {
-					const CargoPacket *cp = *it;
-					if (cp->SourceStation() != station_id) {
-						bool added = false;
+		StationID next = data->GetStation();
+		while (parent->GetParent()->GetParent() != NULL) {
+			stations.push_back(parent->GetStation());
+			parent = parent->GetParent();
+		}
 
-						/* Enable the expand/hide button for this cargo type */
-						SetBit(*transfers, i);
+		CargoID cargo = parent->GetCargo();
+		CargoDataEntry *filter = this->expanded_rows.Retrieve(cargo);
+		while (!stations.empty()) {
+			filter = filter->Retrieve(stations.back());
+			stations.pop_back();
+		}
 
-						/* Don't add cargo lines if not expanded */
-						if (!HasBit(this->cargo, i)) break;
+		this->displayed_rows.push_back(RowDisplay(filter, next));
+	}
 
-						/* Check if we already have this source in the list */
-						for (CargoDataList::iterator jt(cargolist->begin()); jt != cargolist->end(); jt++) {
-							CargoData *cd = &(*jt);
-							if (cd->cargo == i && cd->source == cp->SourceStation()) {
-								cd->count += cp->Count();
-								added = true;
-								break;
-							}
-						}
+	/**
+	 * Select the correct string for an entry referring to the specified station.
+	 * @param station Station the entry is showing cargo for.
+	 * @param here String to be shown if the entry refers to the same station as this station GUI belongs to.
+	 * @param other_station String to be shown if the entry refers to a specific other station.
+	 * @param any String to be shown if the entry refers to "any station".
+	 * @return One of the three given strings, depending on what station the entry refers to.
+	 */
+	StringID GetEntryString(StationID station, StringID here, StringID other_station, StringID any)
+	{
+		if (station == this->window_number) {
+			return here;
+		} else if (station != INVALID_STATION) {
+			SetDParam(2, station);
+			return other_station;
+		} else {
+			return any;
+		}
+	}
 
-						if (!added) cargolist->push_back(CargoData(i, cp->SourceStation(), cp->Count()));
-					}
+	/**
+	 * Determine if we need to show the special "non-stop" string.
+	 * @param cd Entry we are going to show.
+	 * @param station Station the entry refers to.
+	 * @param column The "column" the entry will be shown in.
+	 * @return either STR_STATION_VIEW_VIA or STR_STATION_VIEW_NONSTOP.
+	 */
+	StringID SearchNonStop(CargoDataEntry *cd, StationID station, int column)
+	{
+		CargoDataEntry *parent = cd->GetParent();
+		for (int i = column - 1; i > 0; --i) {
+			if (this->groupings[i] == GR_DESTINATION) {
+				if (parent->GetStation() == station) {
+					return STR_STATION_VIEW_NONSTOP;
+				} else {
+					return STR_STATION_VIEW_VIA;
 				}
 			}
+			parent = parent->GetParent();
 		}
+
+		if (this->groupings[column + 1] == GR_DESTINATION) {
+			CargoDataSet::iterator begin = cd->Begin();
+			CargoDataSet::iterator end = cd->End();
+			if (begin != end && ++(cd->Begin()) == end && (*(begin))->GetStation() == station) {
+				return STR_STATION_VIEW_NONSTOP;
+			} else {
+				return STR_STATION_VIEW_VIA;
+			}
+		}
+
+		return STR_STATION_VIEW_VIA;
 	}
 
 	/**
-	 * Draw waiting cargo.
-	 * @param r Rectangle of the widget.
-	 * @param cargolist Cargo, ordered by type and destination.
-	 * @param transfers Bitmask for cargoes that are transfered.
+	 * Draw the given cargo entries in the station GUI.
+	 * @param entry Root entry for all cargo to be drawn.
+	 * @param r Screen rectangle to draw into.
+	 * @param pos Current row to be drawn to (counted down from 0 to -maxrows, same as vscroll->GetPosition()).
+	 * @param maxrows Maximum row to be drawn.
+	 * @param column Current "column" being drawn.
+	 * @param cargo Current cargo being drawn (if cargo column has been passed).
+	 * @return row (in "pos" counting) after the one we have last drawn to.
 	 */
-	void DrawWaitingCargo(const Rect &r, const CargoDataList &cargolist, uint32 transfers) const
+	int DrawEntries(CargoDataEntry *entry, Rect &r, int pos, int maxrows, int column, CargoID cargo = CT_INVALID)
 	{
-		int y = r.top + WD_FRAMERECT_TOP;
-		int pos = this->vscroll->GetPosition();
-
-		const Station *st = Station::Get(this->window_number);
-		if (--pos < 0) {
-			StringID str = STR_JUST_NOTHING;
-			for (CargoID i = 0; i < NUM_CARGO; i++) {
-				if (!st->goods[i].cargo.Empty()) str = STR_EMPTY;
+		if (this->sortings[column] == ST_AS_GROUPING) {
+			if (this->groupings[column] != GR_CARGO) {
+				entry->Resort(ST_STATION_STRING, this->sort_orders[column]);
 			}
-			SetDParam(0, str);
-			DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_STATION_VIEW_WAITING_TITLE);
-			y += FONT_HEIGHT_NORMAL;
+		} else {
+			entry->Resort(ST_COUNT, this->sort_orders[column]);
 		}
+		for (CargoDataSet::iterator i = entry->Begin(); i != entry->End(); ++i) {
+			CargoDataEntry *cd = *i;
 
-		bool rtl = _current_text_dir == TD_RTL;
-		int text_left    = rtl ? r.left + this->expand_shrink_width : r.left + WD_FRAMERECT_LEFT;
-		int text_right   = rtl ? r.right - WD_FRAMERECT_LEFT : r.right - this->expand_shrink_width;
-		int shrink_left  = rtl ? r.left + WD_FRAMERECT_LEFT : r.right - this->expand_shrink_width + WD_FRAMERECT_LEFT;
-		int shrink_right = rtl ? r.left + this->expand_shrink_width - WD_FRAMERECT_RIGHT : r.right - WD_FRAMERECT_RIGHT;
+			if (this->groupings[column] == GR_CARGO) cargo = cd->GetCargo();
 
+			if (pos > -maxrows && pos <= 0) {
+				StringID str = STR_EMPTY;
+				int y = r.top + WD_FRAMERECT_TOP - pos * FONT_HEIGHT_NORMAL;
+				SetDParam(0, cargo);
+				SetDParam(1, cd->GetCount());
 
-		int maxrows = this->vscroll->GetCapacity();
-		for (CargoDataList::const_iterator it = cargolist.begin(); it != cargolist.end() && pos > -maxrows; ++it) {
-			if (--pos < 0) {
-				const CargoData *cd = &(*it);
-				if (cd->source == INVALID_STATION) {
-					/* Heading */
-					DrawCargoIcons(cd->cargo, cd->count, r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y);
-					SetDParam(0, cd->cargo);
-					SetDParam(1, cd->count);
-					if (HasBit(transfers, cd->cargo)) {
-						/* This cargo has transfers waiting so show the expand or shrink 'button' */
-						const char *sym = HasBit(this->cargo, cd->cargo) ? "-" : "+";
-						DrawString(text_left, text_right, y, STR_STATION_VIEW_WAITING_CARGO, TC_FROMSTRING, SA_RIGHT);
-						DrawString(shrink_left, shrink_right, y, sym, TC_YELLOW, SA_RIGHT);
-					} else {
-						DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_STATION_VIEW_WAITING_CARGO, TC_FROMSTRING, SA_RIGHT);
+				if (this->groupings[column] == GR_CARGO) {
+					str = STR_STATION_VIEW_WAITING_CARGO;
+					DrawCargoIcons(cd->GetCargo(), cd->GetCount(), r.left + WD_FRAMERECT_LEFT + this->expand_shrink_width, r.right - WD_FRAMERECT_RIGHT - this->expand_shrink_width, y);
+				} else {
+					StationID station = cd->GetStation();
+
+					switch (this->groupings[column]) {
+						case GR_SOURCE:
+							str = this->GetEntryString(station, STR_STATION_VIEW_FROM_HERE, STR_STATION_VIEW_FROM, STR_STATION_VIEW_FROM_ANY);
+							break;
+						case GR_NEXT:
+							str = this->GetEntryString(station, STR_STATION_VIEW_VIA_HERE, STR_STATION_VIEW_VIA, STR_STATION_VIEW_VIA_ANY);
+							if (str == STR_STATION_VIEW_VIA) str = SearchNonStop(cd, station, column);
+							break;
+						case GR_DESTINATION:
+							str = this->GetEntryString(station, STR_STATION_VIEW_TO_HERE, STR_STATION_VIEW_TO, STR_STATION_VIEW_TO_ANY);
+							break;
+						default:
+							NOT_REACHED();
 					}
-				} else {
-					SetDParam(0, cd->cargo);
-					SetDParam(1, cd->count);
-					SetDParam(2, cd->source);
-					DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_STATION_VIEW_EN_ROUTE_FROM, TC_FROMSTRING, SA_RIGHT);
+					if (pos == -this->scroll_to_row && Station::IsValidID(station)) {
+						ScrollMainWindowToTile(Station::Get(station)->xy);
+					}
 				}
 
-				y += FONT_HEIGHT_NORMAL;
+				bool rtl = _current_text_dir == TD_RTL;
+				int text_left    = rtl ? r.left + this->expand_shrink_width : r.left + WD_FRAMERECT_LEFT + column * this->expand_shrink_width;
+				int text_right   = rtl ? r.right - WD_FRAMERECT_LEFT - column * this->expand_shrink_width : r.right - this->expand_shrink_width;
+				int shrink_left  = rtl ? r.left + WD_FRAMERECT_LEFT : r.right - this->expand_shrink_width + WD_FRAMERECT_LEFT;
+				int shrink_right = rtl ? r.left + this->expand_shrink_width - WD_FRAMERECT_RIGHT : r.right - WD_FRAMERECT_RIGHT;
+
+				DrawString(text_left, text_right, y, str);
+
+				if (column < NUM_COLUMNS - 1) {
+					const char *sym = cd->GetNumChildren() > 0 ? "-" : "+";
+					DrawString(shrink_left, shrink_right, y, sym, TC_YELLOW);
+				}
+				SetDisplayedRow(cd);
 			}
+			pos = DrawEntries(cd, r, --pos, maxrows, column + 1, cargo);
 		}
+		return pos;
 	}
 
 	/**
+	 * Invalidate the cache for the given cargo.
+	 * @param cargo ID of the cargo.
+	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+	 */
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		if (!gui_scope) return;
+		this->cached_destinations.Remove((CargoID)data);
+	}
+
+	/**
 	 * Draw accepted cargo in the #WID_SV_ACCEPT_RATING_LIST widget.
 	 * @param r Rectangle of the widget.
 	 * @return Number of lines needed for drawing the accepted cargo.
@@ -1076,32 +1620,55 @@
 			if (!HasBit(ge->acceptance_pickup, GoodsEntry::GES_PICKUP)) continue;
 
 			SetDParam(0, cs->name);
-			SetDParam(2, ToPercent8(ge->rating));
-			SetDParam(1, STR_CARGO_RATING_APPALLING + (ge->rating >> 5));
-			DrawString(r.left + WD_FRAMERECT_LEFT + 6, r.right - WD_FRAMERECT_RIGHT - 6, y, STR_STATION_VIEW_CARGO_RATING);
+			SetDParam(1, ge->supply);
+			SetDParam(3, ToPercent8(ge->rating));
+			SetDParam(2, STR_CARGO_RATING_APPALLING + (ge->rating >> 5));
+			DrawString(r.left + WD_FRAMERECT_LEFT + 6, r.right - WD_FRAMERECT_RIGHT - 6, y, STR_STATION_VIEW_CARGO_SUPPLY_RATING);
 			y += FONT_HEIGHT_NORMAL;
 		}
 		return CeilDiv(y - r.top - WD_FRAMERECT_TOP, FONT_HEIGHT_NORMAL);
 	}
 
+	/**
+	 * Expand or collapse a specific row.
+	 * @param filter Parent of the row.
+	 * @param next ID pointing to the row.
+	 */
+	template<class ID>
+	void HandleCargoWaitingClick(CargoDataEntry *filter, ID next)
+	{
+		if (filter->Retrieve(next) != NULL) {
+			filter->Remove(next);
+		} else {
+			filter->InsertOrRetrieve(next);
+		}
+	}
+
+	/**
+	 * Handle a click on a specific row in the cargo view.
+	 * @param row Row being clicked.
+	 */
 	void HandleCargoWaitingClick(int row)
 	{
-		if (row == 0) return;
-
-		for (CargoID c = 0; c < NUM_CARGO; c++) {
-			if (this->cargo_rows[c] == row) {
-				ToggleBit(this->cargo, c);
-				this->SetWidgetDirty(WID_SV_WAITING);
-				break;
+		if (row < 0 || (uint)row >= this->displayed_rows.size()) return;
+		if (_ctrl_pressed) {
+			this->scroll_to_row = row;
+		} else {
+			RowDisplay &display = this->displayed_rows[row];
+			if (display.filter == &this->expanded_rows) {
+				this->HandleCargoWaitingClick<CargoID>(display.filter, display.next_cargo);
+			} else {
+				this->HandleCargoWaitingClick<StationID>(display.filter, display.next_station);
 			}
 		}
+		this->SetWidgetDirty(WID_SV_WAITING);
 	}
 
 	virtual void OnClick(Point pt, int widget, int click_count)
 	{
 		switch (widget) {
 			case WID_SV_WAITING:
-				this->HandleCargoWaitingClick(this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_SV_WAITING, WD_FRAMERECT_TOP, FONT_HEIGHT_NORMAL));
+				this->HandleCargoWaitingClick(this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_SV_WAITING, WD_FRAMERECT_TOP, FONT_HEIGHT_NORMAL) - this->vscroll->GetPosition());
 				break;
 
 			case WID_SV_LOCATION:
@@ -1139,9 +1706,122 @@
 			case WID_SV_PLANES:   // Show list of scheduled aircraft to this station
 				ShowVehicleListWindow(this->owner, (VehicleType)(widget - WID_SV_TRAINS), (StationID)this->window_number);
 				break;
+
+			case WID_SV_SORT_BY: {
+				ShowDropDownMenu(this, _sort_names, this->current_mode, WID_SV_SORT_BY, 0, 0);
+				break;
+			}
+
+			case WID_SV_GROUP_BY: {
+				ShowDropDownMenu(this, _group_names, this->grouping_index, WID_SV_GROUP_BY, 0, 0);
+				break;
+			}
+
+			case WID_SV_SORT_ORDER: { // flip sorting method asc/desc
+				this->SelectSortOrder(this->sort_orders[1] == SO_ASCENDING ? SO_DESCENDING : SO_ASCENDING);
+				this->SetTimeout();
+				this->LowerWidget(WID_SV_SORT_ORDER);
+				break;
+			}
 		}
 	}
 
+	/**
+	 * Select a new sort order for the cargo view.
+	 * @param order New sort order.
+	 */
+	void SelectSortOrder(SortOrder order)
+	{
+		this->sort_orders[1] = this->sort_orders[2] = this->sort_orders[3] = order;
+		_settings_client.gui.station_gui_sort_order = this->sort_orders[1];
+		this->SetDirty();
+	}
+
+	/**
+	 * Select a new sort criterium for the cargo view.
+	 * @param index Row being selected in the sort criteria drop down.
+	 */
+	void SelectSortBy(int index)
+	{
+		_settings_client.gui.station_gui_sort_by = index;
+		switch (_sort_names[index]) {
+			case STR_STATION_VIEW_WAITING_STATION:
+				this->current_mode = MODE_WAITING;
+				this->sortings[1] = this->sortings[2] = this->sortings[3] = ST_AS_GROUPING;
+				break;
+			case STR_STATION_VIEW_WAITING_AMOUNT:
+				this->current_mode = MODE_WAITING;
+				this->sortings[1] = this->sortings[2] = this->sortings[3] = ST_COUNT;
+				break;
+			case STR_STATION_VIEW_PLANNED_STATION:
+				this->current_mode = MODE_PLANNED;
+				this->sortings[1] = this->sortings[2] = this->sortings[3] = ST_AS_GROUPING;
+				break;
+			case STR_STATION_VIEW_PLANNED_AMOUNT:
+				this->current_mode = MODE_PLANNED;
+				this->sortings[1] = this->sortings[2] = this->sortings[3] = ST_COUNT;
+				break;
+			default:
+				NOT_REACHED();
+		}
+		/* Display the current sort variant */
+		this->GetWidget<NWidgetCore>(WID_SV_SORT_BY)->widget_data = _sort_names[index];
+		this->SetDirty();
+	}
+
+	/**
+	 * Select a new grouping mode for the cargo view.
+	 * @param index Row being selected in the grouping drop down.
+	 */
+	void SelectGroupBy(int index)
+	{
+		this->grouping_index = index;
+		_settings_client.gui.station_gui_group_order = index;
+		this->GetWidget<NWidgetCore>(WID_SV_GROUP_BY)->widget_data = _group_names[index];
+		switch (_group_names[index]) {
+			case STR_STATION_VIEW_GROUP_S_V_D:
+				this->groupings[1] = GR_SOURCE;
+				this->groupings[2] = GR_NEXT;
+				this->groupings[3] = GR_DESTINATION;
+				break;
+			case STR_STATION_VIEW_GROUP_S_D_V:
+				this->groupings[1] = GR_SOURCE;
+				this->groupings[2] = GR_DESTINATION;
+				this->groupings[3] = GR_NEXT;
+				break;
+			case STR_STATION_VIEW_GROUP_V_S_D:
+				this->groupings[1] = GR_NEXT;
+				this->groupings[2] = GR_SOURCE;
+				this->groupings[3] = GR_DESTINATION;
+				break;
+			case STR_STATION_VIEW_GROUP_V_D_S:
+				this->groupings[1] = GR_NEXT;
+				this->groupings[2] = GR_DESTINATION;
+				this->groupings[3] = GR_SOURCE;
+				break;
+			case STR_STATION_VIEW_GROUP_D_S_V:
+				this->groupings[1] = GR_DESTINATION;
+				this->groupings[2] = GR_SOURCE;
+				this->groupings[3] = GR_NEXT;
+				break;
+			case STR_STATION_VIEW_GROUP_D_V_S:
+				this->groupings[1] = GR_DESTINATION;
+				this->groupings[2] = GR_NEXT;
+				this->groupings[3] = GR_SOURCE;
+				break;
+		}
+		this->SetDirty();
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		if (widget == WID_SV_SORT_BY) {
+			this->SelectSortBy(index);
+		} else {
+			this->SelectGroupBy(index);
+		}
+	}
+
 	virtual void OnQueryTextFinished(char *str)
 	{
 		if (str == NULL) return;
@@ -1155,9 +1835,26 @@
 	}
 };
 
+const StringID StationViewWindow::_sort_names[] = {
+	STR_STATION_VIEW_WAITING_STATION,
+	STR_STATION_VIEW_WAITING_AMOUNT,
+	STR_STATION_VIEW_PLANNED_STATION,
+	STR_STATION_VIEW_PLANNED_AMOUNT,
+	INVALID_STRING_ID
+};
 
+const StringID StationViewWindow::_group_names[] = {
+	STR_STATION_VIEW_GROUP_S_V_D,
+	STR_STATION_VIEW_GROUP_S_D_V,
+	STR_STATION_VIEW_GROUP_V_S_D,
+	STR_STATION_VIEW_GROUP_V_D_S,
+	STR_STATION_VIEW_GROUP_D_S_V,
+	STR_STATION_VIEW_GROUP_D_V_S,
+	INVALID_STRING_ID
+};
+
 static const WindowDesc _station_view_desc(
-	WDP_AUTO, 249, 110,
+	WDP_AUTO, 249, 117,
 	WC_STATION_VIEW, WC_NONE,
 	WDF_UNCLICK_BUTTONS,
 	_nested_station_view_widgets, lengthof(_nested_station_view_widgets)
Index: src/newgrf.h
===================================================================
--- src/newgrf.h	(revision 24093)
+++ src/newgrf.h	(working copy)
@@ -192,4 +192,6 @@
 StringID MapGRFStringID(uint32 grfid, StringID str);
 void ShowNewGRFError();
 
+struct TemplateVehicle;
+
 #endif /* NEWGRF_H */
Index: src/texteff.cpp
===================================================================
--- src/texteff.cpp	(revision 24093)
+++ src/texteff.cpp	(working copy)
@@ -20,6 +20,7 @@
 /** Container for all information about a text effect */
 struct TextEffect : public ViewportSign {
 	uint64 params_1;     ///< DParam parameter
+	uint64 params_2;     ///< second DParam parameter
 	StringID string_id;  ///< String to draw for the text effect, if INVALID_STRING_ID then it's not valid
 	uint8 duration;      ///< How long the text effect should stay, in ticks (applies only when mode == TE_RISING)
 	TextEffectMode mode; ///< Type of text effect
@@ -52,6 +53,7 @@
 	te->string_id = msg;
 	te->duration = duration;
 	te->params_1 = GetDParam(0);
+	te->params_2 = GetDParam(1);
 	te->mode = mode;
 
 	/* Make sure we only dirty the new area */
@@ -68,6 +70,7 @@
 	if (msg == te->string_id && GetDParam(0) == te->params_1) return;
 	te->string_id = msg;
 	te->params_1 = GetDParam(0);
+	te->params_2 = GetDParam(1);
 
 	te->UpdatePosition(te->center, te->top, msg);
 }
@@ -109,7 +112,7 @@
 	for (TextEffect *te = _text_effects.Begin(); te != end; te++) {
 		if (te->string_id == INVALID_STRING_ID) continue;
 		if (te->mode == TE_RISING || (_settings_client.gui.loading_indicators && !IsTransparencySet(TO_LOADING))) {
-			ViewportAddString(dpi, ZOOM_LVL_OUT_8X, te, te->string_id, te->string_id - 1, 0, te->params_1);
+			ViewportAddString(dpi, ZOOM_LVL_OUT_8X, te, te->string_id, te->string_id - 1, 0, te->params_1, te->params_2);
 		}
 	}
 }
Index: src/cargopacket.h
===================================================================
--- src/cargopacket.h	(revision 24093)
+++ src/cargopacket.h	(working copy)
@@ -15,8 +15,11 @@
 #include "core/pool_type.hpp"
 #include "economy_type.h"
 #include "station_type.h"
+#include "order_type.h"
 #include "cargo_type.h"
+#include "cargotype.h"
 #include "vehicle_type.h"
+#include "core/multimap.hpp"
 #include <list>
 
 /** Unique identifier for a single cargo packet. */
@@ -28,7 +31,9 @@
 /** The actual pool with cargo packets. */
 extern CargoPacketPool _cargopacket_pool;
 
-template <class Tinst> class CargoList;
+template <class Tinst, class Tcont> class CargoList;
+class StationCargoList; // forward-declare, so we can use it in VehicleCargoList::Unreserve
+class VehicleCargoList; // forward-declare, so we can use it in CargoList::MovePacket
 extern const struct SaveLoad *GetCargoPacketDesc();
 
 /**
@@ -46,7 +51,7 @@
 	TileIndex loaded_at_xy;     ///< Location where this cargo has been loaded into the vehicle.
 
 	/** The CargoList caches, thus needs to know about it. */
-	template <class Tinst> friend class CargoList;
+	template <class Tinst, class Tcont> friend class CargoList;
 	friend class VehicleCargoList;
 	friend class StationCargoList;
 	/** We want this to be saved, right? */
@@ -140,7 +145,6 @@
 		return this->loaded_at_xy;
 	}
 
-
 	static void InvalidateAllFrom(SourceType src_type, SourceID src);
 	static void InvalidateAllFrom(StationID sid);
 	static void AfterLoad();
@@ -159,38 +163,46 @@
  */
 #define FOR_ALL_CARGOPACKETS(var) FOR_ALL_CARGOPACKETS_FROM(var, 0)
 
+/** Kind of actions that could be done with packets on unloading */
+enum UnloadType {
+	UL_KEEP     = 0,      ///< keep cargo on vehicle
+	UL_DELIVER  = 1 << 0, ///< deliver cargo
+	UL_TRANSFER = 1 << 1, ///< transfer cargo
+	UL_ACCEPTED = 1 << 2, ///< cargo is accepted
+};
+
 /**
  * Simple collection class for a list of cargo packets.
  * @tparam Tinst Actual instantation of this cargo list.
  */
-template <class Tinst>
+template <class Tinst, class Tcont>
 class CargoList {
 public:
-	/** Container with cargo packets. */
-	typedef std::list<CargoPacket *> List;
-	/** The iterator for our container. */
-	typedef List::iterator Iterator;
-	/** The const iterator for our container. */
-	typedef List::const_iterator ConstIterator;
+	/** Iterator for our container. */
+	typedef typename Tcont::iterator Iterator;
+	/** Const iterator for our container. */
+	typedef typename Tcont::const_iterator ConstIterator;
+	/** Reverse iterator for our container. */
+	typedef typename Tcont::reverse_iterator ReverseIterator;
+	/** Const reverse iterator for our container. */
+	typedef typename Tcont::const_reverse_iterator ConstReverseIterator;
 
-	/** Kind of actions that could be done with packets on move. */
-	enum MoveToAction {
-		MTA_FINAL_DELIVERY, ///< "Deliver" the packet to the final destination, i.e. destroy the packet.
-		MTA_CARGO_LOAD,     ///< Load the packet onto a vehicle, i.e. set the last loaded station ID.
-		MTA_TRANSFER,       ///< The cargo is moved as part of a transfer.
-		MTA_UNLOAD,         ///< The cargo is moved as part of a forced unload.
-	};
-
 protected:
 	uint count;                 ///< Cache for the number of cargo entities.
 	uint cargo_days_in_transit; ///< Cache for the sum of number of days in transit of each entity; comparable to man-hours.
 
-	List packets;               ///< The cargo packets in this list.
+	Tcont packets;              ///< The cargo packets in this list.
 
 	void AddToCache(const CargoPacket *cp);
 
 	void RemoveFromCache(const CargoPacket *cp);
 
+	CargoPacket *RemovePacket(Iterator &it, uint cap, TileIndex load_place = INVALID_TILE);
+
+	uint MovePacket(StationCargoList *dest, StationID next, Iterator &it, uint cap);
+
+	uint MovePacket(VehicleCargoList *dest, Iterator &it, uint cap, TileIndex load_place = INVALID_TILE, bool reserved = false);
+
 public:
 	/** Create the cargo list. */
 	CargoList() {}
@@ -203,7 +215,7 @@
 	 * Returns a pointer to the cargo packet list (so you can iterate over it etc).
 	 * @return Pointer to the packet list.
 	 */
-	inline const List *Packets() const
+	inline const Tcont *Packets() const
 	{
 		return &this->packets;
 	}
@@ -227,15 +239,6 @@
 	}
 
 	/**
-	 * Returns source of the first cargo packet in this list.
-	 * @return The before mentioned source.
-	 */
-	inline StationID Source() const
-	{
-		return this->Empty() ? INVALID_STATION : this->packets.front()->source;
-	}
-
-	/**
 	 * Returns average number of days in transit for a cargo entity.
 	 * @return The before mentioned number.
 	 */
@@ -244,35 +247,44 @@
 		return this->count == 0 ? 0 : this->cargo_days_in_transit / this->count;
 	}
 
-
-	void Append(CargoPacket *cp);
 	void Truncate(uint max_remaining);
 
-	template <class Tother_inst>
-	bool MoveTo(Tother_inst *dest, uint count, MoveToAction mta, CargoPayment *payment, uint data = 0);
-
 	void InvalidateCache();
 };
 
+typedef std::list<CargoPacket *> CargoPacketList;
+
 /**
  * CargoList that is used for vehicles.
  */
-class VehicleCargoList : public CargoList<VehicleCargoList> {
+class VehicleCargoList : public CargoList<VehicleCargoList, CargoPacketList> {
 protected:
+	uint TransferPacket(Iterator &c, uint remaining_unload, StationCargoList *dest, CargoPayment *payment, StationID next);
+	uint DeliverPacket(Iterator &c, uint remaining_unload, CargoPayment *payment);
+	uint KeepPacket(Iterator &c);
+
 	/** The (direct) parent of this class. */
-	typedef CargoList<VehicleCargoList> Parent;
+	typedef CargoList<VehicleCargoList, CargoPacketList> Parent;
 
-	Money feeder_share; ///< Cache for the feeder share.
+	CargoPacketList reserved; ///< Packets reserved for unloading in this list.
+	Money feeder_share;       ///< Cache for the feeder share.
+	uint reserved_count;      ///< Cache for the number of reserved cargo entities.
 
 	void AddToCache(const CargoPacket *cp);
 	void RemoveFromCache(const CargoPacket *cp);
 
 public:
+	/** The station cargo list needs to control the unloading. */
+	friend class StationCargoList;
 	/** The super class ought to know what it's doing. */
-	friend class CargoList<VehicleCargoList>;
+	friend class CargoList<VehicleCargoList, CargoPacketList>;
 	/** The vehicles have a cargo list (and we want that saved). */
 	friend const struct SaveLoad *GetVehicleDescription(VehicleType vt);
 
+	~VehicleCargoList();
+
+	void OnCleanPool();
+
 	/**
 	 * Returns total sum of the feeder share for all packets.
 	 * @return The before mentioned number.
@@ -282,10 +294,68 @@
 		return this->feeder_share;
 	}
 
+	void Append(CargoPacket *cp, bool update_cache = true);
+
+	/**
+	 * Returns sum of cargo on board the vehicle (ie not only
+	 * reserved).
+	 * @return Cargo on board the vehicle.
+	 */
+	inline uint OnboardCount() const
+	{
+		return this->count - this->reserved_count;
+	}
+
+	/**
+	 * Returns sum of cargo reserved for the vehicle.
+	 * @return Cargo reserved for the vehicle.
+	 */
+	inline uint ReservedCount() const
+	{
+		return this->reserved_count;
+	}
+
+	/**
+	 * Returns a pointer to the reserved cargo list.
+	 * @return Pointer to the reserved list.
+	 */
+	inline const CargoPacketList *Reserved() const
+	{
+		return &this->reserved;
+	}
+
+	/**
+	 * Returns source of the first cargo packet in this list.
+	 * If the regular packets list is empty but there are packets
+	 * in the reservation list it returns the source of the first
+	 * reserved packet.
+	 * @return The before mentioned source.
+	 */
+	inline StationID Source() const
+	{
+		if (this->Empty()) {
+			return INVALID_STATION;
+		} else if (this->packets.empty()) {
+			return this->reserved.front()->source;
+		} else {
+			return this->packets.front()->source;
+		}
+	}
+
+	void Reserve(CargoPacket *cp);
+
+	void Unreserve(StationID next, StationCargoList *dest);
+
+	uint LoadReserved(uint count);
+
+	void SwapReserved();
+
 	void AgeCargo();
 
 	void InvalidateCache();
 
+	uint MoveTo(VehicleCargoList *dest, uint cap);
+
 	/**
 	 * Are two the two CargoPackets mergeable in the context of
 	 * a list of CargoPackets for a Vehicle?
@@ -303,16 +373,21 @@
 	}
 };
 
+typedef MultiMap<StationID, CargoPacket *> StationCargoPacketMap;
+typedef std::map<StationID, uint> StationCargoAmountMap;
+
 /**
  * CargoList that is used for stations.
  */
-class StationCargoList : public CargoList<StationCargoList> {
+class StationCargoList : public CargoList<StationCargoList, StationCargoPacketMap> {
 public:
 	/** The super class ought to know what it's doing. */
-	friend class CargoList<StationCargoList>;
+	friend class CargoList<StationCargoList, StationCargoPacketMap>;
 	/** The stations, via GoodsEntry, have a CargoList. */
 	friend const struct SaveLoad *GetGoodsDesc();
 
+	StationCargoList() : station(NULL), cargo(INVALID_CARGO) {}
+
 	/**
 	 * Are two the two CargoPackets mergeable in the context of
 	 * a list of CargoPackets for a Vehicle?
@@ -327,6 +402,40 @@
 				cp1->source_type     == cp2->source_type &&
 				cp1->source_id       == cp2->source_id;
 	}
+
+	uint TakeFrom(VehicleCargoList *source, uint max_unload, OrderUnloadFlags flags, StationID next_station, bool has_stopped, CargoPayment *payment);
+
+	uint MoveTo(VehicleCargoList *dest, uint cap, StationID next_station, bool reserve = false);
+
+	void Append(StationID next, CargoPacket *cp);
+
+	void RerouteStalePackets(StationID to);
+
+	void CountAndTruncate(uint max_remaining, StationCargoAmountMap &cargo_per_source);
+
+	/**
+	 * Returns source of the first cargo packet in this list.
+	 * @return The before mentioned source.
+	 */
+	inline StationID Source() const
+	{
+		return this->Empty() ? INVALID_STATION : this->packets.begin()->second.front()->source;
+	}
+
+	void AssignTo(Station *station, CargoID cargo);
+
+	static void InvalidateAllFrom(SourceType src_type, SourceID src);
+
+protected:
+	Station *station; ///< Station this cargo list belongs to.
+	CargoID cargo;    ///< Cargo type this list holds.
+
+	byte GetUnloadFlags(OrderUnloadFlags order_flags);
+
+	UnloadType WillUnloadOld(byte flags, StationID source);
+	UnloadType WillUnloadCargoDist(byte flags, StationID next_station, StationID via, StationID source);
+
+	uint MovePackets(VehicleCargoList *dest, uint cap, Iterator begin, Iterator end, bool reserve);
 };
 
 #endif /* CARGOPACKET_H */
Index: src/vehicle_gui.h
===================================================================
--- src/vehicle_gui.h	(revision 24093)
+++ src/vehicle_gui.h	(working copy)
@@ -19,7 +19,7 @@
 #include "engine_type.h"
 #include "company_type.h"
 
-void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit = false);
+void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit = false, bool is_virtual_train = false);
 
 /** The tabs in the train details window */
 enum TrainDetailsWindowTabs {
Index: src/aaa_template_vehicle_func.h
===================================================================
--- src/aaa_template_vehicle_func.h	(revision 0)
+++ src/aaa_template_vehicle_func.h	(revision 0)
@@ -0,0 +1,68 @@
+// template_vehicle_func.h
+#ifndef TEMPLATE_VEHICLE_FUNC_H
+#define TEMPLATE_VEHICLE_FUNC_H
+
+#include "stdafx.h"
+#include "window_gui.h"
+
+#include "aaa_template_vehicle.h"
+
+static bool REPLACEMENT_IN_PROGRESS = false;
+
+//void DrawTemplateVehicle(TemplateVehicle*, int, const Rect&);
+void DrawTemplateVehicle(const TemplateVehicle*, int, int, int, VehicleID, int, VehicleID);
+
+void BuildTemplateGuiList(GUITemplateList*, Scrollbar*, Owner, RailType);
+
+Money CalculateOverallTemplateCost(const TemplateVehicle*);
+
+void DrawTemplateTrain(const TemplateVehicle*, int, int, int);
+
+SpriteID GetSpriteID(EngineID, bool);
+
+void DrawTemplate(const TemplateVehicle*, int, int, int);
+
+int GetTemplateDisplayImageWidth(EngineID);
+
+TemplateVehicle *CreateNewTemplateVehicle(EngineID);
+
+void setupVirtTrain(const TemplateVehicle*, Train*);
+
+TemplateVehicle* TemplateVehicleFromVirtualTrain(Train*);
+
+Train* VirtualTrainFromTemplateVehicle(TemplateVehicle*);
+
+inline TemplateVehicle* Last(TemplateVehicle*);
+
+TemplateVehicle *DeleteTemplateVehicle(TemplateVehicle*);
+
+Train* DeleteVirtualTrainPart(Train*, Train*);
+Train* DeleteVirtualTrain(Train*, Train *);
+
+CommandCost CmdTemplateReplaceVehicle(Train*, bool, DoCommandFlag);
+
+void pat();
+void pav();
+void ptv(TemplateVehicle*);
+void pvt(const Train*);
+// for testing
+TemplateVehicle* GetTemplateVehicleByGroupID(GroupID);
+bool ChainContainsVehicle(Train*, Train*);
+Train* ChainContainsEngine(EngineID, Train*);
+Train* DepotContainsEngine(TileIndex, EngineID, Train*);
+
+int NumTrainsNeedTemplateReplacement(GroupID, TemplateVehicle*);
+
+CommandCost TestBuyAllTemplateVehiclesInChain(Train*);
+CommandCost CalculateTemplateReplacementCost(Train*);
+
+short CountEnginesInChain(Train*);
+
+bool TemplateVehicleContainsEngineOfRailtype(const TemplateVehicle*, RailType);
+
+Train* CloneVirtualTrainFromTrain(const Train *);
+TemplateVehicle* CloneTemplateVehicleFromTrain(const Train *);
+
+void TransferCargoForTrain(Train*, Train*, bool);
+
+#endif
Index: src/economy_base.h
===================================================================
--- src/economy_base.h	(revision 24093)
+++ src/economy_base.h	(working copy)
@@ -24,9 +24,10 @@
  * Helper class to perform the cargo payment.
  */
 struct CargoPayment : CargoPaymentPool::PoolItem<&_cargo_payment_pool> {
-	Vehicle *front;      ///< The front vehicle to do the payment of
-	Money route_profit;  ///< The amount of money to add/remove from the bank account
-	Money visual_profit; ///< The visual profit to show
+	Vehicle *front;        ///< The front vehicle to do the payment of
+	Money route_profit;    ///< The amount of money to add/remove from the bank account
+	Money visual_profit;   ///< The visual profit to show
+	Money visual_transfer; ///< The transfer credits to be shown
 
 	/* Unsaved variables */
 	Company *owner;            ///< The owner of the vehicle
Index: src/economy.cpp
===================================================================
--- src/economy.cpp	(revision 24093)
+++ src/economy.cpp	(working copy)
@@ -42,6 +42,7 @@
 #include "economy_base.h"
 #include "core/pool_func.hpp"
 #include "core/backup_type.hpp"
+#include "cargo_type.h"
 #include "water.h"
 #include "game/game.hpp"
 
@@ -1081,21 +1082,23 @@
 
 	this->front->cargo_payment = NULL;
 
-	if (this->visual_profit == 0) return;
+	if (this->visual_profit == 0 && this->visual_transfer == 0) return;
 
 	Backup<CompanyByte> cur_company(_current_company, this->front->owner, FILE_LINE);
 
 	SubtractMoneyFromCompany(CommandCost(this->front->GetExpenseType(true), -this->route_profit));
-	this->front->profit_this_year += this->visual_profit << 8;
+	this->front->profit_this_year += (this->visual_profit + this->visual_transfer) << 8;
 
-	if (this->route_profit != 0) {
-		if (IsLocalCompany() && !PlayVehicleSound(this->front, VSE_LOAD_UNLOAD)) {
-			SndPlayVehicleFx(SND_14_CASHTILL, this->front);
-		}
+	if (this->route_profit != 0 && IsLocalCompany() && !PlayVehicleSound(this->front, VSE_LOAD_UNLOAD)) {
+		SndPlayVehicleFx(SND_14_CASHTILL, this->front);
+	}
 
-		ShowCostOrIncomeAnimation(this->front->x_pos, this->front->y_pos, this->front->z_pos, -this->visual_profit);
-	} else {
-		ShowFeederIncomeAnimation(this->front->x_pos, this->front->y_pos, this->front->z_pos, this->visual_profit);
+	if (this->visual_transfer != 0) {
+		ShowFeederIncomeAnimation(this->front->x_pos, this->front->y_pos,
+				this->front->z_pos, this->visual_transfer, -this->visual_profit);
+	} else if (this->visual_profit != 0) {
+		ShowCostOrIncomeAnimation(this->front->x_pos, this->front->y_pos,
+				this->front->z_pos, -this->visual_profit);
 	}
 
 	cur_company.Restore();
@@ -1137,23 +1140,27 @@
 
 	profit = profit * _settings_game.economy.feeder_payment_share / 100;
 
-	this->visual_profit += profit; // accumulate transfer profits for whole vehicle
+	this->visual_transfer += profit; // accumulate transfer profits for whole vehicle
 	return profit; // account for the (virtual) profit already made for the cargo packet
 }
 
 /**
  * Prepare the vehicle to be unloaded.
+ * @param curr_station the station where the consist is at the moment
  * @param front_v the vehicle to be unloaded
  */
 void PrepareUnload(Vehicle *front_v)
 {
+	Station *curr_station = Station::Get(front_v->last_station_visited);
+	curr_station->loading_vehicles.push_back(front_v);
+
 	/* At this moment loading cannot be finished */
 	ClrBit(front_v->vehicle_flags, VF_LOADING_FINISHED);
 
-	/* Start unloading in at the first possible moment */
+	/* Start unloading at the first possible moment */
 	front_v->load_unload_ticks = 1;
 
-	if ((front_v->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
+	if (front_v->orders.list == NULL || (front_v->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
 		for (Vehicle *v = front_v; v != NULL; v = v->Next()) {
 			if (v->cargo_cap > 0 && !v->cargo.Empty()) {
 				SetBit(v->vehicle_flags, VF_CARGO_UNLOADING);
@@ -1170,6 +1177,53 @@
 }
 
 /**
+ * Reserves cargo if the full load order and improved_load is set.
+ * @param st The station where the consist is loading at the moment.
+ * @param u The front of the loading vehicle consist.
+ * @param next_station Station the vehicle will stop at next.
+ * @return Bit field for the cargo classes with bits for the reserved cargos set (if anything was reserved).
+ */
+uint32 ReserveConsist(Station *st, Vehicle *u, StationID next_station)
+{
+	uint32 ret = 0;
+	if (_settings_game.order.improved_load && (u->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
+		/* Update reserved cargo */
+		for (Vehicle *v = u; v != NULL; v = v->Next()) {
+			/* Only reserve if the vehicle is not unloading anymore.
+			 *
+			 * The packets that are kept in the vehicle because they have the
+			 * same destination as the vehicle are stored in the reservation
+			 * list while unloading for performance reasons. The reservation
+			 * list is swapped with the onboard list after unloading. This
+			 * doesn't increase the load/unload time. So if we start reserving
+			 * cargo before unloading has stopped we'll load that cargo for free
+			 * later. Like this there is a slightly increased probability that
+			 * another vehicle which has arrived later loads cargo that should
+			 * be loaded by this vehicle but as the algorithm isn't perfect in
+			 * that regard anyway we can tolerate it.
+			 *
+			 * The algorithm isn't perfect as it only counts free capacity for
+			 * reservation. If another vehicle arrives later but unloads faster
+			 * than this one, this vehicle won't reserve all the cargo it may
+			 * be able to take after fully unloading. So the other vehicle may
+			 * load it even if it has arrived later.
+			 */
+			if (HasBit(v->vehicle_flags, VF_CARGO_UNLOADING)) continue;
+
+			int cap = v->cargo_cap - v->cargo.Count();
+			if (cap > 0) {
+				int reserved = st->goods[v->cargo_type].cargo.MoveTo(&v->cargo, cap, next_station, true);
+				if (reserved > 0) {
+					cap -= reserved;
+					SetBit(ret, v->cargo_type);
+				}
+			}
+		}
+	}
+	return ret;
+}
+
+/**
  * Checks whether an articulated vehicle is empty.
  * @param v Vehicle
  * @return true if all parts are empty.
@@ -1188,36 +1242,31 @@
 /**
  * Loads/unload the vehicle if possible.
  * @param front the vehicle to be (un)loaded
- * @param cargo_left the amount of each cargo type that is
- *                   virtually left on the platform to be
- *                   picked up by another vehicle when all
- *                   previous vehicles have loaded.
+ * @param cargos_reserved bit field: the cargo classes for which cargo has been reserved in this loading cycle
+ * @return the updated cargo_reserved
  */
-static void LoadUnloadVehicle(Vehicle *front, int *cargo_left)
+static uint32 LoadUnloadVehicle(Vehicle *front, uint32 cargos_reserved)
 {
 	assert(front->current_order.IsType(OT_LOADING));
 
+	StationID last_visited = front->last_station_visited;
+	Station *st = Station::Get(last_visited);
+
+	StationID next_station = front->GetNextStoppingStation();
+
 	/* We have not waited enough time till the next round of loading/unloading */
 	if (front->load_unload_ticks != 0) {
-		if (_settings_game.order.improved_load && (front->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
-			/* 'Reserve' this cargo for this vehicle, because we were first. */
-			for (Vehicle *v = front; v != NULL; v = v->Next()) {
-				int cap_left = v->cargo_cap - v->cargo.Count();
-				if (cap_left > 0) cargo_left[v->cargo_type] -= cap_left;
-			}
-		}
-		return;
+		return cargos_reserved | ReserveConsist(st, front, next_station);
 	}
 
-	StationID last_visited = front->last_station_visited;
-	Station *st = Station::Get(last_visited);
+	OrderUnloadFlags unload_flags = front->current_order.GetUnloadType();
 
 	if (front->type == VEH_TRAIN && (!IsTileType(front->tile, MP_STATION) || GetStationIndex(front->tile) != st->index)) {
 		/* The train reversed in the station. Take the "easy" way
 		 * out and let the train just leave as it always did. */
 		SetBit(front->vehicle_flags, VF_LOADING_FINISHED);
 		front->load_unload_ticks = 1;
-		return;
+		return cargos_reserved;
 	}
 
 	int unloading_time = 0;
@@ -1268,59 +1317,40 @@
 
 		GoodsEntry *ge = &st->goods[v->cargo_type];
 
-		if (HasBit(v->vehicle_flags, VF_CARGO_UNLOADING) && (front->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
-			uint cargo_count = v->cargo.Count();
+		if (HasBit(v->vehicle_flags, VF_CARGO_UNLOADING)) {
+			uint cargo_count = v->cargo.OnboardCount();
 			uint amount_unloaded = _settings_game.order.gradual_loading ? min(cargo_count, load_amount) : cargo_count;
-			bool remaining = false; // Are there cargo entities in this vehicle that can still be unloaded here?
-			bool accepted  = false; // Is the cargo accepted by the station?
 
+			uint prev_count = ge->cargo.Count();
 			payment->SetCargo(v->cargo_type);
+			uint delivered = ge->cargo.TakeFrom(&v->cargo, amount_unloaded, unload_flags,
+					next_station, front->last_loading_station == last_visited, payment);
 
-			if (HasBit(ge->acceptance_pickup, GoodsEntry::GES_ACCEPTANCE) && !(front->current_order.GetUnloadType() & OUFB_TRANSFER)) {
-				/* The cargo has reached its final destination, the packets may now be destroyed */
-				remaining = v->cargo.MoveTo<StationCargoList>(NULL, amount_unloaded, VehicleCargoList::MTA_FINAL_DELIVERY, payment, last_visited);
+			st->time_since_unload = 0;
+			unloading_time += delivered;
 
-				dirty_vehicle = true;
-				accepted = true;
-			}
-
-			/* The !accepted || v->cargo.Count == cargo_count clause is there
-			 * to make it possible to force unload vehicles at the station where
-			 * they were loaded, but to not force unload the vehicle when the
-			 * station is still accepting the cargo in the vehicle. It doesn't
-			 * accept cargo that was loaded at the same station. */
-			if ((front->current_order.GetUnloadType() & (OUFB_UNLOAD | OUFB_TRANSFER)) && (!accepted || v->cargo.Count() == cargo_count)) {
-				remaining = v->cargo.MoveTo(&ge->cargo, amount_unloaded, front->current_order.GetUnloadType() & OUFB_TRANSFER ? VehicleCargoList::MTA_TRANSFER : VehicleCargoList::MTA_UNLOAD, payment);
+			if (ge->cargo.Count() > prev_count) {
+				/* something has been transferred. The station windows need updating. */
+				dirty_station = true;
 				if (!HasBit(ge->acceptance_pickup, GoodsEntry::GES_PICKUP)) {
 					InvalidateWindowData(WC_STATION_LIST, last_visited);
 					SetBit(ge->acceptance_pickup, GoodsEntry::GES_PICKUP);
 				}
-
-				dirty_vehicle = dirty_station = true;
-			} else if (!accepted) {
-				/* The order changed while unloading (unset unload/transfer) or the
-				 * station does not accept our goods. */
-				ClrBit(v->vehicle_flags, VF_CARGO_UNLOADING);
-
-				/* Say we loaded something, otherwise we'll think we didn't unload
-				 * something and we didn't load something, so we must be finished
-				 * at this station. Setting the unloaded means that we will get a
-				 * retry for loading in the next cycle. */
-				anything_unloaded = true;
-				continue;
 			}
 
-			/* Deliver goods to the station */
-			st->time_since_unload = 0;
+			anything_unloaded = true;
+			dirty_vehicle = true;
 
-			unloading_time += amount_unloaded;
-
-			anything_unloaded = true;
-			if (_settings_game.order.gradual_loading && remaining) {
-				completely_emptied = false;
-			} else {
-				/* We have finished unloading (cargo count == 0) */
+			/* load_amount might (theoretically) be 0, which would make delivered == 0 even though there is still cargo
+			 * in the vehicle. Thus OnboardCount > 0. In that case we can't stop unloading as SwapReserved wouldn't work.
+			 * v->cargo also contains the cargo reserved for the vehicle which is not on board at the moment, but will be
+			 * swapped back when done unloading.
+			 */
+			if (v->cargo.OnboardCount() == 0) {
+				/* done delivering */
+				if (!v->cargo.Empty()) completely_emptied = false;
 				ClrBit(v->vehicle_flags, VF_CARGO_UNLOADING);
+				v->cargo.SwapReserved();
 			}
 
 			continue;
@@ -1349,16 +1379,16 @@
 
 			if (new_cid == CT_AUTO_REFIT) {
 				/* Get refittable cargo type with the most waiting cargo. */
-				int amount = 0;
+				uint amount = 0;
 				CargoID cid;
 				FOR_EACH_SET_CARGO_ID(cid, refit_mask) {
-					if (cargo_left[cid] > amount) {
+					if (st->goods[cid].cargo.Count() > amount) {
 						/* Try to find out if auto-refitting would succeed. In case the refit is allowed,
 						 * the returned refit capacity will be greater than zero. */
 						new_subtype = GetBestFittingSubType(v, v, cid);
 						DoCommand(v_start->tile, v_start->index, cid | 1U << 6 | new_subtype << 8 | 1U << 16, DC_QUERY_COST, GetCmdRefitVeh(v_start)); // Auto-refit and only this vehicle including artic parts.
 						if (_returned_refit_capacity > 0) {
-							amount = cargo_left[cid];
+							amount = st->goods[cid].cargo.Count();
 							new_cid = cid;
 						}
 					}
@@ -1401,39 +1431,25 @@
 
 		/* If there's goods waiting at the station, and the vehicle
 		 * has capacity for it, load it on the vehicle. */
-		int cap_left = v->cargo_cap - v->cargo.Count();
-		if (!ge->cargo.Empty() && cap_left > 0) {
-			uint cap = cap_left;
-			uint count = ge->cargo.Count();
+		int cap_left = v->cargo_cap - v->cargo.OnboardCount();
+		if (cap_left > 0) {
+			if (_settings_game.order.gradual_loading) cap_left = min(cap_left, load_amount);
+			if (v->cargo.Empty()) TriggerVehicle(v, VEHICLE_TRIGGER_NEW_CARGO);
 
-			/* Skip loading this vehicle if another train/vehicle is already handling
-			 * the same cargo type at this station */
-			if (_settings_game.order.improved_load && cargo_left[v->cargo_type] <= 0) {
-				SetBit(cargo_not_full, v->cargo_type);
-				continue;
-			}
-
-			if (cap > count) cap = count;
-			if (_settings_game.order.gradual_loading) {
-				cap = min(cap, load_amount);
-				cap_left = min(cap_left, load_amount);
-			}
+			int loaded = 0;
 			if (_settings_game.order.improved_load) {
-				/* Don't load stuff that is already 'reserved' for other vehicles */
-				cap = min((uint)cargo_left[v->cargo_type], cap);
-				count = cargo_left[v->cargo_type];
-				cargo_left[v->cargo_type] -= cap;
+				loaded += v->cargo.LoadReserved(cap_left);
 			}
 
+			loaded += ge->cargo.MoveTo(&v->cargo, cap_left - loaded, next_station);
+
 			/* Store whether the maximum possible load amount was loaded or not.*/
-			if (count >= (uint)cap_left) {
+			if (loaded == cap_left) {
 				SetBit(full_load_amount, v->cargo_type);
 			} else {
 				ClrBit(full_load_amount, v->cargo_type);
 			}
 
-			if (v->cargo.Empty()) TriggerVehicle(v, VEHICLE_TRIGGER_NEW_CARGO);
-
 			/* TODO: Regarding this, when we do gradual loading, we
 			 * should first unload all vehicles and then start
 			 * loading them. Since this will cause
@@ -1441,25 +1457,30 @@
 			 * the whole vehicle chain is really totally empty, the
 			 * completely_emptied assignment can then be safely
 			 * removed; that's how TTDPatch behaves too. --pasky */
-			completely_emptied = false;
-			anything_loaded = true;
+			if (loaded > 0) {
+				completely_emptied = false;
+				anything_loaded = true;
 
-			ge->cargo.MoveTo(&v->cargo, cap, StationCargoList::MTA_CARGO_LOAD, NULL, st->xy);
+				st->time_since_load = 0;
+				st->last_vehicle_type = v->type;
 
-			st->time_since_load = 0;
-			st->last_vehicle_type = v->type;
+				if (ge->cargo.Empty()) {
+					TriggerStationAnimation(st, st->xy, SAT_CARGO_TAKEN, v->cargo_type);
+					AirportAnimationTrigger(st, AAT_STATION_CARGO_TAKEN, v->cargo_type);
+				}
 
-			if (ge->cargo.Empty()) {
-				TriggerStationAnimation(st, st->xy, SAT_CARGO_TAKEN, v->cargo_type);
-				AirportAnimationTrigger(st, AAT_STATION_CARGO_TAKEN, v->cargo_type);
+				unloading_time += loaded;
+
+				dirty_vehicle = dirty_station = true;
+			} else if (_settings_game.order.improved_load && HasBit(cargos_reserved, v->cargo_type)) {
+				/* Skip loading this vehicle if another train/vehicle is already handling
+				 * the same cargo type at this station */
+				SetBit(cargo_not_full, v->cargo_type);
+				continue;
 			}
-
-			unloading_time += cap;
-
-			dirty_vehicle = dirty_station = true;
 		}
 
-		if (v->cargo.Count() >= v->cargo_cap) {
+		if (v->cargo.OnboardCount() >= v->cargo_cap) {
 			SetBit(cargo_full, v->cargo_type);
 		} else {
 			SetBit(cargo_not_full, v->cargo_type);
@@ -1473,18 +1494,6 @@
 	/* Only set completely_emptied, if we just unloaded all remaining cargo */
 	completely_emptied &= anything_unloaded;
 
-	/* We update these variables here, so gradual loading still fills
-	 * all wagons at the same time instead of using the same 'improved'
-	 * loading algorithm for the wagons (only fill wagon when there is
-	 * enough to fill the previous wagons) */
-	if (_settings_game.order.improved_load && (front->current_order.GetLoadType() & OLFB_FULL_LOAD)) {
-		/* Update left cargo */
-		for (Vehicle *v = front; v != NULL; v = v->Next()) {
-			int cap_left = v->cargo_cap - v->cargo.Count();
-			if (cap_left > 0) cargo_left[v->cargo_type] -= cap_left;
-		}
-	}
-
 	if (!anything_unloaded) delete payment;
 
 	ClrBit(front->vehicle_flags, VF_STOP_LOADING);
@@ -1508,13 +1517,16 @@
 			if (front->current_order.GetLoadType() == OLF_FULL_LOAD_ANY) {
 				/* if the aircraft carries passengers and is NOT full, then
 				 * continue loading, no matter how much mail is in */
-				if ((front->type == VEH_AIRCRAFT && IsCargoInClass(front->cargo_type, CC_PASSENGERS) && front->cargo_cap > front->cargo.Count()) ||
+				if ((front->type == VEH_AIRCRAFT && IsCargoInClass(front->cargo_type, CC_PASSENGERS) && front->cargo_cap > front->cargo.OnboardCount()) ||
 						(cargo_not_full && (cargo_full & ~cargo_not_full) == 0)) { // There are still non-full cargoes
 					finished_loading = false;
 				}
 			} else if (cargo_not_full != 0) {
 				finished_loading = false;
 			}
+
+			/* Refresh next hop stats if we're full loading to avoid deadlocks. */
+			if (!finished_loading) front->RefreshNextHopsStats();
 		}
 		unloading_time = 20;
 
@@ -1562,6 +1574,7 @@
 		st->MarkTilesDirty(true);
 		SetWindowDirty(WC_STATION_VIEW, last_visited);
 	}
+	return cargos_reserved;
 }
 
 /**
@@ -1596,13 +1609,11 @@
 	 */
 	if (last_loading == NULL) return;
 
-	int cargo_left[NUM_CARGO];
+	uint cargos_reserved = 0;
 
-	for (uint i = 0; i < NUM_CARGO; i++) cargo_left[i] = st->goods[i].cargo.Count();
-
 	for (iter = st->loading_vehicles.begin(); iter != st->loading_vehicles.end(); ++iter) {
 		Vehicle *v = *iter;
-		if (!(v->vehstatus & (VS_STOPPED | VS_CRASHED))) LoadUnloadVehicle(v, cargo_left);
+		if (!(v->vehstatus & (VS_STOPPED | VS_CRASHED))) cargos_reserved = LoadUnloadVehicle(v, cargos_reserved);
 		if (v == last_loading) break;
 	}
 
Index: src/cargopacket.cpp
===================================================================
--- src/cargopacket.cpp	(revision 24093)
+++ src/cargopacket.cpp	(working copy)
@@ -10,7 +10,9 @@
 /** @file cargopacket.cpp Implementation of the cargo packets. */
 
 #include "stdafx.h"
+#include "station_base.h"
 #include "core/pool_func.hpp"
+#include "core/random_func.hpp"
 #include "economy_base.h"
 
 /* Initialize the cargopacket-pool */
@@ -138,8 +140,8 @@
 /**
  * Destroy the cargolist ("frees" all cargo packets).
  */
-template <class Tinst>
-CargoList<Tinst>::~CargoList()
+template <class Tinst, class Tcont>
+CargoList<Tinst, Tcont>::~CargoList()
 {
 	for (Iterator it(this->packets.begin()); it != this->packets.end(); ++it) {
 		delete *it;
@@ -150,8 +152,8 @@
  * Empty the cargo list, but don't free the cargo packets;
  * the cargo packets are cleaned by CargoPacket's CleanPool.
  */
-template <class Tinst>
-void CargoList<Tinst>::OnCleanPool()
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::OnCleanPool()
 {
 	this->packets.clear();
 }
@@ -161,8 +163,8 @@
  * Decreases count and days_in_transit.
  * @param cp Packet to be removed from cache.
  */
-template <class Tinst>
-void CargoList<Tinst>::RemoveFromCache(const CargoPacket *cp)
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::RemoveFromCache(const CargoPacket *cp)
 {
 	this->count                 -= cp->count;
 	this->cargo_days_in_transit -= cp->days_in_transit * cp->count;
@@ -173,8 +175,8 @@
  * Increases count and days_in_transit.
  * @param cp New packet to be inserted.
  */
-template <class Tinst>
-void CargoList<Tinst>::AddToCache(const CargoPacket *cp)
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::AddToCache(const CargoPacket *cp)
 {
 	this->count                 += cp->count;
 	this->cargo_days_in_transit += cp->days_in_transit * cp->count;
@@ -186,17 +188,17 @@
  * @warning After appending this packet may not exist anymore!
  * @note Do not use the cargo packet anymore after it has been appended to this CargoList!
  * @param cp Cargo packet to add.
+ * @param update_cache If false, the cache is not updated; used when loading from
+ *        the reservation list.
  * @pre cp != NULL
  */
-template <class Tinst>
-void CargoList<Tinst>::Append(CargoPacket *cp)
+void VehicleCargoList::Append(CargoPacket *cp, bool update_cache)
 {
 	assert(cp != NULL);
-	static_cast<Tinst *>(this)->AddToCache(cp);
-
-	for (List::reverse_iterator it(this->packets.rbegin()); it != this->packets.rend(); it++) {
+	if (update_cache) this->AddToCache(cp);
+	for (CargoPacketList::reverse_iterator it(this->packets.rbegin()); it != this->packets.rend(); it++) {
 		CargoPacket *icp = *it;
-		if (Tinst::AreMergable(icp, cp) && icp->count + cp->count <= CargoPacket::MAX_COUNT) {
+		if (VehicleCargoList::AreMergable(icp, cp) && icp->count + cp->count <= CargoPacket::MAX_COUNT) {
 			icp->Merge(cp);
 			return;
 		}
@@ -211,8 +213,8 @@
  * first count cargo entities and removes the rest.
  * @param max_remaining Maximum amount of entities to be in the list after the command.
  */
-template <class Tinst>
-void CargoList<Tinst>::Truncate(uint max_remaining)
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::Truncate(uint max_remaining)
 {
 	for (Iterator it(packets.begin()); it != packets.end(); /* done during loop*/) {
 		CargoPacket *cp = *it;
@@ -239,120 +241,409 @@
 }
 
 /**
- * Moves the given amount of cargo to another list.
- * Depending on the value of mta the side effects of this function differ:
- *  - MTA_FINAL_DELIVERY: Destroys the packets that do not originate from a specific station.
- *  - MTA_CARGO_LOAD:     Sets the loaded_at_xy value of the moved packets.
- *  - MTA_TRANSFER:       Just move without side effects.
- *  - MTA_UNLOAD:         Just move without side effects.
- * @param dest  Destination to move the cargo to.
- * @param max_move Amount of cargo entities to move.
- * @param mta   How to handle the moving (side effects).
- * @param data  Depending on mta the data of this variable differs:
- *              - MTA_FINAL_DELIVERY - Station ID of packet's origin not to remove.
- *              - MTA_CARGO_LOAD     - Station's tile index of load.
- *              - MTA_TRANSFER       - Unused.
- *              - MTA_UNLOAD         - Unused.
- * @param payment The payment helper.
- *
- * @pre mta == MTA_FINAL_DELIVERY || dest != NULL
- * @pre mta == MTA_UNLOAD || mta == MTA_CARGO_LOAD || payment != NULL
- * @return True if there are still packets that might be moved from this cargo list.
+ * Reserves a packet for later loading and adds it to the cache.
+ * @param cp Packet to be reserved.
  */
-template <class Tinst>
-template <class Tother_inst>
-bool CargoList<Tinst>::MoveTo(Tother_inst *dest, uint max_move, MoveToAction mta, CargoPayment *payment, uint data)
+void VehicleCargoList::Reserve(CargoPacket *cp)
 {
-	assert(mta == MTA_FINAL_DELIVERY || dest != NULL);
-	assert(mta == MTA_UNLOAD || mta == MTA_CARGO_LOAD || payment != NULL);
+	assert(cp != NULL);
+	this->AddToCache(cp);
+	this->reserved_count += cp->count;
+	this->reserved.push_back(cp);
+}
 
-	Iterator it(this->packets.begin());
-	while (it != this->packets.end() && max_move > 0) {
+/**
+ * Returns all reserved cargo to the station and removes it from the cache.
+ * @param ID of next the station the cargo wants to go next.
+ * @param dest Station the cargo is returned to.
+ */
+void VehicleCargoList::Unreserve(StationID next, StationCargoList *dest)
+{
+	Iterator it(this->reserved.begin());
+	while (it != this->reserved.end()) {
 		CargoPacket *cp = *it;
-		if (cp->source == data && mta == MTA_FINAL_DELIVERY) {
-			/* Skip cargo that originated from this station. */
-			++it;
-			continue;
-		}
+		this->RemoveFromCache(cp);
+		this->reserved_count -= cp->count;
+		dest->Append(next, cp);
+		it = this->reserved.erase(it);
+	}
+}
 
+/**
+ * Load packets from the reservation list.
+ * @params max_move Number of cargo to load.
+ * @return Amount of cargo actually loaded.
+ */
+uint VehicleCargoList::LoadReserved(uint max_move)
+{
+	uint orig_max = max_move;
+	Iterator it(this->reserved.begin());
+	while (it != this->reserved.end() && max_move > 0) {
+		CargoPacket *cp = *it;
 		if (cp->count <= max_move) {
 			/* Can move the complete packet */
 			max_move -= cp->count;
-			it = this->packets.erase(it);
-			static_cast<Tinst *>(this)->RemoveFromCache(cp);
-			switch (mta) {
-				case MTA_FINAL_DELIVERY:
-					payment->PayFinalDelivery(cp, cp->count);
-					delete cp;
-					continue; // of the loop
+			it = this->reserved.erase(it);
+			this->reserved_count -= cp->count;
+			this->Append(cp, false);
+		} else if (CargoPacket::CanAllocateItem()) {
+			cp->count -= max_move;
+			CargoPacket *cp_new = new CargoPacket(max_move, cp->days_in_transit, cp->source, cp->source_xy, cp->loaded_at_xy, 0, cp->source_type, cp->source_id);
+			this->Append(cp_new, false);
+			this->reserved_count -= max_move;
+			max_move = 0;
+		}
+	}
+	return orig_max - max_move;
+}
 
-				case MTA_CARGO_LOAD:
-					cp->loaded_at_xy = data;
-					break;
+/**
+ * Move a single packet or part of it from this list to a vehicle and increment
+ * the given iterator.
+ * @param dest       Vehicle cargo list to move to.
+ * @param it         Iterator pointing to the packet.
+ * @param cap        Maximum amount of cargo to be moved.
+ * @param load_place New loaded_at for the packet.
+ * @param reserve    If the packet should be loaded on or reserved for the vehicle.
+ * @return           Actual amount of cargo which has been moved.
+ */
+template<class Tinst, class Tcont>
+uint CargoList<Tinst, Tcont>::MovePacket(VehicleCargoList *dest, Iterator &it, uint cap, TileIndex load_place, bool reserve)
+{
+	CargoPacket *packet = this->RemovePacket(it, cap, load_place);
+	uint ret = packet->count;
+	if (reserve) {
+		dest->Reserve(packet);
+	} else {
+		dest->Append(packet);
+	}
+	return ret;
+}
 
-				case MTA_TRANSFER:
-					cp->feeder_share += payment->PayTransfer(cp, cp->count);
-					break;
+/**
+ * Move a single packet or part of it from this list to a station and increment
+ * the given iterator.
+ * @param dest Station cargo list to move to.
+ * @param next Next station the packet will travel to.
+ * @param it Iterator pointing to the packet.
+ * @param cap Maximum amount of cargo to be moved.
+ * @return Actual amount of cargo which has been moved.
+ */
+template<class Tinst, class Tcont>
+uint CargoList<Tinst, Tcont>::MovePacket(StationCargoList *dest, StationID next, Iterator &it, uint cap)
+{
+	CargoPacket *packet = this->RemovePacket(it, cap);
+	uint ret = packet->count;
+	dest->Append(next, packet);
+	return ret;
+}
 
-				case MTA_UNLOAD:
-					break;
-			}
-			dest->Append(cp);
-			continue;
+/**
+ * Remove a single packet or part of it from this list and increment the given
+ * iterator.
+ * @param it Iterator pointing to the packet.
+ * @param cap Maximum amount of cargo to be moved.
+ * @param load_place New loaded_at for the packet or INVALID_TILE if the current
+ *        one shall be kept.
+ * @return Removed packet.
+ */
+template<class Tinst, class Tcont>
+CargoPacket *CargoList<Tinst, Tcont>::RemovePacket(Iterator &it, uint cap, TileIndex load_place)
+{
+	CargoPacket *packet = *it;
+	/* load the packet if possible */
+	if (packet->count > cap) {
+		/* packet needs to be split */
+		packet = packet->Split(cap);
+
+		/* We could not allocate a CargoPacket? Is the map that full?
+		 * Just remove the whole packet and drop some cargo then.
+		 */
+		if (packet == NULL) {
+			packet = *it;
+			uint dropped = packet->count - cap;
+			this->count -= dropped;
+			this->cargo_days_in_transit -= dropped * packet->days_in_transit;
+			packet->count = cap;
+			it = this->packets.erase(it);
+		} else {
+			assert(packet->count == cap);
+			++it;
 		}
+	} else {
+		it = this->packets.erase(it);
+	}
+	static_cast<Tinst *>(this)->RemoveFromCache(packet);
+	if (load_place != INVALID_TILE) {
+		packet->loaded_at_xy = load_place;
+	}
+	return packet;
+}
 
-		/* Can move only part of the packet */
-		if (mta == MTA_FINAL_DELIVERY) {
-			/* Final delivery doesn't need package splitting. */
-			payment->PayFinalDelivery(cp, max_move);
+/**
+ * Invalidates the cached data and rebuilds it.
+ */
+template <class Tinst, class Tcont>
+void CargoList<Tinst, Tcont>::InvalidateCache()
+{
+	this->count = 0;
+	this->cargo_days_in_transit = 0;
 
-			/* Remove the delivered data from the cache */
-			uint left = cp->count - max_move;
-			cp->count = max_move;
-			static_cast<Tinst *>(this)->RemoveFromCache(cp);
+	for (ConstIterator it(this->packets.begin()); it != this->packets.end(); it++) {
+		static_cast<Tinst *>(this)->AddToCache(*it);
+	}
+}
 
-			/* Final delivery payment pays the feeder share, so we have to
-			 * reset that so it is not 'shown' twice for partial unloads. */
-			cp->feeder_share = 0;
-			cp->count = left;
-		} else {
-			/* But... the rest needs package splitting. */
-			CargoPacket *cp_new = cp->Split(max_move);
+/**
+ * Delete a vehicle cargo list and clear its reservation list.
+ */
+VehicleCargoList::~VehicleCargoList()
+{
+	for (Iterator it(this->reserved.begin()); it != this->reserved.end(); ++it) {
+		delete *it;
+	}
+}
 
-			/* We could not allocate a CargoPacket? Is the map that full? */
-			if (cp_new == NULL) return false;
+/**
+ * Deliver a specific packet or part of it to a station and handle payment. The
+ * given iterator is incremented in the process.
+ * @param it      Iterator pointing to the packet to be delivered.
+ * @param cap     Maximum amount of cargo to be unloaded.
+ * @param payment Payment object to use for payment.
+ * @return        Amount of cargo actually unloaded.
+ */
+uint VehicleCargoList::DeliverPacket(Iterator &it, uint cap, CargoPayment *payment)
+{
+	CargoPacket *p = *it;
+	uint unloaded = 0;
+	if (p->count <= cap) {
+		payment->PayFinalDelivery(p, p->count);
+		it = this->packets.erase(it);
+		this->RemoveFromCache(p);
+		unloaded = p->count;
+		delete p;
+	} else {
+		payment->PayFinalDelivery(p, cap);
+		this->count -= cap;
+		this->cargo_days_in_transit -= cap * p->days_in_transit;
+		this->feeder_share -= p->feeder_share;
+		p->feeder_share = 0;
+		p->count -= cap;
+		unloaded = cap;
+		++it;
+	}
+	return unloaded;
+}
 
-			static_cast<Tinst *>(this)->RemoveFromCache(cp_new); // this reflects the changes in cp.
+/**
+ * Keep a packet in the vehicle while unloading by temporarily moving it to the
+ * reservation list. The given iterator is incremented in the process.
+ * @param it Iterator pointing to the packet.
+ * @return Size of the packet.
+ */
+uint VehicleCargoList::KeepPacket(Iterator &it)
+{
+	CargoPacket *cp = *it;
+	this->reserved.push_back(cp);
+	this->reserved_count += cp->count;
+	it = this->packets.erase(it);
+	return cp->count;
+}
 
-			if (mta == MTA_TRANSFER) {
-				/* Add the feeder share before inserting in dest. */
-				cp_new->feeder_share += payment->PayTransfer(cp_new, max_move);
-			} else if (mta == MTA_CARGO_LOAD) {
-				cp_new->loaded_at_xy = data;
-			}
+/**
+ * Transfer a packet to a station, but don't deliver it. Increment the given
+ * iterator in the process.
+ * @param it Iterator pointing to a packet in the list.
+ * @param cap Maximum amount of cargo to be transferred.
+ * @param dest Cargo list of the station the cargo should be transferred to.
+ * @param payment Payment object to be updated with the resulting transfer
+ *                credits.
+ * @param next ID of the station the cargo wants to go to next.
+ * @return Amount of cargo actually moved.
+ */
+uint VehicleCargoList::TransferPacket(Iterator &it, uint cap, StationCargoList *dest, CargoPayment *payment, StationID next)
+{
+	CargoPacket *cp = this->RemovePacket(it, cap);
+	cp->feeder_share += payment->PayTransfer(cp, cp->count);
+	uint ret = cp->count;
+	dest->Append(next, cp);
+	return ret;
+}
 
-			dest->Append(cp_new);
+/**
+ * Determine what a cargo packet arriving at the station this list belongs to
+ * will do, using the "old", non-cargodist algorithm.
+ * @param flags  Unload flags telling if the cargo is accepted and what order
+ *               flags there are.
+ * @param source ID of the packets source station.
+ * @return       Unload type (deliver, transfer, keep) telling what to do with
+ *               the packet.
+ */
+UnloadType StationCargoList::WillUnloadOld(byte flags, StationID source)
+{
+	/* try to unload cargo */
+	bool move = (flags & (UL_DELIVER | UL_ACCEPTED | UL_TRANSFER)) != 0;
+	/* try to deliver cargo if unloading */
+	bool deliver = (flags & UL_ACCEPTED) && !(flags & UL_TRANSFER) && (source != this->station->index);
+	/* transfer cargo if delivery was unsuccessful */
+	bool transfer = (flags & (UL_TRANSFER | UL_DELIVER)) != 0;
+	if (move) {
+		if(deliver) {
+			return UL_DELIVER;
+		} else if (transfer) {
+			return UL_TRANSFER;
+		} else {
+			/* this case is for (non-)delivery to the source station without special flags.
+			 * like the code in MoveTo did, we keep the packet in this case
+			 */
+			return UL_KEEP;
 		}
+	} else {
+		return UL_KEEP;
+	}
+}
 
-		max_move = 0;
+/**
+ * Determine what a cargo packet arriving at the station this list belongs to
+ * will do, using the Cargodist algorithm.
+ * @param flags  Unload flags telling if the cargo is accepted and what order
+ *               flags there are.
+ * @param next   Station the vehicle the cargo is coming from will
+ *               visit next (or INVALID_STATION if unknown).
+ * @param via    Station the cargo wants to go to next. If that is this
+ *               station the cargo wants to be delivered.
+ * @param source ID of the packets source station.
+ * @return       Unload type (deliver, transfer, keep) telling what to do with
+ *               the packet.
+ */
+UnloadType StationCargoList::WillUnloadCargoDist(byte flags, StationID next, StationID via, StationID source)
+{
+	if (via == this->station->index) {
+		/* this is the final destination, deliver ... */
+		if (flags & UL_TRANSFER) {
+			/* .. except if explicitly told not to do so ... */
+			return UL_TRANSFER;
+		} else if (flags & UL_ACCEPTED) {
+			return UL_DELIVER;
+		} else if (flags & UL_DELIVER) {
+			/* .. or if the station suddenly doesn't accept our cargo, but we have an explicit deliver order... */
+			return UL_TRANSFER;
+		} else {
+			/* .. or else if it doesn't accept. */
+			return UL_KEEP;
+		}
+	} else {
+		/* packet has to travel on, find out if it can stay on board */
+		if (flags & UL_DELIVER) {
+			/* order overrides cargodist:
+			 * play by the old loading rules here as player is interfering with cargodist
+			 * try to deliver, as move has been forced upon us */
+			if ((flags & UL_ACCEPTED) && !(flags & UL_TRANSFER) && source != this->station->index) {
+				return UL_DELIVER;
+			} else {
+				/* transfer cargo, as delivering didn't work */
+				return UL_TRANSFER;
+			}
+		} else if (flags & UL_TRANSFER) {
+			/* transfer forced */
+			return UL_TRANSFER;
+		} else if (next == via && next != INVALID_STATION) {
+			/* vehicle goes to the packet's next hop or has nondeterministic order: keep the packet*/
+			return UL_KEEP;
+		} else {
+			/* vehicle goes somewhere else, transfer the packet*/
+			return UL_TRANSFER;
+		}
 	}
+}
 
-	return it != packets.end();
+/**
+ * Swap the reserved and packets lists when starting to load cargo. Pull in the
+ * "kept" packets which were stored in the reservation list so that we don't
+ * have to iterate over them all the time.
+ * @pre this->packets.empty()
+ */
+void VehicleCargoList::SwapReserved()
+{
+	assert(this->packets.empty());
+	this->packets.swap(this->reserved);
+	this->reserved_count = 0;
 }
 
-/** Invalidates the cached data and rebuilds it. */
-template <class Tinst>
-void CargoList<Tinst>::InvalidateCache()
+/**
+ * Moves the given amount of cargo from a vehicle to a station.
+ * Depending on the value of flags the side effects of this function differ:
+ *  - OUFB_UNLOAD_IF_POSSIBLE and dest->acceptance_pickup & GoodsEntry::GES_ACCEPTANCE:
+ *  	packets are accepted here and may be unloaded and/or delivered (=destroyed);
+ *  	if not using cargodist: all packets are unloaded and delivered
+ *  	if using cargodist: only packets which have this station as final destination are unloaded and delivered.
+ *  	if using cargodist: other packets may or may not be unloaded, depending on next_station.
+ *  	if GoodsEntry::GES_ACCEPTANCE is not set and using cargodist: packets may still be unloaded, but not delivered.
+ *  - OUFB_UNLOAD: unload all packets unconditionally;
+ *  	if OUF_UNLOAD_IF_POSSIBLE set and OUFB_TRANSFER not set: also deliver packets (no matter if using cargodist).
+ *  - OUFB_TRANSFER: don't deliver any packets;
+ *  	overrides delivering aspect of OUFB_UNLOAD_IF_POSSIBLE.
+ * @param source       Vehicle cargo list to take the cargo from.
+ * @param max_unload   Maximum amount of cargo entities to move.
+ * @param flags        How to handle the moving (side effects).
+ * @param next         Next unloading station in the vehicle's order list.
+ * @param has_stopped  Vehicle has stopped at this station before, so don't update the flow stats for kept cargo.
+ * @param payment      Payment object to be updated when delivering/transferring.
+ * @return Number of cargo entities actually moved.
+ */
+uint StationCargoList::TakeFrom(VehicleCargoList *source, uint max_unload, OrderUnloadFlags order_flags, StationID next, bool has_stopped, CargoPayment *payment)
 {
-	this->count = 0;
-	this->cargo_days_in_transit = 0;
+	uint remaining_unload = max_unload;
+	uint unloaded;
+	byte flags = this->GetUnloadFlags(order_flags);
+	GoodsEntry *dest = &this->station->goods[this->cargo];
+	UnloadType action;
 
-	for (ConstIterator it(this->packets.begin()); it != this->packets.end(); it++) {
-		static_cast<Tinst *>(this)->AddToCache(*it);
+	for (VehicleCargoList::Iterator c = source->packets.begin(); c != source->packets.end() && remaining_unload > 0;) {
+		StationID cargo_source = (*c)->source;
+		FlowStatMap::const_iterator flows_it = dest->flows.find(cargo_source);
+		StationID via;
+		if (flows_it != dest->flows.end()) {
+			via = flows_it->second.GetVia();
+			/* use cargodist unloading*/
+			action = this->WillUnloadCargoDist(flags, next, via, cargo_source);
+		} else {
+			via = INVALID_STATION;
+			/* there is no plan: use normal unloading */
+			action = this->WillUnloadOld(flags, cargo_source);
+		}
+
+		switch (action) {
+			case UL_DELIVER:
+				unloaded = source->DeliverPacket(c, remaining_unload, payment);
+				remaining_unload -= unloaded;
+				break;
+			case UL_TRANSFER:
+				/* TransferPacket may split the packet and return the transferred part */
+				if (via == this->station->index) via = flows_it->second.GetVia(via);
+				unloaded = source->TransferPacket(c, remaining_unload, this, payment, via);
+				remaining_unload -= unloaded;
+				break;
+			case UL_KEEP:
+				unloaded = source->KeepPacket(c);
+				break;
+			default:
+				NOT_REACHED();
+		}
 	}
+	return max_unload - remaining_unload;
 }
 
 /**
+ * Additionally empty the reservation list for vehicle cargo lists.
+ */
+void VehicleCargoList::OnCleanPool()
+{
+	this->reserved.clear();
+	this->Parent::OnCleanPool();
+}
+
+/**
  * Update the cached values to reflect the removal of this packet.
  * Decreases count, feeder share and days_in_transit.
  * @param cp Packet to be removed from cache.
@@ -375,6 +666,22 @@
 }
 
 /**
+ * Moves the given amount of cargo to another vehicle (during autoreplace).
+ * @param dest         Destination to move the cargo to.
+ * @param cap          Maximum amount of cargo entities to move.
+ * @return             Amount of cargo actually moved.
+ */
+uint VehicleCargoList::MoveTo(VehicleCargoList *dest, uint cap)
+{
+	uint orig_cap = cap;
+	Iterator it = packets.begin();
+	while (it != packets.end() && cap > 0) {
+		cap -= MovePacket(dest, it, cap);
+	}
+	return orig_cap - cap;
+}
+
+/**
  * Ages the all cargo in this list.
  */
 void VehicleCargoList::AgeCargo()
@@ -389,22 +696,188 @@
 	}
 }
 
-/** Invalidates the cached data and rebuild it. */
+/*
+ *
+ * Station cargo list implementation
+ *
+ */
+
+/**
+ * build unload flags from order flags and station acceptance.
+ * @param order_flags order flags to check for forced transfer/deliver
+ * @return some combination of UL_ACCEPTED, UL_DELIVER and UL_TRANSFER
+ */
+inline byte StationCargoList::GetUnloadFlags(OrderUnloadFlags order_flags)
+{
+	byte flags = 0;
+	if (HasBit(this->station->goods[this->cargo].acceptance_pickup, GoodsEntry::GES_ACCEPTANCE)) {
+		flags |= UL_ACCEPTED;
+	}
+	if (order_flags & OUFB_UNLOAD) {
+		flags |= UL_DELIVER;
+	}
+	if (order_flags & OUFB_TRANSFER) {
+		flags |= UL_TRANSFER;
+	}
+	return flags;
+}
+
+/**
+ * Appends the given cargo packet to the range of packets with the same next station
+ * @warning After appending this packet may not exist anymore!
+ * @note Do not use the cargo packet anymore after it has been appended to this CargoList!
+ * @param next the next hop
+ * @param cp the cargo packet to add
+ * @pre cp != NULL
+ */
+void StationCargoList::Append(StationID next, CargoPacket *cp)
+{
+	assert(cp != NULL);
+	this->AddToCache(cp);
+
+	StationCargoPacketMap::List &list = this->packets[next];
+	for (StationCargoPacketMap::List::reverse_iterator it(list.rbegin()); it != list.rend(); it++) {
+		CargoPacket *icp = *it;
+		if (StationCargoList::AreMergable(icp, cp) && icp->count + cp->count <= CargoPacket::MAX_COUNT) {
+			icp->Merge(cp);
+			return;
+		}
+	}
+
+	/* The packet could not be merged with another one */
+	list.push_back(cp);
+}
+
+/**
+ * Move packets from a specific range in this list to a vehicle.
+ * @param dest Cargo list the packets will be moved to.
+ * @param cap Maximum amount of cargo to move.
+ * @param begin Begin of the range to take packets from.
+ * @param end End of the range to take packets from.
+ * @param reserve If the packets should be loaded on or reserved for the vehicle.
+ * @return Amount of cargo that has been moved.
+ */
+uint StationCargoList::MovePackets(VehicleCargoList *dest, uint cap, Iterator begin, Iterator end, bool reserve)
+{
+	uint orig_cap = cap;
+	while (begin != end && cap > 0) {
+		cap -= this->MovePacket(dest, begin, cap, this->station->xy, reserve);
+	}
+	return orig_cap - cap;
+}
+
+/**
+ * Move suitable packets from this list to a vehicle.
+ * @param dest Vehicle cargo list to move packets to.
+ * @param cap Maximum amount of cargo to be moved.
+ * @param next Next station the vehicle will stop at.
+ * @param reserve If the packets should be loaded on or reserved for the vehicle.
+ * @return Amount of cargo that has been moved.
+ */
+uint StationCargoList::MoveTo(VehicleCargoList *dest, uint cap, StationID next, bool reserve)
+{
+	uint orig_cap = cap;
+	std::pair<Iterator, Iterator> bounds(this->packets.equal_range(next));
+	cap -= this->MovePackets(dest, cap, bounds.first, bounds.second, reserve);
+	if (next != INVALID_STATION && cap > 0) {
+		bounds = this->packets.equal_range(INVALID_STATION);
+		cap -= this->MovePackets(dest, cap, bounds.first, bounds.second, reserve);
+	}
+	return orig_cap - cap;
+}
+
+/**
+ * Route all packets with station "to" as next hop to a different place.
+ * @param to station to exclude from routing.
+ */
+void StationCargoList::RerouteStalePackets(StationID to)
+{
+	std::pair<Iterator, Iterator> range(this->packets.equal_range(to));
+	for (Iterator it(range.first); it != range.second && it.GetKey() == to;) {
+		CargoPacket *packet = *it;
+		it = this->packets.erase(it);
+		StationID next = this->station->goods[this->cargo].GetVia(packet->source, this->station->index);
+		assert(next != to);
+
+		/* legal, as insert doesn't invalidate iterators in the MultiMap, however
+		 * this might insert the packet between range.first and range.second (which might be end())
+		 * This is why we check for GetKey above to avoid infinite loops
+		 */
+		this->packets.Insert(next, packet);
+	}
+}
+
+/**
+ * Truncate where each destination loses roughly the same percentage of its cargo.
+ * This is done by randomizing the selection of packets to be removed. Also count
+ * the cargo by origin station.
+ * @param max_remaining Maximum amount of cargo to keep in the station.
+ * @param cargo_per_source Container for counting the cargo by origin list.
+ */
+void StationCargoList::CountAndTruncate(uint max_remaining, StationCargoAmountMap &cargo_per_source)
+{
+	uint prev_count = this->count;
+	uint loop = 0;
+	while (this->count > max_remaining) {
+		for (Iterator it(this->packets.begin()); it != this->packets.end();) {
+			CargoPacket *packet = *it;
+			if (loop == 0) cargo_per_source[packet->source] += packet->count;
+
+			if (RandomRange(prev_count) < max_remaining) {
+				++it;
+				continue;
+			}
+
+			uint diff = this->count - max_remaining;
+			if (packet->count > diff) {
+				packet->count -= diff;
+				this->count = max_remaining;
+				this->cargo_days_in_transit -= packet->days_in_transit * diff;
+				if (loop > 0) {
+					return;
+				} else {
+					++it;
+				}
+			} else {
+				it = this->packets.erase(it);
+				this->RemoveFromCache(packet);
+				delete packet;
+			}
+		}
+		loop++;
+	}
+}
+
+/**
+ * Invalidates the cached data and rebuilds it.
+ */
 void VehicleCargoList::InvalidateCache()
 {
 	this->feeder_share = 0;
+	this->reserved_count = 0;
 	this->Parent::InvalidateCache();
+	for (ConstIterator it(this->reserved.begin()); it != this->reserved.end(); it++) {
+		this->AddToCache(*it);
+		this->reserved_count += (*it)->count;
+	}
 }
 
+/**
+ * Assign the cargo list to a goods entry.
+ * @param station the station the cargo list is assigned to
+ * @param cargo the cargo the list is assigned to
+ */
+void StationCargoList::AssignTo(Station *station, CargoID cargo)
+{
+	assert(this->station == NULL);
+	assert(station != NULL && cargo != INVALID_CARGO);
+	this->station = station;
+	this->cargo = cargo;
+}
+
+
 /*
  * We have to instantiate everything we want to be usable.
  */
-template class CargoList<VehicleCargoList>;
-template class CargoList<StationCargoList>;
-
-/** Autoreplace Vehicle -> Vehicle 'transfer'. */
-template bool CargoList<VehicleCargoList>::MoveTo(VehicleCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, uint data);
-/** Cargo unloading at a station. */
-template bool CargoList<VehicleCargoList>::MoveTo(StationCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, uint data);
-/** Cargo loading at a station. */
-template bool CargoList<StationCargoList>::MoveTo(VehicleCargoList *, uint max_move, MoveToAction mta, CargoPayment *payment, uint data);
+template class CargoList<VehicleCargoList, CargoPacketList>;
+template class CargoList<StationCargoList, StationCargoPacketMap>;
Index: src/vehicle_gui.cpp
===================================================================
--- src/vehicle_gui.cpp	(revision 24093)
+++ src/vehicle_gui.cpp	(working copy)
@@ -39,7 +39,6 @@
 #include "tilehighlight_func.h"
 #include "zoom_func.h"
 
-
 Sorting _sorting;
 
 static GUIVehicleList::SortFunction VehicleNumberSorter;
@@ -156,6 +155,7 @@
 {
 	DropDownList *list = new DropDownList();
 
+	list->push_back(new DropDownListStringItem(STR_TMPL_TEMPLATE_REPLACEMENT, ADI_TEMPLATE_REPLACE, false));		// MYGUI_NOEND
 	if (show_autoreplace) list->push_back(new DropDownListStringItem(STR_VEHICLE_LIST_REPLACE_VEHICLES, ADI_REPLACE, false));
 	list->push_back(new DropDownListStringItem(STR_VEHICLE_LIST_SEND_FOR_SERVICING, ADI_SERVICE, false));
 	list->push_back(new DropDownListStringItem(this->vehicle_depot_name[this->vli.vtype], ADI_DEPOT, false));
@@ -370,6 +370,7 @@
 	VehicleID selected_vehicle;  ///< First vehicle in the current selection.
 	uint8 num_vehicles;          ///< Number of selected vehicles.
 	bool auto_refit;             ///< Select cargo for auto-refitting.
+	bool is_virtual_train;
 
 	/**
 	 * Collects all (cargo, subcargo) refit options of a vehicle chain.
@@ -483,10 +484,11 @@
 		return NULL;
 	}
 
-	RefitWindow(const WindowDesc *desc, const Vehicle *v, VehicleOrderID order, bool auto_refit) : Window()
+	RefitWindow(const WindowDesc *desc, const Vehicle *v, VehicleOrderID order, bool auto_refit, bool is_virtual) : Window()
 	{
 		this->sel = -1;
 		this->auto_refit = auto_refit;
+		this->is_virtual_train = is_virtual;
 		this->CreateNestedTree(desc);
 
 		this->vscroll = this->GetScrollbar(WID_VR_SCROLLBAR);
@@ -829,14 +831,15 @@
 			}
 
 			case WID_VR_REFIT: // refit button
+
 				if (this->cargo != NULL) {
 					const Vehicle *v = Vehicle::Get(this->window_number);
 
 					if (this->order == INVALID_VEH_ORDER_ID) {
 						bool delete_window = this->selected_vehicle == v->index && this->num_vehicles == UINT8_MAX;
-						if (DoCommandP(v->tile, this->selected_vehicle, this->cargo->cargo | this->cargo->subtype << 8 | this->num_vehicles << 16, GetCmdRefitVeh(v)) && delete_window) delete this;
+						if (DoCommandP(v->tile, this->selected_vehicle, this->cargo->cargo | this->cargo->subtype << 8 | this->num_vehicles << 16 | this->is_virtual_train << 5, GetCmdRefitVeh(v)) && delete_window) delete this;
 					} else {
-						if (DoCommandP(v->tile, v->index, this->cargo->cargo | this->cargo->subtype << 8 | this->order << 16, CMD_ORDER_REFIT)) delete this;
+						if (DoCommandP(v->tile, v->index, this->cargo->cargo | this->cargo->subtype << 8 | this->order << 16 | this->is_virtual_train << 5, CMD_ORDER_REFIT)) delete this;
 					}
 				}
 				break;
@@ -917,10 +920,10 @@
  * @param parent the parent window of the refit window
  * @param auto_refit Choose cargo for auto-refitting
  */
-void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit)
+void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit, bool is_virtual_train)
 {
 	DeleteWindowById(WC_VEHICLE_REFIT, v->index);
-	RefitWindow *w = new RefitWindow(&_vehicle_refit_desc, v, order, auto_refit);
+	RefitWindow *w = new RefitWindow(&_vehicle_refit_desc, v, order, auto_refit, is_virtual_train);
 	w->parent = parent;
 }
 
Index: src/aaa_template_gui_replaceall.cpp
===================================================================
--- src/aaa_template_gui_replaceall.cpp	(revision 0)
+++ src/aaa_template_gui_replaceall.cpp	(revision 0)
@@ -0,0 +1,519 @@
+// replace all gui impl
+
+#include "aaa_template_gui_replaceall.h"
+
+#include <stdio.h>
+
+/*
+ * A wrapper which contains a virtual train and additional info of the template vehicle it is replacing
+ * We will restore this additional info when creating a new template from the changed virtual train
+ */
+struct VirtTrainInfo {
+	// the virtual train
+	Train *vt;
+
+	// additional info from the template
+	VehicleID original_index;
+
+	bool	reuse_depot_vehicles,
+			keep_remaining_vehicles,
+			refit_as_template;
+
+	CargoID cargo_type;
+	byte cargo_subtype;
+
+	// a fancy constructor
+	VirtTrainInfo(Train *t) { this->vt = t; }
+};
+
+typedef AutoFreeSmallVector<VirtTrainInfo*, 64> VirtTrainList;
+enum Widgets {
+	RPLALL_GUI_CAPTION,
+
+	RPLALL_GUI_INSET_1,
+	RPLALL_GUI_INSET_1_1,
+	RPLALL_GUI_INSET_1_2,
+	RPLALL_GUI_MATRIX_TOPLEFT,
+	RPLALL_GUI_MATRIX_TOPRIGHT,
+	RPLALL_GUI_SCROLL_TL,
+	RPLALL_GUI_SCROLL_TR,
+
+	RPLALL_GUI_INSET_2,
+	RPLALL_GUI_MATRIX_BOTTOM,
+	RPLALL_GUI_SCROLL_BO,
+
+	RPLALL_GUI_INSET_3,
+	RPLALL_GUI_BUTTON_RPLALL,
+	RPLALL_GUI_PANEL_BUTTONFLUFF_1,
+	RPLALL_GUI_PANEL_BUTTONFLUFF_2,
+	RPLALL_GUI_BUTTON_APPLY,
+	RPLALL_GUI_PANEL_BUTTONFLUFF_3,
+	RPLALL_GUI_BUTTON_CANCEL,
+
+	RPLALL_GUI_PANEL_RESIZEFLUFF
+};
+
+static const NWidgetPart widgets[] = {
+	// title bar
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, RPLALL_GUI_CAPTION), SetDataTip(STR_TMPL_RPLALLGUI_TITLE, STR_TMPL_RPLALLGUI_TITLE),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	// top matrices
+		NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_1), SetMinimalSize(100,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_INSET_TOP, STR_TMPL_RPLALLGUI_INSET_TOP), EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_1_1), SetMinimalSize(100,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_INSET_TOP_1, STR_TMPL_RPLALLGUI_INSET_TOP_1), EndContainer(),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_MATRIX, COLOUR_GREY, RPLALL_GUI_MATRIX_TOPLEFT), SetMinimalSize(100, 16), SetFill(1, 1), SetResize(1, 1), SetScrollbar(RPLALL_GUI_SCROLL_TL),// SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY),
+				NWidget(NWID_VSCROLLBAR, COLOUR_GREY, RPLALL_GUI_SCROLL_TL),
+			EndContainer(),
+		EndContainer(),
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_1_2), SetMinimalSize(100,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_INSET_TOP_2, STR_TMPL_RPLALLGUI_INSET_TOP_2), EndContainer(),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_MATRIX, COLOUR_GREY, RPLALL_GUI_MATRIX_TOPRIGHT), SetMinimalSize(100, 16), SetFill(1, 1), SetResize(1, 1), SetScrollbar(RPLALL_GUI_SCROLL_TR),// SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY),
+				NWidget(NWID_VSCROLLBAR, COLOUR_GREY, RPLALL_GUI_SCROLL_TR),
+			EndContainer(),
+		EndContainer(),
+	EndContainer(),
+	// bottom matrix
+	NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_2), SetMinimalSize(200,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_INSET_BOTTOM, STR_TMPL_RPLALLGUI_INSET_BOTTOM), EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, RPLALL_GUI_MATRIX_BOTTOM), SetMinimalSize(200, 16), SetFill(1, 1), SetResize(1, 1), SetScrollbar(RPLALL_GUI_SCROLL_BO),// SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY),
+		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, RPLALL_GUI_SCROLL_BO),
+	EndContainer(),
+	// control area
+	NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_3), SetMinimalSize(200,12), SetResize(1,0), EndContainer(),// SetDataTip(STR_TMPL_MAINGUI_DEFINEDGROUPS, STR_TMPL_MAINGUI_DEFINEDGROUPS),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY, RPLALL_GUI_PANEL_BUTTONFLUFF_1), SetMinimalSize(75,12), SetResize(1,0), EndContainer(),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, RPLALL_GUI_BUTTON_RPLALL), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_RPLALLGUI_BUTTON_RPLALL, STR_TMPL_RPLALLGUI_BUTTON_RPLALL),
+		NWidget(WWT_PANEL, COLOUR_GREY, RPLALL_GUI_PANEL_BUTTONFLUFF_2), SetMinimalSize(75,12), SetResize(1,0), EndContainer(),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, RPLALL_GUI_BUTTON_APPLY), SetMinimalSize(75,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_BUTTON_APPLY, STR_TMPL_RPLALLGUI_BUTTON_APPLY),
+		NWidget(WWT_PANEL, COLOUR_GREY, RPLALL_GUI_PANEL_BUTTONFLUFF_3), SetMinimalSize(150,12), SetResize(0,0), EndContainer(),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, RPLALL_GUI_BUTTON_CANCEL), SetMinimalSize(75,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_BUTTON_CANCEL, STR_TMPL_RPLALLGUI_BUTTON_CANCEL),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY, RPLALL_GUI_PANEL_RESIZEFLUFF), SetMinimalSize(100,12), SetResize(1,0), EndContainer(),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static const WindowDesc _template_replace_replaceall_desc(
+	WDP_AUTO, 400, 200,
+	WC_TEMPLATEGUI_RPLALL, WC_NONE,
+	WDF_UNCLICK_BUTTONS | WDF_CONSTRUCTION,
+	widgets, lengthof(widgets)
+);
+
+static int CDECL EngineNumberSorter(const EngineID *a, const EngineID *b)
+{
+	int r = ListPositionOfEngine(*a) - ListPositionOfEngine(*b);
+	return r;
+}
+static int CDECL TrainEnginesThenWagonsSorter(const EngineID *a, const EngineID *b)
+{
+	int val_a = (RailVehInfo(*a)->railveh_type == RAILVEH_WAGON ? 1 : 0);
+	int val_b = (RailVehInfo(*b)->railveh_type == RAILVEH_WAGON ? 1 : 0);
+	int r = val_a - val_b;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return r;
+}
+
+
+class TemplateReplacementReplaceAllWindow : public Window {
+private:
+	uint16 line_height;
+	Scrollbar	*vscroll_tl,
+				*vscroll_tr,
+				*vscroll_bo;
+	GUIEngineList *engines_left,
+				  *engines_right;
+	short	selected_left,
+			selected_right;
+	VirtTrainList *virtualTrains;
+
+public:
+	TemplateReplacementReplaceAllWindow(const WindowDesc *wdesc) : Window()
+	{
+
+		this->CreateNestedTree(wdesc);
+
+		this->vscroll_tl = this->GetScrollbar(RPLALL_GUI_SCROLL_TL);
+		this->vscroll_tr = this->GetScrollbar(RPLALL_GUI_SCROLL_TR);
+		this->vscroll_bo = this->GetScrollbar(RPLALL_GUI_SCROLL_BO);
+		this->vscroll_tl->SetStepSize(16);
+		this->vscroll_tr->SetStepSize(16);
+		this->vscroll_bo->SetStepSize(16);
+
+		this->FinishInitNested(wdesc, VEH_TRAIN);
+
+		this->owner = _local_company;
+
+		engines_left = new GUIEngineList();
+		engines_right = new GUIEngineList();
+		virtualTrains = new VirtTrainList();
+
+		this->GenerateBuyableEnginesList();
+		this->GenerateIncludedTemplateList();
+
+		this->line_height = 16;
+		this->selected_left = -1;
+		this->selected_right = -1;
+	}
+
+	~TemplateReplacementReplaceAllWindow()
+	{
+		for ( int i=0; i<this->virtualTrains->Length(); i++ )
+			delete (*this->virtualTrains)[i]->vt;
+		SetWindowClassesDirty(WC_TEMPLATEGUI_MAIN);
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch ( widget ) {
+			case RPLALL_GUI_MATRIX_TOPLEFT:
+			case RPLALL_GUI_MATRIX_TOPRIGHT:
+			case RPLALL_GUI_MATRIX_BOTTOM: {
+				resize->height = 16;
+				size->height = 16;
+				break;
+			}
+		}
+	}
+
+	virtual void OnPaint()
+	{
+ 		this->GetWidget<NWidgetCore>(RPLALL_GUI_PANEL_BUTTONFLUFF_3)->colour  = _company_colours[_local_company];
+
+		this->DrawWidgets();
+	}
+
+	virtual void OnResize()
+	{
+		NWidgetCore *nwi_tl = this->GetWidget<NWidgetCore>(RPLALL_GUI_MATRIX_TOPLEFT);
+		this->vscroll_tl->SetCapacityFromWidget(this, RPLALL_GUI_MATRIX_TOPLEFT);
+		nwi_tl->widget_data = (this->vscroll_tl->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+
+		NWidgetCore *nwi_tr = this->GetWidget<NWidgetCore>(RPLALL_GUI_MATRIX_TOPRIGHT);
+		this->vscroll_tr->SetCapacityFromWidget(this, RPLALL_GUI_MATRIX_TOPRIGHT);
+		nwi_tr->widget_data = (this->vscroll_tr->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+
+		NWidgetCore *nwi_bo = this->GetWidget<NWidgetCore>(RPLALL_GUI_MATRIX_BOTTOM);
+		this->vscroll_bo->SetCapacityFromWidget(this, RPLALL_GUI_MATRIX_BOTTOM);
+		nwi_bo->widget_data = (this->vscroll_bo->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch (widget) {
+			case RPLALL_GUI_MATRIX_TOPLEFT: {
+				this->DrawEngineList(r, true);
+				break;
+			}
+			case RPLALL_GUI_MATRIX_TOPRIGHT: {
+				this->DrawEngineList(r, false);
+				break;
+			}
+			case RPLALL_GUI_MATRIX_BOTTOM: {
+				this->DrawVirtualTrains(r);
+				break;
+			}
+		}
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch(widget) {
+			case RPLALL_GUI_MATRIX_TOPLEFT: {
+				uint16 newindex = (uint16)((pt.y - this->nested_array[RPLALL_GUI_MATRIX_TOPLEFT]->pos_y) / this->line_height) + this->vscroll_tl->GetPosition();
+				if ( newindex >= this->engines_left->Length() || newindex==this->selected_left )
+					this->selected_left = -1;
+				else
+					this->selected_left = newindex;
+				this->SetDirty();
+				break;
+			}
+			case RPLALL_GUI_MATRIX_TOPRIGHT: {
+				uint16 newindex = (uint16)((pt.y - this->nested_array[RPLALL_GUI_MATRIX_TOPRIGHT]->pos_y) / this->line_height) + this->vscroll_tr->GetPosition();
+				if ( newindex > this->engines_right->Length() || newindex==this->selected_right )
+					this->selected_right = -1;
+				else
+					this->selected_right = newindex;
+				this->SetDirty();
+				break;
+			}
+			case RPLALL_GUI_BUTTON_RPLALL: {
+				this->ReplaceAll();
+				break;
+			}
+			case RPLALL_GUI_BUTTON_APPLY: {
+				// check if we actually did anything so far, if not, applying is forbidden
+				if ( this->virtualTrains->Length() == 0 )
+					return;
+				// first delete all current templates
+				this->DeleteAllTemplateTrains();
+				// then build a new list from the current virtual trains
+				for ( int i=0; i<this->virtualTrains->Length(); i++ ) {
+					// the relevant info struct
+					VirtTrainInfo *vti = (*this->virtualTrains)[i];
+					// setup template from contained train
+					Train *t = vti->vt;
+					TemplateVehicle *tv = TemplateVehicleFromVirtualTrain(t);
+					// restore template specific stuff
+					tv->reuse_depot_vehicles		= vti->reuse_depot_vehicles;
+					tv->keep_remaining_vehicles		= vti->keep_remaining_vehicles;
+					tv->refit_as_template			= vti->refit_as_template;
+					tv->cargo_type					= vti->cargo_type;
+					tv->cargo_subtype				= vti->cargo_subtype;
+					// use the original_index information to repoint the relevant TemplateReplacement if existing
+					TemplateReplacement *tr = GetTemplateReplacementByTemplateID(vti->original_index);
+					if ( tr )
+						tr->sel_template = tv->index;
+				}
+				// then close this window and return to parent
+				delete this;
+				break;
+			}
+			case RPLALL_GUI_BUTTON_CANCEL: {
+				delete this;
+				break;
+			}
+		}
+	}
+
+	bool HasTemplateWithEngine(EngineID eid) const
+	{
+		const TemplateVehicle *tv;
+		FOR_ALL_TEMPLATES(tv) {
+			if ( tv->Prev() || tv->owner != _local_company ) continue;
+			for ( const TemplateVehicle *tmp=tv; tmp; tmp=tmp->GetNextUnit() ) {
+				if ( tmp->engine_type == eid )
+					return true;
+			}
+		}
+		return false;
+	}
+
+	void GenerateVirtualTrains()
+	{
+		this->virtualTrains->Clear();
+
+		TemplateVehicle *tv;
+		FOR_ALL_TEMPLATES(tv) {
+			if ( !tv->Prev() && tv->owner==this->owner ) {
+				// setup template train
+				Train *newtrain = VirtualTrainFromTemplateVehicle(tv);
+				VirtTrainInfo *vti = new VirtTrainInfo(newtrain);
+				// store template specific stuff
+				vti->original_index				= tv->index;
+				vti->reuse_depot_vehicles		= tv->reuse_depot_vehicles;
+				vti->keep_remaining_vehicles	= tv->keep_remaining_vehicles;
+				vti->refit_as_template			= tv->refit_as_template;
+				vti->cargo_type					= tv->cargo_type;
+				vti->cargo_subtype				= tv->cargo_subtype;
+				// add new info struct
+				*this->virtualTrains->Append() = vti;
+			}
+		}
+
+		this->vscroll_bo->SetCount(this->virtualTrains->Length());
+	}
+
+	// move to func ?
+	void DeleteAllTemplateTrains()
+	{
+		TemplateVehicle *tv, *tmp;
+		FOR_ALL_TEMPLATES(tv) {
+			tmp = tv;
+			if ( tmp->Prev()==0 && tmp->owner==this->owner )
+				delete tmp;
+		}
+	}
+
+	void GenerateIncludedTemplateList()
+	{
+		int num_engines = 0;
+		int num_wagons  = 0;
+
+		this->engines_left->Clear();
+
+		const Engine *e;
+		FOR_ALL_ENGINES_OF_TYPE(e, VEH_TRAIN) {
+			EngineID eid = e->index;
+			const RailVehicleInfo*rvi = &e->u.rail;
+
+			if ( !HasTemplateWithEngine(eid) ) continue;
+
+			*this->engines_left->Append() = eid;
+
+			if (rvi->railveh_type != RAILVEH_WAGON) {
+				num_engines++;
+			} else {
+				num_wagons++;
+			}
+		}
+		this->vscroll_tl->SetCount(this->engines_left->Length());
+	}
+
+	bool VirtualTrainHasEngineID(EngineID eid)
+	{
+// 		printf("called for eid: %d\n", eid);
+
+		for ( int i=0; i<this->virtualTrains->Length(); i++ ) {
+			const Train *tmp = (*this->virtualTrains)[i]->vt;
+// 			printf("checking train:\n"); pvt(tmp);
+			for ( ; tmp; tmp=tmp->Next() )
+				if ( tmp->engine_type == eid )
+					return true;
+// 			printf("_________\n");
+		}
+// 		printf("return false\n______\n");
+		return false;
+	}
+
+	// after 'replace all' we need to replace the currently used templates as well
+	void RebuildIncludedTemplateList() {
+		// first remove all engine ids
+		for ( int i=0; i<this->engines_left->Length(); i++ ) {
+			EngineID entry = (*this->engines_left)[i];
+			if ( !VirtualTrainHasEngineID(entry) )
+				this->engines_left->Erase(&((*this->engines_left)[i]));
+		}
+	}
+
+	void ReplaceAll()
+	{
+
+		if ( this->selected_left==-1 || this->selected_right==-1 )
+			return;
+
+		EngineID eid_orig = (*this->engines_left)[this->selected_left];
+		EngineID eid_repl = (*this->engines_right)[this->selected_right];
+
+		if ( eid_orig == eid_repl )
+			return;
+
+		if ( this->virtualTrains->Length() == 0 )
+			this->GenerateVirtualTrains();
+
+		for ( int i=0; i<this->virtualTrains->Length(); i++ ) {
+			Train *tmp = (*this->virtualTrains)[i]->vt;
+			while ( tmp ) {
+				if ( tmp->engine_type == eid_orig ) {
+					// build a new virtual rail vehicle and test for success
+					Train *nt = CmdBuildVirtualRailVehicle(eid_repl);
+					if ( !nt ) continue;
+					// include the (probably) new engine into the 'included'-list
+					this->engines_left->Include( nt->engine_type );
+					// advance the tmp pointer in the chain, otherwise it would get deleted later on
+					Train *to_del = tmp;
+					tmp = tmp->GetNextUnit();
+					// first move the new virtual rail vehicle behind to_del
+					CommandCost move = CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, nt->index|(1<<21), to_del->index, 0);
+					// then move to_del away from the chain and delete it
+					move = CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, to_del->index|(1<<21), INVALID_VEHICLE, 0);
+					(*this->virtualTrains)[i]->vt = nt->First();
+					delete to_del;
+				} else {
+					tmp = tmp->GetNextUnit();
+				}
+			}
+		}
+		this->selected_left = -1;
+		// rebuild the left engines list as some engines might not be there anymore
+		this->RebuildIncludedTemplateList();
+		this->SetDirty();
+	}
+
+	void GenerateBuyableEnginesList()
+	{
+		int num_engines = 0;
+		int num_wagons  = 0;
+
+		this->engines_right->Clear();
+
+		const Engine *e;
+		FOR_ALL_ENGINES_OF_TYPE(e, VEH_TRAIN) {
+			EngineID eid = e->index;
+			const RailVehicleInfo *rvi = &e->u.rail;
+
+			if (!IsEngineBuildable(eid, VEH_TRAIN, _local_company)) continue;
+
+			*this->engines_right->Append() = eid;
+
+			if (rvi->railveh_type != RAILVEH_WAGON) {
+				num_engines++;
+			} else {
+				num_wagons++;
+			}
+		}
+
+		/* make engines first, and then wagons, sorted by ListPositionOfEngine() */
+		EngList_Sort(this->engines_right, TrainEnginesThenWagonsSorter);
+
+		this->vscroll_tr->SetCount(this->engines_right->Length());
+	}
+
+	void DrawEngineList(const Rect &r, bool left) const//, GUIEngineList el, Scrollbar* sb) const
+	{
+		uint16 y = r.top;
+		uint32 eid;
+
+		Scrollbar *sb;
+		const GUIEngineList *el;
+
+		if ( left ) {
+			sb = this->vscroll_tl;
+			el = this->engines_left;
+		} else {
+			sb = this->vscroll_tr;
+			el = this->engines_right;
+		}
+
+		int maximum = min((int)sb->GetCapacity(), (int)el->Length()) + sb->GetPosition();
+
+		for ( int i=sb->GetPosition(); i<maximum; i++ ) {
+
+			eid = (*el)[i];
+
+			/* Draw a grey background rectangle if the current line is the selected one */
+			if ( (left && this->selected_left == i) || (!left && this->selected_right == i) )
+				GfxFillRect(r.left, y, r.right, y+this->line_height, _colour_gradient[COLOUR_GREY][3]);
+
+			/* Draw a description string of the current engine */
+			SetDParam(0, eid);
+			DrawString(r.left+100, r.right, y+4, STR_ENGINE_NAME, TC_BLACK);
+
+			/* Draw the engine */
+			DrawVehicleEngine( r.left, r.right, r.left+29, y+8, eid, GetEnginePalette(eid, _local_company), EIT_PURCHASE );
+
+			y += this->line_height;
+		}
+	}
+
+	void DrawVirtualTrains(const Rect &r) const
+	{
+		uint16 y = r.top;
+
+		uint16 max = min(virtualTrains->Length(), this->vscroll_bo->GetCapacity());
+
+		for ( uint16 i=vscroll_bo->GetPosition(); i<max+vscroll_bo->GetPosition(); i++ ) {
+			/* Draw a virtual train*/
+			DrawTrainImage( (*this->virtualTrains)[i]->vt, r.left+32, r.right, y, INVALID_VEHICLE, EIT_PURCHASE, 0, -1 );
+
+			y+= this->line_height;
+		}
+	}
+};
+
+void ShowTemplateReplaceAllGui()
+{
+	new TemplateReplacementReplaceAllWindow(&_template_replace_replaceall_desc);
+}
\ No newline at end of file
Index: src/saveload/saveload.cpp
===================================================================
--- src/saveload/saveload.cpp	(revision 24093)
+++ src/saveload/saveload.cpp	(working copy)
@@ -42,6 +42,8 @@
 #include "../fios.h"
 #include "../error.h"
 
+#include "../aaa_template_vehicle.h" //MYGUI
+
 #include "table/strings.h"
 
 #include "saveload_internal.h"
@@ -239,7 +241,7 @@
  *  173   23967   1.2.0-RC1
  *  174   23973   1.2.x
  */
-extern const uint16 SAVEGAME_VERSION = 174; ///< Current savegame version of OpenTTD.
+extern const uint16 SAVEGAME_VERSION = SL_EXT_RATING; ///< Current savegame version of OpenTTD.
 
 SavegameType _savegame_type; ///< type of savegame we are loading
 
@@ -417,9 +419,12 @@
 extern const ChunkHandler _cargopacket_chunk_handlers[];
 extern const ChunkHandler _autoreplace_chunk_handlers[];
 extern const ChunkHandler _labelmaps_chunk_handlers[];
+extern const ChunkHandler _linkgraph_chunk_handlers[];
 extern const ChunkHandler _airport_chunk_handlers[];
 extern const ChunkHandler _object_chunk_handlers[];
 extern const ChunkHandler _persistent_storage_chunk_handlers[];
+extern const ChunkHandler _template_replacement_chunk_handlers[]; //MYGUI
+extern const ChunkHandler _template_vehicle_chunk_handlers[]; //MYGUI
 
 /** Array of all chunks in a savegame, \c NULL terminated. */
 static const ChunkHandler * const _chunk_handlers[] = {
@@ -450,9 +455,12 @@
 	_cargopacket_chunk_handlers,
 	_autoreplace_chunk_handlers,
 	_labelmaps_chunk_handlers,
+	_linkgraph_chunk_handlers,
 	_airport_chunk_handlers,
 	_object_chunk_handlers,
 	_persistent_storage_chunk_handlers,
+	_template_replacement_chunk_handlers,			// MYGUI
+	_template_vehicle_chunk_handlers,				// MYGUI
 	NULL,
 };
 
@@ -1199,6 +1207,7 @@
 	switch (rt) {
 		case REF_VEHICLE_OLD: // Old vehicles we save as new onces
 		case REF_VEHICLE:   return ((const  Vehicle*)obj)->index + 1;
+		case REF_TEMPLATE_VEHICLE: return ((const TemplateVehicle*)obj)->index + 1;	// MYGUI
 		case REF_STATION:   return ((const  Station*)obj)->index + 1;
 		case REF_TOWN:      return ((const     Town*)obj)->index + 1;
 		case REF_ORDER:     return ((const    Order*)obj)->index + 1;
@@ -1256,6 +1265,10 @@
 			if (Vehicle::IsValidID(index)) return Vehicle::Get(index);
 			SlErrorCorrupt("Referencing invalid Vehicle");
 
+		case REF_TEMPLATE_VEHICLE:						// MYGUI
+			if (TemplateVehicle::IsValidID(index)) return TemplateVehicle::Get(index);
+			SlErrorCorrupt("Referencing invalid TemplateVehicle");
+
 		case REF_STATION:
 			if (Station::IsValidID(index)) return Station::Get(index);
 			SlErrorCorrupt("Referencing invalid Station");
Index: src/saveload/saveload_internal.h
===================================================================
--- src/saveload/saveload_internal.h	(revision 24093)
+++ src/saveload/saveload_internal.h	(working copy)
@@ -28,9 +28,11 @@
 
 void AfterLoadVehicles(bool part_of_load);
 void FixupTrainLengths();
+void AfterLoadTemplateVehicles(); //MYGUI
 void AfterLoadStations();
 void AfterLoadRoadStops();
 void AfterLoadLabelMaps();
+void AfterLoadLinkGraphs();
 void AfterLoadCompanyStats();
 void UpdateHousesAndTowns();
 
Index: src/saveload/oldloader_sl.cpp
===================================================================
--- src/saveload/oldloader_sl.cpp	(revision 24093)
+++ src/saveload/oldloader_sl.cpp	(working copy)
@@ -710,7 +710,7 @@
 	SB(ge->acceptance_pickup, GoodsEntry::GES_ACCEPTANCE, 1, HasBit(_waiting_acceptance, 15));
 	SB(ge->acceptance_pickup, GoodsEntry::GES_PICKUP, 1, _cargo_source != 0xFF);
 	if (GB(_waiting_acceptance, 0, 12) != 0 && CargoPacket::CanAllocateItem()) {
-		ge->cargo.Append(new CargoPacket(GB(_waiting_acceptance, 0, 12), _cargo_days, (_cargo_source == 0xFF) ? INVALID_STATION : _cargo_source, 0, 0));
+		ge->cargo.Append(INVALID_STATION, new CargoPacket(GB(_waiting_acceptance, 0, 12), _cargo_days, (_cargo_source == 0xFF) ? INVALID_STATION : _cargo_source, 0, 0));
 	}
 
 	return true;
Index: src/saveload/economy_sl.cpp
===================================================================
--- src/saveload/economy_sl.cpp	(revision 24093)
+++ src/saveload/economy_sl.cpp	(working copy)
@@ -63,11 +63,11 @@
 }
 
 static const SaveLoad _cargopayment_desc[] = {
-	SLE_REF(CargoPayment, front,         REF_VEHICLE),
-	SLE_VAR(CargoPayment, route_profit,  SLE_INT64),
-	SLE_VAR(CargoPayment, visual_profit, SLE_INT64),
-
-	SLE_END()
+	    SLE_REF(CargoPayment, front,           REF_VEHICLE),
+	    SLE_VAR(CargoPayment, route_profit,    SLE_INT64),
+	    SLE_VAR(CargoPayment, visual_profit,   SLE_INT64),
+	SLE_CONDVAR(CargoPayment, visual_transfer, SLE_INT64, SL_CARGOMAP, SL_MAX_VERSION),
+	    SLE_END()
 };
 
 static void Save_CAPY()
Index: src/saveload/cargopacket_sl.cpp
===================================================================
--- src/saveload/cargopacket_sl.cpp	(revision 24093)
+++ src/saveload/cargopacket_sl.cpp	(working copy)
@@ -29,7 +29,7 @@
 		 * to the current tile of the vehicle to prevent excessive profits
 		 */
 		FOR_ALL_VEHICLES(v) {
-			const VehicleCargoList::List *packets = v->cargo.Packets();
+			const CargoPacketList *packets = v->cargo.Packets();
 			for (VehicleCargoList::ConstIterator it(packets->begin()); it != packets->end(); it++) {
 				CargoPacket *cp = *it;
 				cp->source_xy = Station::IsValidID(cp->source) ? Station::Get(cp->source)->xy : v->tile;
@@ -47,7 +47,7 @@
 			for (CargoID c = 0; c < NUM_CARGO; c++) {
 				GoodsEntry *ge = &st->goods[c];
 
-				const StationCargoList::List *packets = ge->cargo.Packets();
+				const StationCargoPacketMap *packets = ge->cargo.Packets();
 				for (StationCargoList::ConstIterator it(packets->begin()); it != packets->end(); it++) {
 					CargoPacket *cp = *it;
 					cp->source_xy = Station::IsValidID(cp->source) ? Station::Get(cp->source)->xy : st->xy;
Index: src/saveload/aaa_template_replacement_sl.cpp
===================================================================
--- src/saveload/aaa_template_replacement_sl.cpp	(revision 0)
+++ src/saveload/aaa_template_replacement_sl.cpp	(revision 0)
@@ -0,0 +1,35 @@
+#include "../stdafx.h"
+
+#include "../aaa_template_vehicle.h"
+
+#include "saveload.h"
+
+static const SaveLoad _template_replacement_desc[] = {
+	SLE_VAR(TemplateReplacement, sel_template, SLE_UINT16),
+	SLE_VAR(TemplateReplacement, group, SLE_UINT16),
+	SLE_END()
+};
+
+static void Save_TMPL_RPLS()
+{
+	TemplateReplacement *tr;
+
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		SlSetArrayIndex(tr->index);
+		SlObject(tr, _template_replacement_desc);
+	}
+}
+
+static void Load_TMPL_RPLS()
+{
+	int index;
+
+	while ((index = SlIterateArray()) != -1) {
+		TemplateReplacement *tr = new (index) TemplateReplacement();
+		SlObject(tr, _template_replacement_desc);
+	}
+}
+
+extern const ChunkHandler _template_replacement_chunk_handlers[] = {
+	{'TRPL', Save_TMPL_RPLS, Load_TMPL_RPLS, NULL, NULL, CH_ARRAY | CH_LAST},
+};
Index: src/saveload/afterload.cpp
===================================================================
--- src/saveload/afterload.cpp	(revision 24093)
+++ src/saveload/afterload.cpp	(working copy)
@@ -685,6 +685,9 @@
 	/* Update all vehicles */
 	AfterLoadVehicles(true);
 
+	// MYGUI
+	AfterLoadTemplateVehicles();
+
 	/* Make sure there is an AI attached to an AI company */
 	{
 		Company *c;
@@ -2742,6 +2745,8 @@
 	InitializeWindowsAndCaches();
 	/* Restore the signals */
 	ResetSignalHandlers();
+
+	AfterLoadLinkGraphs();
 	return true;
 }
 
Index: src/saveload/saveload.h
===================================================================
--- src/saveload/saveload.h	(revision 24093)
+++ src/saveload/saveload.h	(working copy)
@@ -83,11 +83,9 @@
 	REF_CARGO_PACKET  = 7, ///< Load/save a reference to a cargo packet.
 	REF_ORDERLIST     = 8, ///< Load/save a reference to an orderlist.
 	REF_STORAGE       = 9, ///< Load/save a reference to a persistent storage.
+	REF_TEMPLATE_VEHICLE = 10, ///< Load/save a reference to a template vehicle     // MYGUI
 };
 
-/** Highest possible savegame version. */
-#define SL_MAX_VERSION 255
-
 /** Flags of a chunk. */
 enum ChunkType {
 	CH_RIFF         =  0,
@@ -546,4 +544,23 @@
 extern char _savegame_format[8];
 extern bool _do_autosave;
 
+/**
+ * Save/load versions used for the various branches.
+ * SL_TRUNK is always the current trunk version.
+ */
+enum SaveLoadVersions {
+	SL_TRUNK = 174,
+	SL_CAPACITIES,
+	SL_COMPONENTS,
+	SL_DEMANDS,
+	SL_MCF,
+	SL_FLOWMAP,
+	SL_RESERVATION,
+	SL_CARGOMAP,
+	SL_EXT_RATING,
+
+	/** Highest possible savegame version. */
+	SL_MAX_VERSION = 255
+};
+
 #endif /* SAVELOAD_H */
Index: src/saveload/vehicle_sl.cpp
===================================================================
--- src/saveload/vehicle_sl.cpp	(revision 24093)
+++ src/saveload/vehicle_sl.cpp	(working copy)
@@ -589,6 +589,7 @@
 		     SLE_VAR(Vehicle, vehstatus,             SLE_UINT8),
 		 SLE_CONDVAR(Vehicle, last_station_visited,  SLE_FILE_U8  | SLE_VAR_U16,   0,   4),
 		 SLE_CONDVAR(Vehicle, last_station_visited,  SLE_UINT16,                   5, SL_MAX_VERSION),
+		 SLE_CONDVAR(Vehicle, last_loading_station,  SLE_UINT16,       SL_CAPACITIES, SL_MAX_VERSION),
 
 		     SLE_VAR(Vehicle, cargo_type,            SLE_UINT8),
 		 SLE_CONDVAR(Vehicle, cargo_subtype,         SLE_UINT8,                   35, SL_MAX_VERSION),
@@ -597,8 +598,10 @@
 		SLEG_CONDVAR(         _cargo_source,         SLE_UINT16,                   7,  67),
 		SLEG_CONDVAR(         _cargo_source_xy,      SLE_UINT32,                  44,  67),
 		     SLE_VAR(Vehicle, cargo_cap,             SLE_UINT16),
+		 SLE_CONDVAR(Vehicle, refit_cap,             SLE_UINT16,       SL_CAPACITIES, SL_MAX_VERSION),
 		SLEG_CONDVAR(         _cargo_count,          SLE_UINT16,                   0,  67),
 		 SLE_CONDLST(Vehicle, cargo.packets,         REF_CARGO_PACKET,            68, SL_MAX_VERSION),
+		 SLE_CONDLST(Vehicle, cargo.reserved,        REF_CARGO_PACKET,SL_RESERVATION, SL_MAX_VERSION),
 		 SLE_CONDVAR(Vehicle, cargo_age_counter,     SLE_UINT16,                 162, SL_MAX_VERSION),
 
 		     SLE_VAR(Vehicle, day_counter,           SLE_UINT8),
@@ -885,6 +888,8 @@
 			v->last_station_visited = INVALID_STATION;
 		}
 
+		if (IsSavegameVersionBefore(SL_CAPACITIES)) v->last_loading_station = INVALID_STATION;
+
 		if (IsSavegameVersionBefore(5)) {
 			/* Convert the current_order.type (which is a mix of type and flags, because
 			 *  in those versions, they both were 4 bits big) to type and flags */
Index: src/saveload/aaa_template_veh_sl.cpp
===================================================================
--- src/saveload/aaa_template_veh_sl.cpp	(revision 0)
+++ src/saveload/aaa_template_veh_sl.cpp	(revision 0)
@@ -0,0 +1,100 @@
+#include "../stdafx.h"
+
+#include "../aaa_template_vehicle.h"
+
+#include "saveload.h"
+
+const SaveLoad* GTD() {
+
+	static const SaveLoad _template_veh_desc[] = {
+		SLE_REF(TemplateVehicle, next, 		REF_TEMPLATE_VEHICLE),
+
+		SLE_VAR(TemplateVehicle, reuse_depot_vehicles, SLE_UINT8),
+		SLE_VAR(TemplateVehicle, keep_remaining_vehicles, SLE_UINT8),
+		SLE_VAR(TemplateVehicle, refit_as_template, SLE_UINT8),
+
+		SLE_VAR(TemplateVehicle, owner, SLE_UINT8),
+		SLE_VAR(TemplateVehicle, owner_b, SLE_UINT8),
+
+		SLE_VAR(TemplateVehicle, engine_type, SLE_UINT16),
+		SLE_VAR(TemplateVehicle, cargo_type, SLE_UINT16),
+		SLE_VAR(TemplateVehicle, cargo_cap, SLE_UINT16),
+		SLE_VAR(TemplateVehicle, cargo_subtype, SLE_UINT8),
+
+		SLE_VAR(TemplateVehicle, subtype, SLE_UINT8),
+		SLE_VAR(TemplateVehicle, railtype, SLE_UINT8),
+
+		SLE_VAR(TemplateVehicle, index, SLE_UINT32),
+
+		SLE_VAR(TemplateVehicle, real_consist_length, SLE_UINT16),
+
+		SLE_VAR(TemplateVehicle, max_speed, SLE_UINT16),
+		SLE_VAR(TemplateVehicle, power, SLE_UINT32),
+		SLE_VAR(TemplateVehicle, weight, SLE_UINT32),
+		SLE_VAR(TemplateVehicle, max_te, SLE_UINT32),
+
+		SLE_VAR(TemplateVehicle, spritenum, SLE_UINT8),
+		SLE_VAR(TemplateVehicle, cur_image, SLE_UINT32),
+		SLE_VAR(TemplateVehicle, image_width, SLE_UINT32),
+		SLE_VAR(TemplateVehicle, sgroup, SLE_UINT32),
+
+		SLE_END()
+	};
+
+	static const SaveLoad * const _ret[] = {
+		_template_veh_desc,
+	};
+
+	return _ret[0];
+}
+
+static void Save_TMPLS()
+{
+	TemplateVehicle *tv;
+
+	FOR_ALL_TEMPLATES(tv) {
+		SlSetArrayIndex(tv->index);
+		SlObject(tv, GTD());
+	}
+}
+
+static void Load_TMPLS()
+{
+	int index;
+
+	while ((index = SlIterateArray()) != -1) {
+		TemplateVehicle *tv = new (index) TemplateVehicle(); //TODO:check with veh sl code
+		SlObject(tv, GTD());
+	}
+}
+
+static void Ptrs_TMPLS()
+{
+	TemplateVehicle *tv;
+	FOR_ALL_TEMPLATES(tv) {
+		SlObject(tv, GTD());
+	}
+}
+
+void AfterLoadTemplateVehicles()
+{
+	TemplateVehicle *tv;
+
+	FOR_ALL_TEMPLATES(tv) {
+		/* Reinstate the previous pointer */
+		if (tv->next != NULL) tv->next->previous = tv;
+		tv->first =NULL;
+	}
+	FOR_ALL_TEMPLATES(tv) {
+		/* Fill the first pointers */
+		if (tv->previous == NULL) {
+			for (TemplateVehicle *u = tv; u != NULL; u = u->Next()) {
+				u->first = tv;
+			}
+		}
+	}
+}
+
+extern const ChunkHandler _template_vehicle_chunk_handlers[] = {
+	{'TMPL', Save_TMPLS, Load_TMPLS, Ptrs_TMPLS, NULL, CH_ARRAY | CH_LAST},
+};
Index: src/saveload/station_sl.cpp
===================================================================
--- src/saveload/station_sl.cpp	(revision 24093)
+++ src/saveload/station_sl.cpp	(working copy)
@@ -224,9 +224,11 @@
 };
 
 static uint16 _waiting_acceptance;
+static uint16 _num_links;
+static uint32 _num_flows;
 static uint16 _cargo_source;
 static uint32 _cargo_source_xy;
-static uint16 _cargo_days;
+static uint8  _cargo_days;
 static Money  _cargo_feeder_share;
 
 static const SaveLoad _station_speclist_desc[] = {
@@ -236,7 +238,45 @@
 	SLE_END()
 };
 
+static StationID _station_id;
+
 /**
+ * Wrapper function to get the LinkStat's internal structure while
+ * some of the variables are private.
+ * @return Saveload description for LinkStat.
+ */
+const SaveLoad *GetLinkStatDesc()
+{
+	static const SaveLoad linkstat_desc[] = {
+		SLEG_VAR(          _station_id, SLE_UINT16),
+		 SLE_VAR(LinkStat, length,      SLE_UINT32),
+		 SLE_VAR(LinkStat, capacity,    SLE_UINT32),
+		 SLE_VAR(LinkStat, timeout,     SLE_UINT32),
+		 SLE_VAR(LinkStat, usage,       SLE_UINT32),
+		 SLE_END()
+	};
+
+	return linkstat_desc;
+}
+
+std::list<CargoPacket *> _packets;
+uint32 _num_dests;
+
+struct FlowSaveLoad {
+	FlowSaveLoad() : via(0), share(0) {}
+	StationID source;
+	StationID via;
+	uint32 share;
+};
+
+static const SaveLoad _flow_desc[] = {
+	SLE_CONDVAR(FlowSaveLoad, source,             SLE_UINT16,         SL_FLOWMAP, SL_MAX_VERSION),
+	SLE_CONDVAR(FlowSaveLoad, via,                SLE_UINT16,         SL_FLOWMAP, SL_MAX_VERSION),
+	SLE_CONDVAR(FlowSaveLoad, share,              SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+	SLE_END()
+};
+
+/**
  * Wrapper function to get the GoodsEntry's internal structure while
  * some of the variables itself are private.
  * @return the saveload description for GoodsEntry.
@@ -258,15 +298,50 @@
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_FILE_U32 | SLE_VAR_I64, 14, 64),
 		SLEG_CONDVAR(            _cargo_feeder_share, SLE_INT64,                  65, 67),
 		 SLE_CONDVAR(GoodsEntry, amount_fract,        SLE_UINT8,                 150, SL_MAX_VERSION),
-		 SLE_CONDLST(GoodsEntry, cargo.packets,       REF_CARGO_PACKET,           68, SL_MAX_VERSION),
-
+		SLEG_CONDLST(            _packets,            REF_CARGO_PACKET,           68, SL_CARGOMAP - 1),
+		SLEG_CONDVAR(            _num_dests,          SLE_UINT32,        SL_CARGOMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, supply,              SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, supply_new,          SLE_UINT32,      SL_CAPACITIES, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_links,          SLE_UINT16,      SL_CAPACITIES, SL_MAX_VERSION),
+		SLEG_CONDVAR(            _num_flows,          SLE_UINT32,         SL_FLOWMAP, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, last_component,      SLE_UINT16,      SL_COMPONENTS, SL_MAX_VERSION),
+		 SLE_CONDVAR(GoodsEntry, max_waiting_cargo,   SLE_UINT32,      SL_EXT_RATING, SL_MAX_VERSION),
 		SLE_END()
 	};
 
 	return goods_desc;
 }
 
+typedef std::pair<const StationID, std::list<CargoPacket *> > StationCargoPair;
 
+static const SaveLoad _cargo_list_desc[] = {
+	SLE_VAR(StationCargoPair, first,  SLE_UINT16),
+	SLE_LST(StationCargoPair, second, REF_CARGO_PACKET),
+	SLE_END()
+};
+
+/**
+ * swap the temporary packets with the packets without specific destination in
+ * the given goods entry. Assert that at least one of those is empty.
+ * @param ge the goods entry to swap with
+ */
+static void SwapPackets(GoodsEntry *ge)
+{
+	StationCargoPacketMap &ge_packets = const_cast<StationCargoPacketMap &>(*ge->cargo.Packets());
+
+	if (_packets.empty()) {
+		std::map<StationID, std::list<CargoPacket *> >::iterator it(ge_packets.find(INVALID_STATION));
+		if (it == ge_packets.end()) {
+			return;
+		} else {
+			it->second.swap(_packets);
+		}
+	} else {
+		assert(ge_packets[INVALID_STATION].empty());
+		ge_packets[INVALID_STATION].swap(_packets);
+	}
+}
+
 static void Load_STNS()
 {
 	int index;
@@ -281,6 +356,7 @@
 		for (CargoID i = 0; i < num_cargo; i++) {
 			GoodsEntry *ge = &st->goods[i];
 			SlObject(ge, GetGoodsDesc());
+			SwapPackets(ge);
 			if (IsSavegameVersionBefore(68)) {
 				SB(ge->acceptance_pickup, GoodsEntry::GES_ACCEPTANCE, 1, HasBit(_waiting_acceptance, 15));
 				if (GB(_waiting_acceptance, 0, 12) != 0) {
@@ -292,7 +368,10 @@
 					 * savegame versions. As the CargoPacketPool has more than
 					 * 16 million entries; it fits by an order of magnitude. */
 					assert(CargoPacket::CanAllocateItem());
-					ge->cargo.Append(new CargoPacket(GB(_waiting_acceptance, 0, 12), _cargo_days, source, _cargo_source_xy, _cargo_source_xy, _cargo_feeder_share));
+
+					/* Don't construct the packet with station here, because that'll fail with old savegames */
+					CargoPacket *cp = new CargoPacket(GB(_waiting_acceptance, 0, 12), _cargo_days, source, _cargo_source_xy, _cargo_source_xy, _cargo_feeder_share);
+					ge->cargo.Append(INVALID_STATION, cp);
 					SB(ge->acceptance_pickup, GoodsEntry::GES_PICKUP, 1, 1);
 				}
 			}
@@ -318,7 +397,9 @@
 		if (!IsSavegameVersionBefore(68)) {
 			for (CargoID i = 0; i < NUM_CARGO; i++) {
 				GoodsEntry *ge = &st->goods[i];
+				SwapPackets(ge);
 				SlObject(ge, GetGoodsDesc());
+				SwapPackets(ge);
 			}
 		}
 		SlObject(st, _old_station_desc);
@@ -409,7 +490,34 @@
 	if (!waypoint) {
 		Station *st = Station::From(bst);
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
+			_num_dests = (uint32)st->goods[i].cargo.Packets()->MapSize();
+			_num_links = (uint16)st->goods[i].link_stats.size();
+			_num_flows = 0;
+			for (FlowStatMap::const_iterator it(st->goods[i].flows.begin()); it != st->goods[i].flows.end(); ++it) {
+				_num_flows += (uint32)it->second.GetShares()->size();
+			}
 			SlObject(&st->goods[i], GetGoodsDesc());
+			for (LinkStatMap::const_iterator it(st->goods[i].link_stats.begin()); it != st->goods[i].link_stats.end(); ++it) {
+				_station_id = it->first;
+				LinkStat ls(it->second); // make a copy to avoid constness problems
+				SlObject(&ls, GetLinkStatDesc());
+			}
+			for (FlowStatMap::const_iterator outer_it(st->goods[i].flows.begin()); outer_it != st->goods[i].flows.end(); ++outer_it) {
+				const FlowStat::SharesMap *shares = outer_it->second.GetShares();
+				uint32 sum_shares = 0;
+				FlowSaveLoad flow;
+				flow.source = outer_it->first;
+				for (FlowStat::SharesMap::const_iterator inner_it(shares->begin()); inner_it != shares->end(); ++inner_it) {
+					flow.via = inner_it->second;
+					flow.share = inner_it->first - sum_shares;
+					sum_shares = inner_it->first;
+					assert(flow.share > 0);
+					SlObject(&flow, _flow_desc);
+				}
+			}
+			for (StationCargoPacketMap::ConstMapIterator it(st->goods[i].cargo.Packets()->begin()); it != st->goods[i].cargo.Packets()->end(); ++it) {
+				SlObject(const_cast<StationCargoPacketMap::value_type *>(&(*it)), _cargo_list_desc);
+			}
 		}
 	}
 
@@ -451,6 +559,34 @@
 
 			for (CargoID i = 0; i < NUM_CARGO; i++) {
 				SlObject(&st->goods[i], GetGoodsDesc());
+				LinkStat ls(1);
+				for (uint16 j = 0; j < _num_links; ++j) {
+					SlObject(&ls, GetLinkStatDesc());
+					assert(ls.IsValid());
+					st->goods[i].link_stats.insert(std::make_pair(_station_id, ls));
+				}
+				FlowSaveLoad flow;
+				FlowStat *fs = NULL;
+				StationID prev_source = INVALID_STATION;
+				for (uint32 j = 0; j < _num_flows; ++j) {
+					SlObject(&flow, _flow_desc);
+					if (fs == NULL || prev_source != flow.source) {
+						fs = &(st->goods[i].flows.insert(std::make_pair(flow.source, FlowStat(flow.via, flow.share))).first->second);
+					} else {
+						fs->AddShare(flow.via, flow.share);
+					}
+					prev_source = flow.source;
+				}
+				if (IsSavegameVersionBefore(SL_CARGOMAP -1)) {
+					SwapPackets(&st->goods[i]);
+				} else {
+					StationCargoPair pair;
+					for (uint j = 0; j < _num_dests; ++j) {
+						SlObject(&pair, _cargo_list_desc);
+						const_cast<StationCargoPacketMap &>(*(st->goods[i].cargo.Packets()))[pair.first].swap(pair.second);
+						assert(pair.second.empty());
+					}
+				}
 			}
 		}
 
@@ -473,7 +609,16 @@
 	FOR_ALL_STATIONS(st) {
 		for (CargoID i = 0; i < NUM_CARGO; i++) {
 			GoodsEntry *ge = &st->goods[i];
-			SlObject(ge, GetGoodsDesc());
+			if (IsSavegameVersionBefore(SL_CARGOMAP)) {
+				SwapPackets(ge);
+				SlObject(ge, GetGoodsDesc());
+				SwapPackets(ge);
+			} else {
+				SlObject(ge, GetGoodsDesc());
+				for (StationCargoPacketMap::ConstMapIterator it = ge->cargo.Packets()->begin(); it != ge->cargo.Packets()->end(); ++it) {
+					SlObject(const_cast<StationCargoPair *>(&(*it)), _cargo_list_desc);
+				}
+			}
 		}
 		SlObject(st, _station_desc);
 	}
Index: src/station_base.h
===================================================================
--- src/station_base.h	(revision 24093)
+++ src/station_base.h	(working copy)
@@ -12,11 +12,15 @@
 #ifndef STATION_BASE_H
 #define STATION_BASE_H
 
+#include "core/random_func.hpp"
 #include "base_station_base.h"
 #include "newgrf_airport.h"
 #include "cargopacket.h"
 #include "industry_type.h"
+#include "linkgraph/linkgraph_type.h"
 #include "newgrf_storage.h"
+#include "moving_average.h"
+#include <map>
 
 typedef Pool<BaseStation, StationID, 32, 64000> StationPool;
 extern StationPool _station_pool;
@@ -24,6 +28,189 @@
 static const byte INITIAL_STATION_RATING = 175;
 
 /**
+ * Link statistics. They include figures for capacity and usage of a link. Both
+ * are moving averages which are increased for every vehicle arriving at the
+ * destination station and decreased in regular intervals. Additionally while a
+ * vehicle is loading at the source station part of the capacity is frozen and
+ * prevented from being decreased. This is done so that the link won't break
+ * down all the time when the typical "full load" order is used.
+ */
+class LinkStat : private MovingAverage<uint> {
+private:
+	/**
+	 * Capacity of the link.
+	 * This is a moving average. Use MovingAverage::Monthly() to get a meaningful value.
+	 */
+	uint capacity;
+
+	/**
+	 * Time until the link is removed. Decreases exponentially.
+	 */
+	uint timeout;
+
+	/**
+	 * Usage of the link.
+	 * This is a moving average. Use MovingAverage::Monthly() to get a meaningful value.
+	 */
+	uint usage;
+
+public:
+	/**
+	 * Minimum length of moving averages for capacity and usage.
+	 */
+	static const uint MIN_AVERAGE_LENGTH = 48;
+
+	friend const SaveLoad *GetLinkStatDesc();
+
+	/**
+	 * We don't allow creating a link stat without a timeout/length.
+	 */
+	LinkStat() : MovingAverage<uint>(0) {NOT_REACHED();}
+
+	/**
+	 * Create a link stat with at least a distance.
+	 * @param distance Length for the moving average and link timeout.
+	 * @param capacity Initial capacity of the link.
+	 * @param usage Initial usage of the link.
+	 */
+	inline LinkStat(uint distance, uint capacity = 1, uint usage = 0) :
+		MovingAverage<uint>(distance), capacity(capacity), timeout(distance), usage(usage)
+	{
+		assert(this->usage <= this->capacity);
+	}
+
+	/**
+	 * Reset everything to 0.
+	 */
+	inline void Clear()
+	{
+		this->capacity = 1;
+		this->usage = 0;
+		this->timeout = this->length;
+	}
+
+	/**
+	 * Apply the moving averages to usage and capacity.
+	 */
+	inline void Decrease()
+	{
+		this->MovingAverage<uint>::Decrease(this->usage);
+		this->timeout = this->timeout * MIN_AVERAGE_LENGTH / (MIN_AVERAGE_LENGTH + 1);
+		this->capacity = max(this->MovingAverage<uint>::Decrease(this->capacity), (uint)1);
+		assert(this->usage <= this->capacity);
+	}
+
+	/**
+	 * Get an estimate of the current the capacity by calculating the moving average.
+	 * @return Capacity.
+	 */
+	inline uint Capacity() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->capacity);
+	}
+
+	/**
+	 * Get an estimage of the current usage by calculating the moving average.
+	 * @return Usage.
+	 */
+	inline uint Usage() const
+	{
+		return this->MovingAverage<uint>::Monthly(this->usage);
+	}
+
+	/**
+	 * Add some capacity and usage.
+	 * @param capacity Additional capacity.
+	 * @param usage Additional usage.
+	 */
+	inline void Increase(uint capacity, uint usage)
+	{
+		this->timeout = this->length;
+		this->capacity += capacity;
+		this->usage += usage;
+		assert(this->usage <= this->capacity);
+	}
+
+	/**
+	 * Reset the timeout and make sure there is at least a minimum capacity.
+	 */
+	inline void Refresh(uint min_capacity)
+	{
+		this->capacity = max(this->capacity, min_capacity);
+		this->timeout = this->length;
+	}
+
+	/**
+	 * Check if the timeout has hit.
+	 * @return If timeout is > 0.
+	 */
+	inline bool IsValid() const
+	{
+		return this->timeout > 0;
+	}
+};
+
+/**
+ * Flow statistics telling how much flow should be sent along a link. This is
+ * done by creating "flow shares" and using std::map's upper_bound() method to
+ * look them up with a random number. A flow share is the difference between a
+ * key in a map and the previous key. So one key in the map doesn't actually
+ * mean anything by itself.
+ */
+class FlowStat {
+public:
+	typedef std::map<uint32, StationID> SharesMap;
+
+	inline FlowStat() {NOT_REACHED();}
+
+	inline FlowStat(StationID st, uint flow)
+	{
+		assert(flow > 0);
+		this->shares[flow] = st;
+	}
+
+	/**
+	 * Add some flow.
+	 * @param st Remote station.
+	 * @param flow Amount of flow to be added.
+	 */
+	inline void AddShare(StationID st, uint flow)
+	{
+		assert(flow > 0);
+		this->shares[(--this->shares.end())->first + flow] = st;
+	}
+
+	uint GetShare(StationID st) const;
+
+	void EraseShare(StationID st);
+
+	inline const SharesMap *GetShares() const {return &this->shares;}
+
+	/**
+	 * Get a station a package can be routed to. This done by drawing a
+	 * random number between 0 and sum_shares and then looking that up in
+	 * the map with lower_bound. So each share gets selected with a
+	 * probability dependent on its flow.
+         * @return A station ID from the shares map.
+         */
+	inline StationID GetVia() const
+	{
+		assert(!this->shares.empty());
+		return this->shares.upper_bound(RandomRange((--this->shares.end())->first - 1))->second;
+	}
+
+	StationID GetVia(StationID excluded) const;
+
+private:
+	SharesMap shares;  ///< Shares of flow to be sent via specified station (or consumed locally).
+};
+
+typedef std::map<StationID, LinkStat> LinkStatMap;
+typedef std::map<StationID, FlowStat> FlowStatMap; ///< Flow descriptions by origin stations.
+
+uint GetMovingAverageLength(const Station *from, const Station *to);
+
+/**
  * Stores station stats for a single cargo.
  */
 struct GoodsEntry {
@@ -42,7 +229,11 @@
 		days_since_pickup(255),
 		rating(INITIAL_STATION_RATING),
 		last_speed(0),
-		last_age(255)
+		last_age(255),
+		supply(0),
+		supply_new(0),
+		last_component(INVALID_LINKGRAPH_COMPONENT),
+		max_waiting_cargo(0)
 	{}
 
 	byte acceptance_pickup; ///< Status of this cargo, see #GoodsEntryStatus.
@@ -52,6 +243,20 @@
 	byte last_age;          ///< Age in years of the last vehicle that picked up this cargo.
 	byte amount_fract;      ///< Fractional part of the amount in the cargo list
 	StationCargoList cargo; ///< The cargo packets of cargo waiting in this station
+	uint supply;            ///< Cargo supplied last month.
+	uint supply_new;        ///< Cargo supplied so far this month.
+	FlowStatMap flows;      ///< Planned flows through this station.
+	LinkStatMap link_stats; ///< Capacities and usage statistics for outgoing links.
+	LinkGraphComponentID last_component; ///< Component this station was last part of in this cargo's link graph.
+	uint max_waiting_cargo;              ///< Max cargo from this station waiting at any station.
+
+	uint GetSumFlowVia(StationID via) const;
+
+	inline StationID GetVia(StationID source, StationID excluded = INVALID_STATION) const
+	{
+		FlowStatMap::const_iterator flow_it(this->flows.find(source));
+		return flow_it != this->flows.end() ? flow_it->second.GetVia(excluded) : INVALID_STATION;
+	}
 };
 
 /** All airport-related information. Only valid if tile != INVALID_TILE. */
@@ -257,6 +462,8 @@
 	/* virtual */ uint32 GetNewGRFVariable(const ResolverObject *object, byte variable, byte parameter, bool *available) const;
 
 	/* virtual */ void GetTileArea(TileArea *ta, StationType type) const;
+
+	void RunAverages();
 };
 
 #define FOR_ALL_STATIONS(var) FOR_ALL_BASE_STATIONS_OF_TYPE(Station, var)
Index: src/train_gui.cpp
===================================================================
--- src/train_gui.cpp	(revision 24093)
+++ src/train_gui.cpp	(working copy)
@@ -18,6 +18,9 @@
 
 #include "table/strings.h"
 
+// MYGUI_NOEND
+#include <stdio.h>
+
 /**
  * Callback for building wagons.
  * @param result The result of the command.
@@ -56,7 +59,8 @@
  * @param selection Selected vehicle that is dragged.
  * @return The width of the highlight mark.
  */
-static int HighlightDragPosition(int px, int max_width, VehicleID selection)
+// MYGUI_NOEND previously static
+int HighlightDragPosition(int px, int max_width, VehicleID selection)
 {
 	bool rtl = _current_text_dir == TD_RTL;
 
Index: src/landscape.cpp
===================================================================
--- src/landscape.cpp	(revision 24093)
+++ src/landscape.cpp	(working copy)
@@ -1284,6 +1284,7 @@
 void OnTick_Industry();
 
 void OnTick_Companies();
+void OnTick_LinkGraph();
 
 void CallLandscapeTick()
 {
@@ -1293,4 +1294,5 @@
 	OnTick_Industry();
 
 	OnTick_Companies();
+	OnTick_LinkGraph();
 }
Index: src/roadveh_cmd.cpp
===================================================================
--- src/roadveh_cmd.cpp	(revision 24093)
+++ src/roadveh_cmd.cpp	(working copy)
@@ -262,6 +262,7 @@
 		v->cargo_cap = rvi->capacity;
 
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 		v->engine_type = e->index;
 		v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
 
Index: src/aaa_template_gui_create_virtualtrain.h
===================================================================
--- src/aaa_template_gui_create_virtualtrain.h	(revision 0)
+++ src/aaa_template_gui_create_virtualtrain.h	(revision 0)
@@ -0,0 +1,8 @@
+#ifndef BUILD_VIRTUAL_TRAIN_GUI
+#define BUILD_VIRTUAL_TRAIN_GUI
+
+#include "train.h"
+
+void ShowBuildVirtualTrainWindow(Train**, bool*);
+
+#endif
Index: src/aaa_template_vehicle.h
===================================================================
--- src/aaa_template_vehicle.h	(revision 0)
+++ src/aaa_template_vehicle.h	(revision 0)
@@ -0,0 +1,229 @@
+#ifndef TEMPLATE_VEH_H
+#define TEMPLATE_VEH_H
+
+#include "vehicle_type.h"
+#include "vehicle_base.h"
+#include "vehicle_func.h"
+
+#include "articulated_vehicles.h"
+#include "newgrf_callbacks.h"
+#include "newgrf_engine.h"
+#include "newgrf_spritegroup.h"
+
+#include "engine_base.h"
+#include "engine_type.h"
+#include "engine_func.h"
+
+#include "sortlist_type.h"
+
+#define FOR_ALL_TEMPLATES_FROM(var, start) FOR_ALL_ITEMS_FROM(TemplateVehicle, template_index, var, start)
+#define FOR_ALL_TEMPLATES(var) FOR_ALL_TEMPLATES_FROM(var, 0)
+
+#define FOR_ALL_TEMPLATE_REPLACEMENTS_FROM(var, start) FOR_ALL_ITEMS_FROM(TemplateReplacement, template_replacement_index, var, start)
+#define FOR_ALL_TEMPLATE_REPLACEMENTS(var) FOR_ALL_TEMPLATE_REPLACEMENTS_FROM(var, 0)
+
+struct TemplateVehicle;
+struct TemplateReplacement;
+
+CommandCost CmdBuildTemplateVehicle(uint i, DoCommandFlag flags, uint p1, uint p2, char const* text);
+CommandCost CmdTemplateReplaceVehicle(uint i, DoCommandFlag flags, uint p1, uint p2, char const* text);
+typedef uint16 TemplateID;
+
+
+static const uint16 CONSIST_HEAD = 0x0;
+static const uint16 CONSIST_TAIL = 0xffff;
+
+/** A pool allowing to store up to ~64k templates */
+typedef Pool<TemplateVehicle, TemplateID, 512, 0x10000> TemplatePool;
+extern TemplatePool _template_pool;
+
+/// listing/sorting templates
+typedef GUIList<const TemplateVehicle*> GUITemplateList;
+
+/* TODO: rearrange attribs -.- care fore saveload as well */
+struct TemplateVehicle : TemplatePool::PoolItem<&_template_pool>, BaseVehicle {
+private:
+	TemplateVehicle *next;                      ///< pointer to the next vehicle in the chain
+	TemplateVehicle *previous;                  ///< NOSAVE: pointer to the previous vehicle in the chain
+	TemplateVehicle *first;                     ///< NOSAVE: pointer to the first vehicle in the chain
+
+public:
+	friend const SaveLoad* GTD();
+	friend void AfterLoadTemplateVehicles();
+
+	// Template usage configuration
+	bool reuse_depot_vehicles;
+	bool keep_remaining_vehicles;
+	bool refit_as_template;
+
+	// Things derived from a virtual train
+	TemplateVehicle *other_multiheaded_part;	///< Multiheaded Engine support
+	Money value;                        ///< Value of the vehicle
+	Owner owner;
+	OwnerByte owner_b;
+
+	EngineID engine_type;               ///< The type of engine used for this vehicle.
+	CargoID cargo_type;                 ///< type of cargo this vehicle is carrying
+	uint16 cargo_cap;                   ///< total capacity
+	byte cargo_subtype;
+
+	byte subtype;
+	RailTypeByte railtype;
+
+	VehicleID index;
+
+	uint16 real_consist_length;
+
+	uint16 max_speed;
+	uint32 power;
+	uint32 weight;
+	uint32 max_te;
+
+	byte spritenum;
+	SpriteID cur_image;
+	int image_width;
+	const SpriteGroup *sgroup;
+
+	TemplateVehicle(VehicleType type=VEH_INVALID,  EngineID e=INVALID_ENGINE, byte B=0, Owner=OWNER_BEGIN); // TODO:owner_begin not a good choice for the default
+	TemplateVehicle(EngineID, RailVehicleInfo*);
+	TemplateVehicle(EngineID eid) {
+		next=0;
+		previous=0;
+		first=this;
+		engine_type=eid;
+		this->reuse_depot_vehicles = true;
+		this->keep_remaining_vehicles = true;
+		this->refit_as_template = true;
+	}
+	~TemplateVehicle();
+
+	inline TemplateVehicle* Next() const { return this->next; }
+	inline TemplateVehicle* Prev() const { return this->previous; }
+	inline TemplateVehicle* First() const { return this->first; }
+
+	void SetNext(TemplateVehicle*);
+	void SetPrev(TemplateVehicle*);
+	void SetFirst(TemplateVehicle*);
+
+	// TODO
+	TemplateVehicle* GetNextUnit() const;
+	TemplateVehicle* GetPrevUnit();
+
+	bool IsSetReuseDepotVehicles() const { return this->reuse_depot_vehicles; }
+	bool IsSetKeepRemainingVehicles() const { return this->keep_remaining_vehicles; }
+	bool IsSetRefitAsTemplate() const { return this->refit_as_template; }
+	void ToggleReuseDepotVehicles() { this->reuse_depot_vehicles = !this->reuse_depot_vehicles; }
+	void ToggleKeepRemainingVehicles() { this->keep_remaining_vehicles = !this->keep_remaining_vehicles; }
+	void ToggleRefitAsTemplate() { this->refit_as_template = !this->refit_as_template; }
+
+	bool IsPrimaryVehicle() const { return this->IsFrontEngine(); }
+	inline bool IsFrontEngine() const { return HasBit(this->subtype, GVSF_FRONT); }
+	inline bool HasArticulatedPart() const { return this->Next() != NULL && this->Next()->IsArticulatedPart(); }
+
+	inline bool IsArticulatedPart() const { return HasBit(this->subtype, GVSF_ARTICULATED_PART); }
+	inline bool IsMultiheaded() const { return HasBit(this->subtype, GVSF_MULTIHEADED); }
+
+	inline bool IsFreeWagonChain() const { return HasBit(this->subtype, GVSF_FREE_WAGON); }
+
+	// since CmdBuildTemplateVehicle(...)
+	inline void SetFrontEngine() 		{ SetBit(this->subtype, GVSF_FRONT); }
+	inline void SetEngine()			{ SetBit(this->subtype, GVSF_ENGINE); }
+	inline void SetArticulatedPart()	{ SetBit(this->subtype, GVSF_ARTICULATED_PART); }
+	inline void SetMultiheaded()	 	{ SetBit(this->subtype, GVSF_MULTIHEADED); }
+
+	inline void SetWagon() { SetBit(this->subtype, GVSF_WAGON); }
+	inline void SetFreeWagon() { SetBit(this->subtype, GVSF_FREE_WAGON); }
+
+	inline uint16 GetRealLength() const { return this->real_consist_length; }
+	inline void SetRealLength(uint16 len) { this->real_consist_length = len; }
+
+	int Length() const;
+
+	SpriteID GetImage(Direction) const;
+	//int GetDisplayImageWidth(Point *offset = NULL) const;
+	SpriteID GetSpriteID() const;
+
+	short NumGroupsUsingTemplate() const;
+
+	short CountEnginesInChain();
+
+};
+
+void appendTemplateVehicle(TemplateVehicle*, TemplateVehicle*);
+void insertTemplateVehicle(TemplateVehicle*, TemplateVehicle*, TemplateVehicle*);
+
+void NeutralizeVehicleStatus(Train*);
+void SplitVehicleRemainders(Train*);
+
+// TemplateReplacement stuff
+
+typedef Pool<TemplateReplacement, uint16, 16, 1024> TemplateReplacementPool;
+extern TemplateReplacementPool _template_replacement_pool;
+
+struct TemplateReplacement : TemplateReplacementPool::PoolItem<&_template_replacement_pool> {
+	GroupID group;
+	TemplateID sel_template;
+
+	TemplateReplacement(GroupID gid, TemplateID tid) { this->group=gid; this->sel_template=tid; }
+	TemplateReplacement() {}
+	~TemplateReplacement() {}
+
+	inline GroupID Group() { return this->group; }
+	inline GroupID Template() { return this->sel_template; }
+
+ 	inline void SetGroup(GroupID gid) { this->group = gid; }
+ 	inline void SetTemplate(TemplateID tid) { this->sel_template = tid; }
+
+ 	inline TemplateID GetTemplateVehicleID() { return sel_template; }
+ 	inline const TemplateVehicle* GetTemplateVehicle() {
+		const TemplateVehicle *tv;
+		FOR_ALL_TEMPLATES(tv) {
+			if ( tv->index == this->sel_template )
+				return tv;
+		}
+		return NULL;
+	}
+};
+
+TemplateReplacement* GetTemplateReplacementByGroupID(GroupID);
+TemplateReplacement* GetTemplateReplacementByTemplateID(TemplateID);
+bool IssueTemplateReplacement(GroupID, TemplateID);
+
+short deleteIllegalTemplateReplacements(GroupID);
+
+#endif /* TEMPLATE_VEH_H */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Index: src/newgrf_spritegroup.cpp
===================================================================
--- src/newgrf_spritegroup.cpp	(revision 24093)
+++ src/newgrf_spritegroup.cpp	(working copy)
@@ -77,7 +77,6 @@
 	return (val >> rot) | (val << (32 - rot));
 }
 
-
 /* Evaluate an adjustment for a variable of the given size.
  * U is the unsigned type and S is the signed type to use. */
 template <typename U, typename S>
Index: src/station_func.h
===================================================================
--- src/station_func.h	(revision 24093)
+++ src/station_func.h	(working copy)
@@ -15,6 +15,7 @@
 #include "sprite.h"
 #include "rail_type.h"
 #include "road_type.h"
+#include "vehicle_type.h"
 #include "economy_func.h"
 
 void ModifyStationRatingAround(TileIndex tile, Owner owner, int amount, uint radius);
@@ -44,6 +45,12 @@
 
 void UpdateAirportsNoise();
 
+void IncreaseStats(Station *st, const Vehicle *v, StationID next_station_id);
+
+void IncreaseStats(Station *st, CargoID cargo, StationID next_station_id, uint capacity, uint usage);
+
+void DeleteStaleFlows(StationID at, CargoID c_id, StationID to);
+
 /**
  * Calculates the maintenance cost of a number of station tiles.
  * @param num Number of station tiles.
Index: src/newgrf_engine.cpp
===================================================================
--- src/newgrf_engine.cpp	(revision 24093)
+++ src/newgrf_engine.cpp	(working copy)
@@ -908,7 +908,6 @@
 	return in_motion ? group->loaded[set] : group->loading[set];
 }
 
-
 static inline void NewVehicleResolver(ResolverObject *res, EngineID engine_type, const Vehicle *v)
 {
 	res->GetRandomBits = &VehicleGetRandomBits;
@@ -932,6 +931,10 @@
 	res->grffile         = (e != NULL ? e->GetGRF() : NULL);
 }
 
+void NewVehicleResolverWrapper(ResolverObject *res, EngineID eid)
+{
+	NewVehicleResolver(res, eid, 0);
+}
 
 /**
  * Retrieve the SpriteGroup for the specified vehicle.
@@ -1296,3 +1299,114 @@
 	/* Make sure really all bits are set. */
 	assert(v->grf_cache.cache_valid == (1 << NCVV_END) - 1);
 }
+
+// TODO MYGUI
+/*
+uint16 SimulateLengthCallback(EngineID eid) {
+	Engine *e = Engine::Get(eid);
+
+	// callback stuff
+	const SpriteGroup *group;
+	ResolverObject object;
+
+	// setup the newvehicleresolver
+	object.GetRandomBits = &VehicleGetRandomBits;
+	object.GetTriggers   = &VehicleGetTriggers;
+	object.SetTriggers   = &VehicleSetTriggers;
+	object.GetVariable   = &VehicleGetVariable;
+	object.ResolveReal   = &VehicleResolveReal;
+	object.u.vehicle.self   = 0;
+	object.u.vehicle.parent = 0;
+	object.u.vehicle.self_type = eid;
+ 	object.u.vehicle.info_view = false;
+	object.ResetState();
+	object.grffile         = (e != NULL ? e->grf_prop.grffile : NULL);
+
+	// more setup from train_cmd.cpp
+	object.callback        = CBID_VEHICLE_LENGTH;
+	object.callback_param1 = 0;
+	object.callback_param2 = 0;
+
+	group = e->grf_prop.spritegroup[CT_DEFAULT];
+	group = SpriteGroup::Resolve(group, &object);
+
+	if (group == NULL) return CALLBACK_FAILED;
+	return group->GetCallbackResult();
+}
+
+
+
+SpriteID GetTemplateImage(EngineID eid, uint8 sprnum) {
+	uint8 spritenum = sprnum;
+	SpriteID sprite;
+
+	//if (HasBit(tv->flags, VRF_REVERSE_DIRECTION)) direction = ReverseDir(direction);
+
+	if (is_custom_sprite(spritenum)) {
+		const SpriteGroup *group;
+
+		ResolverObject object;
+		// resolver
+		object.GetRandomBits = &VehicleGetRandomBits;
+		object.GetTriggers   = &VehicleGetTriggers;
+		object.SetTriggers   = &VehicleSetTriggers;
+		object.GetVariable   = &VehicleGetVariable;
+		object.ResolveReal   = &VehicleResolveReal;
+		object.u.vehicle.self   = 0;
+		object.u.vehicle.parent = 0;
+		object.u.vehicle.self_type = eid;
+		object.u.vehicle.info_view = false;
+		object.callback        = CBID_NO_CALLBACK;
+		object.callback_param1 = 0;
+		object.callback_param2 = 0;
+		object.ResetState();
+		const Engine *e = Engine::Get(eid);
+		object.grffile         = (e != NULL ? e->grf_prop.grffile : NULL);
+
+		group = SpriteGroup::Resolve(e->grf_prop.spritegroup[CT_DEFAULT], &object);
+		if (group == NULL || group->GetNumResults() == 0) sprite=0;
+		sprite = group->GetResult() + (DIR_W % group->GetNumResults());
+
+		if (sprite != 0) return sprite;
+
+		spritenum = Engine::Get(eid)->original_image_index;
+	}
+	//sprite = GetDefaultTrainSprite(spritenum, direction);
+};*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// TODO
+
Index: src/vehicle.cpp
===================================================================
--- src/vehicle.cpp	(revision 24093)
+++ src/vehicle.cpp	(working copy)
@@ -53,6 +53,9 @@
 
 #include "table/strings.h"
 
+// MYGUI
+#include "aaa_template_vehicle_func.h"
+
 #define GEN_HASH(x, y) ((GB((y), 6 + ZOOM_LVL_SHIFT, 6) << 6) + GB((x), 7 + ZOOM_LVL_SHIFT, 6))
 
 VehicleID _new_vehicle_id;
@@ -597,6 +600,13 @@
 typedef SmallMap<Vehicle *, bool, 4> AutoreplaceMap;
 static AutoreplaceMap _vehicles_to_autoreplace;
 
+/**
+ * List of vehicles that are issued for template replacement this tick.
+ * Mapping is {vehicle : leave depot after replacement}
+ */
+typedef SmallMap<Train *, bool, 4> TemplateReplacementMap;
+static TemplateReplacementMap _vehicles_to_templatereplace;
+
 void InitializeVehicles()
 {
 	_vehicles_to_autoreplace.Reset();
@@ -711,10 +721,11 @@
 	if (CleaningPool()) return;
 
 	if (Station::IsValidID(this->last_station_visited)) {
-		Station::Get(this->last_station_visited)->loading_vehicles.remove(this);
+		Station *st = Station::Get(this->last_station_visited);
+		st->loading_vehicles.remove(this);
 
 		HideFillingPercent(&this->fill_percent_te_id);
-
+		this->CancelReservation(INVALID_STATION, st);
 		delete this->cargo_payment;
 	}
 
@@ -800,14 +811,25 @@
  */
 void VehicleEnteredDepotThisTick(Vehicle *v)
 {
-	/* Vehicle should stop in the depot if it was in 'stopping' state */
-	_vehicles_to_autoreplace[v] = !(v->vehstatus & VS_STOPPED);
+	/* Template Replacement Setup stuff */ // MYGUI
+	bool stayInDepot = v->current_order.GetDepotActionType();
+	TemplateReplacement *tr = GetTemplateReplacementByGroupID(v->group_id);
+	if ( tr ) {
+		if ( stayInDepot )	_vehicles_to_templatereplace[(Train*)v] = true;
+		else				_vehicles_to_templatereplace[(Train*)v] = false;
+	}
+	/* Moved the assignment for auto replacement here to prevent auto replacement
+	 * from happening if template replacement is also scheduled */
+	else
+		/* Vehicle should stop in the depot if it was in 'stopping' state */
+		_vehicles_to_autoreplace[v] = !(v->vehstatus & VS_STOPPED);
 
 	/* We ALWAYS set the stopped state. Even when the vehicle does not plan on
 	 * stopping in the depot, so we stop it to ensure that it will not reserve
 	 * the path out of the depot before we might autoreplace it to a different
 	 * engine. The new engine would not own the reserved path we store that we
 	 * stopped the vehicle, so autoreplace can start it again */
+
 	v->vehstatus |= VS_STOPPED;
 }
 
@@ -844,6 +866,7 @@
 void CallVehicleTicks()
 {
 	_vehicles_to_autoreplace.Clear();
+	_vehicles_to_templatereplace.Clear();
 
 	RunVehicleDayProc();
 
@@ -888,6 +911,7 @@
 		}
 	}
 
+	/* do Auto Replacement */
 	Backup<CompanyByte> cur_company(_current_company, FILE_LINE);
 	for (AutoreplaceMap::iterator it = _vehicles_to_autoreplace.Begin(); it != _vehicles_to_autoreplace.End(); it++) {
 		v = it->first;
@@ -932,8 +956,28 @@
 		SetDParam(1, error_message);
 		AddVehicleNewsItem(message, NS_ADVICE, v->index);
 	}
+	cur_company.Restore();
 
-	cur_company.Restore();
+	/* do Template Replacement */
+	Backup<CompanyByte> tmpl_cur_company(_current_company, FILE_LINE);
+	for (TemplateReplacementMap::iterator it = _vehicles_to_templatereplace.Begin(); it != _vehicles_to_templatereplace.End(); it++) {
+
+		Train *t = it->first;
+
+		tmpl_cur_company.Change(t->owner);
+
+		bool stayInDepot = it->second;
+
+		it->first->vehstatus |= VS_STOPPED;
+		REPLACEMENT_IN_PROGRESS = true;
+
+		CmdTemplateReplaceVehicle(t, stayInDepot, DC_EXEC);
+		/* Redraw main gui for changed statistics */
+		SetWindowClassesDirty(WC_TEMPLATEGUI_MAIN);
+
+		REPLACEMENT_IN_PROGRESS = false;
+	}
+	tmpl_cur_company.Restore();
 }
 
 /**
@@ -1240,7 +1284,7 @@
 
 	/* Count up max and used */
 	for (; v != NULL; v = v->Next()) {
-		count += v->cargo.Count();
+		count += v->cargo.OnboardCount();
 		max += v->cargo_cap;
 		if (v->cargo_cap != 0 && colour != NULL) {
 			unloading += HasBit(v->vehicle_flags, VF_CARGO_UNLOADING) ? 1 : 0;
@@ -1945,7 +1989,12 @@
 		this->current_order.MakeLoading(false);
 	}
 
-	Station::Get(this->last_station_visited)->loading_vehicles.push_back(this);
+	if (this->last_loading_station != INVALID_STATION &&
+			this->last_loading_station != this->last_station_visited &&
+			((this->current_order.GetLoadType() & OLFB_NO_LOAD) == 0 ||
+			(this->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0)) {
+		IncreaseStats(Station::Get(this->last_loading_station), this, this->last_station_visited);
+	}
 
 	PrepareUnload(this);
 
@@ -1960,6 +2009,23 @@
 }
 
 /**
+ * Return all reserved cargo packets to the station.
+ * @param st the station where the reserved packets should go.
+ */
+void Vehicle::CancelReservation(StationID next, Station *st)
+{
+	for (Vehicle *v = this; v != NULL; v = v->next) {
+		VehicleCargoList &cargo = v->cargo;
+		if (cargo.ReservedCount() > 0) {
+			DEBUG(misc, 1, "cancelling cargo reservation");
+			GoodsEntry &ge = st->goods[v->cargo_type];
+			cargo.Unreserve(next, &ge.cargo);
+			SetBit(ge.acceptance_pickup, GoodsEntry::GES_PICKUP);
+		}
+	}
+}
+
+/**
  * Perform all actions when leaving a station.
  * @pre this->current_order.IsType(OT_LOADING)
  */
@@ -1972,8 +2038,28 @@
 	/* Only update the timetable if the vehicle was supposed to stop here. */
 	if (this->current_order.GetNonStopType() != ONSF_STOP_EVERYWHERE) UpdateVehicleTimetable(this, false);
 
+	if ((this->current_order.GetLoadType() & OLFB_NO_LOAD) == 0 ||
+			(this->current_order.GetUnloadType() & OUFB_NO_UNLOAD) == 0) {
+		if (this->current_order.CanLeaveWithCargo(this->last_loading_station != INVALID_STATION)) {
+			/* Refresh next hop stats to make sure we've done that at least once
+			 * during the stop and that refit_cap == cargo_cap for each vehicle in
+			 * the consist.
+			 */
+			this->RefreshNextHopsStats();
+
+			/* if the vehicle could load here or could stop with cargo loaded set the last loading station */
+			this->last_loading_station = this->last_station_visited;
+		} else {
+			/* if the vehicle couldn't load and had to unload or transfer everything
+			 * set the last loading station to invalid as it will leave empty.
+			 */
+			this->last_loading_station = INVALID_STATION;
+		}
+	}
+
 	this->current_order.MakeLeaveStation();
 	Station *st = Station::Get(this->last_station_visited);
+	this->CancelReservation(INVALID_STATION, st);
 	st->loading_vehicles.remove(this);
 
 	HideFillingPercent(&this->fill_percent_te_id);
@@ -1986,7 +2072,101 @@
 	}
 }
 
+/**
+ * Predict a vehicle's course from it's current state and refresh all links it
+ * will visit. As a side effect reset the refit_cap of all vehicles in the
+ * consist to the cargo_cap. This method is expected to be called when loading
+ * at a station so it's safe to do so.
+ */
+void Vehicle::RefreshNextHopsStats()
+{
+	/* Assemble list of capacities and set last loading stations to 0. */
+	SmallMap<CargoID, uint, 1> capacities;
+	for (Vehicle *v = this; v != NULL; v = v->Next()) {
+		v->refit_cap = v->cargo_cap;
+		if (v->refit_cap == 0) continue;
+		SmallPair<CargoID, uint> *i = capacities.Find(v->cargo_type);
+		if (i == capacities.End()) {
+			/* Braindead smallmap not providing a good method for that. */
+			i = capacities.Append();
+			i->first = v->cargo_type;
+			i->second = v->cargo_cap;
+		} else {
+			i->second += v->cargo_cap;
+		}
+	}
 
+	/* If orders were deleted while loading, we're done here.*/
+	if (this->orders.list == NULL) return;
+
+	uint hops = 0;
+	const Order *first = this->orders.list->GetNextStoppingOrder(this,
+			this->GetOrder(this->cur_implicit_order_index), hops);
+	const Order *cur = first;
+	const Order *next = first;
+	while (next != NULL && cur->CanLeaveWithCargo(true)) {
+		next = this->orders.list->GetNextStoppingOrder(this,
+				this->orders.list->GetNext(next), ++hops);
+		if (next == NULL) break;
+
+		if (next->IsType(OT_GOTO_DEPOT)) {
+			/* handle refit by dropping some vehicles. */
+			CargoID new_cid = next->GetRefitCargo();
+			byte new_subtype = next->GetRefitSubtype();
+			for (Vehicle *v = this; v != NULL; v = v->Next()) {
+				const Engine *e = Engine::Get(v->engine_type);
+				if (!HasBit(e->info.refit_mask, new_cid)) continue;
+
+				/* Back up the vehicle's cargo type */
+				CargoID temp_cid = v->cargo_type;
+				byte temp_subtype = v->cargo_subtype;
+				v->cargo_type = new_cid;
+				v->cargo_subtype = new_subtype;
+
+				uint16 mail_capacity = 0;
+				uint amount = e->DetermineCapacity(v, &mail_capacity);
+
+				/* Restore the original cargo type */
+				v->cargo_type = temp_cid;
+				v->cargo_subtype = temp_subtype;
+
+				/* Skip on next refit. */
+				if (new_cid != v->cargo_type && v->refit_cap > 0) {
+					capacities[v->cargo_type] -= v->refit_cap;
+					v->refit_cap = 0;
+				} else if (amount < v->refit_cap) {
+					capacities[v->cargo_type] -= v->refit_cap - amount;
+					v->refit_cap = amount;
+				}
+
+				/* Special case for aircraft with mail. */
+				if (v->type == VEH_AIRCRAFT) {
+					Vehicle *u = v->Next();
+					if (mail_capacity < u->refit_cap) {
+						capacities[u->cargo_type] -= u->refit_cap - mail_capacity;
+						u->refit_cap = mail_capacity;
+					}
+					break; // aircraft have only one vehicle
+				}
+				if (v->type == VEH_SHIP) break; // ships too
+			}
+		} else {
+			StationID next_station = next->GetDestination();
+			Station *st = Station::GetIfValid(cur->GetDestination());
+			if (st != NULL && next_station != INVALID_STATION && next_station != st->index) {
+				for (const SmallPair<CargoID, uint> *i = capacities.Begin(); i != capacities.End(); ++i) {
+					/* Refresh the link and give it a minimum capacity. */
+					if (i->second > 0) IncreaseStats(st, i->first, next_station, i->second, UINT_MAX);
+				}
+			}
+			cur = next;
+			if (cur == first) break;
+		}
+	}
+
+	for (Vehicle *v = this; v != NULL; v = v->Next()) v->refit_cap = v->cargo_cap;
+}
+
 /**
  * Handle the loading of the vehicle; when not it skips through dummy
  * orders and does nothing in all other cases.
@@ -2024,6 +2204,34 @@
 }
 
 /**
+ * Get a map of cargoes and free capacities in the consist.
+ * @param capacities Map to be filled with cargoes and capacities.
+ */
+void Vehicle::GetConsistFreeCapacities(SmallMap<CargoID, uint> &capacities) const
+{
+	for (const Vehicle *v = this; v != NULL; v = v->Next()) {
+		if (v->cargo_cap == 0) continue;
+		SmallPair<CargoID, uint> *pair = capacities.Find(v->cargo_type);
+		if (pair == capacities.End()) {
+			pair = capacities.Append();
+			pair->first = v->cargo_type;
+			pair->second = v->cargo_cap - v->cargo.Count();
+		} else {
+			pair->second += v->cargo_cap - v->cargo.Count();
+		}
+	}
+}
+
+uint Vehicle::GetConsistTotalCapacity() const
+{
+	uint result = 0;
+	for (const Vehicle *v = this; v != NULL; v = v->Next()) {
+		result += v->cargo_cap;
+	}
+	return result;
+}
+
+/**
  * Send this vehicle to the depot using the given command(s).
  * @param flags   the command flags (like execute and such).
  * @param command the command to execute.
@@ -2191,8 +2399,6 @@
 			this->cur_speed < 2) {
 		return;
 	}
-
-	uint max_speed = this->vcache.cached_max_speed;
 	if (this->type == VEH_TRAIN) {
 		const Train *t = Train::From(this);
 		/* For trains, do not show any smoke when:
@@ -2204,11 +2410,7 @@
 				t->cur_speed >= t->Train::GetCurrentMaxSpeed())) {
 			return;
 		}
-
-		max_speed = min(max_speed, t->gcache.cached_max_track_speed);
-		max_speed = min(max_speed, this->current_order.max_speed);
 	}
-	if (this->type == VEH_ROAD || this->type == VEH_SHIP) max_speed = min(max_speed, this->current_order.max_speed * 2);
 
 	const Vehicle *v = this;
 
@@ -2254,7 +2456,7 @@
 				 * third of its maximum speed spectrum. Steam emission finally normalises at very close to vehicle's maximum speed.
 				 * REGULATION:
 				 * - instead of 1, 4 / 2^smoke_amount (max. 2) is used to provide sufficient regulation to steam puffs' amount. */
-				if (GB(v->tick_counter, 0, ((4 >> _settings_game.vehicle.smoke_amount) + ((this->cur_speed * 3) / max_speed))) == 0) {
+				if (GB(v->tick_counter, 0, ((4 >> _settings_game.vehicle.smoke_amount) + ((this->cur_speed * 3) / this->vcache.cached_max_speed))) == 0) {
 					CreateEffectVehicleRel(v, x, y, 10, EV_STEAM_SMOKE);
 					sound = true;
 				}
@@ -2276,8 +2478,8 @@
 				if (v->type == VEH_TRAIN) {
 					power_weight_effect = (32 >> (Train::From(this)->gcache.cached_power >> 10)) - (32 >> (Train::From(this)->gcache.cached_weight >> 9));
 				}
-				if (this->cur_speed < (max_speed >> (2 >> _settings_game.vehicle.smoke_amount)) &&
-						Chance16((64 - ((this->cur_speed << 5) / max_speed) + power_weight_effect), (512 >> _settings_game.vehicle.smoke_amount))) {
+				if (this->cur_speed < (this->vcache.cached_max_speed >> (2 >> _settings_game.vehicle.smoke_amount)) &&
+						Chance16((64 - ((this->cur_speed << 5) / this->vcache.cached_max_speed) + power_weight_effect), (512 >> _settings_game.vehicle.smoke_amount))) {
 					CreateEffectVehicleRel(v, x, y, 10, EV_DIESEL_SMOKE);
 					sound = true;
 				}
@@ -2292,7 +2494,7 @@
 				 * REGULATION:
 				 * - in Chance16 the last value is 360 / 2^smoke_amount (max. sparks when 90 = smoke_amount of 2). */
 				if (GB(v->tick_counter, 0, 2) == 0 &&
-						Chance16((6 - ((this->cur_speed << 2) / max_speed)), (360 >> _settings_game.vehicle.smoke_amount))) {
+						Chance16((6 - ((this->cur_speed << 2) / this->vcache.cached_max_speed)), (360 >> _settings_game.vehicle.smoke_amount))) {
 					CreateEffectVehicleRel(v, x, y, 10, EV_ELECTRIC_SPARK);
 					sound = true;
 				}
Index: src/viewport.cpp
===================================================================
--- src/viewport.cpp	(revision 24093)
+++ src/viewport.cpp	(working copy)
@@ -45,6 +45,7 @@
 #include "window_func.h"
 #include "tilehighlight_func.h"
 #include "window_gui.h"
+#include "linkgraph_gui.h"
 
 #include "table/strings.h"
 #include "table/palettes.h"
@@ -218,6 +219,8 @@
 	vp->dest_scrollpos_x = pt.x;
 	vp->dest_scrollpos_y = pt.y;
 
+	vp->overlay = NULL;
+
 	w->viewport = vp;
 	vp->virtual_left = 0;//pt.x;
 	vp->virtual_top = 0;//pt.y;
@@ -1399,22 +1402,8 @@
 	} while (--bottom > 0);
 }
 
-static void ViewportDrawStrings(DrawPixelInfo *dpi, const StringSpriteToDrawVector *sstdv)
+static void ViewportDrawStrings(ZoomLevel zoom, const StringSpriteToDrawVector *sstdv)
 {
-	DrawPixelInfo dp;
-	ZoomLevel zoom;
-
-	_cur_dpi = &dp;
-	dp = *dpi;
-
-	zoom = dp.zoom;
-	dp.zoom = ZOOM_LVL_NORMAL;
-
-	dp.left   = UnScaleByZoom(dp.left,   zoom);
-	dp.top    = UnScaleByZoom(dp.top,    zoom);
-	dp.width  = UnScaleByZoom(dp.width,  zoom);
-	dp.height = UnScaleByZoom(dp.height, zoom);
-
 	const StringSpriteToDraw *ssend = sstdv->End();
 	for (const StringSpriteToDraw *ss = sstdv->Begin(); ss != ssend; ++ss) {
 		TextColour colour = TC_BLACK;
@@ -1497,8 +1486,25 @@
 	if (_draw_bounding_boxes) ViewportDrawBoundingBoxes(&_vd.parent_sprites_to_sort);
 	if (_draw_dirty_blocks) ViewportDrawDirtyBlocks();
 
-	if (_vd.string_sprites_to_draw.Length() != 0) ViewportDrawStrings(&_vd.dpi, &_vd.string_sprites_to_draw);
+	DrawPixelInfo dp = _vd.dpi;
+	ZoomLevel zoom = _vd.dpi.zoom;
+	dp.zoom = ZOOM_LVL_NORMAL;
+	dp.width = UnScaleByZoom(dp.width, zoom);
+	dp.height = UnScaleByZoom(dp.height, zoom);
+	_cur_dpi = &dp;
 
+	/* translate to window coordinates */
+	dp.left = x;
+	dp.top = y;
+
+	if (vp->overlay != NULL) vp->overlay->Draw(&dp);
+
+	/* translate back to world coordinates */
+	dp.left = UnScaleByZoom(_vd.dpi.left, zoom);
+	dp.top = UnScaleByZoom(_vd.dpi.top, zoom);
+
+	if (_vd.string_sprites_to_draw.Length() != 0) ViewportDrawStrings(zoom, &_vd.string_sprites_to_draw);
+
 	_cur_dpi = old_dpi;
 
 	_vd.string_sprites_to_draw.Clear();
@@ -1613,6 +1619,7 @@
 		int delta_x = w->viewport->dest_scrollpos_x - w->viewport->scrollpos_x;
 		int delta_y = w->viewport->dest_scrollpos_y - w->viewport->scrollpos_y;
 
+		bool update_overlay = false;
 		if (delta_x != 0 || delta_y != 0) {
 			if (_settings_client.gui.smooth_scroll) {
 				int max_scroll = ScaleByMapSize1D(512 * ZOOM_LVL_BASE);
@@ -1623,11 +1630,14 @@
 				w->viewport->scrollpos_x = w->viewport->dest_scrollpos_x;
 				w->viewport->scrollpos_y = w->viewport->dest_scrollpos_y;
 			}
+			update_overlay = (w->viewport->scrollpos_x == w->viewport->dest_scrollpos_x &&
+								w->viewport->scrollpos_y == w->viewport->dest_scrollpos_y);
 		}
 
 		ClampViewportToMap(vp, w->viewport->scrollpos_x, w->viewport->scrollpos_y);
 
 		SetViewportPosition(w, w->viewport->scrollpos_x, w->viewport->scrollpos_y);
+		if (update_overlay) RebuildViewportOverlay(w);
 	}
 }
 
@@ -1976,9 +1986,10 @@
 		DEBUG(misc, 2, "Vehicle %d (index %d) at %p", v->unitnumber, v->index, v);
 		if (IsCompanyBuildableVehicleType(v)) {
 			v = v->First();
+			WindowClass wc = _thd.GetCallbackWnd()->window_class;
 			if (_ctrl_pressed && v->owner == _local_company) {
 				StartStopVehicle(v, true);
-			} else {
+			} else if ( wc != WC_CREATE_TEMPLATE && wc != WC_TEMPLATEGUI_MAIN) {
 				ShowVehicleViewWindow(v);
 			}
 		}
@@ -1987,6 +1998,15 @@
 	return result;
 }
 
+void RebuildViewportOverlay(Window *w)
+{
+	if (w->viewport->overlay != NULL &&
+			w->viewport->overlay->GetCompanyMask() != 0 &&
+			w->viewport->overlay->GetCargoMask() != 0) {
+		w->viewport->overlay->RebuildCache();
+		w->SetDirty();
+	}
+}
 
 /**
  * Scrolls the viewport in a window to a given location.
@@ -2010,6 +2030,7 @@
 	if (instant) {
 		w->viewport->scrollpos_x = pt.x;
 		w->viewport->scrollpos_y = pt.y;
+		RebuildViewportOverlay(w);
 	}
 
 	w->viewport->dest_scrollpos_x = pt.x;
@@ -2966,3 +2987,15 @@
 {
 	SetObjectToPlace(SPR_CURSOR_MOUSE, PAL_NONE, HT_NONE, WC_MAIN_WINDOW, 0);
 }
+
+Point GetViewportStationMiddle(const ViewPort *vp, const Station *st)
+{
+	int x = TileX(st->xy) * TILE_SIZE;
+	int y = TileY(st->xy) * TILE_SIZE;
+	int z = GetSlopePixelZ(Clamp(x, 0, MapSizeX() * TILE_SIZE - 1), Clamp(y, 0, MapSizeY() * TILE_SIZE - 1));
+
+	Point p = RemapCoords(x, y, z);
+	p.x = UnScaleByZoom(p.x - vp->virtual_left, vp->zoom) + vp->left;
+	p.y = UnScaleByZoom(p.y - vp->virtual_top, vp->zoom) + vp->top;
+	return p;
+}
Index: src/station_type.h
===================================================================
--- src/station_type.h	(revision 24093)
+++ src/station_type.h	(working copy)
@@ -14,6 +14,7 @@
 
 #include "core/smallvec_type.hpp"
 #include "tilearea_type.h"
+#include <list>
 
 typedef uint16 StationID;
 typedef uint16 RoadStopID;
@@ -87,6 +88,9 @@
 
 static const uint MAX_LENGTH_STATION_NAME_CHARS = 32; ///< The maximum length of a station name in characters including '\0'
 
+/** List of station IDs */
+typedef std::list<StationID> StationIDList;
+
 /** List of stations */
 typedef SmallVector<Station *, 2> StationList;
 
Index: src/screenshot.cpp
===================================================================
--- src/screenshot.cpp	(revision 24093)
+++ src/screenshot.cpp	(working copy)
@@ -754,6 +754,7 @@
 	vp.width = UnScaleByZoom(vp.virtual_width, vp.zoom);
 	vp.virtual_height = w->viewport->virtual_height;
 	vp.height = UnScaleByZoom(vp.virtual_height, vp.zoom);
+	vp.overlay = NULL;
 
 	const ScreenshotFormat *sf = _screenshot_formats + _cur_screenshot_format;
 	return sf->proc(MakeScreenshotName(SCREENSHOT_NAME, sf->extension), LargeWorldCallback, &vp, vp.width, vp.height,
@@ -780,6 +781,7 @@
 	vp.width = vp.virtual_width;
 	vp.virtual_height = ((MapMaxX() + MapMaxY()) * TILE_PIXELS >> 1) + extra_height_top - reclaim_height_bottom;
 	vp.height = vp.virtual_height;
+	vp.overlay = NULL;
 
 	sf = _screenshot_formats + _cur_screenshot_format;
 	return sf->proc(MakeScreenshotName(SCREENSHOT_NAME, sf->extension), LargeWorldCallback, &vp, vp.width, vp.height,
Index: src/aaa_template_gui_main.h
===================================================================
--- src/aaa_template_gui_main.h	(revision 0)
+++ src/aaa_template_gui_main.h	(revision 0)
@@ -0,0 +1,20 @@
+// _template_gui_main.h
+
+#ifndef TEMPLATE_GUI_H
+#define TEMPLATE_GUI_H
+
+#include "engine_type.h"
+#include "group_type.h"
+#include "vehicle_type.h"
+#include "string_func.h"
+#include "strings_func.h"
+
+#include "aaa_template_vehicle.h"
+#include "aaa_template_vehicle_func.h"
+#include "aaa_template_gui_replaceall.h"
+
+typedef GUIList<const Group*> GUIGroupList;
+
+void ShowTemplateReplaceWindow(byte, int);
+
+#endif
Index: src/aaa_template_gui_create.h
===================================================================
--- src/aaa_template_gui_create.h	(revision 0)
+++ src/aaa_template_gui_create.h	(revision 0)
@@ -0,0 +1,11 @@
+// template creation gui
+
+#ifndef TEMPLATE_GUI_CREATE
+#define TEMPLATE_GUI_CREATE
+
+#include "aaa_template_vehicle.h"
+#include "aaa_template_gui_create_virtualtrain.h"
+
+void ShowTemplateCreateWindow(TemplateVehicle*, bool*, bool*, int);
+
+#endif
Index: src/aaa_template_vehicle.cpp
===================================================================
--- src/aaa_template_vehicle.cpp	(revision 0)
+++ src/aaa_template_vehicle.cpp	(revision 0)
@@ -0,0 +1,233 @@
+#include "stdafx.h"
+#include "company_func.h"
+#include "train.h"
+#include "command_func.h"
+#include "engine_func.h"
+#include "vehicle_func.h"
+#include "autoreplace_func.h"
+#include "autoreplace_gui.h"
+#include "group.h"
+#include "articulated_vehicles.h"
+#include "core/random_func.hpp"
+#include "core/pool_type.hpp"
+#include "engine_type.h"
+#include "group_type.h"
+#include "core/pool_func.hpp"
+
+#include "table/strings.h"
+
+#include "newgrf.h"
+
+#include "vehicle_type.h"
+#include "vehicle_base.h"
+#include "vehicle_func.h"
+
+#include "table/train_cmd.h"
+
+
+#include "aaa_template_vehicle.h"
+
+// since doing stuff with sprites
+#include "newgrf_spritegroup.h"
+#include "newgrf_engine.h"
+#include "newgrf_cargo.h"
+
+TemplatePool _template_pool("TemplatePool");
+INSTANTIATE_POOL_METHODS(Template)
+
+TemplateReplacementPool _template_replacement_pool("TemplateReplacementPool");
+INSTANTIATE_POOL_METHODS(TemplateReplacement)
+
+
+TemplateVehicle::TemplateVehicle(VehicleType ty, EngineID eid, byte subtypeflag, Owner current_owner)
+{
+	this->type = ty;
+	this->engine_type = eid;
+
+	this->reuse_depot_vehicles = true;
+	this->keep_remaining_vehicles = true;
+
+	this->first = this;
+	this->next = 0x0;
+	this->previous = 0x0;
+	this->owner_b = _current_company;
+
+	this->cur_image = SPR_IMG_QUERY;
+
+	this->owner = current_owner;
+
+	this->real_consist_length = 0;
+}
+
+TemplateVehicle::~TemplateVehicle() {
+	//free(this->name);
+
+	TemplateVehicle *v = this->Next();
+	this->SetNext(NULL);
+
+	delete v;
+}
+
+/** getting */
+void TemplateVehicle::SetNext(TemplateVehicle *v) { this->next = v; }
+void TemplateVehicle::SetPrev(TemplateVehicle *v) { this->previous = v; }
+void TemplateVehicle::SetFirst(TemplateVehicle *v) { this->first = v; }
+
+TemplateVehicle* TemplateVehicle::GetNextUnit() const
+{
+		TemplateVehicle *tv = this->Next();
+		//if ( tv != NULL ) {
+			while ( tv && HasBit(tv->subtype, GVSF_ARTICULATED_PART) ) tv = tv->Next();
+			if ( tv && HasBit(tv->subtype, GVSF_MULTIHEADED) && !HasBit(tv->subtype, GVSF_ENGINE) ) tv = tv->Next();
+		//}
+		return tv;
+}
+
+TemplateVehicle* TemplateVehicle::GetPrevUnit()
+{
+	TemplateVehicle *tv = this->Prev();
+	//if ( tv != NULL ) {
+		while ( tv && HasBit(tv->subtype, GVSF_ARTICULATED_PART|GVSF_ENGINE) ) tv = tv->Prev();
+		if ( tv && HasBit(tv->subtype, GVSF_MULTIHEADED|GVSF_ENGINE) ) tv = tv->Prev();
+	//}
+	return tv;
+}
+
+/** setting */
+void appendTemplateVehicle(TemplateVehicle *orig, TemplateVehicle *newv)
+{
+	if ( !orig ) return;
+	while ( orig->Next() ) orig=orig->Next();
+	orig->SetNext(newv);
+	newv->SetPrev(orig);
+	newv->SetFirst(orig->First());
+}
+
+void insertTemplateVehicle(TemplateVehicle *orig, TemplateVehicle *newv, TemplateVehicle *insert_after)
+{
+	if ( !orig || !insert_after ) return;
+	TemplateVehicle *insert_before = insert_after->Next();
+	insert_after->SetNext(newv);
+	insert_before->SetPrev(newv);
+	newv->SetPrev(insert_after);
+	newv->SetNext(insert_before);
+	newv->SetFirst(insert_after);
+}
+
+/** Length()
+ * @return: length of vehicle, including current part
+ */
+int TemplateVehicle::Length() const
+{
+	int l=1;
+	const TemplateVehicle *tmp=this;
+	while ( tmp->Next() ) { tmp=tmp->Next(); l++; }
+	return l;
+}
+
+TemplateReplacement* GetTemplateReplacementByGroupID(GroupID gid)
+{
+	TemplateReplacement *tr;
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->Group() == gid )
+			return tr;
+	}
+	return 0;
+}
+
+TemplateReplacement* GetTemplateReplacementByTemplateID(TemplateID tid) {
+	TemplateReplacement *tr;
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->Template() == tid )
+			return tr;
+	}
+	return 0;
+}
+
+bool IssueTemplateReplacement(GroupID gid, TemplateID tid) {
+
+	TemplateReplacement *tr = GetTemplateReplacementByGroupID(gid);
+
+	if ( tr ) {
+		/* Then set the new TemplateVehicle and return */
+		tr->SetTemplate(tid);
+		return true;
+	}
+
+	else if ( TemplateReplacement::CanAllocateItem() ) {
+		tr = new TemplateReplacement(gid, tid);
+		return true;
+	}
+
+	else return false;
+}
+
+short TemplateVehicle::NumGroupsUsingTemplate() const
+{
+	short amount = 0;
+	const TemplateReplacement *tr;
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->sel_template == this->index )
+			amount++;
+	}
+	return amount;
+}
+
+short TemplateVehicle::CountEnginesInChain()
+{
+	TemplateVehicle *tv = this->first;
+	short count = 0;
+	for ( ; tv; tv=tv->GetNextUnit() )
+		if ( HasBit(tv->subtype, GVSF_ENGINE ) )
+			count++;
+	return count;
+}
+
+short deleteIllegalTemplateReplacements(GroupID g_id)
+{
+	short del_amount = 0;
+	const TemplateReplacement *tr;
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->group == g_id ) {
+			delete tr;
+			del_amount++;
+		}
+	}
+	return del_amount;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
Index: src/vehicle_base.h
===================================================================
--- src/vehicle_base.h	(revision 24093)
+++ src/vehicle_base.h	(working copy)
@@ -12,6 +12,7 @@
 #ifndef VEHICLE_BASE_H
 #define VEHICLE_BASE_H
 
+#include "core/smallmap_type.hpp"
 #include "track_type.h"
 #include "command_type.h"
 #include "order_base.h"
@@ -22,6 +23,8 @@
 #include "transport_type.h"
 #include "group_type.h"
 
+CommandCost CmdRefitVehicle(TileIndex, DoCommandFlag, uint32, uint32, const char*);
+
 /** Vehicle status bits in #Vehicle::vehstatus. */
 enum VehStatus {
 	VS_HIDDEN          = 0x01, ///< Vehicle is not visible.
@@ -89,6 +92,7 @@
  * This is defined here instead of at #GroundVehicle because some common function require access to these flags.
  * Do not access it directly unless you have to. Use the subtype access functions.
  */
+// MYGUI appended virtual subtype
 enum GroundVehicleSubtypeFlags {
 	GVSF_FRONT            = 0, ///< Leading engine of a consist.
 	GVSF_ARTICULATED_PART = 1, ///< Articulated part of an engine.
@@ -96,6 +100,7 @@
 	GVSF_ENGINE           = 3, ///< Engine that can be front engine, but might be placed behind another engine (not used for road vehicles).
 	GVSF_FREE_WAGON       = 4, ///< First in a wagon chain (in depot) (not used for road vehicles).
 	GVSF_MULTIHEADED      = 5, ///< Engine is multiheaded (not used for road vehicles).
+	GVSF_VIRTUAL		  = 6, ///< Used for virtual trains during template design, needed to skip checks for tile or depot status
 };
 
 /** Cached often queried values common to all vehicles. */
@@ -129,6 +134,7 @@
 
 	Vehicle *next_shared;               ///< pointer to the next vehicle that shares the order
 	Vehicle *previous_shared;           ///< NOSAVE: pointer to the previous vehicle in the shared order chain
+
 public:
 	friend const SaveLoad *GetVehicleDescription(VehicleType vt); ///< So we can use private/protected variables in the saveload code
 	friend void FixOldVehicles();
@@ -216,10 +222,12 @@
 	byte waiting_triggers;              ///< Triggers to be yet matched before rerandomizing the random bits.
 
 	StationID last_station_visited;     ///< The last station we stopped at.
+	StationID last_loading_station;     ///< Last station the vehicle has stopped at and could possibly leave from with any cargo loaded.
 
 	CargoID cargo_type;                 ///< type of cargo this vehicle is carrying
 	byte cargo_subtype;                 ///< Used for livery refits (NewGRF variations)
 	uint16 cargo_cap;                   ///< total capacity
+	uint16 refit_cap;                   ///< Capacity left over from before last refit.
 	VehicleCargoList cargo;             ///< The cargo this vehicle is carrying
 	uint16 cargo_age_counter;           ///< Ticks till cargo is aged next.
 
@@ -253,6 +261,7 @@
 	virtual ~Vehicle();
 
 	void BeginLoading();
+	void CancelReservation(StationID next, Station *st);
 	void LeaveStation();
 
 	GroundVehicleCache *GetGroundVehicleCache();
@@ -265,6 +274,10 @@
 
 	void HandleLoading(bool mode = false);
 
+	void GetConsistFreeCapacities(SmallMap<CargoID, uint> &capacities) const;
+
+	uint GetConsistTotalCapacity() const;
+
 	/**
 	 * Marks the vehicles to be redrawn and updates cached variables
 	 *
@@ -467,6 +480,7 @@
 	Money GetDisplayProfitLastYear() const { return (this->profit_last_year >> 8); }
 
 	void SetNext(Vehicle *next);
+	inline void SetFirst(Vehicle *f) { this->first=f; }
 
 	/**
 	 * Get the next vehicle of this vehicle.
@@ -572,6 +586,17 @@
 	inline VehicleOrderID GetNumManualOrders() const { return (this->orders.list == NULL) ? 0 : this->orders.list->GetNumManualOrders(); }
 
 	/**
+	 * Get the next station the vehicle will stop at.
+	 * @return ID of the next station the vehicle will stop at or INVALID_STATION.
+	 */
+	inline StationID GetNextStoppingStation() const
+	{
+		return (this->orders.list == NULL) ? INVALID_STATION : this->orders.list->GetNextStoppingStation(this);
+	}
+
+	void RefreshNextHopsStats();
+
+	/**
 	 * Copy certain configurations and statistics of a vehicle after successful autoreplace/renew
 	 * The function shall copy everything that cannot be copied by a command (like orders / group etc),
 	 * and that shall not be resetted for the new vehicle.
Index: src/autoreplace_cmd.cpp
===================================================================
--- src/autoreplace_cmd.cpp	(revision 24093)
+++ src/autoreplace_cmd.cpp	(working copy)
@@ -106,7 +106,7 @@
 			if (dest->cargo.Count() >= dest->cargo_cap || dest->cargo_type != src->cargo_type) continue;
 
 			uint amount = min(to_spread, dest->cargo_cap - dest->cargo.Count());
-			src->cargo.MoveTo(&dest->cargo, amount, VehicleCargoList::MTA_UNLOAD, NULL);
+			src->cargo.MoveTo(&dest->cargo, amount);
 			to_spread -= amount;
 		}
 
@@ -145,7 +145,7 @@
 			uint amount = min(src->cargo.Count(), dest->cargo_cap - dest->cargo.Count());
 			if (amount <= 0) continue;
 
-			src->cargo.MoveTo(&dest->cargo, amount, VehicleCargoList::MTA_UNLOAD, NULL);
+			src->cargo.MoveTo(&dest->cargo, amount);
 		}
 	}
 
@@ -332,7 +332,7 @@
  * @param new_head The new head of the completely replaced vehicle chain
  * @param flags the command flags to use
  */
-static CommandCost CopyHeadSpecificThings(Vehicle *old_head, Vehicle *new_head, DoCommandFlag flags)
+CommandCost CopyHeadSpecificThings(Vehicle *old_head, Vehicle *new_head, DoCommandFlag flags)
 {
 	CommandCost cost = CommandCost();
 
Index: src/openttd.cpp
===================================================================
--- src/openttd.cpp	(revision 24093)
+++ src/openttd.cpp	(working copy)
@@ -62,6 +62,8 @@
 
 
 
+#include "linkgraph/linkgraph.h"
+
 #include <stdarg.h>
 
 
@@ -290,6 +292,12 @@
 	/* Uninitialize variables that are allocated dynamically */
 	GamelogReset();
 
+	/* Reinitialize the link graphs to forcibly stop the threads.
+	 * If a link graph thread is running while the link graph handlers are
+	 * deleted we get a crash.
+	 */
+	InitializeLinkGraphs();
+
 #ifdef ENABLE_NETWORK
 	free(_config_file);
 #endif
Index: src/aircraft_cmd.cpp
===================================================================
--- src/aircraft_cmd.cpp	(revision 24093)
+++ src/aircraft_cmd.cpp	(working copy)
@@ -268,6 +268,7 @@
 
 		v->name = NULL;
 		v->last_station_visited = INVALID_STATION;
+		v->last_loading_station = INVALID_STATION;
 
 		v->acceleration = avi->acceleration;
 		v->engine_type = e->index;
Index: src/main_gui.cpp
===================================================================
--- src/main_gui.cpp	(revision 24093)
+++ src/main_gui.cpp	(working copy)
@@ -29,6 +29,7 @@
 #include "company_func.h"
 #include "toolbar_gui.h"
 #include "statusbar_gui.h"
+#include "linkgraph_gui.h"
 #include "tilehighlight_func.h"
 #include "hotkeys.h"
 
@@ -239,6 +240,11 @@
 
 struct MainWindow : Window
 {
+	uint refresh;
+
+	static const uint LINKGRAPH_REFRESH_PERIOD = 0xff;
+	static const uint LINKGRAPH_DELAY = 0xf;
+
 	MainWindow() : Window()
 	{
 		this->InitNested(&_main_window_desc, 0);
@@ -247,8 +253,20 @@
 
 		NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(WID_M_VIEWPORT);
 		nvp->InitializeViewport(this, TileXY(32, 32), ZOOM_LVL_VIEWPORT);
+
+		this->viewport->overlay = new LinkGraphOverlay(this, WID_M_VIEWPORT, 0, 0, 3);
+		this->refresh = LINKGRAPH_DELAY;
 	}
 
+	virtual void OnTick()
+	{
+		if (--refresh == 0) {
+			this->viewport->overlay->RebuildCache();
+			this->GetWidget<NWidgetBase>(WID_M_VIEWPORT)->SetDirty(this);
+			this->refresh = LINKGRAPH_REFRESH_PERIOD;
+		}
+	}
+
 	virtual void OnPaint()
 	{
 		this->DrawWidgets();
@@ -416,6 +434,7 @@
 		this->viewport->scrollpos_y += ScaleByZoom(delta.y, this->viewport->zoom);
 		this->viewport->dest_scrollpos_x = this->viewport->scrollpos_x;
 		this->viewport->dest_scrollpos_y = this->viewport->scrollpos_y;
+		this->refresh = LINKGRAPH_DELAY;
 	}
 
 	virtual void OnMouseWheel(int wheel)
@@ -430,6 +449,7 @@
 		if (this->viewport != NULL) {
 			NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(WID_M_VIEWPORT);
 			nvp->UpdateViewportCoordinates(this);
+			this->refresh = LINKGRAPH_DELAY;
 		}
 	}
 
Index: projects/openttd_vs80.vcproj
===================================================================
--- projects/openttd_vs80.vcproj	(revision 24093)
+++ projects/openttd_vs80.vcproj	(working copy)
@@ -435,6 +435,54 @@
 			Name="Source Files"
 			>
 			<File
+				RelativePath=".\..\src\aaa_template_gui_main.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create_virtualtrain.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_replaceall.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle_func.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_main.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create_virtualtrain.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_replaceall.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle_func.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\airport.cpp"
 				>
 			</File>
@@ -583,6 +631,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1119,6 +1183,30 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph_gui.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\demands.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_type.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -1135,6 +1223,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
@@ -1803,6 +1899,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\core\multimap.hpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\core\overflowsafe_type.hpp"
 				>
 			</File>
@@ -1935,6 +2035,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\main_gui.cpp"
 				>
 			</File>
@@ -2175,6 +2279,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\widgets\link_graph_legend_widget.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\widgets\main_widget.h"
 				>
 			</File>
@@ -2475,6 +2583,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
@@ -2560,6 +2672,18 @@
 			</File>
 		</Filter>
 		<Filter
+			Name="MYGUI SL HANDLERS"
+			>
+			<File
+				RelativePath=".\..\src\saveload\aaa_template_replacement_sl.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\saveload\aaa_template_veh_sl.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
 			Name="Tables"
 			>
 			<File
Index: projects/openttd_vs90.vcproj
===================================================================
--- projects/openttd_vs90.vcproj	(revision 24093)
+++ projects/openttd_vs90.vcproj	(working copy)
@@ -432,6 +432,54 @@
 			Name="Source Files"
 			>
 			<File
+				RelativePath=".\..\src\aaa_template_gui_main.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create_virtualtrain.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_replaceall.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle_func.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_main.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create_virtualtrain.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_replaceall.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle_func.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\airport.cpp"
 				>
 			</File>
@@ -580,6 +628,22 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph\demands.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\map.cpp"
 				>
 			</File>
@@ -1116,6 +1180,30 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph_gui.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\demands.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\flowmapper.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\linkgraph_type.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\linkgraph\mcf.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\livery.h"
 				>
 			</File>
@@ -1132,6 +1220,14 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\moving_average.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\moving_average.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\network\network.h"
 				>
 			</File>
@@ -1800,6 +1896,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\core\multimap.hpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\core\overflowsafe_type.hpp"
 				>
 			</File>
@@ -1932,6 +2032,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\linkgraph_gui.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\main_gui.cpp"
 				>
 			</File>
@@ -2172,6 +2276,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\widgets\link_graph_legend_widget.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\widgets\main_widget.h"
 				>
 			</File>
@@ -2472,6 +2580,10 @@
 				>
 			</File>
 			<File
+				RelativePath=".\..\src\saveload\linkgraph_sl.cpp"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\saveload\map_sl.cpp"
 				>
 			</File>
@@ -2557,6 +2669,18 @@
 			</File>
 		</Filter>
 		<Filter
+			Name="MYGUI SL HANDLERS"
+			>
+			<File
+				RelativePath=".\..\src\saveload\aaa_template_replacement_sl.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\saveload\aaa_template_veh_sl.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
 			Name="Tables"
 			>
 			<File
Index: projects/openttd_vs100.vcxproj
===================================================================
--- projects/openttd_vs100.vcxproj	(revision 24093)
+++ projects/openttd_vs100.vcxproj	(working copy)
@@ -291,6 +291,18 @@
     </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
+    <ClCompile Include="..\src\aaa_template_gui_main.cpp" />
+    <ClCompile Include="..\src\aaa_template_gui_create.cpp" />
+    <ClCompile Include="..\src\aaa_template_gui_create_virtualtrain.cpp" />
+    <ClCompile Include="..\src\aaa_template_gui_replaceall.cpp" />
+    <ClCompile Include="..\src\aaa_template_vehicle.cpp" />
+    <ClCompile Include="..\src\aaa_template_vehicle_func.cpp" />
+    <ClInclude Include="..\src\aaa_template_gui_main.h" />
+    <ClInclude Include="..\src\aaa_template_gui_create.h" />
+    <ClInclude Include="..\src\aaa_template_gui_create_virtualtrain.h" />
+    <ClInclude Include="..\src\aaa_template_gui_replaceall.h" />
+    <ClInclude Include="..\src\aaa_template_vehicle.h" />
+    <ClInclude Include="..\src\aaa_template_vehicle_func.h" />
     <ClCompile Include="..\src\airport.cpp" />
     <ClCompile Include="..\src\animated_tile.cpp" />
     <ClCompile Include="..\src\articulated_vehicles.cpp" />
@@ -328,6 +340,10 @@
     <ClCompile Include="..\src\ini.cpp" />
     <ClCompile Include="..\src\ini_load.cpp" />
     <ClCompile Include="..\src\landscape.cpp" />
+    <ClCompile Include="..\src\linkgraph\demands.cpp" />
+    <ClCompile Include="..\src\linkgraph\flowmapper.cpp" />
+    <ClCompile Include="..\src\linkgraph\linkgraph.cpp" />
+    <ClCompile Include="..\src\linkgraph\mcf.cpp" />
     <ClCompile Include="..\src\map.cpp" />
     <ClCompile Include="..\src\misc.cpp" />
     <ClCompile Include="..\src\mixer.cpp" />
@@ -461,10 +477,18 @@
     <ClInclude Include="..\src\landscape.h" />
     <ClInclude Include="..\src\landscape_type.h" />
     <ClInclude Include="..\src\language.h" />
+    <ClInclude Include="..\src\linkgraph_gui.h" />
+    <ClInclude Include="..\src\linkgraph\demands.h" />
+    <ClInclude Include="..\src\linkgraph\flowmapper.h" />
+    <ClInclude Include="..\src\linkgraph\linkgraph.h" />
+    <ClInclude Include="..\src\linkgraph\linkgraph_type.h" />
+    <ClInclude Include="..\src\linkgraph\mcf.h" />
     <ClInclude Include="..\src\livery.h" />
     <ClInclude Include="..\src\map_func.h" />
     <ClInclude Include="..\src\map_type.h" />
     <ClInclude Include="..\src\mixer.h" />
+    <ClInclude Include="..\src\moving_average.h" />
+    <ClCompile Include="..\src\moving_average.cpp" />
     <ClInclude Include="..\src\network\network.h" />
     <ClInclude Include="..\src\network\network_admin.h" />
     <ClInclude Include="..\src\network\network_base.h" />
@@ -631,6 +655,7 @@
     <ClCompile Include="..\src\core\math_func.cpp" />
     <ClInclude Include="..\src\core\math_func.hpp" />
     <ClInclude Include="..\src\core\mem_func.hpp" />
+    <ClInclude Include="..\src\core\multimap.hpp" />
     <ClInclude Include="..\src\core\overflowsafe_type.hpp" />
     <ClCompile Include="..\src\core\pool_func.cpp" />
     <ClInclude Include="..\src\core\pool_func.hpp" />
@@ -663,6 +688,7 @@
     <ClCompile Include="..\src\highscore_gui.cpp" />
     <ClCompile Include="..\src\industry_gui.cpp" />
     <ClCompile Include="..\src\intro_gui.cpp" />
+    <ClCompile Include="..\src\linkgraph_gui.cpp" />
     <ClCompile Include="..\src\main_gui.cpp" />
     <ClCompile Include="..\src\misc_gui.cpp" />
     <ClCompile Include="..\src\music_gui.cpp" />
@@ -722,6 +748,7 @@
     <ClInclude Include="..\src\widgets\highscore_widget.h" />
     <ClInclude Include="..\src\widgets\industry_widget.h" />
     <ClInclude Include="..\src\widgets\intro_widget.h" />
+    <ClInclude Include="..\src\widgets\link_graph_legend_widget.h" />
     <ClInclude Include="..\src\widgets\main_widget.h" />
     <ClInclude Include="..\src\widgets\misc_widget.h" />
     <ClInclude Include="..\src\widgets\music_widget.h" />
@@ -795,6 +822,7 @@
     <ClCompile Include="..\src\saveload\group_sl.cpp" />
     <ClCompile Include="..\src\saveload\industry_sl.cpp" />
     <ClCompile Include="..\src\saveload\labelmaps_sl.cpp" />
+    <ClCompile Include="..\src\saveload\linkgraph_sl.cpp" />
     <ClCompile Include="..\src\saveload\map_sl.cpp" />
     <ClCompile Include="..\src\saveload\misc_sl.cpp" />
     <ClCompile Include="..\src\saveload\newgrf_sl.cpp" />
@@ -816,6 +844,8 @@
     <ClCompile Include="..\src\saveload\town_sl.cpp" />
     <ClCompile Include="..\src\saveload\vehicle_sl.cpp" />
     <ClCompile Include="..\src\saveload\waypoint_sl.cpp" />
+    <ClCompile Include="..\src\saveload\aaa_template_replacement_sl.cpp" />
+    <ClCompile Include="..\src\saveload\aaa_template_veh_sl.cpp" />
     <ClInclude Include="..\src\table\airport_defaults.h" />
     <ClInclude Include="..\src\table\airport_movement.h" />
     <ClInclude Include="..\src\table\airporttile_ids.h" />
Index: projects/openttd_vs100.vcxproj.filters
===================================================================
--- projects/openttd_vs100.vcxproj.filters	(revision 24093)
+++ projects/openttd_vs100.vcxproj.filters	(working copy)
@@ -22,86 +22,125 @@
     <Filter Include="Save/Load handlers">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000006}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Tables">
+    <Filter Include="MYGUI SL HANDLERS">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000007}</UniqueIdentifier>
     </Filter>
-    <Filter Include="MD5">
+    <Filter Include="Tables">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000008}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Script">
+    <Filter Include="MD5">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000009}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Squirrel">
+    <Filter Include="Script">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000010}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Squirrel headers">
+    <Filter Include="Squirrel">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000011}</UniqueIdentifier>
     </Filter>
-    <Filter Include="AI Core">
+    <Filter Include="Squirrel headers">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000012}</UniqueIdentifier>
     </Filter>
-    <Filter Include="AI API">
+    <Filter Include="AI Core">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000013}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Game API">
+    <Filter Include="AI API">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000014}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Game Core">
+    <Filter Include="Game API">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000015}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Script API">
+    <Filter Include="Game Core">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000016}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Script API Implementation">
+    <Filter Include="Script API">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000017}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Blitters">
+    <Filter Include="Script API Implementation">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000018}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Drivers">
+    <Filter Include="Blitters">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000019}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Sprite loaders">
+    <Filter Include="Drivers">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000020}</UniqueIdentifier>
     </Filter>
-    <Filter Include="NewGRF">
+    <Filter Include="Sprite loaders">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000021}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Map Accessors">
+    <Filter Include="NewGRF">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000022}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Misc">
+    <Filter Include="Map Accessors">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000023}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Network Core">
+    <Filter Include="Misc">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000024}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Pathfinder">
+    <Filter Include="Network Core">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000025}</UniqueIdentifier>
     </Filter>
-    <Filter Include="NPF">
+    <Filter Include="Pathfinder">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000026}</UniqueIdentifier>
     </Filter>
-    <Filter Include="YAPF">
+    <Filter Include="NPF">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000027}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Video">
+    <Filter Include="YAPF">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000028}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Music">
+    <Filter Include="Video">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000029}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Sound">
+    <Filter Include="Music">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000030}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Windows files">
+    <Filter Include="Sound">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000031}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Threading">
+    <Filter Include="Windows files">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000032}</UniqueIdentifier>
     </Filter>
+    <Filter Include="Threading">
+      <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000033}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
   <ItemGroup>
+    <ClCompile Include="..\src\aaa_template_gui_main.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_gui_create.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_gui_create_virtualtrain.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_gui_replaceall.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_vehicle.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_vehicle_func.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClInclude Include="..\src\aaa_template_gui_main.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_gui_create.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_gui_create_virtualtrain.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_gui_replaceall.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_vehicle.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_vehicle_func.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
     <ClCompile Include="..\src\airport.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -213,6 +252,18 @@
     <ClCompile Include="..\src\landscape.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\linkgraph\demands.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\linkgraph\flowmapper.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\linkgraph\linkgraph.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\linkgraph\mcf.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\map.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -612,6 +663,24 @@
     <ClInclude Include="..\src\language.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\linkgraph_gui.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\demands.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\flowmapper.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\linkgraph.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\linkgraph_type.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\linkgraph\mcf.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\livery.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -624,6 +693,12 @@
     <ClInclude Include="..\src\mixer.h">
       <Filter>Header Files</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\moving_average.h">
+      <Filter>Header Files</Filter>
+    </ClInclude>
+    <ClCompile Include="..\src\moving_average.cpp">
+      <Filter>Header Files</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\network\network.h">
       <Filter>Header Files</Filter>
     </ClInclude>
@@ -1122,6 +1197,9 @@
     <ClInclude Include="..\src\core\mem_func.hpp">
       <Filter>Core Source Code</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\core\multimap.hpp">
+      <Filter>Core Source Code</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\core\overflowsafe_type.hpp">
       <Filter>Core Source Code</Filter>
     </ClInclude>
@@ -1218,6 +1296,9 @@
     <ClCompile Include="..\src\intro_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\linkgraph_gui.cpp">
+      <Filter>GUI Source Code</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\main_gui.cpp">
       <Filter>GUI Source Code</Filter>
     </ClCompile>
@@ -1395,6 +1476,9 @@
     <ClInclude Include="..\src\widgets\intro_widget.h">
       <Filter>Widgets</Filter>
     </ClInclude>
+    <ClInclude Include="..\src\widgets\link_graph_legend_widget.h">
+      <Filter>Widgets</Filter>
+    </ClInclude>
     <ClInclude Include="..\src\widgets\main_widget.h">
       <Filter>Widgets</Filter>
     </ClInclude>
@@ -1614,6 +1698,9 @@
     <ClCompile Include="..\src\saveload\labelmaps_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\saveload\linkgraph_sl.cpp">
+      <Filter>Save/Load handlers</Filter>
+    </ClCompile>
     <ClCompile Include="..\src\saveload\map_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
@@ -1677,6 +1764,12 @@
     <ClCompile Include="..\src\saveload\waypoint_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\saveload\aaa_template_replacement_sl.cpp">
+      <Filter>MYGUI SL HANDLERS</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\saveload\aaa_template_veh_sl.cpp">
+      <Filter>MYGUI SL HANDLERS</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\table\airport_defaults.h">
       <Filter>Tables</Filter>
     </ClInclude>
Index: source.list
===================================================================
--- source.list	(revision 24093)
+++ source.list	(working copy)
@@ -1,4 +1,17 @@
 # Source Files
+aaa_template_gui_main.cpp
+aaa_template_gui_create.cpp
+aaa_template_gui_create_virtualtrain.cpp
+aaa_template_gui_replaceall.cpp
+aaa_template_vehicle.cpp
+aaa_template_vehicle_func.cpp
+aaa_template_gui_main.h
+aaa_template_gui_create.h
+aaa_template_gui_create_virtualtrain.h
+aaa_template_gui_replaceall.h
+aaa_template_vehicle.h
+aaa_template_vehicle_func.h
+
 airport.cpp
 animated_tile.cpp
 articulated_vehicles.cpp
@@ -36,6 +49,10 @@
 ini.cpp
 ini_load.cpp
 landscape.cpp
+linkgraph/demands.cpp
+linkgraph/flowmapper.cpp
+linkgraph/linkgraph.cpp
+linkgraph/mcf.cpp
 map.cpp
 misc.cpp
 mixer.cpp
@@ -194,10 +211,18 @@
 landscape.h
 landscape_type.h
 language.h
+linkgraph_gui.h
+linkgraph/demands.h
+linkgraph/flowmapper.h
+linkgraph/linkgraph.h
+linkgraph/linkgraph_type.h
+linkgraph/mcf.h
 livery.h
 map_func.h
 map_type.h
 mixer.h
+moving_average.h
+moving_average.cpp
 network/network.h
 network/network_admin.h
 network/network_base.h
@@ -381,6 +406,7 @@
 core/math_func.cpp
 core/math_func.hpp
 core/mem_func.hpp
+core/multimap.hpp
 core/overflowsafe_type.hpp
 core/pool_func.cpp
 core/pool_func.hpp
@@ -415,6 +441,7 @@
 highscore_gui.cpp
 industry_gui.cpp
 intro_gui.cpp
+linkgraph_gui.cpp
 main_gui.cpp
 misc_gui.cpp
 music_gui.cpp
@@ -476,6 +503,7 @@
 widgets/highscore_widget.h
 widgets/industry_widget.h
 widgets/intro_widget.h
+widgets/link_graph_legend_widget.h
 widgets/main_widget.h
 widgets/misc_widget.h
 widgets/music_widget.h
@@ -553,6 +581,7 @@
 saveload/group_sl.cpp
 saveload/industry_sl.cpp
 saveload/labelmaps_sl.cpp
+saveload/linkgraph_sl.cpp
 saveload/map_sl.cpp
 saveload/misc_sl.cpp
 saveload/newgrf_sl.cpp
@@ -574,6 +603,9 @@
 saveload/town_sl.cpp
 saveload/vehicle_sl.cpp
 saveload/waypoint_sl.cpp
+# MYGUI SL HANDLERS
+saveload/aaa_template_replacement_sl.cpp
+saveload/aaa_template_veh_sl.cpp
 
 # Tables
 table/airport_defaults.h
