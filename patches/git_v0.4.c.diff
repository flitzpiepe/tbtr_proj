diff --git a/projects/openttd_vs100.vcxproj b/projects/openttd_vs100.vcxproj
index ebab0e4..615684d 100644
--- a/projects/openttd_vs100.vcxproj
+++ b/projects/openttd_vs100.vcxproj
@@ -291,6 +291,18 @@
     </Link>
   </ItemDefinitionGroup>
   <ItemGroup>
+    <ClCompile Include="..\src\aaa_template_gui_main.cpp" />
+    <ClCompile Include="..\src\aaa_template_gui_create.cpp" />
+    <ClCompile Include="..\src\aaa_template_gui_create_virtualtrain.cpp" />
+    <ClCompile Include="..\src\aaa_template_gui_replaceall.cpp" />
+    <ClCompile Include="..\src\aaa_template_vehicle.cpp" />
+    <ClCompile Include="..\src\aaa_template_vehicle_func.cpp" />
+    <ClInclude Include="..\src\aaa_template_gui_main.h" />
+    <ClInclude Include="..\src\aaa_template_gui_create.h" />
+    <ClInclude Include="..\src\aaa_template_gui_create_virtualtrain.h" />
+    <ClInclude Include="..\src\aaa_template_gui_replaceall.h" />
+    <ClInclude Include="..\src\aaa_template_vehicle.h" />
+    <ClInclude Include="..\src\aaa_template_vehicle_func.h" />
     <ClCompile Include="..\src\airport.cpp" />
     <ClCompile Include="..\src\animated_tile.cpp" />
     <ClCompile Include="..\src\articulated_vehicles.cpp" />
@@ -828,6 +840,8 @@
     <ClCompile Include="..\src\saveload\town_sl.cpp" />
     <ClCompile Include="..\src\saveload\vehicle_sl.cpp" />
     <ClCompile Include="..\src\saveload\waypoint_sl.cpp" />
+    <ClCompile Include="..\src\saveload\aaa_template_replacement_sl.cpp" />
+    <ClCompile Include="..\src\saveload\aaa_template_veh_sl.cpp" />
     <ClInclude Include="..\src\table\airport_defaults.h" />
     <ClInclude Include="..\src\table\airport_movement.h" />
     <ClInclude Include="..\src\table\airporttile_ids.h" />
diff --git a/projects/openttd_vs100.vcxproj.filters b/projects/openttd_vs100.vcxproj.filters
index b04bdef..452d184 100644
--- a/projects/openttd_vs100.vcxproj.filters
+++ b/projects/openttd_vs100.vcxproj.filters
@@ -22,86 +22,125 @@
     <Filter Include="Save/Load handlers">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000006}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Tables">
+    <Filter Include="MYGUI SL HANDLERS">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000007}</UniqueIdentifier>
     </Filter>
-    <Filter Include="MD5">
+    <Filter Include="Tables">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000008}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Script">
+    <Filter Include="MD5">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000009}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Squirrel">
+    <Filter Include="Script">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000010}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Squirrel headers">
+    <Filter Include="Squirrel">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000011}</UniqueIdentifier>
     </Filter>
-    <Filter Include="AI Core">
+    <Filter Include="Squirrel headers">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000012}</UniqueIdentifier>
     </Filter>
-    <Filter Include="AI API">
+    <Filter Include="AI Core">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000013}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Game API">
+    <Filter Include="AI API">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000014}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Game Core">
+    <Filter Include="Game API">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000015}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Script API">
+    <Filter Include="Game Core">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000016}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Script API Implementation">
+    <Filter Include="Script API">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000017}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Blitters">
+    <Filter Include="Script API Implementation">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000018}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Drivers">
+    <Filter Include="Blitters">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000019}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Sprite loaders">
+    <Filter Include="Drivers">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000020}</UniqueIdentifier>
     </Filter>
-    <Filter Include="NewGRF">
+    <Filter Include="Sprite loaders">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000021}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Map Accessors">
+    <Filter Include="NewGRF">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000022}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Misc">
+    <Filter Include="Map Accessors">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000023}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Network Core">
+    <Filter Include="Misc">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000024}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Pathfinder">
+    <Filter Include="Network Core">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000025}</UniqueIdentifier>
     </Filter>
-    <Filter Include="NPF">
+    <Filter Include="Pathfinder">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000026}</UniqueIdentifier>
     </Filter>
-    <Filter Include="YAPF">
+    <Filter Include="NPF">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000027}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Video">
+    <Filter Include="YAPF">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000028}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Music">
+    <Filter Include="Video">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000029}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Sound">
+    <Filter Include="Music">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000030}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Windows files">
+    <Filter Include="Sound">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000031}</UniqueIdentifier>
     </Filter>
-    <Filter Include="Threading">
+    <Filter Include="Windows files">
       <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000032}</UniqueIdentifier>
     </Filter>
+    <Filter Include="Threading">
+      <UniqueIdentifier>{c76ff9f1-1e62-46d8-8d55-000000000033}</UniqueIdentifier>
+    </Filter>
   </ItemGroup>
   <ItemGroup>
+    <ClCompile Include="..\src\aaa_template_gui_main.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_gui_create.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_gui_create_virtualtrain.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_gui_replaceall.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_vehicle.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\aaa_template_vehicle_func.cpp">
+      <Filter>Source Files</Filter>
+    </ClCompile>
+    <ClInclude Include="..\src\aaa_template_gui_main.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_gui_create.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_gui_create_virtualtrain.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_gui_replaceall.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_vehicle.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
+    <ClInclude Include="..\src\aaa_template_vehicle_func.h">
+      <Filter>Source Files</Filter>
+    </ClInclude>
     <ClCompile Include="..\src\airport.cpp">
       <Filter>Source Files</Filter>
     </ClCompile>
@@ -1713,6 +1752,12 @@
     <ClCompile Include="..\src\saveload\waypoint_sl.cpp">
       <Filter>Save/Load handlers</Filter>
     </ClCompile>
+    <ClCompile Include="..\src\saveload\aaa_template_replacement_sl.cpp">
+      <Filter>MYGUI SL HANDLERS</Filter>
+    </ClCompile>
+    <ClCompile Include="..\src\saveload\aaa_template_veh_sl.cpp">
+      <Filter>MYGUI SL HANDLERS</Filter>
+    </ClCompile>
     <ClInclude Include="..\src\table\airport_defaults.h">
       <Filter>Tables</Filter>
     </ClInclude>
diff --git a/projects/openttd_vs80.vcproj b/projects/openttd_vs80.vcproj
index 04373e8..9e5885b 100644
--- a/projects/openttd_vs80.vcproj
+++ b/projects/openttd_vs80.vcproj
@@ -435,6 +435,54 @@
 			Name="Source Files"
 			>
 			<File
+				RelativePath=".\..\src\aaa_template_gui_main.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create_virtualtrain.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_replaceall.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle_func.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_main.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create_virtualtrain.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_replaceall.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle_func.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\airport.cpp"
 				>
 			</File>
@@ -2608,6 +2656,18 @@
 			</File>
 		</Filter>
 		<Filter
+			Name="MYGUI SL HANDLERS"
+			>
+			<File
+				RelativePath=".\..\src\saveload\aaa_template_replacement_sl.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\saveload\aaa_template_veh_sl.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
 			Name="Tables"
 			>
 			<File
diff --git a/projects/openttd_vs90.vcproj b/projects/openttd_vs90.vcproj
index 511261d..3c86efa 100644
--- a/projects/openttd_vs90.vcproj
+++ b/projects/openttd_vs90.vcproj
@@ -432,6 +432,54 @@
 			Name="Source Files"
 			>
 			<File
+				RelativePath=".\..\src\aaa_template_gui_main.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create_virtualtrain.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_replaceall.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle_func.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_main.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_create_virtualtrain.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_gui_replaceall.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle.h"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\aaa_template_vehicle_func.h"
+				>
+			</File>
+			<File
 				RelativePath=".\..\src\airport.cpp"
 				>
 			</File>
@@ -2605,6 +2653,18 @@
 			</File>
 		</Filter>
 		<Filter
+			Name="MYGUI SL HANDLERS"
+			>
+			<File
+				RelativePath=".\..\src\saveload\aaa_template_replacement_sl.cpp"
+				>
+			</File>
+			<File
+				RelativePath=".\..\src\saveload\aaa_template_veh_sl.cpp"
+				>
+			</File>
+		</Filter>
+		<Filter
 			Name="Tables"
 			>
 			<File
diff --git a/source.list b/source.list
index 5553921..f007a7c 100644
--- a/source.list
+++ b/source.list
@@ -1,4 +1,17 @@
 # Source Files
+aaa_template_gui_main.cpp
+aaa_template_gui_create.cpp
+aaa_template_gui_create_virtualtrain.cpp
+aaa_template_gui_replaceall.cpp
+aaa_template_vehicle.cpp
+aaa_template_vehicle_func.cpp
+aaa_template_gui_main.h
+aaa_template_gui_create.h
+aaa_template_gui_create_virtualtrain.h
+aaa_template_gui_replaceall.h
+aaa_template_vehicle.h
+aaa_template_vehicle_func.h
+
 airport.cpp
 animated_tile.cpp
 articulated_vehicles.cpp
@@ -586,6 +599,9 @@ saveload/subsidy_sl.cpp
 saveload/town_sl.cpp
 saveload/vehicle_sl.cpp
 saveload/waypoint_sl.cpp
+# MYGUI SL HANDLERS
+saveload/aaa_template_replacement_sl.cpp
+saveload/aaa_template_veh_sl.cpp
 
 # Tables
 table/airport_defaults.h
diff --git a/src/aaa_template_gui_create.cpp b/src/aaa_template_gui_create.cpp
new file mode 100644
index 0000000..872c049
--- /dev/null
+++ b/src/aaa_template_gui_create.cpp
@@ -0,0 +1,462 @@
+#include "stdafx.h"
+
+#include "gfx_func.h"
+#include "direction_type.h"
+
+#include "strings_func.h"
+#include "window_func.h"
+#include "company_func.h"
+#include "window_gui.h"
+#include "settings_func.h"
+#include "core/geometry_func.hpp"
+#include "table/sprites.h"
+#include "table/strings.h"
+// since setobjtoplacewnd() TODO: del unnecessary
+#include "viewport_func.h"
+#include "window_func.h"
+#include "gui.h"
+#include "textbuf_gui.h"
+#include "command_func.h"
+#include "depot_base.h"
+#include "vehicle_gui.h"
+#include "spritecache.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "vehicle_func.h"
+#include "company_func.h"
+#include "tilehighlight_func.h"
+#include "window_gui.h"
+#include "vehiclelist.h"
+#include "order_backup.h"
+//
+#include "group.h"
+#include "company_base.h"
+
+#include "aaa_template_gui_create.h"
+#include "aaa_template_vehicle.h"
+#include "aaa_template_vehicle_func.h"
+
+#include "train.h"
+
+// TODO: rm
+
+//Company *_cme = Company::Get(0))
+
+class TemplateReplaceWindow;
+
+// some space in front of the virtual train in the matrix
+uint16 TRAIN_FRONT_SPACE = 16;
+
+enum TemplateReplaceWindowWidgets {
+	TCW_CAPTION,
+	TCW_MATRIX_NEW_TMPL,
+	TCW_INFO_PANEL,
+	TCW_SCROLLBAR_NEW_TMPL,
+	TCW_SELL_TMPL,
+	TCW_NEW,
+	TCW_OK,
+	TCW_CANCEL,
+	TCW_REFIT,
+	TCW_CLONE,
+};
+
+static const NWidgetPart _widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, TCW_CAPTION), SetDataTip(STR_TMPL_CREATEGUI_TITLE, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_MATRIX, COLOUR_GREY, TCW_MATRIX_NEW_TMPL), SetMinimalSize(216, 60), SetFill(1, 0), SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY), SetResize(1, 0), SetScrollbar(TCW_SCROLLBAR_NEW_TMPL),
+			NWidget(WWT_PANEL, COLOUR_GREY, TCW_INFO_PANEL), SetMinimalSize(216,80), SetResize(1,1), EndContainer(),
+			NWidget(NWID_HSCROLLBAR, COLOUR_GREY, TCW_SCROLLBAR_NEW_TMPL), SetResize(1,0),
+		EndContainer(),
+		NWidget(WWT_IMGBTN, COLOUR_GREY, TCW_SELL_TMPL), SetDataTip(0x0, STR_NULL), SetMinimalSize(23,23), SetResize(0, 1), SetFill(0, 1),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TCW_OK),		SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_CONFIRM, STR_TMPL_CONFIRM),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TCW_NEW),		SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_NEW,	 STR_TMPL_NEW),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, TCW_CLONE),	SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_CREATE_CLONE_VEH,	 STR_TMPL_CREATE_CLONE_VEH),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TCW_REFIT),	SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_REFIT,	 STR_TMPL_REFIT),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TCW_CANCEL),	SetMinimalSize(52, 12), SetResize(1,0), SetDataTip(STR_TMPL_CANCEL,  STR_TMPL_CANCEL),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static const WindowDesc _template_create_window_desc(
+	WDP_AUTO, 456, 100,
+	WC_CREATE_TEMPLATE, WC_NONE,					// TODO change wc_replace_vehicle
+	WDF_UNCLICK_BUTTONS | WDF_CONSTRUCTION,
+	_widgets, lengthof(_widgets)
+);
+
+static void TrainDepotMoveVehicle(const Vehicle *wagon, VehicleID sel, const Vehicle *head)
+{
+	const Vehicle *v = Vehicle::Get(sel);
+
+	if (v == wagon) return;
+
+	if (wagon == NULL) {
+		if (head != NULL) wagon = head->Last();
+	} else {
+		wagon = wagon->Previous();
+		if (wagon == NULL) return;
+	}
+
+	if (wagon == v) return;
+
+	CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, (_ctrl_pressed ? 1:0)<<20 | (1<<21) | v->index, wagon == NULL ? INVALID_VEHICLE : wagon->index, 0);
+}
+
+class TemplateCreateWindow : public Window {
+private:
+	Scrollbar *hscroll;
+	int line_height;
+	Train* virtual_train;
+	bool editMode;
+	bool *noticeParent;
+	bool *createWindowOpen;			/// used to notify main window of progress (dummy way of disabling 'delete' while editing a template)
+	bool virtualTrainChangedNotice;
+	VehicleID sel;
+	VehicleID vehicle_over;
+	TemplateVehicle *editTemplate;
+
+public:
+	TemplateCreateWindow(const WindowDesc* _wdesc, TemplateVehicle *to_edit, bool *notice, bool *windowOpen, int step_h) : Window()
+	{
+		this->line_height = step_h;
+		this->CreateNestedTree(_wdesc);
+		this->hscroll = this->GetScrollbar(TCW_SCROLLBAR_NEW_TMPL);
+		this->FinishInitNested(_wdesc, VEH_TRAIN);
+		/* a sprite */
+		this->GetWidget<NWidgetCore>(TCW_SELL_TMPL)->widget_data = SPR_SELL_TRAIN;
+
+		this->owner = _local_company;
+
+		noticeParent = notice;
+		createWindowOpen = windowOpen;
+		virtualTrainChangedNotice = false;
+		this->editTemplate = to_edit;
+
+		if ( to_edit ) editMode = true;
+		else editMode = false;
+
+		this->sel = INVALID_VEHICLE;
+		this->vehicle_over = INVALID_VEHICLE;
+
+		this->virtual_train = VirtualTrainFromTemplateVehicle(to_edit);
+
+		this->resize.step_height = 1;
+	}
+	~TemplateCreateWindow()
+	{
+		if ( virtual_train )
+			delete virtual_train;
+
+		SetWindowClassesDirty(WC_TRAINS_LIST);
+
+		/* more cleanup */
+		*createWindowOpen = false;
+		DeleteWindowById(WC_BUILD_VIRTUAL_TRAIN, this->window_number);
+
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case TCW_MATRIX_NEW_TMPL:
+				size->height = 20;
+				break;
+		}
+	}
+	virtual void OnResize()
+	{
+		NWidgetCore *nwi = this->GetWidget<NWidgetCore>(TCW_MATRIX_NEW_TMPL);
+		this->hscroll->SetCapacity(nwi->current_x);
+		nwi->widget_data = (this->hscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		virtualTrainChangedNotice = true;
+	}
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch(widget) {
+			case TCW_MATRIX_NEW_TMPL: {
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(TCW_MATRIX_NEW_TMPL);
+				ClickedOnVehiclePanel(pt.x - nwi->pos_x-TRAIN_FRONT_SPACE, pt.y - nwi->pos_y);
+				break;
+			}
+			case TCW_NEW: {
+				ShowBuildVirtualTrainWindow(&virtual_train, &virtualTrainChangedNotice);
+				break;
+			}
+			case TCW_CLONE: {
+				this->SetWidgetDirty(TCW_CLONE);
+				this->ToggleWidgetLoweredState(TCW_CLONE);
+				if (this->IsWidgetLowered(TCW_CLONE)) {
+					static const CursorID clone_icon =	SPR_CURSOR_CLONE_TRAIN;
+					SetObjectToPlaceWnd(clone_icon, PAL_NONE, HT_VEHICLE, this);
+				} else {
+					ResetObjectToPlace();
+				}
+				break;
+			}
+			case TCW_OK: {
+				TemplateVehicle *tv = NULL;
+				if ( editMode )	tv = DeleteTemplateVehicle(editTemplate);
+				editTemplate = TemplateVehicleFromVirtualTrain(virtual_train);
+				if ( tv ) *noticeParent = true;
+				delete this;
+				break;
+			}
+			case TCW_CANCEL: {
+				delete this;
+				break;
+			}
+			case TCW_REFIT: {
+				ShowVehicleRefitWindow(virtual_train, INVALID_VEH_ORDER_ID, this, false, true);
+				break;
+			}
+		}
+	}
+	virtual bool OnVehicleSelect(const Vehicle *v)
+	{
+		// throw away the current virtual train
+		if ( virtual_train )
+			delete this->virtual_train;
+		// create a new one
+		this->virtual_train = CloneVirtualTrainFromTrain((const Train*)v);
+		this->ToggleWidgetLoweredState(TCW_CLONE);
+		ResetObjectToPlace();
+		this->SetDirty();
+
+		return true;
+	}
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch(widget) {
+			case TCW_MATRIX_NEW_TMPL: {
+				if ( this->virtual_train ) {
+					DrawTrainImage(virtual_train, r.left+TRAIN_FRONT_SPACE, r.right, r.top+2, this->sel, EIT_PURCHASE, this->hscroll->GetPosition(), this->vehicle_over);
+					SetDParam(0, CeilDiv(virtual_train->gcache.cached_total_length * 10, TILE_SIZE));
+					SetDParam(1, 1);
+					DrawString(r.left, r.right, r.top, STR_TINY_BLACK_DECIMAL, TC_BLACK, SA_RIGHT);
+				}
+				break;
+			}
+			case TCW_INFO_PANEL: {
+				if ( this->virtual_train ) {
+					/* Draw vehicle performance info */
+					const GroundVehicleCache *gcache = this->virtual_train->GetGroundVehicleCache();
+					SetDParam(2, this->virtual_train->GetDisplayMaxSpeed());
+					SetDParam(1, gcache->cached_power);
+					SetDParam(0, gcache->cached_weight);
+					SetDParam(3, gcache->cached_max_te / 1000);
+					DrawString(r.left+8, r.right, r.top+4, STR_VEHICLE_INFO_WEIGHT_POWER_MAX_SPEED_MAX_TE);
+					/* Draw cargo summary */
+					CargoArray cargo_caps;
+					for ( const Train *tmp=this->virtual_train; tmp; tmp=tmp->Next() )
+						cargo_caps[tmp->cargo_type] += tmp->cargo_cap;
+					int y = r.top+24;
+					for (CargoID i = 0; i < NUM_CARGO; i++) {
+						if ( cargo_caps[i] > 0 ) {
+							SetDParam(0, i);
+							SetDParam(1, cargo_caps[i]);
+							SetDParam(2, _settings_game.vehicle.freight_trains);
+							DrawString(r.left+8, r.right, y, STR_TMPL_CARGO_SUMMARY, TC_WHITE, SA_LEFT);
+							y += this->line_height/2;
+						}
+					}
+				}
+				break;
+			}
+			default:
+				break;
+		}
+	}
+	virtual void OnTick()
+	{
+		if ( virtualTrainChangedNotice ) {
+			this->SetDirty();
+			virtualTrainChangedNotice = false;
+		}
+	}
+	virtual void OnDragDrop(Point pt, int widget)
+	{
+		switch (widget) {
+			case TCW_MATRIX_NEW_TMPL: {
+				const Vehicle *v = NULL;
+				VehicleID sel;
+				if ( virtual_train ) sel = virtual_train->index;
+				else sel = INVALID_VEHICLE;
+
+				this->SetDirty();
+
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(TCW_MATRIX_NEW_TMPL);
+				GetDepotVehiclePtData gdvp = { NULL, NULL };
+
+				if (this->GetVehicleFromDepotWndPt(pt.x - nwi->pos_x, pt.y - nwi->pos_y, &v, &gdvp) == MODE_DRAG_VEHICLE && sel != INVALID_VEHICLE) {
+					if (gdvp.wagon == NULL || gdvp.wagon->index != sel) {
+						this->vehicle_over = INVALID_VEHICLE;
+						TrainDepotMoveVehicle(gdvp.wagon, sel, gdvp.head);
+						virtual_train = virtual_train->First();
+					}
+				}
+				break;
+			}
+			case TCW_SELL_TMPL: {
+				if (this->IsWidgetDisabled(widget)) return;
+				if (this->sel == INVALID_VEHICLE) return;
+
+				virtual_train = DeleteVirtualTrain(virtual_train, Train::Get(this->sel));
+
+				this->sel = INVALID_VEHICLE;
+
+				this->SetDirty();
+				break;
+			}
+			default:
+				this->sel = INVALID_VEHICLE;
+				this->SetDirty();
+		}
+		_cursor.vehchain = false;
+		this->sel = INVALID_VEHICLE;
+		this->SetDirty();
+	}
+	virtual void OnMouseDrag(Point pt, int widget)
+	{
+		if (this->sel == INVALID_VEHICLE) return;
+		/* A rail vehicle is dragged.. */
+		if (widget != TCW_MATRIX_NEW_TMPL) { // ..outside of the depot matrix.
+			if (this->vehicle_over != INVALID_VEHICLE) {
+				this->vehicle_over = INVALID_VEHICLE;
+				this->SetWidgetDirty(TCW_MATRIX_NEW_TMPL);
+			}
+			return;
+		}
+
+		NWidgetBase *matrix = this->GetWidget<NWidgetBase>(widget);
+		const Vehicle *v = NULL;
+		GetDepotVehiclePtData gdvp = {NULL, NULL};
+
+		if (this->GetVehicleFromDepotWndPt(pt.x - matrix->pos_x, pt.y - matrix->pos_y, &v, &gdvp) != MODE_DRAG_VEHICLE) return;
+		VehicleID new_vehicle_over = INVALID_VEHICLE;
+		if (gdvp.head != NULL) {
+			if (gdvp.wagon == NULL && gdvp.head->Last()->index != this->sel) { // ..at the end of the train.
+				/* NOTE: As a wagon can't be moved at the begin of a train, head index isn't used to mark a drag-and-drop
+				 * destination inside a train. This head index is then used to indicate that a wagon is inserted at
+				 * the end of the train.
+				 */
+				new_vehicle_over = gdvp.head->index;
+			} else if (gdvp.wagon != NULL && gdvp.head != gdvp.wagon &&
+					gdvp.wagon->index != this->sel &&
+					gdvp.wagon->Previous()->index != this->sel) { // ..over an existing wagon.
+				new_vehicle_over = gdvp.wagon->index;
+			}
+		}
+		if (this->vehicle_over == new_vehicle_over) return;
+
+		this->vehicle_over = new_vehicle_over;
+		this->SetWidgetDirty(widget);
+	}
+	virtual void OnPaint()
+	{
+		uint max_width = 32;
+		uint width = 0;
+		if ( virtual_train )
+			for (Train *v = virtual_train; v != NULL; v = v->Next())
+				width += v->GetDisplayImageWidth();
+
+		max_width = max(max_width, width);
+		this->hscroll->SetCount(max_width+25);
+
+		this->DrawWidgets();
+	}
+	struct GetDepotVehiclePtData {
+		const Vehicle *head;
+		const Vehicle *wagon;
+	};
+
+	enum DepotGUIAction {
+		MODE_ERROR,
+		MODE_DRAG_VEHICLE,
+		MODE_SHOW_VEHICLE,
+		MODE_START_STOP,
+	};
+
+	uint count_width;
+	uint header_width;
+ 	DepotGUIAction GetVehicleFromDepotWndPt(int x, int y, const Vehicle **veh, GetDepotVehiclePtData *d) const
+	{
+		const NWidgetCore *matrix_widget = this->GetWidget<NWidgetCore>(TCW_MATRIX_NEW_TMPL);
+		/* In case of RTL the widgets are swapped as a whole */
+		if (_current_text_dir == TD_RTL) x = matrix_widget->current_x - x;
+
+		uint xm = x;
+
+		bool wagon = false;
+
+		x += this->hscroll->GetPosition();
+		const Train *v = virtual_train;
+		d->head = d->wagon = v;
+
+		if (xm <= this->header_width) {
+
+			if (wagon) return MODE_ERROR;
+
+			return MODE_SHOW_VEHICLE;
+		}
+
+		/* Account for the header */
+		x -= this->header_width;
+
+		/* find the vehicle in this row that was clicked */
+		for (; v != NULL; v = v->Next()) {
+			x -= v->GetDisplayImageWidth();
+			if (x < 0) break;
+		}
+
+		d->wagon = (v != NULL ? v->GetFirstEnginePart() : NULL);
+
+		return MODE_DRAG_VEHICLE;
+	}
+
+	void ClickedOnVehiclePanel(int x, int y)
+	{
+		GetDepotVehiclePtData gdvp = { NULL, NULL };
+		const Vehicle *v = NULL;
+		DepotGUIAction mode = this->GetVehicleFromDepotWndPt(x, y, &v, &gdvp);
+
+		v = gdvp.wagon;
+
+		if (v != NULL && VehicleClicked(v)) return;
+		VehicleID sel = this->sel;
+
+		if (sel != INVALID_VEHICLE) {
+			this->sel = INVALID_VEHICLE;
+		} else if (v != NULL) {
+			int image = v->GetImage(_current_text_dir == TD_RTL ? DIR_E : DIR_W, EIT_PURCHASE);
+			SetObjectToPlaceWnd(image, GetVehiclePalette(v), HT_DRAG, this);
+
+			this->sel = v->index;
+			this->SetDirty();
+
+			_cursor.short_vehicle_offset = v->IsGroundVehicle() ? 16 - v->GetGroundVehicleCache()->cached_veh_length * 2 : 0;
+			_cursor.vehchain = _ctrl_pressed;
+		}
+	}
+
+};
+
+void ShowTemplateCreateWindow(TemplateVehicle *to_edit, bool *noticeParent, bool *createWindowOpen, int step_h)
+{
+	if ( BringWindowToFrontById(WC_CREATE_TEMPLATE, VEH_TRAIN) != NULL ) return;
+	new TemplateCreateWindow(&_template_create_window_desc, to_edit, noticeParent, createWindowOpen, step_h);
+}
+
+
diff --git a/src/aaa_template_gui_create.h b/src/aaa_template_gui_create.h
new file mode 100644
index 0000000..5cfa29d
--- /dev/null
+++ b/src/aaa_template_gui_create.h
@@ -0,0 +1,11 @@
+// template creation gui
+
+#ifndef TEMPLATE_GUI_CREATE
+#define TEMPLATE_GUI_CREATE
+
+#include "aaa_template_vehicle.h"
+#include "aaa_template_gui_create_virtualtrain.h"
+
+void ShowTemplateCreateWindow(TemplateVehicle*, bool*, bool*, int);
+
+#endif
diff --git a/src/aaa_template_gui_create_virtualtrain.cpp b/src/aaa_template_gui_create_virtualtrain.cpp
new file mode 100644
index 0000000..266ec42
--- /dev/null
+++ b/src/aaa_template_gui_create_virtualtrain.cpp
@@ -0,0 +1,839 @@
+/* $Id: build_vehicle_gui.cpp 23792 2012-01-12 19:23:00Z yexo $ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file build_vehicle_gui.cpp GUI for building vehicles. */
+
+#include "stdafx.h"
+#include "engine_base.h"
+#include "engine_func.h"
+#include "station_base.h"
+#include "articulated_vehicles.h"
+#include "textbuf_gui.h"
+#include "command_func.h"
+#include "company_func.h"
+#include "vehicle_gui.h"
+#include "newgrf_engine.h"
+#include "newgrf_text.h"
+#include "group.h"
+#include "string_func.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "date_func.h"
+#include "vehicle_func.h"
+#include "widgets/dropdown_func.h"
+#include "engine_gui.h"
+#include "cargotype.h"
+#include "core/geometry_func.hpp"
+
+#include "widgets/build_vehicle_widget.h"
+
+#include "table/strings.h"
+
+// MYGUI
+#include "aaa_template_gui_create_virtualtrain.h"
+#include "vehicle_gui.h"
+
+/**
+ * Get the height of a single 'entry' in the engine lists.
+ * @param type the vehicle type to get the height of
+ * @return the height for the entry
+ */
+static uint GetEngineListHeight(VehicleType type)
+{
+	return max<uint>(FONT_HEIGHT_NORMAL + WD_MATRIX_TOP + WD_MATRIX_BOTTOM, GetVehicleHeight(type));
+}
+
+static const NWidgetPart _nested_build_vehicle_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_BV_CAPTION), SetDataTip(STR_WHITE_STRING, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY),
+		NWidget(NWID_HORIZONTAL),
+			NWidget(NWID_VERTICAL),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_BV_SORT_ASSENDING_DESCENDING), SetDataTip(STR_BUTTON_SORT_BY, STR_TOOLTIP_SORT_ORDER), SetFill(1, 0),
+				NWidget(NWID_SPACER), SetFill(1, 1),
+			EndContainer(),
+			NWidget(NWID_VERTICAL),
+				NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_BV_SORT_DROPDOWN), SetResize(1, 0), SetFill(1, 0), SetDataTip(STR_JUST_STRING, STR_TOOLTIP_SORT_CRITERIA),
+				NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_BV_CARGO_FILTER_DROPDOWN), SetResize(1, 0), SetFill(1, 0), SetDataTip(STR_JUST_STRING, STR_TOOLTIP_FILTER_CRITERIA),
+			EndContainer(),
+		EndContainer(),
+	EndContainer(),
+	/* Vehicle list. */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, WID_BV_LIST), SetResize(1, 1), SetFill(1, 0), SetDataTip(0x101, STR_NULL), SetScrollbar(WID_BV_SCROLLBAR),
+		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_BV_SCROLLBAR),
+	EndContainer(),
+	/* Panel with details. */
+	NWidget(WWT_PANEL, COLOUR_GREY, WID_BV_PANEL), SetMinimalSize(240, 122), SetResize(1, 0), EndContainer(),
+	/* Build/rename buttons, resize button. */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_BV_BUILD), SetResize(1, 0), SetFill(1, 0), SetDataTip(STR_TMPL_CONFIRM, STR_TMPL_CONFIRM),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_BV_RENAME), SetResize(1, 0), SetFill(1, 0),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+/** Special cargo filter criteria */
+static const CargoID CF_ANY  = CT_NO_REFIT; ///< Show all vehicles independent of carried cargo (i.e. no filtering)
+static const CargoID CF_NONE = CT_INVALID;  ///< Show only vehicles which do not carry cargo (e.g. train engines)
+
+static bool _internal_sort_order;           ///< false = descending, true = ascending
+static byte _last_sort_criteria[]      = {0, 0, 0, 0};
+static bool _last_sort_order[]         = {false, false, false, false};
+static CargoID _last_filter_criteria[] = {CF_ANY, CF_ANY, CF_ANY, CF_ANY};
+
+/**
+ * Determines order of engines by engineID
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineNumberSorter(const EngineID *a, const EngineID *b)
+{
+	int r = ListPositionOfEngine(*a) - ListPositionOfEngine(*b);
+
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by introduction date
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineIntroDateSorter(const EngineID *a, const EngineID *b)
+{
+	const int va = Engine::Get(*a)->intro_date;
+	const int vb = Engine::Get(*b)->intro_date;
+	const int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by name
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineNameSorter(const EngineID *a, const EngineID *b)
+{
+	static EngineID last_engine[2] = { INVALID_ENGINE, INVALID_ENGINE };
+	static char     last_name[2][64] = { "\0", "\0" };
+
+	const EngineID va = *a;
+	const EngineID vb = *b;
+
+	if (va != last_engine[0]) {
+		last_engine[0] = va;
+		SetDParam(0, va);
+		GetString(last_name[0], STR_ENGINE_NAME, lastof(last_name[0]));
+	}
+
+	if (vb != last_engine[1]) {
+		last_engine[1] = vb;
+		SetDParam(0, vb);
+		GetString(last_name[1], STR_ENGINE_NAME, lastof(last_name[1]));
+	}
+
+	int r = strnatcmp(last_name[0], last_name[1]); // Sort by name (natural sorting).
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by reliability
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineReliabilitySorter(const EngineID *a, const EngineID *b)
+{
+	const int va = Engine::Get(*a)->reliability;
+	const int vb = Engine::Get(*b)->reliability;
+	const int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by purchase cost
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineCostSorter(const EngineID *a, const EngineID *b)
+{
+	Money va = Engine::Get(*a)->GetCost();
+	Money vb = Engine::Get(*b)->GetCost();
+	int r = ClampToI32(va - vb);
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by speed
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineSpeedSorter(const EngineID *a, const EngineID *b)
+{
+	int va = Engine::Get(*a)->GetDisplayMaxSpeed();
+	int vb = Engine::Get(*b)->GetDisplayMaxSpeed();
+	int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by power
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EnginePowerSorter(const EngineID *a, const EngineID *b)
+{
+	int va = Engine::Get(*a)->GetPower();
+	int vb = Engine::Get(*b)->GetPower();
+	int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by tractive effort
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineTractiveEffortSorter(const EngineID *a, const EngineID *b)
+{
+	int va = Engine::Get(*a)->GetDisplayMaxTractiveEffort();
+	int vb = Engine::Get(*b)->GetDisplayMaxTractiveEffort();
+	int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by running costs
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EngineRunningCostSorter(const EngineID *a, const EngineID *b)
+{
+	Money va = Engine::Get(*a)->GetRunningCost();
+	Money vb = Engine::Get(*b)->GetRunningCost();
+	int r = ClampToI32(va - vb);
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of engines by running costs
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL EnginePowerVsRunningCostSorter(const EngineID *a, const EngineID *b)
+{
+	const Engine *e_a = Engine::Get(*a);
+	const Engine *e_b = Engine::Get(*b);
+
+	/* Here we are using a few tricks to get the right sort.
+	 * We want power/running cost, but since we usually got higher running cost than power and we store the result in an int,
+	 * we will actually calculate cunning cost/power (to make it more than 1).
+	 * Because of this, the return value have to be reversed as well and we return b - a instead of a - b.
+	 * Another thing is that both power and running costs should be doubled for multiheaded engines.
+	 * Since it would be multipling with 2 in both numerator and denumerator, it will even themselves out and we skip checking for multiheaded. */
+	Money va = (e_a->GetRunningCost()) / max(1U, (uint)e_a->GetPower());
+	Money vb = (e_b->GetRunningCost()) / max(1U, (uint)e_b->GetPower());
+	int r = ClampToI32(vb - va);
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/* Train sorting functions */
+
+/**
+ * Determines order of train engines by capacity
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL TrainEngineCapacitySorter(const EngineID *a, const EngineID *b)
+{
+	const RailVehicleInfo *rvi_a = RailVehInfo(*a);
+	const RailVehicleInfo *rvi_b = RailVehInfo(*b);
+
+	int va = GetTotalCapacityOfArticulatedParts(*a) * (rvi_a->railveh_type == RAILVEH_MULTIHEAD ? 2 : 1);
+	int vb = GetTotalCapacityOfArticulatedParts(*b) * (rvi_b->railveh_type == RAILVEH_MULTIHEAD ? 2 : 1);
+	int r = va - vb;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+/**
+ * Determines order of train engines by engine / wagon
+ * @param *a first engine to compare
+ * @param *b second engine to compare
+ * @return for descending order: returns < 0 if a < b and > 0 for a > b. Vice versa for ascending order and 0 for equal
+ */
+static int CDECL TrainEnginesThenWagonsSorter(const EngineID *a, const EngineID *b)
+{
+	int val_a = (RailVehInfo(*a)->railveh_type == RAILVEH_WAGON ? 1 : 0);
+	int val_b = (RailVehInfo(*b)->railveh_type == RAILVEH_WAGON ? 1 : 0);
+	int r = val_a - val_b;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return _internal_sort_order ? -r : r;
+}
+
+// TODO: make this single-dim
+
+static EngList_SortTypeFunction * const _sorter[][11] = {{
+	/* Trains */
+	&EngineNumberSorter,
+	&EngineCostSorter,
+	&EngineSpeedSorter,
+	&EnginePowerSorter,
+	&EngineTractiveEffortSorter,
+	&EngineIntroDateSorter,
+	&EngineNameSorter,
+	&EngineRunningCostSorter,
+	&EnginePowerVsRunningCostSorter,
+	&EngineReliabilitySorter,
+	&TrainEngineCapacitySorter,
+}};
+
+static const StringID _sort_listing[][12] = {{
+	/* Trains */
+	STR_SORT_BY_ENGINE_ID,
+	STR_SORT_BY_COST,
+	STR_SORT_BY_MAX_SPEED,
+	STR_SORT_BY_POWER,
+	STR_SORT_BY_TRACTIVE_EFFORT,
+	STR_SORT_BY_INTRO_DATE,
+	STR_SORT_BY_NAME,
+	STR_SORT_BY_RUNNING_COST,
+	STR_SORT_BY_POWER_VS_RUNNING_COST,
+	STR_SORT_BY_RELIABILITY,
+	STR_SORT_BY_CARGO_CAPACITY,
+	INVALID_STRING_ID
+}};
+
+/** Cargo filter functions */
+static bool CDECL CargoFilter(const EngineID *eid, const CargoID cid)
+{
+	if (cid == CF_ANY) return true;
+	uint32 refit_mask = GetUnionOfArticulatedRefitMasks(*eid, true);
+	return (cid == CF_NONE ? refit_mask == 0 : HasBit(refit_mask, cid));
+}
+
+static GUIEngineList::FilterFunction * const _filter_funcs[] = {
+	&CargoFilter,
+};
+
+/**
+ * Engine drawing loop
+ * @param type Type of vehicle (VEH_*)
+ * @param l The left most location of the list
+ * @param r The right most location of the list
+ * @param y The top most location of the list
+ * @param eng_list What engines to draw
+ * @param min where to start in the list
+ * @param max where in the list to end
+ * @param selected_id what engine to highlight as selected, if any
+ * @param show_count Whether to show the amount of engines or not
+ * @param selected_group the group to list the engines of
+ */
+static void DrawEngineList(VehicleType type, int l, int r, int y, const GUIEngineList *eng_list, uint16 min, uint16 max, EngineID selected_id, bool show_count, GroupID selected_group)
+{
+	static const int sprite_widths[]  = { 60, 60, 76, 67 };
+	static const int sprite_y_offsets[] = { -1, -1, -2, -2 };
+
+	/* Obligatory sanity checks! */
+	assert((uint)type < lengthof(sprite_widths));
+	assert_compile(lengthof(sprite_y_offsets) == lengthof(sprite_widths));
+	assert(max <= eng_list->Length());
+
+	bool rtl = _current_text_dir == TD_RTL;
+	int step_size = GetEngineListHeight(type);
+	int sprite_width = sprite_widths[type];
+
+	int sprite_x        = (rtl ? r - sprite_width / 2 : l + sprite_width / 2) - 1;
+	int sprite_y_offset = sprite_y_offsets[type] + step_size / 2;
+
+	int text_left  = l + (rtl ? WD_FRAMERECT_LEFT : sprite_width);
+	int text_right = r - (rtl ? sprite_width : WD_FRAMERECT_RIGHT);
+
+	int normal_text_y_offset = (step_size - FONT_HEIGHT_NORMAL) / 2;
+	int small_text_y_offset  = step_size - FONT_HEIGHT_SMALL - WD_FRAMERECT_BOTTOM - 1;
+
+	for (; min < max; min++, y += step_size) {
+		const EngineID engine = (*eng_list)[min];
+		/* Note: num_engines is only used in the autoreplace GUI, so it is correct to use _local_company here. */
+		const uint num_engines = GetGroupNumEngines(_local_company, selected_group, engine);
+
+		SetDParam(0, engine);
+		DrawString(text_left, text_right, y + normal_text_y_offset, STR_ENGINE_NAME, engine == selected_id ? TC_WHITE : TC_BLACK);
+		DrawVehicleEngine(l, r, sprite_x, y + sprite_y_offset, engine, (show_count && num_engines == 0) ? PALETTE_CRASH : GetEnginePalette(engine, _local_company), EIT_PURCHASE);
+		if (show_count) {
+			SetDParam(0, num_engines);
+			DrawString(text_left, text_right, y + small_text_y_offset, STR_TINY_BLACK_COMA, TC_FROMSTRING, SA_RIGHT);
+		}
+	}
+}
+
+
+struct BuildVirtualTrainWindow : Window {
+	VehicleType vehicle_type;
+	union {
+		RailTypeByte railtype;
+		RoadTypes roadtypes;
+	} filter;
+	bool descending_sort_order;
+	byte sort_criteria;
+	bool listview_mode;
+	EngineID sel_engine;
+	EngineID rename_engine;
+	GUIEngineList eng_list;
+	CargoID cargo_filter[NUM_CARGO + 2];        ///< Available cargo filters; CargoID or CF_ANY or CF_NONE
+	StringID cargo_filter_texts[NUM_CARGO + 3]; ///< Texts for filter_cargo, terminated by INVALID_STRING_ID
+	byte cargo_filter_criteria;                 ///< Selected cargo filter
+	int details_height;                         ///< Minimal needed height of the details panels (found so far).
+	Scrollbar *vscroll;
+	// MYGUI
+	Train **virtual_train;
+	bool *noticeParent;
+
+	BuildVirtualTrainWindow(const WindowDesc *desc, Train **vt, bool *notice) : Window()
+	{
+		this->vehicle_type = VEH_TRAIN; // TODO change type to VEH_TRAIN everywhere
+		this->window_number = 0;//tile == INVALID_TILE ? (int)type : tile;
+
+		this->sel_engine      = INVALID_ENGINE;
+
+		this->sort_criteria         = _last_sort_criteria[VEH_TRAIN];
+		this->descending_sort_order = _last_sort_order[VEH_TRAIN];
+
+		this->filter.railtype = RAILTYPE_END;
+
+		this->listview_mode = (this->window_number <= VEH_END);
+
+		this->CreateNestedTree(desc);
+
+		this->vscroll = this->GetScrollbar(WID_BV_SCROLLBAR);
+
+		NWidgetCore *widget = this->GetWidget<NWidgetCore>(WID_BV_LIST);
+
+		widget = this->GetWidget<NWidgetCore>(WID_BV_BUILD);
+
+		widget = this->GetWidget<NWidgetCore>(WID_BV_RENAME);
+		widget->widget_data = STR_BUY_VEHICLE_TRAIN_RENAME_BUTTON + VEH_TRAIN;
+		widget->tool_tip    = STR_BUY_VEHICLE_TRAIN_RENAME_TOOLTIP + VEH_TRAIN;
+
+		this->details_height = ((this->vehicle_type == VEH_TRAIN) ? 10 : 9) * FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+
+		this->FinishInitNested(desc, VEH_TRAIN);
+
+		this->owner = _local_company;
+
+		this->eng_list.ForceRebuild();
+		this->GenerateBuildList();
+
+		if (this->eng_list.Length() > 0) this->sel_engine = this->eng_list[0];
+
+		this->virtual_train = vt;
+		this->noticeParent = notice;
+	}
+
+	/** Populate the filter list and set the cargo filter criteria. */
+	void SetCargoFilterArray()
+	{
+		uint filter_items = 0;
+
+		/* Add item for disabling filtering. */
+		this->cargo_filter[filter_items] = CF_ANY;
+		this->cargo_filter_texts[filter_items] = STR_PURCHASE_INFO_ALL_TYPES;
+		filter_items++;
+
+		/* Add item for vehicles not carrying anything, e.g. train engines.
+		 * This could also be useful for eyecandy vehicles of other types, but is likely too confusing for joe, */
+		if (this->vehicle_type == VEH_TRAIN) {
+			this->cargo_filter[filter_items] = CF_NONE;
+			this->cargo_filter_texts[filter_items] = STR_LAND_AREA_INFORMATION_LOCAL_AUTHORITY_NONE;
+			filter_items++;
+		}
+
+		/* Collect available cargo types for filtering. */
+		const CargoSpec *cs;
+		FOR_ALL_SORTED_STANDARD_CARGOSPECS(cs) {
+			this->cargo_filter[filter_items] = cs->Index();
+			this->cargo_filter_texts[filter_items] = cs->name;
+			filter_items++;
+		}
+
+		/* Terminate the filter list. */
+		this->cargo_filter_texts[filter_items] = INVALID_STRING_ID;
+
+		/* If not found, the cargo criteria will be set to all cargoes. */
+		this->cargo_filter_criteria = 0;
+
+		/* Find the last cargo filter criteria. */
+		for (uint i = 0; i < filter_items; i++) {
+			if (this->cargo_filter[i] == _last_filter_criteria[this->vehicle_type]) {
+				this->cargo_filter_criteria = i;
+				break;
+			}
+		}
+
+		this->eng_list.SetFilterFuncs(_filter_funcs);
+		this->eng_list.SetFilterState(this->cargo_filter[this->cargo_filter_criteria] != CF_ANY);
+	}
+
+	void OnInit()
+	{
+		this->SetCargoFilterArray();
+	}
+
+	/** Filter the engine list against the currently selected cargo filter */
+	void FilterEngineList()
+	{
+		this->eng_list.Filter(this->cargo_filter[this->cargo_filter_criteria]);
+		if (0 == this->eng_list.Length()) { // no engine passed through the filter, invalidate the previously selected engine
+			this->sel_engine = INVALID_ENGINE;
+		} else if (!this->eng_list.Contains(this->sel_engine)) { // previously selected engine didn't pass the filter, select the first engine of the list
+			this->sel_engine = this->eng_list[0];
+		}
+	}
+
+	/** Filter a single engine */
+	bool FilterSingleEngine(EngineID eid)
+	{
+		CargoID filter_type = this->cargo_filter[this->cargo_filter_criteria];
+		return (filter_type == CF_ANY || CargoFilter(&eid, filter_type));
+	}
+
+	/* Figure out what train EngineIDs to put in the list */
+	void GenerateBuildTrainList()
+	{
+		EngineID sel_id = INVALID_ENGINE;
+		int num_engines = 0;
+		int num_wagons  = 0;
+
+		this->filter.railtype = (this->listview_mode) ? RAILTYPE_END : GetRailType(this->window_number);
+
+		this->eng_list.Clear();
+
+		/* Make list of all available train engines and wagons.
+		 * Also check to see if the previously selected engine is still available,
+		 * and if not, reset selection to INVALID_ENGINE. This could be the case
+		 * when engines become obsolete and are removed */
+		const Engine *e;
+		FOR_ALL_ENGINES_OF_TYPE(e, VEH_TRAIN) {
+			EngineID eid = e->index;
+			const RailVehicleInfo *rvi = &e->u.rail;
+
+			if (this->filter.railtype != RAILTYPE_END && !HasPowerOnRail(rvi->railtype, this->filter.railtype)) continue;
+			if (!IsEngineBuildable(eid, VEH_TRAIN, _local_company)) continue;
+
+			/* Filter now! So num_engines and num_wagons is valid */
+			if (!FilterSingleEngine(eid)) continue;
+
+			*this->eng_list.Append() = eid;
+
+			if (rvi->railveh_type != RAILVEH_WAGON) {
+				num_engines++;
+			} else {
+				num_wagons++;
+			}
+
+			if (eid == this->sel_engine) sel_id = eid;
+		}
+
+		this->sel_engine = sel_id;
+
+		/* make engines first, and then wagons, sorted by ListPositionOfEngine() */
+		_internal_sort_order = false;
+		EngList_Sort(&this->eng_list, TrainEnginesThenWagonsSorter);
+
+		/* and then sort engines */
+		_internal_sort_order = this->descending_sort_order;
+		EngList_SortPartial(&this->eng_list, _sorter[0][this->sort_criteria], 0, num_engines);
+
+		/* and finally sort wagons */
+		EngList_SortPartial(&this->eng_list, _sorter[0][this->sort_criteria], num_engines, num_wagons);
+	}
+
+	// TODO: cleanup this func
+	/* Generate the list of vehicles */
+	void GenerateBuildList()
+	{
+		if (!this->eng_list.NeedRebuild()) return;
+
+		this->GenerateBuildTrainList();
+		this->eng_list.Compact();
+		this->eng_list.RebuildDone();
+		return; // trains should not reach the last sorting
+
+
+		this->FilterEngineList();
+
+		_internal_sort_order = this->descending_sort_order;
+		EngList_Sort(&this->eng_list, _sorter[this->vehicle_type][this->sort_criteria]);
+
+		this->eng_list.Compact();
+		this->eng_list.RebuildDone();
+	}
+
+	virtual	void OnClick(Point pt, int widget, int click_count)
+	{
+		switch (widget) {
+			case WID_BV_SORT_ASSENDING_DESCENDING:
+				this->descending_sort_order ^= true;
+				_last_sort_order[this->vehicle_type] = this->descending_sort_order;
+				this->eng_list.ForceRebuild();
+				this->SetDirty();
+				break;
+
+			case WID_BV_LIST: {
+				uint i = this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_BV_LIST);
+				size_t num_items = this->eng_list.Length();
+				this->sel_engine = (i < num_items) ? this->eng_list[i] : INVALID_ENGINE;
+				this->SetDirty();
+				if (click_count > 1 && !this->listview_mode) this->OnClick(pt, WID_BV_BUILD, 1);
+				break;
+			}
+			case WID_BV_SORT_DROPDOWN: { // Select sorting criteria dropdown menu
+				uint32 hidden_mask = 0;
+				/* Disable sorting by power or tractive effort when the original acceleration model for road vehicles is being used. */
+				if (this->vehicle_type == VEH_ROAD &&
+						_settings_game.vehicle.roadveh_acceleration_model == AM_ORIGINAL) {
+					SetBit(hidden_mask, 3); // power
+					SetBit(hidden_mask, 4); // tractive effort
+					SetBit(hidden_mask, 8); // power by running costs
+				}
+				/* Disable sorting by tractive effort when the original acceleration model for trains is being used. */
+				if (this->vehicle_type == VEH_TRAIN &&
+						_settings_game.vehicle.train_acceleration_model == AM_ORIGINAL) {
+					SetBit(hidden_mask, 4); // tractive effort
+				}
+				ShowDropDownMenu(this, _sort_listing[this->vehicle_type], this->sort_criteria, WID_BV_SORT_DROPDOWN, 0, hidden_mask);
+				break;
+			}
+
+			case WID_BV_CARGO_FILTER_DROPDOWN: // Select cargo filtering criteria dropdown menu
+				ShowDropDownMenu(this, this->cargo_filter_texts, this->cargo_filter_criteria, WID_BV_CARGO_FILTER_DROPDOWN, 0, 0);
+				break;
+
+			case WID_BV_BUILD: {
+				EngineID sel_eng = this->sel_engine;
+				if (sel_eng != INVALID_ENGINE) {
+					Train *tmp = CmdBuildVirtualRailVehicle(sel_eng);
+					if (tmp) AddVirtualEngine(tmp);
+				}
+				break;
+			}
+		}
+	}
+
+	/**
+	 * Some data on this window has become invalid.
+	 * @param data Information about the changed data.
+	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+	 */
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		if (!gui_scope) return;
+		/* When switching to original acceleration model for road vehicles, clear the selected sort criteria if it is not available now. */
+		if (this->vehicle_type == VEH_ROAD &&
+				_settings_game.vehicle.roadveh_acceleration_model == AM_ORIGINAL &&
+				this->sort_criteria > 7) {
+			this->sort_criteria = 0;
+			_last_sort_criteria[VEH_ROAD] = 0;
+		}
+		this->eng_list.ForceRebuild();
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			case WID_BV_CAPTION:
+				if (this->vehicle_type == VEH_TRAIN && !this->listview_mode) {
+					const RailtypeInfo *rti = GetRailTypeInfo(this->filter.railtype);
+					SetDParam(0, rti->strings.build_caption);
+				} else {
+					SetDParam(0, (this->listview_mode ? STR_VEHICLE_LIST_AVAILABLE_TRAINS : STR_BUY_VEHICLE_TRAIN_ALL_CAPTION) + this->vehicle_type);
+				}
+				break;
+
+			case WID_BV_SORT_DROPDOWN:
+				SetDParam(0, _sort_listing[this->vehicle_type][this->sort_criteria]);
+				break;
+
+			case WID_BV_CARGO_FILTER_DROPDOWN:
+				SetDParam(0, this->cargo_filter_texts[this->cargo_filter_criteria]);
+		}
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case WID_BV_LIST:
+				resize->height = GetEngineListHeight(this->vehicle_type);
+				size->height = 3 * resize->height;
+				break;
+
+			case WID_BV_PANEL:
+				size->height = this->details_height;
+				break;
+
+			case WID_BV_SORT_ASSENDING_DESCENDING: {
+				Dimension d = GetStringBoundingBox(this->GetWidget<NWidgetCore>(widget)->widget_data);
+				d.width += padding.width + WD_SORTBUTTON_ARROW_WIDTH * 2; // Doubled since the string is centred and it also looks better.
+				d.height += padding.height;
+				*size = maxdim(*size, d);
+				break;
+			}
+		}
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch (widget) {
+			case WID_BV_LIST:
+				DrawEngineList(this->vehicle_type, r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, &this->eng_list, this->vscroll->GetPosition(), min(this->vscroll->GetPosition() + this->vscroll->GetCapacity(), this->eng_list.Length()), this->sel_engine, false, DEFAULT_GROUP);
+				break;
+
+			case WID_BV_SORT_ASSENDING_DESCENDING:
+				this->DrawSortButtonState(WID_BV_SORT_ASSENDING_DESCENDING, this->descending_sort_order ? SBS_DOWN : SBS_UP);
+				break;
+		}
+	}
+
+	virtual void OnPaint()
+	{
+		this->GenerateBuildList();
+		this->vscroll->SetCount(this->eng_list.Length());
+
+		this->DrawWidgets();
+
+		if (!this->IsShaded()) {
+			int needed_height = this->details_height;
+			/* Draw details panels. */
+			if (this->sel_engine != INVALID_ENGINE) {
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(WID_BV_PANEL);
+				int text_end = DrawVehiclePurchaseInfo(nwi->pos_x + WD_FRAMETEXT_LEFT, nwi->pos_x + nwi->current_x - WD_FRAMETEXT_RIGHT,
+						nwi->pos_y + WD_FRAMERECT_TOP, this->sel_engine);
+				needed_height = max(needed_height, text_end - (int)nwi->pos_y + WD_FRAMERECT_BOTTOM);
+			}
+			if (needed_height != this->details_height) { // Details window are not high enough, enlarge them.
+				int resize = needed_height - this->details_height;
+				this->details_height = needed_height;
+				this->ReInit(0, resize);
+				return;
+			}
+		}
+	}
+
+	virtual void OnQueryTextFinished(char *str)
+	{
+		if (str == NULL) return;
+
+		DoCommandP(0, this->rename_engine, 0, CMD_RENAME_ENGINE | CMD_MSG(STR_ERROR_CAN_T_RENAME_TRAIN_TYPE + this->vehicle_type), NULL, str);
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		switch (widget) {
+			case WID_BV_SORT_DROPDOWN:
+				if (this->sort_criteria != index) {
+					this->sort_criteria = index;
+					_last_sort_criteria[this->vehicle_type] = this->sort_criteria;
+					this->eng_list.ForceRebuild();
+				}
+				break;
+
+			case WID_BV_CARGO_FILTER_DROPDOWN: // Select a cargo filter criteria
+				if (this->cargo_filter_criteria != index) {
+					this->cargo_filter_criteria = index;
+					_last_filter_criteria[this->vehicle_type] = this->cargo_filter[this->cargo_filter_criteria];
+					/* deactivate filter if criteria is 'Show All', activate it otherwise */
+					this->eng_list.SetFilterState(this->cargo_filter[this->cargo_filter_criteria] != CF_ANY);
+					this->eng_list.ForceRebuild();
+				}
+				break;
+		}
+		this->SetDirty();
+	}
+
+	virtual void OnResize()
+	{
+		this->vscroll->SetCapacityFromWidget(this, WID_BV_LIST);
+		this->GetWidget<NWidgetCore>(WID_BV_LIST)->widget_data = (this->vscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+	void AddVirtualEngine(Train *toadd)
+	{
+		if ( !*virtual_train ) {
+			*virtual_train = toadd;
+		}
+		else {
+			VehicleID target = (*(this->virtual_train))->GetLastUnit()->index;
+			CommandCost movec;
+			movec = CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, (1<<21) | toadd->index, target, 0);
+		}
+		*noticeParent = true;
+	}
+};
+
+static const WindowDesc _build_vehicle_desc(
+	WDP_AUTO, 240, 268,
+	WC_BUILD_VIRTUAL_TRAIN, WC_NONE,
+	WDF_UNCLICK_BUTTONS | WDF_CONSTRUCTION,
+	_nested_build_vehicle_widgets, lengthof(_nested_build_vehicle_widgets)
+);
+
+void ShowBuildVirtualTrainWindow(Train **vt, bool *noticeParent)
+{
+	// '0' as in VEH_TRAIN = Tile=0
+	assert(IsCompanyBuildableVehicleType(VEH_TRAIN));
+
+	DeleteWindowById(WC_BUILD_VEHICLE, 0);
+
+	new BuildVirtualTrainWindow(&_build_vehicle_desc, vt, noticeParent);
+}
diff --git a/src/aaa_template_gui_create_virtualtrain.h b/src/aaa_template_gui_create_virtualtrain.h
new file mode 100644
index 0000000..d454f74
--- /dev/null
+++ b/src/aaa_template_gui_create_virtualtrain.h
@@ -0,0 +1,8 @@
+#ifndef BUILD_VIRTUAL_TRAIN_GUI
+#define BUILD_VIRTUAL_TRAIN_GUI
+
+#include "train.h"
+
+void ShowBuildVirtualTrainWindow(Train**, bool*);
+
+#endif
diff --git a/src/aaa_template_gui_main.cpp b/src/aaa_template_gui_main.cpp
new file mode 100644
index 0000000..aa0ed16
--- /dev/null
+++ b/src/aaa_template_gui_main.cpp
@@ -0,0 +1,740 @@
+// mygui.c
+
+
+//#include "aaa_mygui.h"
+#include <iostream>
+#include <stdio.h>
+
+
+#include "stdafx.h"
+#include "command_func.h"
+#include "vehicle_gui.h"
+#include "newgrf_engine.h"
+#include "group.h"
+#include "rail.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "autoreplace_func.h"
+#include "company_func.h"
+#include "engine_base.h"
+#include "window_gui.h"
+#include "viewport_func.h"
+#include "tilehighlight_func.h"
+#include "engine_gui.h"
+#include "settings_func.h"
+#include "core/geometry_func.hpp"
+#include "rail_gui.h"
+
+#include "table/sprites.h"
+#include "table/strings.h"
+
+// test creating pool -> creating vehicles
+#include "core/pool_func.hpp"
+
+#include "vehicle_gui_base.h"
+#include "vehicle_base.h"
+#include "train.h"
+#include "vehicle_func.h"
+
+#include "gfx_type.h"
+
+#include "engine_func.h"
+
+// drawing the vehicle length based on occupied tiles
+#include "spritecache.h"
+
+#include "aaa_template_gui_main.h"
+#include "aaa_template_gui_create.h"
+#include "aaa_template_vehicle.h"
+//#include "aaa_template_vehicle_func.h"
+
+
+typedef GUIList<const Group*> GUIGroupList;
+
+
+/* template creation */
+void ShowTemplateCreationWindow(TileIndex);
+void ShowTestWindow();
+
+enum TemplateReplaceWindowWidgets {
+	TRW_CAPTION,
+
+	TRW_WIDGET_INSET_GROUPS,
+	TRW_WIDGET_TOP_MATRIX,
+	TRW_WIDGET_TOP_SCROLLBAR,
+
+	TRW_WIDGET_INSET_TEMPLATES,
+	TRW_WIDGET_BOTTOM_MATRIX,
+	TRW_WIDGET_BOTTOM_SCROLLBAR,
+
+	TRW_WIDGET_TMPL_INFO_INSET,
+	TRW_WIDGET_TMPL_INFO_PANEL,
+
+	TRW_WIDGET_TMPL_PRE_BUTTON_FLUFF,
+
+	TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REUSE,
+	TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_KEEP,
+	TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REFIT,
+	TRW_WIDGET_TMPL_BUTTONS_CONFIG_RIGHTPANEL,
+
+	TRW_WIDGET_TMPL_BUTTONS_DEFINE,
+	TRW_WIDGET_TMPL_BUTTONS_EDIT,
+	TRW_WIDGET_TMPL_BUTTONS_CLONE,
+	TRW_WIDGET_TMPL_BUTTONS_DELETE,
+	TRW_WIDGET_TMPL_BUTTONS_RPLALL,
+	TRW_WIDGET_TMPL_BUTTON_FLUFF,
+	TRW_WIDGET_TMPL_BUTTONS_EDIT_RIGHTPANEL,
+
+	TRW_WIDGET_TITLE_INFO_GROUP,
+	TRW_WIDGET_TITLE_INFO_TEMPLATE,
+
+	TRW_WIDGET_INFO_GROUP,
+ 	TRW_WIDGET_INFO_TEMPLATE,
+
+	TRW_WIDGET_TMPL_BUTTONS_SPACER,
+
+	TRW_WIDGET_START,
+	TRW_WIDGET_TRAIN_FLUFF_LEFT,
+	TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN,
+	TRW_WIDGET_TRAIN_FLUFF_RIGHT,
+	TRW_WIDGET_STOP,
+
+	TRW_WIDGET_SEL_TMPL_DISPLAY_CREATE,
+};
+
+
+static const NWidgetPart _widgets[] = {
+	// Title bar
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, TRW_CAPTION), SetDataTip(STR_TMPL_RPL_TITLE, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	//Top Matrix
+	NWidget(NWID_VERTICAL),
+		NWidget(WWT_INSET, COLOUR_GREY, TRW_WIDGET_INSET_GROUPS), SetMinimalSize(216,12), SetDataTip(STR_TMPL_MAINGUI_DEFINEDGROUPS, STR_TMPL_MAINGUI_DEFINEDGROUPS), SetResize(1, 0), EndContainer(),
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_MATRIX, COLOUR_GREY, TRW_WIDGET_TOP_MATRIX), SetMinimalSize(216, 0), SetFill(1, 1), SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY), SetResize(1, 0), SetScrollbar(TRW_WIDGET_TOP_SCROLLBAR),
+			NWidget(NWID_VSCROLLBAR, COLOUR_GREY, TRW_WIDGET_TOP_SCROLLBAR),
+		EndContainer(),
+	EndContainer(),
+	// Template Display
+	NWidget(NWID_VERTICAL),
+		NWidget(WWT_INSET, COLOUR_GREY, TRW_WIDGET_INSET_TEMPLATES), SetMinimalSize(216,12), SetDataTip(STR_TMPL_AVAILABLE_TEMPLATES, STR_TMPL_AVAILABLE_TEMPLATES), SetResize(1, 0), EndContainer(),
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_MATRIX, COLOUR_GREY, TRW_WIDGET_BOTTOM_MATRIX), SetMinimalSize(216, 0), SetFill(1, 1), SetDataTip(0x1, STR_REPLACE_HELP_RIGHT_ARRAY), SetResize(1, 1), SetScrollbar(TRW_WIDGET_BOTTOM_SCROLLBAR),
+			NWidget(NWID_VSCROLLBAR, COLOUR_GREY, TRW_WIDGET_BOTTOM_SCROLLBAR),
+		EndContainer(),
+	EndContainer(),
+	// Info Area
+	NWidget(NWID_VERTICAL),
+		NWidget(WWT_INSET, COLOUR_GREY, TRW_WIDGET_TMPL_INFO_INSET), SetMinimalSize(216,12), SetResize(1,0), SetDataTip(STR_TMPL_AVAILABLE_TEMPLATES, STR_TMPL_AVAILABLE_TEMPLATES), EndContainer(),
+		NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TMPL_INFO_PANEL), SetMinimalSize(216,50), SetResize(1,0), EndContainer(),
+	EndContainer(),
+	// Control Area
+	NWidget(NWID_VERTICAL),
+		// Spacing
+		NWidget(WWT_INSET, COLOUR_GREY, TRW_WIDGET_TMPL_PRE_BUTTON_FLUFF), SetMinimalSize(139, 12), SetResize(1,0), EndContainer(),
+		// Config buttons
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REUSE), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_SET_USEDEPOT, STR_TMPL_SET_USEDEPOT_TIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_KEEP), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_SET_KEEPREMAINDERS, STR_TMPL_SET_KEEPREMAINDERS_TIP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REFIT), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_SET_REFIT, STR_TMPL_SET_REFIT_TIP),
+			NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CONFIG_RIGHTPANEL), SetMinimalSize(12,12), SetResize(1,0), EndContainer(),
+		EndContainer(),
+		// Edit buttons
+		NWidget(NWID_HORIZONTAL),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_DEFINE), SetMinimalSize(75,12), SetResize(0,0), SetDataTip(STR_TMPL_DEFINE_TEMPLATE, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_EDIT), SetMinimalSize(75,12), SetResize(0,0), SetDataTip(STR_TMPL_EDIT_TEMPLATE, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_TEXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_CLONE), SetMinimalSize(75,12), SetResize(0,0), SetDataTip(STR_TMPL_CREATE_CLONE_VEH, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_DELETE), SetMinimalSize(75,12), SetResize(0,0), SetDataTip(STR_TMPL_DELETE_TEMPLATE, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_RPLALL), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_RPL_ALL_TMPL, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+			NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TMPL_BUTTONS_EDIT_RIGHTPANEL), SetMinimalSize(50,12), SetResize(1,0), EndContainer(),
+		EndContainer(),
+	EndContainer(),
+	// Start/Stop buttons
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_START), SetMinimalSize(150, 12), SetDataTip(STR_TMPL_RPL_START, STR_REPLACE_ENGINE_WAGON_SELECT_HELP),
+		NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TRAIN_FLUFF_LEFT), SetMinimalSize(15, 12), EndContainer(),
+		NWidget(WWT_DROPDOWN, COLOUR_GREY, TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN), SetMinimalSize(150, 12), SetDataTip(0x0, STR_REPLACE_HELP_RAILTYPE), SetResize(1, 0),
+		NWidget(WWT_PANEL, COLOUR_GREY, TRW_WIDGET_TRAIN_FLUFF_RIGHT), SetMinimalSize(16, 12), EndContainer(),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, TRW_WIDGET_STOP), SetMinimalSize(150, 12), SetDataTip(STR_TMPL_RPL_STOP, STR_REPLACE_REMOVE_WAGON_HELP),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static const WindowDesc _replace_rail_vehicle_desc(
+	WDP_AUTO, 456, 156,
+	WC_TEMPLATEGUI_MAIN, WC_NONE,					// TODO change wc_replace_vehicle
+	WDF_UNCLICK_BUTTONS | WDF_CONSTRUCTION,
+	_widgets, lengthof(_widgets)
+);
+
+class TemplateReplaceWindow : public Window {
+private:
+
+	GUIGroupList groups;  		 ///< List of groups
+	byte unitnumber_digits;
+	//Own
+	short line_height;
+	short matrixContentLeftMargin;
+
+	// from AutoreplaceGUI
+	int details_height;           ///< Minimal needed height of the details panels (found so far).
+	RailType sel_railtype;        ///< Type of rail tracks selected.
+	Scrollbar *vscroll[2];
+	// listing/sorting continued
+	GUITemplateList templates;
+	GUITemplateList::SortFunction **template_sorter_funcs;
+
+	short selected_template_index;
+	short selected_group_index;
+
+	bool templateNotice;
+	bool editInProgress;
+
+public:
+	TemplateReplaceWindow(const WindowDesc *wdesc, byte dig, int step_h) : Window()
+	{
+		// listing/sorting
+		templates.SetSortFuncs(this->template_sorter_funcs);
+
+		// From BaseVehicleListWindow
+		this->unitnumber_digits = dig;
+
+		// from AutoreplaceGUI
+		this->sel_railtype = RAILTYPE_BEGIN;
+		this->details_height   = 10 * FONT_HEIGHT_NORMAL + WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM;
+
+		this->line_height = step_h;
+
+		this->CreateNestedTree(wdesc);
+		this->vscroll[0] = this->GetScrollbar(TRW_WIDGET_TOP_SCROLLBAR);
+		this->vscroll[1] = this->GetScrollbar(TRW_WIDGET_BOTTOM_SCROLLBAR);
+		this->vscroll[0]->SetStepSize(step_h / 2);
+		this->vscroll[1]->SetStepSize(step_h);
+		this->FinishInitNested(wdesc, VEH_TRAIN);
+
+		this->owner = _local_company;
+
+// 		this->groups = new GUIGroupList();
+		this->groups.ForceRebuild();
+		this->groups.NeedResort();
+ 		this->BuildGroupList(_local_company);
+		this->groups.Sort(&GroupNameSorter);
+
+
+		this->matrixContentLeftMargin = 40;
+		this->selected_template_index = -1;
+		this->selected_group_index = -1;
+
+		this->templateNotice = false;
+		this->editInProgress = false;
+
+		this->templates.ForceRebuild();
+
+		BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+
+		//CmdBuildVirtualRailVehicle(20);
+	}
+
+	~TemplateReplaceWindow() {
+		DeleteWindowById(WC_CREATE_TEMPLATE, this->window_number);
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case TRW_WIDGET_TOP_MATRIX:
+				resize->height = GetVehicleListHeight(VEH_TRAIN, FONT_HEIGHT_NORMAL + WD_MATRIX_TOP) / 2;
+				size->height = 8 * resize->height;
+				break;
+			case TRW_WIDGET_BOTTOM_MATRIX:
+				resize->height = GetVehicleListHeight(VEH_TRAIN, FONT_HEIGHT_NORMAL + WD_MATRIX_TOP);
+				size->height = 4 * resize->height;
+				break;
+			case TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN: {
+				Dimension d = {0, 0};
+				for (RailType rt = RAILTYPE_BEGIN; rt != RAILTYPE_END; rt++) {
+					const RailtypeInfo *rti = GetRailTypeInfo(rt);
+					// Skip rail type if it has no label
+					if (rti->label == 0) continue;
+					d = maxdim(d, GetStringBoundingBox(rti->strings.replace_text));
+				}
+				d.width += padding.width;
+				d.height += padding.height;
+				*size = maxdim(*size, d);
+				break;
+			}
+		}
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			// TODO: rm
+			case TRW_CAPTION:
+				SetDParam(0, STR_REPLACE_VEHICLE_TRAIN + this->window_number);
+				break;
+		}
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		// TODO: why -1 ??
+		deleteIllegalTemplateReplacements(-1);
+
+		switch (widget) {
+			case TRW_WIDGET_TOP_MATRIX: {
+				DrawAllGroupsFunction(this->line_height, r);
+				break;
+			}
+			case TRW_WIDGET_BOTTOM_MATRIX: {
+				DrawTemplateList(this->line_height, r);
+				break;
+			}
+			case TRW_WIDGET_TMPL_INFO_PANEL: {
+				DrawTemplateInfo(this->line_height, r);
+				break;
+			}
+		}
+	}
+
+	virtual void OnPaint()
+	{
+		// TODO: only temporary because of allreplacement
+		BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+
+		this->BuildGroupList(_local_company);
+		this->groups.Sort(&GroupNameSorter);
+
+		if ( templateNotice ) {
+			BuildTemplateGuiList(&this->templates, vscroll[1], _local_company, this->sel_railtype);
+			templateNotice = false;
+			this->SetDirty();
+		}
+		// TODO: rm if ?
+		if (this->window_number == VEH_TRAIN) {
+			/* sets the colour of that art thing */
+			// TODO: use stored company for colors
+			this->GetWidget<NWidgetCore>(TRW_WIDGET_TRAIN_FLUFF_LEFT)->colour  = _company_colours[_local_company];
+			this->GetWidget<NWidgetCore>(TRW_WIDGET_TRAIN_FLUFF_RIGHT)->colour = _company_colours[_local_company];
+
+			/* Show the selected railtype in the pulldown menu */
+			this->GetWidget<NWidgetCore>(TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN)->widget_data = GetRailTypeInfo(sel_railtype)->strings.replace_text;
+		}
+		this->DrawWidgets();
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		if ( this->editInProgress ) return;
+
+		switch (widget) {
+			case TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REUSE: {
+				if ( this->selected_template_index >= 0 ) {
+					//TemplateVehicle *sel = (TemplateVehicle*)(this->templates)[selected_template_index];
+					//const TemplateVehicle* ctv = ;
+					TemplateVehicle *sel = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					sel->ToggleReuseDepotVehicles();
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_KEEP: {
+				if ( this->selected_template_index >= 0 ) {
+					//TemplateVehicle *sel = (TemplateVehicle*)(this->templates)[selected_template_index];
+					TemplateVehicle *sel = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					sel->ToggleKeepRemainingVehicles();
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_CONFIGTMPL_REFIT: {
+				if ( this->selected_template_index >= 0 ) {
+					//TemplateVehicle *sel = (TemplateVehicle*)(this->templates)[selected_template_index];
+					TemplateVehicle *sel = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					sel->ToggleRefitAsTemplate();
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_DEFINE:
+				ShowTemplateCreateWindow(0, &templateNotice, &editInProgress, this->line_height);
+				break;
+			case TRW_WIDGET_TMPL_BUTTONS_EDIT: {
+				if ( this->selected_template_index >= 0 ) {
+					editInProgress = true;
+					TemplateVehicle *sel = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					ShowTemplateCreateWindow(sel, &templateNotice, &editInProgress, this->line_height);
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_CLONE: {
+				this->SetWidgetDirty(TRW_WIDGET_TMPL_BUTTONS_CLONE);
+				this->ToggleWidgetLoweredState(TRW_WIDGET_TMPL_BUTTONS_CLONE);
+
+				if (this->IsWidgetLowered(TRW_WIDGET_TMPL_BUTTONS_CLONE)) {
+					static const CursorID clone_icon =	SPR_CURSOR_CLONE_TRAIN;
+					SetObjectToPlaceWnd(clone_icon, PAL_NONE, HT_VEHICLE, this);
+				} else {
+					ResetObjectToPlace();
+				}
+				break;
+			}
+			case TRW_WIDGET_TMPL_BUTTONS_DELETE:
+				if ( selected_template_index >= 0 && !editInProgress ) {
+					// identify template to delete
+					TemplateVehicle *del = TemplateVehicle::Get(((this->templates)[selected_template_index])->index);
+					// remove a corresponding template replacement if existing
+					TemplateReplacement *tr = GetTemplateReplacementByTemplateID(del->index);
+					if ( tr ) {
+						delete tr;
+					}
+					delete del;
+					BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+					selected_template_index = -1;
+				}
+				break;
+			case TRW_WIDGET_TMPL_BUTTONS_RPLALL: {
+				ShowTemplateReplaceAllGui();
+				//testfunc();
+				break;
+			}
+			case TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN: // Railtype selection dropdown menu
+				ShowDropDownList(this, GetRailTypeDropDownList(true), sel_railtype, TRW_WIDGET_TRAIN_RAILTYPE_DROPDOWN);
+				break;
+			case TRW_WIDGET_TOP_MATRIX: {
+ 				uint16 newindex = (uint16)((pt.y - this->nested_array[TRW_WIDGET_TOP_MATRIX]->pos_y) / (this->line_height/2) ) + this->vscroll[0]->GetPosition();
+				if ( newindex == this->selected_group_index || newindex >= this->groups.Length() ) {
+					this->selected_group_index = -1;
+				}
+				else if ( newindex < this->groups.Length() ) {
+					this->selected_group_index = newindex;
+				}
+				break;
+			}
+			case TRW_WIDGET_BOTTOM_MATRIX: {
+ 				uint16 newindex = (uint16)((pt.y - this->nested_array[TRW_WIDGET_BOTTOM_MATRIX]->pos_y) / this->line_height) + this->vscroll[1]->GetPosition();
+				if ( newindex == this->selected_template_index || newindex >= templates.Length() ) {
+					this->selected_template_index = -1;
+				}
+				else if ( newindex < templates.Length() ) {
+					this->selected_template_index = newindex;
+				}
+				break;
+			}
+			// TODO: start button dependent on selected template ?
+			case TRW_WIDGET_START: {
+				if ( this->selected_template_index >= 0 && this->selected_group_index >= 0) {
+					uint32 tv_index = ((this->templates)[selected_template_index])->index;
+					int current_group_index = (this->groups)[this->selected_group_index]->index;
+					IssueTemplateReplacement(current_group_index, tv_index);
+				}
+				break;
+			}
+			case TRW_WIDGET_STOP:
+				if ( this->selected_group_index == -1 )
+					return;
+				int current_group_index = (this->groups)[this->selected_group_index]->index;
+				TemplateReplacement *tr = GetTemplateReplacementByGroupID(current_group_index);
+				if ( tr )
+					delete tr;
+				break;
+		}
+		this->SetDirty();
+	}
+
+	virtual bool OnVehicleSelect(const Vehicle *v)
+	{
+		// create a new template from the clicked vehicle
+		TemplateVehicle *tv = CloneTemplateVehicleFromTrain((const Train*)v);
+		if ( !tv )	return false;
+
+		BuildTemplateGuiList(&this->templates, vscroll[1], _local_company, this->sel_railtype);
+		this->ToggleWidgetLoweredState(TRW_WIDGET_TMPL_BUTTONS_CLONE);
+		ResetObjectToPlace();
+		this->SetDirty();
+
+		return true;
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		RailType temp = (RailType)index;
+		if (temp == this->sel_railtype) return; // we didn't select a new one. No need to change anything
+		this->sel_railtype = temp;
+		/* Reset scrollbar positions */
+		this->vscroll[0]->SetPosition(0);
+		this->vscroll[1]->SetPosition(0);
+		BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+		this->SetDirty();
+	}
+
+	virtual void OnResize()
+	{
+		/* Top Matrix */
+		NWidgetCore *nwi = this->GetWidget<NWidgetCore>(TRW_WIDGET_TOP_MATRIX);
+		this->vscroll[0]->SetCapacityFromWidget(this, TRW_WIDGET_TOP_MATRIX);
+		nwi->widget_data = (this->vscroll[0]->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+		/* Bottom Matrix */
+		NWidgetCore *nwi2 = this->GetWidget<NWidgetCore>(TRW_WIDGET_BOTTOM_MATRIX);
+		this->vscroll[1]->SetCapacityFromWidget(this, TRW_WIDGET_BOTTOM_MATRIX);
+		nwi2->widget_data = (this->vscroll[1]->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+	virtual void OnTick()
+	{
+		if ( templateNotice ) {
+			BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+			this->SetDirty();
+			templateNotice = false;
+		}
+
+	}
+
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		this->groups.ForceRebuild();
+		this->templates.ForceRebuild();
+	}
+	void testfunc() {
+		// replace 764 by 775
+		TemplateVehicle *tmp = (TemplateVehicle*)this->templates[1];
+		Train *t = VirtualTrainFromTemplateVehicle(tmp);
+
+		for ( Train *tt = t; tt; ) {
+			if ( tt->engine_type == 764 ) {
+				Train *n = CmdBuildVirtualRailVehicle(775);
+				// move new after old
+				CommandCost cost = CmdMoveRailVehicle(0, DC_EXEC, n->index | (1<<21), tt->index, 0);
+				// move old away
+				CommandCost cost2 = CmdMoveRailVehicle(0, DC_EXEC, tt->index | (1<<21), INVALID_VEHICLE, 0);
+				tt = n;
+			}
+			else
+				tt = tt->GetNextUnit();
+		}
+
+		delete tmp;
+		TemplateVehicle *ntv = TemplateVehicleFromVirtualTrain(t);
+		BuildTemplateGuiList(&this->templates, this->vscroll[1], this->owner, this->sel_railtype);
+		this->SetDirty();
+
+		printf("finished\n");
+
+	}
+	/** For a given group (id) find the template that is issued for template replacement for this group and return this template's index
+	 *  from the gui list */
+	short FindTemplateIndexForGroup(short gid) const
+	{
+		TemplateReplacement *tr = GetTemplateReplacementByGroupID(gid);
+		if ( !tr )
+			return -1;
+
+		for ( uint32 i=0; i<this->templates.Length(); i++ )
+			if ( templates[i]->index == tr->sel_template )
+				return i;
+		return -1;
+	}
+
+		/** Sort the groups by their name */
+	static int CDECL GroupNameSorter(const Group * const *a, const Group * const *b)
+	{
+		static const Group *last_group[2] = { NULL, NULL };
+		static char         last_name[2][64] = { "", "" };
+
+		if (*a != last_group[0]) {
+			last_group[0] = *a;
+			SetDParam(0, (*a)->index);
+			GetString(last_name[0], STR_GROUP_NAME, lastof(last_name[0]));
+		}
+
+		if (*b != last_group[1]) {
+			last_group[1] = *b;
+			SetDParam(0, (*b)->index);
+			GetString(last_name[1], STR_GROUP_NAME, lastof(last_name[1]));
+		}
+
+		int r = strnatcmp(last_name[0], last_name[1]); // Sort by name (natural sorting).
+		if (r == 0) return (*a)->index - (*b)->index;
+		return r;
+	}
+
+	void BuildGroupList(Owner owner)
+	{
+		if (!this->groups.NeedRebuild()) {
+			return;
+		}
+		this->groups.Clear();
+
+		const Group *g;
+		FOR_ALL_GROUPS(g) {
+			if (g->owner == owner ) {
+				*this->groups.Append() = g;
+			}
+		}
+
+		this->groups.Compact();
+		this->groups.RebuildDone();
+		this->vscroll[0]->SetCount(groups.Length());
+	}
+
+	void DrawAllGroupsFunction(int line_height, const Rect &r) const
+	{
+		int left = r.left + WD_MATRIX_LEFT;
+		int right = r.right - WD_MATRIX_RIGHT;
+		int y = r.top;
+		int max = min(this->vscroll[0]->GetPosition() + this->vscroll[0]->GetCapacity(), this->groups.Length());
+
+		/* Then treat all groups defined by/for the current company */
+		for ( int i=this->vscroll[0]->GetPosition(); i<max; i++ ) {
+			const Group *g = (this->groups)[i];
+			short g_id = g->index;
+
+			/* Fill the background of the current cell in a darker tone for the currently selected template */
+			if ( this->selected_group_index == i ) {
+				GfxFillRect(left, y, right, y+(this->line_height)/2, _colour_gradient[COLOUR_GREY][3]);
+			}
+
+			SetDParam(0, g_id);
+			StringID str = STR_GROUP_NAME;
+			DrawString(left+30, right, y+2, str, TC_BLACK);
+
+			/* Draw the template in use for this group, if there is one */
+			short template_in_use = FindTemplateIndexForGroup(g_id);
+			if ( template_in_use >= 0 ) {
+				SetDParam(0, template_in_use);
+				DrawString ( left, right, y+2, STR_TMPL_GROUP_USES_TEMPLATE, TC_BLACK, SA_HOR_CENTER);
+			}
+			/* If there isn't a template applied from the current group, check if there is one for another rail type */
+			else if ( GetTemplateReplacementByGroupID(g_id) ) {
+				DrawString ( left, right, y+2, STR_TMPL_TMPLRPL_EX_DIFF_RAILTYPE, TC_SILVER, SA_HOR_CENTER);
+			}
+
+			/* Draw the number of trains that still need to be treated by the currently selected template replacement */
+			TemplateReplacement *tr = GetTemplateReplacementByGroupID(g_id);
+			if ( tr ) {
+				TemplateVehicle *tv = TemplateVehicle::Get(tr->sel_template);
+				int num_trains = NumTrainsNeedTemplateReplacement(g_id, tv);
+				// Draw text
+				TextColour color = TC_GREY;
+				if ( num_trains ) color = TC_BLACK;
+				DrawString(left, right-16, y+2, STR_TMPL_NUM_TRAINS_NEED_RPL, color, SA_RIGHT);
+				// Draw number
+				if ( num_trains ) color = TC_ORANGE;
+				else color = TC_GREY;
+				SetDParam(0, num_trains);
+				DrawString(left, right-4, y+2, STR_JUST_INT, color, SA_RIGHT);
+			}
+
+			y+=line_height / 2;
+		}
+	}
+
+	void DrawTemplateList(int line_height, const Rect &r) const
+	{
+		int left = r.left;
+		int right = r.right;
+		int y = r.top;
+
+		Scrollbar *draw_vscroll = vscroll[1];
+		uint max = min(draw_vscroll->GetPosition() + draw_vscroll->GetCapacity(), this->templates.Length());
+
+		const TemplateVehicle *v;
+		for ( uint i = draw_vscroll->GetPosition(); i < max; ++i) {
+
+			v = (this->templates)[i];
+
+			/* Fill the background of the current cell in a darker tone for the currently selected template */
+			if ( this->selected_template_index == i ) {
+				GfxFillRect(left, y, right, y+this->line_height, _colour_gradient[COLOUR_GREY][3]);
+			}
+
+			/* Draw a notification string for chains that are not runnable */
+			if ( v->IsFreeWagonChain() ) {
+				DrawString(left, right-2, y+line_height-FONT_HEIGHT_SMALL-WD_FRAMERECT_BOTTOM - 2, STR_TMPL_WARNING_FREE_WAGON, TC_RED, SA_RIGHT);
+			}
+
+			/* Draw the template's length in tile-units */
+			SetDParam(0, v->GetRealLength());
+			SetDParam(1, 1);
+			DrawString(left, right-4, y+2, STR_TINY_BLACK_DECIMAL, TC_BLACK, SA_RIGHT);
+
+			/* Draw the template */
+			DrawTemplate(v, left+50, right, y);
+
+			/* Buying cost */
+			SetDParam(0, CalculateOverallTemplateCost(v));
+			DrawString(left+35, right, y + line_height - FONT_HEIGHT_SMALL - WD_FRAMERECT_BOTTOM - 2, STR_TMPL_TEMPLATE_OVR_VALUE_notinyfont, TC_BLUE, SA_LEFT);
+
+			/* Index of current template vehicle in the list of all templates for its company */
+			SetDParam(0, i);
+			DrawString(left+5, left+25, y + line_height/2, STR_BLACK_INT, TC_BLACK, SA_RIGHT);
+
+			/* Draw whether the current template is in use by any group */
+			if ( v->NumGroupsUsingTemplate() > 0 ) {
+				DrawString(left+200, right, y + line_height - FONT_HEIGHT_SMALL - WD_FRAMERECT_BOTTOM - 2, STR_TMP_TEMPLATE_IN_USE, TC_GREEN, SA_LEFT);
+			}
+
+			/* Draw information about template configuration settings */
+			TextColour color;
+			if ( v->IsSetReuseDepotVehicles() ) color = TC_LIGHT_BLUE;
+			else color = TC_GREY;
+			DrawString(left+200, right, y+2, STR_TMPL_CONFIG_USEDEPOT, color, SA_LEFT);
+			if ( v->IsSetKeepRemainingVehicles() ) color = TC_LIGHT_BLUE;
+			else color = TC_GREY;
+			DrawString(left+275, right, y+2, STR_TMPL_CONFIG_KEEPREMAINDERS, color, SA_LEFT);
+			if ( v->IsSetRefitAsTemplate() ) color = TC_LIGHT_BLUE;
+			else color = TC_GREY;
+			DrawString(left+350, right, y+2, STR_TMPL_CONFIG_REFIT, color, SA_LEFT);
+
+			y += line_height;
+		}
+	}
+
+	void DrawTemplateInfo(int line_height, const Rect &r) const
+	{
+		if ( this->selected_template_index == -1 || (short)this->templates.Length() <= this->selected_template_index )
+			return;
+
+		const TemplateVehicle *tmp = this->templates[this->selected_template_index];
+
+		/* Draw vehicle performance info */
+		SetDParam(2, tmp->max_speed);
+		SetDParam(1, tmp->power);
+		SetDParam(0, tmp->weight);
+		SetDParam(3, tmp->max_te);
+		DrawString(r.left+8, r.right, r.top+4, STR_VEHICLE_INFO_WEIGHT_POWER_MAX_SPEED_MAX_TE);
+
+		/* Draw cargo summary */
+		short top = r.top + 24;
+		short left = r.left + 8;
+		short count_rows = 0;
+		short max_rows = 2;
+
+		CargoArray cargo_caps;
+		for ( ; tmp; tmp=tmp->Next() )
+			cargo_caps[tmp->cargo_type] += tmp->cargo_cap;
+		int y = top;
+		for (CargoID i = 0; i < NUM_CARGO; i++) {
+			if ( cargo_caps[i] > 0 ) {
+				count_rows++;
+				SetDParam(0, i);
+				SetDParam(1, cargo_caps[i]);
+				SetDParam(2, _settings_game.vehicle.freight_trains);
+				DrawString(left, r.right, y, FreightWagonMult(i) > 1 ? STR_TMPL_CARGO_SUMMARY_MULTI : STR_TMPL_CARGO_SUMMARY, TC_WHITE, SA_LEFT);
+				y += this->line_height/2;
+				if ( count_rows % max_rows == 0 ) {
+					y = top;
+					left += 150;
+				}
+			}
+		}
+	}
+};
+
+void ShowTemplateReplaceWindow(byte dig, int step_h)
+{
+
+	new TemplateReplaceWindow(&_replace_rail_vehicle_desc, dig, step_h);
+}
+
diff --git a/src/aaa_template_gui_main.h b/src/aaa_template_gui_main.h
new file mode 100644
index 0000000..f8022a9
--- /dev/null
+++ b/src/aaa_template_gui_main.h
@@ -0,0 +1,20 @@
+// _template_gui_main.h
+
+#ifndef TEMPLATE_GUI_H
+#define TEMPLATE_GUI_H
+
+#include "engine_type.h"
+#include "group_type.h"
+#include "vehicle_type.h"
+#include "string_func.h"
+#include "strings_func.h"
+
+#include "aaa_template_vehicle.h"
+#include "aaa_template_vehicle_func.h"
+#include "aaa_template_gui_replaceall.h"
+
+typedef GUIList<const Group*> GUIGroupList;
+
+void ShowTemplateReplaceWindow(byte, int);
+
+#endif
diff --git a/src/aaa_template_gui_replaceall.cpp b/src/aaa_template_gui_replaceall.cpp
new file mode 100644
index 0000000..0561ab9
--- /dev/null
+++ b/src/aaa_template_gui_replaceall.cpp
@@ -0,0 +1,519 @@
+// replace all gui impl
+
+#include "aaa_template_gui_replaceall.h"
+
+#include <stdio.h>
+
+/*
+ * A wrapper which contains a virtual train and additional info of the template vehicle it is replacing
+ * We will restore this additional info when creating a new template from the changed virtual train
+ */
+struct VirtTrainInfo {
+	// the virtual train
+	Train *vt;
+
+	// additional info from the template
+	VehicleID original_index;
+
+	bool	reuse_depot_vehicles,
+			keep_remaining_vehicles,
+			refit_as_template;
+
+	CargoID cargo_type;
+	byte cargo_subtype;
+
+	// a fancy constructor
+	VirtTrainInfo(Train *t) { this->vt = t; }
+};
+
+typedef AutoFreeSmallVector<VirtTrainInfo*, 64> VirtTrainList;
+enum Widgets {
+	RPLALL_GUI_CAPTION,
+
+	RPLALL_GUI_INSET_1,
+	RPLALL_GUI_INSET_1_1,
+	RPLALL_GUI_INSET_1_2,
+	RPLALL_GUI_MATRIX_TOPLEFT,
+	RPLALL_GUI_MATRIX_TOPRIGHT,
+	RPLALL_GUI_SCROLL_TL,
+	RPLALL_GUI_SCROLL_TR,
+
+	RPLALL_GUI_INSET_2,
+	RPLALL_GUI_MATRIX_BOTTOM,
+	RPLALL_GUI_SCROLL_BO,
+
+	RPLALL_GUI_INSET_3,
+	RPLALL_GUI_BUTTON_RPLALL,
+	RPLALL_GUI_PANEL_BUTTONFLUFF_1,
+	RPLALL_GUI_PANEL_BUTTONFLUFF_2,
+	RPLALL_GUI_BUTTON_APPLY,
+	RPLALL_GUI_PANEL_BUTTONFLUFF_3,
+	RPLALL_GUI_BUTTON_CANCEL,
+
+	RPLALL_GUI_PANEL_RESIZEFLUFF
+};
+
+static const NWidgetPart widgets[] = {
+	// title bar
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, RPLALL_GUI_CAPTION), SetDataTip(STR_TMPL_RPLALLGUI_TITLE, STR_TMPL_RPLALLGUI_TITLE),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	// top matrices
+		NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_1), SetMinimalSize(100,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_INSET_TOP, STR_TMPL_RPLALLGUI_INSET_TOP), EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_1_1), SetMinimalSize(100,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_INSET_TOP_1, STR_TMPL_RPLALLGUI_INSET_TOP_1), EndContainer(),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_MATRIX, COLOUR_GREY, RPLALL_GUI_MATRIX_TOPLEFT), SetMinimalSize(100, 16), SetFill(1, 1), SetResize(1, 1), SetScrollbar(RPLALL_GUI_SCROLL_TL),// SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY),
+				NWidget(NWID_VSCROLLBAR, COLOUR_GREY, RPLALL_GUI_SCROLL_TL),
+			EndContainer(),
+		EndContainer(),
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_1_2), SetMinimalSize(100,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_INSET_TOP_2, STR_TMPL_RPLALLGUI_INSET_TOP_2), EndContainer(),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_MATRIX, COLOUR_GREY, RPLALL_GUI_MATRIX_TOPRIGHT), SetMinimalSize(100, 16), SetFill(1, 1), SetResize(1, 1), SetScrollbar(RPLALL_GUI_SCROLL_TR),// SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY),
+				NWidget(NWID_VSCROLLBAR, COLOUR_GREY, RPLALL_GUI_SCROLL_TR),
+			EndContainer(),
+		EndContainer(),
+	EndContainer(),
+	// bottom matrix
+	NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_2), SetMinimalSize(200,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_INSET_BOTTOM, STR_TMPL_RPLALLGUI_INSET_BOTTOM), EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, RPLALL_GUI_MATRIX_BOTTOM), SetMinimalSize(200, 16), SetFill(1, 1), SetResize(1, 1), SetScrollbar(RPLALL_GUI_SCROLL_BO),// SetDataTip(0x1, STR_REPLACE_HELP_LEFT_ARRAY),
+		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, RPLALL_GUI_SCROLL_BO),
+	EndContainer(),
+	// control area
+	NWidget(WWT_INSET, COLOUR_GREY, RPLALL_GUI_INSET_3), SetMinimalSize(200,12), SetResize(1,0), EndContainer(),// SetDataTip(STR_TMPL_MAINGUI_DEFINEDGROUPS, STR_TMPL_MAINGUI_DEFINEDGROUPS),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY, RPLALL_GUI_PANEL_BUTTONFLUFF_1), SetMinimalSize(75,12), SetResize(1,0), EndContainer(),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, RPLALL_GUI_BUTTON_RPLALL), SetMinimalSize(150,12), SetResize(0,0), SetDataTip(STR_TMPL_RPLALLGUI_BUTTON_RPLALL, STR_TMPL_RPLALLGUI_BUTTON_RPLALL),
+		NWidget(WWT_PANEL, COLOUR_GREY, RPLALL_GUI_PANEL_BUTTONFLUFF_2), SetMinimalSize(75,12), SetResize(1,0), EndContainer(),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, RPLALL_GUI_BUTTON_APPLY), SetMinimalSize(75,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_BUTTON_APPLY, STR_TMPL_RPLALLGUI_BUTTON_APPLY),
+		NWidget(WWT_PANEL, COLOUR_GREY, RPLALL_GUI_PANEL_BUTTONFLUFF_3), SetMinimalSize(150,12), SetResize(0,0), EndContainer(),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, RPLALL_GUI_BUTTON_CANCEL), SetMinimalSize(75,12), SetResize(1,0), SetDataTip(STR_TMPL_RPLALLGUI_BUTTON_CANCEL, STR_TMPL_RPLALLGUI_BUTTON_CANCEL),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY, RPLALL_GUI_PANEL_RESIZEFLUFF), SetMinimalSize(100,12), SetResize(1,0), EndContainer(),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static const WindowDesc _template_replace_replaceall_desc(
+	WDP_AUTO, 400, 200,
+	WC_TEMPLATEGUI_RPLALL, WC_NONE,
+	WDF_UNCLICK_BUTTONS | WDF_CONSTRUCTION,
+	widgets, lengthof(widgets)
+);
+
+static int CDECL EngineNumberSorter(const EngineID *a, const EngineID *b)
+{
+	int r = ListPositionOfEngine(*a) - ListPositionOfEngine(*b);
+	return r;
+}
+static int CDECL TrainEnginesThenWagonsSorter(const EngineID *a, const EngineID *b)
+{
+	int val_a = (RailVehInfo(*a)->railveh_type == RAILVEH_WAGON ? 1 : 0);
+	int val_b = (RailVehInfo(*b)->railveh_type == RAILVEH_WAGON ? 1 : 0);
+	int r = val_a - val_b;
+
+	/* Use EngineID to sort instead since we want consistent sorting */
+	if (r == 0) return EngineNumberSorter(a, b);
+	return r;
+}
+
+
+class TemplateReplacementReplaceAllWindow : public Window {
+private:
+	uint16 line_height;
+	Scrollbar	*vscroll_tl,
+				*vscroll_tr,
+				*vscroll_bo;
+	GUIEngineList *engines_left,
+				  *engines_right;
+	short	selected_left,
+			selected_right;
+	VirtTrainList *virtualTrains;
+
+public:
+	TemplateReplacementReplaceAllWindow(const WindowDesc *wdesc) : Window()
+	{
+
+		this->CreateNestedTree(wdesc);
+
+		this->vscroll_tl = this->GetScrollbar(RPLALL_GUI_SCROLL_TL);
+		this->vscroll_tr = this->GetScrollbar(RPLALL_GUI_SCROLL_TR);
+		this->vscroll_bo = this->GetScrollbar(RPLALL_GUI_SCROLL_BO);
+		this->vscroll_tl->SetStepSize(16);
+		this->vscroll_tr->SetStepSize(16);
+		this->vscroll_bo->SetStepSize(16);
+
+		this->FinishInitNested(wdesc, VEH_TRAIN);
+
+		this->owner = _local_company;
+
+		engines_left = new GUIEngineList();
+		engines_right = new GUIEngineList();
+		virtualTrains = new VirtTrainList();
+
+		this->GenerateBuyableEnginesList();
+		this->GenerateIncludedTemplateList();
+
+		this->line_height = 16;
+		this->selected_left = -1;
+		this->selected_right = -1;
+	}
+
+	~TemplateReplacementReplaceAllWindow()
+	{
+		for ( int i=0; i<this->virtualTrains->Length(); i++ )
+			delete (*this->virtualTrains)[i]->vt;
+		SetWindowClassesDirty(WC_TEMPLATEGUI_MAIN);
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch ( widget ) {
+			case RPLALL_GUI_MATRIX_TOPLEFT:
+			case RPLALL_GUI_MATRIX_TOPRIGHT:
+			case RPLALL_GUI_MATRIX_BOTTOM: {
+				resize->height = 16;
+				size->height = 16;
+				break;
+			}
+		}
+	}
+
+	virtual void OnPaint()
+	{
+ 		this->GetWidget<NWidgetCore>(RPLALL_GUI_PANEL_BUTTONFLUFF_3)->colour  = _company_colours[_local_company];
+
+		this->DrawWidgets();
+	}
+
+	virtual void OnResize()
+	{
+		NWidgetCore *nwi_tl = this->GetWidget<NWidgetCore>(RPLALL_GUI_MATRIX_TOPLEFT);
+		this->vscroll_tl->SetCapacityFromWidget(this, RPLALL_GUI_MATRIX_TOPLEFT);
+		nwi_tl->widget_data = (this->vscroll_tl->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+
+		NWidgetCore *nwi_tr = this->GetWidget<NWidgetCore>(RPLALL_GUI_MATRIX_TOPRIGHT);
+		this->vscroll_tr->SetCapacityFromWidget(this, RPLALL_GUI_MATRIX_TOPRIGHT);
+		nwi_tr->widget_data = (this->vscroll_tr->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+
+		NWidgetCore *nwi_bo = this->GetWidget<NWidgetCore>(RPLALL_GUI_MATRIX_BOTTOM);
+		this->vscroll_bo->SetCapacityFromWidget(this, RPLALL_GUI_MATRIX_BOTTOM);
+		nwi_bo->widget_data = (this->vscroll_bo->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch (widget) {
+			case RPLALL_GUI_MATRIX_TOPLEFT: {
+				this->DrawEngineList(r, true);
+				break;
+			}
+			case RPLALL_GUI_MATRIX_TOPRIGHT: {
+				this->DrawEngineList(r, false);
+				break;
+			}
+			case RPLALL_GUI_MATRIX_BOTTOM: {
+				this->DrawVirtualTrains(r);
+				break;
+			}
+		}
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch(widget) {
+			case RPLALL_GUI_MATRIX_TOPLEFT: {
+				uint16 newindex = (uint16)((pt.y - this->nested_array[RPLALL_GUI_MATRIX_TOPLEFT]->pos_y) / this->line_height) + this->vscroll_tl->GetPosition();
+				if ( newindex >= this->engines_left->Length() || newindex==this->selected_left )
+					this->selected_left = -1;
+				else
+					this->selected_left = newindex;
+				this->SetDirty();
+				break;
+			}
+			case RPLALL_GUI_MATRIX_TOPRIGHT: {
+				uint16 newindex = (uint16)((pt.y - this->nested_array[RPLALL_GUI_MATRIX_TOPRIGHT]->pos_y) / this->line_height) + this->vscroll_tr->GetPosition();
+				if ( newindex > this->engines_right->Length() || newindex==this->selected_right )
+					this->selected_right = -1;
+				else
+					this->selected_right = newindex;
+				this->SetDirty();
+				break;
+			}
+			case RPLALL_GUI_BUTTON_RPLALL: {
+				this->ReplaceAll();
+				break;
+			}
+			case RPLALL_GUI_BUTTON_APPLY: {
+				// check if we actually did anything so far, if not, applying is forbidden
+				if ( this->virtualTrains->Length() == 0 )
+					return;
+				// first delete all current templates
+				this->DeleteAllTemplateTrains();
+				// then build a new list from the current virtual trains
+				for ( int i=0; i<this->virtualTrains->Length(); i++ ) {
+					// the relevant info struct
+					VirtTrainInfo *vti = (*this->virtualTrains)[i];
+					// setup template from contained train
+					Train *t = vti->vt;
+					TemplateVehicle *tv = TemplateVehicleFromVirtualTrain(t);
+					// restore template specific stuff
+					tv->reuse_depot_vehicles		= vti->reuse_depot_vehicles;
+					tv->keep_remaining_vehicles		= vti->keep_remaining_vehicles;
+					tv->refit_as_template			= vti->refit_as_template;
+					tv->cargo_type					= vti->cargo_type;
+					tv->cargo_subtype				= vti->cargo_subtype;
+					// use the original_index information to repoint the relevant TemplateReplacement if existing
+					TemplateReplacement *tr = GetTemplateReplacementByTemplateID(vti->original_index);
+					if ( tr )
+						tr->sel_template = tv->index;
+				}
+				// then close this window and return to parent
+				delete this;
+				break;
+			}
+			case RPLALL_GUI_BUTTON_CANCEL: {
+				delete this;
+				break;
+			}
+		}
+	}
+
+	bool HasTemplateWithEngine(EngineID eid) const
+	{
+		const TemplateVehicle *tv;
+		FOR_ALL_TEMPLATES(tv) {
+			if ( tv->Prev() || tv->owner != _local_company ) continue;
+			for ( const TemplateVehicle *tmp=tv; tmp; tmp=tmp->GetNextUnit() ) {
+				if ( tmp->engine_type == eid )
+					return true;
+			}
+		}
+		return false;
+	}
+
+	void GenerateVirtualTrains()
+	{
+		this->virtualTrains->Clear();
+
+		TemplateVehicle *tv;
+		FOR_ALL_TEMPLATES(tv) {
+			if ( !tv->Prev() && tv->owner==this->owner ) {
+				// setup template train
+				Train *newtrain = VirtualTrainFromTemplateVehicle(tv);
+				VirtTrainInfo *vti = new VirtTrainInfo(newtrain);
+				// store template specific stuff
+				vti->original_index				= tv->index;
+				vti->reuse_depot_vehicles		= tv->reuse_depot_vehicles;
+				vti->keep_remaining_vehicles	= tv->keep_remaining_vehicles;
+				vti->refit_as_template			= tv->refit_as_template;
+				vti->cargo_type					= tv->cargo_type;
+				vti->cargo_subtype				= tv->cargo_subtype;
+				// add new info struct
+				*this->virtualTrains->Append() = vti;
+			}
+		}
+
+		this->vscroll_bo->SetCount(this->virtualTrains->Length());
+	}
+
+	// move to func ?
+	void DeleteAllTemplateTrains()
+	{
+		TemplateVehicle *tv, *tmp;
+		FOR_ALL_TEMPLATES(tv) {
+			tmp = tv;
+			if ( tmp->Prev()==0 && tmp->owner==this->owner )
+				delete tmp;
+		}
+	}
+
+	void GenerateIncludedTemplateList()
+	{
+		int num_engines = 0;
+		int num_wagons  = 0;
+
+		this->engines_left->Clear();
+
+		const Engine *e;
+		FOR_ALL_ENGINES_OF_TYPE(e, VEH_TRAIN) {
+			EngineID eid = e->index;
+			const RailVehicleInfo*rvi = &e->u.rail;
+
+			if ( !HasTemplateWithEngine(eid) ) continue;
+
+			*this->engines_left->Append() = eid;
+
+			if (rvi->railveh_type != RAILVEH_WAGON) {
+				num_engines++;
+			} else {
+				num_wagons++;
+			}
+		}
+		this->vscroll_tl->SetCount(this->engines_left->Length());
+	}
+
+	bool VirtualTrainHasEngineID(EngineID eid)
+	{
+// 		printf("called for eid: %d\n", eid);
+
+		for ( int i=0; i<this->virtualTrains->Length(); i++ ) {
+			const Train *tmp = (*this->virtualTrains)[i]->vt;
+// 			printf("checking train:\n"); pvt(tmp);
+			for ( ; tmp; tmp=tmp->Next() )
+				if ( tmp->engine_type == eid )
+					return true;
+// 			printf("_________\n");
+		}
+// 		printf("return false\n______\n");
+		return false;
+	}
+
+	// after 'replace all' we need to replace the currently used templates as well
+	void RebuildIncludedTemplateList() {
+		// first remove all engine ids
+		for ( int i=0; i<this->engines_left->Length(); i++ ) {
+			EngineID entry = (*this->engines_left)[i];
+			if ( !VirtualTrainHasEngineID(entry) )
+				this->engines_left->Erase(&((*this->engines_left)[i]));
+		}
+	}
+
+	void ReplaceAll()
+	{
+
+		if ( this->selected_left==-1 || this->selected_right==-1 )
+			return;
+
+		EngineID eid_orig = (*this->engines_left)[this->selected_left];
+		EngineID eid_repl = (*this->engines_right)[this->selected_right];
+
+		if ( eid_orig == eid_repl )
+			return;
+
+		if ( this->virtualTrains->Length() == 0 )
+			this->GenerateVirtualTrains();
+
+		for ( int i=0; i<this->virtualTrains->Length(); i++ ) {
+			Train *tmp = (*this->virtualTrains)[i]->vt;
+			while ( tmp ) {
+				if ( tmp->engine_type == eid_orig ) {
+					// build a new virtual rail vehicle and test for success
+					Train *nt = CmdBuildVirtualRailVehicle(eid_repl);
+					if ( !nt ) continue;
+					// include the (probably) new engine into the 'included'-list
+					this->engines_left->Include( nt->engine_type );
+					// advance the tmp pointer in the chain, otherwise it would get deleted later on
+					Train *to_del = tmp;
+					tmp = tmp->GetNextUnit();
+					// first move the new virtual rail vehicle behind to_del
+					CommandCost move = CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, nt->index|(1<<21), to_del->index, 0);
+					// then move to_del away from the chain and delete it
+					move = CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, to_del->index|(1<<21), INVALID_VEHICLE, 0);
+					(*this->virtualTrains)[i]->vt = nt->First();
+					delete to_del;
+				} else {
+					tmp = tmp->GetNextUnit();
+				}
+			}
+		}
+		this->selected_left = -1;
+		// rebuild the left engines list as some engines might not be there anymore
+		this->RebuildIncludedTemplateList();
+		this->SetDirty();
+	}
+
+	void GenerateBuyableEnginesList()
+	{
+		int num_engines = 0;
+		int num_wagons  = 0;
+
+		this->engines_right->Clear();
+
+		const Engine *e;
+		FOR_ALL_ENGINES_OF_TYPE(e, VEH_TRAIN) {
+			EngineID eid = e->index;
+			const RailVehicleInfo *rvi = &e->u.rail;
+
+			if (!IsEngineBuildable(eid, VEH_TRAIN, _local_company)) continue;
+
+			*this->engines_right->Append() = eid;
+
+			if (rvi->railveh_type != RAILVEH_WAGON) {
+				num_engines++;
+			} else {
+				num_wagons++;
+			}
+		}
+
+		/* make engines first, and then wagons, sorted by ListPositionOfEngine() */
+		EngList_Sort(this->engines_right, TrainEnginesThenWagonsSorter);
+
+		this->vscroll_tr->SetCount(this->engines_right->Length());
+	}
+
+	void DrawEngineList(const Rect &r, bool left) const//, GUIEngineList el, Scrollbar* sb) const
+	{
+		uint16 y = r.top;
+		uint32 eid;
+
+		Scrollbar *sb;
+		const GUIEngineList *el;
+
+		if ( left ) {
+			sb = this->vscroll_tl;
+			el = this->engines_left;
+		} else {
+			sb = this->vscroll_tr;
+			el = this->engines_right;
+		}
+
+		int maximum = min((int)sb->GetCapacity(), (int)el->Length()) + sb->GetPosition();
+
+		for ( int i=sb->GetPosition(); i<maximum; i++ ) {
+
+			eid = (*el)[i];
+
+			/* Draw a grey background rectangle if the current line is the selected one */
+			if ( (left && this->selected_left == i) || (!left && this->selected_right == i) )
+				GfxFillRect(r.left, y, r.right, y+this->line_height, _colour_gradient[COLOUR_GREY][3]);
+
+			/* Draw a description string of the current engine */
+			SetDParam(0, eid);
+			DrawString(r.left+100, r.right, y+4, STR_ENGINE_NAME, TC_BLACK);
+
+			/* Draw the engine */
+			DrawVehicleEngine( r.left, r.right, r.left+29, y+8, eid, GetEnginePalette(eid, _local_company), EIT_PURCHASE );
+
+			y += this->line_height;
+		}
+	}
+
+	void DrawVirtualTrains(const Rect &r) const
+	{
+		uint16 y = r.top;
+
+		uint16 max = min(virtualTrains->Length(), this->vscroll_bo->GetCapacity());
+
+		for ( uint16 i=vscroll_bo->GetPosition(); i<max+vscroll_bo->GetPosition(); i++ ) {
+			/* Draw a virtual train*/
+			DrawTrainImage( (*this->virtualTrains)[i]->vt, r.left+32, r.right, y, INVALID_VEHICLE, EIT_PURCHASE, 0, -1 );
+
+			y+= this->line_height;
+		}
+	}
+};
+
+void ShowTemplateReplaceAllGui()
+{
+	new TemplateReplacementReplaceAllWindow(&_template_replace_replaceall_desc);
+}
\ No newline at end of file
diff --git a/src/aaa_template_gui_replaceall.h b/src/aaa_template_gui_replaceall.h
new file mode 100644
index 0000000..4d8f805
--- /dev/null
+++ b/src/aaa_template_gui_replaceall.h
@@ -0,0 +1,27 @@
+#ifndef TMPL_RPLALL_GUI
+#define TMPL_RPLALL_GUI
+
+
+
+#include "stdafx.h"
+#include "window_gui.h"
+#include "window_func.h"
+
+#include "company_func.h"
+#include "engine_base.h"
+#include "engine_func.h"
+#include "engine_gui.h"
+#include "train.h"
+#include "strings_func.h"
+#include "vehicle_base.h"
+#include "vehicle_func.h"
+
+#include "aaa_template_vehicle.h"
+#include "aaa_template_vehicle_func.h"
+
+#include "core/math_func.hpp"
+#include "table/strings.h"
+
+void ShowTemplateReplaceAllGui();
+
+#endif
\ No newline at end of file
diff --git a/src/aaa_template_vehicle.cpp b/src/aaa_template_vehicle.cpp
new file mode 100644
index 0000000..b8d5763
--- /dev/null
+++ b/src/aaa_template_vehicle.cpp
@@ -0,0 +1,233 @@
+#include "stdafx.h"
+#include "company_func.h"
+#include "train.h"
+#include "command_func.h"
+#include "engine_func.h"
+#include "vehicle_func.h"
+#include "autoreplace_func.h"
+#include "autoreplace_gui.h"
+#include "group.h"
+#include "articulated_vehicles.h"
+#include "core/random_func.hpp"
+#include "core/pool_type.hpp"
+#include "engine_type.h"
+#include "group_type.h"
+#include "core/pool_func.hpp"
+
+#include "table/strings.h"
+
+#include "newgrf.h"
+
+#include "vehicle_type.h"
+#include "vehicle_base.h"
+#include "vehicle_func.h"
+
+#include "table/train_cmd.h"
+
+
+#include "aaa_template_vehicle.h"
+
+// since doing stuff with sprites
+#include "newgrf_spritegroup.h"
+#include "newgrf_engine.h"
+#include "newgrf_cargo.h"
+
+TemplatePool _template_pool("TemplatePool");
+INSTANTIATE_POOL_METHODS(Template)
+
+TemplateReplacementPool _template_replacement_pool("TemplateReplacementPool");
+INSTANTIATE_POOL_METHODS(TemplateReplacement)
+
+
+TemplateVehicle::TemplateVehicle(VehicleType ty, EngineID eid, byte subtypeflag, Owner current_owner)
+{
+	this->type = ty;
+	this->engine_type = eid;
+
+	this->reuse_depot_vehicles = true;
+	this->keep_remaining_vehicles = true;
+
+	this->first = this;
+	this->next = 0x0;
+	this->previous = 0x0;
+	this->owner_b = _current_company;
+
+	this->cur_image = SPR_IMG_QUERY;
+
+	this->owner = current_owner;
+
+	this->real_consist_length = 0;
+}
+
+TemplateVehicle::~TemplateVehicle() {
+	//free(this->name);
+
+	TemplateVehicle *v = this->Next();
+	this->SetNext(NULL);
+
+	delete v;
+}
+
+/** getting */
+void TemplateVehicle::SetNext(TemplateVehicle *v) { this->next = v; }
+void TemplateVehicle::SetPrev(TemplateVehicle *v) { this->previous = v; }
+void TemplateVehicle::SetFirst(TemplateVehicle *v) { this->first = v; }
+
+TemplateVehicle* TemplateVehicle::GetNextUnit() const
+{
+		TemplateVehicle *tv = this->Next();
+		//if ( tv != NULL ) {
+			while ( tv && HasBit(tv->subtype, GVSF_ARTICULATED_PART) ) tv = tv->Next();
+			if ( tv && HasBit(tv->subtype, GVSF_MULTIHEADED) && !HasBit(tv->subtype, GVSF_ENGINE) ) tv = tv->Next();
+		//}
+		return tv;
+}
+
+TemplateVehicle* TemplateVehicle::GetPrevUnit()
+{
+	TemplateVehicle *tv = this->Prev();
+	//if ( tv != NULL ) {
+		while ( tv && HasBit(tv->subtype, GVSF_ARTICULATED_PART|GVSF_ENGINE) ) tv = tv->Prev();
+		if ( tv && HasBit(tv->subtype, GVSF_MULTIHEADED|GVSF_ENGINE) ) tv = tv->Prev();
+	//}
+	return tv;
+}
+
+/** setting */
+void appendTemplateVehicle(TemplateVehicle *orig, TemplateVehicle *newv)
+{
+	if ( !orig ) return;
+	while ( orig->Next() ) orig=orig->Next();
+	orig->SetNext(newv);
+	newv->SetPrev(orig);
+	newv->SetFirst(orig->First());
+}
+
+void insertTemplateVehicle(TemplateVehicle *orig, TemplateVehicle *newv, TemplateVehicle *insert_after)
+{
+	if ( !orig || !insert_after ) return;
+	TemplateVehicle *insert_before = insert_after->Next();
+	insert_after->SetNext(newv);
+	insert_before->SetPrev(newv);
+	newv->SetPrev(insert_after);
+	newv->SetNext(insert_before);
+	newv->SetFirst(insert_after);
+}
+
+/** Length()
+ * @return: length of vehicle, including current part
+ */
+int TemplateVehicle::Length() const
+{
+	int l=1;
+	const TemplateVehicle *tmp=this;
+	while ( tmp->Next() ) { tmp=tmp->Next(); l++; }
+	return l;
+}
+
+TemplateReplacement* GetTemplateReplacementByGroupID(GroupID gid)
+{
+	TemplateReplacement *tr;
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->Group() == gid )
+			return tr;
+	}
+	return 0;
+}
+
+TemplateReplacement* GetTemplateReplacementByTemplateID(TemplateID tid) {
+	TemplateReplacement *tr;
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->Template() == tid )
+			return tr;
+	}
+	return 0;
+}
+
+bool IssueTemplateReplacement(GroupID gid, TemplateID tid) {
+
+	TemplateReplacement *tr = GetTemplateReplacementByGroupID(gid);
+
+	if ( tr ) {
+		/* Then set the new TemplateVehicle and return */
+		tr->SetTemplate(tid);
+		return true;
+	}
+
+	else if ( TemplateReplacement::CanAllocateItem() ) {
+		tr = new TemplateReplacement(gid, tid);
+		return true;
+	}
+
+	else return false;
+}
+
+short TemplateVehicle::NumGroupsUsingTemplate() const
+{
+	short amount = 0;
+	const TemplateReplacement *tr;
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->sel_template == this->index )
+			amount++;
+	}
+	return amount;
+}
+
+short TemplateVehicle::CountEnginesInChain()
+{
+	TemplateVehicle *tv = this->first;
+	short count = 0;
+	for ( ; tv; tv=tv->GetNextUnit() )
+		if ( HasBit(tv->subtype, GVSF_ENGINE ) )
+			count++;
+	return count;
+}
+
+short deleteIllegalTemplateReplacements(GroupID g_id)
+{
+	short del_amount = 0;
+	const TemplateReplacement *tr;
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->group == g_id ) {
+			delete tr;
+			del_amount++;
+		}
+	}
+	return del_amount;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/src/aaa_template_vehicle.h b/src/aaa_template_vehicle.h
new file mode 100644
index 0000000..a9aff07
--- /dev/null
+++ b/src/aaa_template_vehicle.h
@@ -0,0 +1,229 @@
+#ifndef TEMPLATE_VEH_H
+#define TEMPLATE_VEH_H
+
+#include "vehicle_type.h"
+#include "vehicle_base.h"
+#include "vehicle_func.h"
+
+#include "articulated_vehicles.h"
+#include "newgrf_callbacks.h"
+#include "newgrf_engine.h"
+#include "newgrf_spritegroup.h"
+
+#include "engine_base.h"
+#include "engine_type.h"
+#include "engine_func.h"
+
+#include "sortlist_type.h"
+
+#define FOR_ALL_TEMPLATES_FROM(var, start) FOR_ALL_ITEMS_FROM(TemplateVehicle, template_index, var, start)
+#define FOR_ALL_TEMPLATES(var) FOR_ALL_TEMPLATES_FROM(var, 0)
+
+#define FOR_ALL_TEMPLATE_REPLACEMENTS_FROM(var, start) FOR_ALL_ITEMS_FROM(TemplateReplacement, template_replacement_index, var, start)
+#define FOR_ALL_TEMPLATE_REPLACEMENTS(var) FOR_ALL_TEMPLATE_REPLACEMENTS_FROM(var, 0)
+
+struct TemplateVehicle;
+struct TemplateReplacement;
+
+CommandCost CmdBuildTemplateVehicle(uint i, DoCommandFlag flags, uint p1, uint p2, char const* text);
+CommandCost CmdTemplateReplaceVehicle(uint i, DoCommandFlag flags, uint p1, uint p2, char const* text);
+typedef uint16 TemplateID;
+
+
+static const uint16 CONSIST_HEAD = 0x0;
+static const uint16 CONSIST_TAIL = 0xffff;
+
+/** A pool allowing to store up to ~64k templates */
+typedef Pool<TemplateVehicle, TemplateID, 512, 0x10000> TemplatePool;
+extern TemplatePool _template_pool;
+
+/// listing/sorting templates
+typedef GUIList<const TemplateVehicle*> GUITemplateList;
+
+/* TODO: rearrange attribs -.- care fore saveload as well */
+struct TemplateVehicle : TemplatePool::PoolItem<&_template_pool>, BaseVehicle {
+private:
+	TemplateVehicle *next;                      ///< pointer to the next vehicle in the chain
+	TemplateVehicle *previous;                  ///< NOSAVE: pointer to the previous vehicle in the chain
+	TemplateVehicle *first;                     ///< NOSAVE: pointer to the first vehicle in the chain
+
+public:
+	friend const SaveLoad* GTD();
+	friend void AfterLoadTemplateVehicles();
+
+	// Template usage configuration
+	bool reuse_depot_vehicles;
+	bool keep_remaining_vehicles;
+	bool refit_as_template;
+
+	// Things derived from a virtual train
+	TemplateVehicle *other_multiheaded_part;	///< Multiheaded Engine support
+	Money value;                        ///< Value of the vehicle
+	Owner owner;
+	OwnerByte owner_b;
+
+	EngineID engine_type;               ///< The type of engine used for this vehicle.
+	CargoID cargo_type;                 ///< type of cargo this vehicle is carrying
+	uint16 cargo_cap;                   ///< total capacity
+	byte cargo_subtype;
+
+	byte subtype;
+	RailTypeByte railtype;
+
+	VehicleID index;
+
+	uint16 real_consist_length;
+
+	uint16 max_speed;
+	uint32 power;
+	uint32 weight;
+	uint32 max_te;
+
+	byte spritenum;
+	SpriteID cur_image;
+	int image_width;
+	const SpriteGroup *sgroup;
+
+	TemplateVehicle(VehicleType type=VEH_INVALID,  EngineID e=INVALID_ENGINE, byte B=0, Owner=OWNER_BEGIN); // TODO:owner_begin not a good choice for the default
+	TemplateVehicle(EngineID, RailVehicleInfo*);
+	TemplateVehicle(EngineID eid) {
+		next=0;
+		previous=0;
+		first=this;
+		engine_type=eid;
+		this->reuse_depot_vehicles = true;
+		this->keep_remaining_vehicles = true;
+		this->refit_as_template = true;
+	}
+	~TemplateVehicle();
+
+	inline TemplateVehicle* Next() const { return this->next; }
+	inline TemplateVehicle* Prev() const { return this->previous; }
+	inline TemplateVehicle* First() const { return this->first; }
+
+	void SetNext(TemplateVehicle*);
+	void SetPrev(TemplateVehicle*);
+	void SetFirst(TemplateVehicle*);
+
+	// TODO
+	TemplateVehicle* GetNextUnit() const;
+	TemplateVehicle* GetPrevUnit();
+
+	bool IsSetReuseDepotVehicles() const { return this->reuse_depot_vehicles; }
+	bool IsSetKeepRemainingVehicles() const { return this->keep_remaining_vehicles; }
+	bool IsSetRefitAsTemplate() const { return this->refit_as_template; }
+	void ToggleReuseDepotVehicles() { this->reuse_depot_vehicles = !this->reuse_depot_vehicles; }
+	void ToggleKeepRemainingVehicles() { this->keep_remaining_vehicles = !this->keep_remaining_vehicles; }
+	void ToggleRefitAsTemplate() { this->refit_as_template = !this->refit_as_template; }
+
+	bool IsPrimaryVehicle() const { return this->IsFrontEngine(); }
+	inline bool IsFrontEngine() const { return HasBit(this->subtype, GVSF_FRONT); }
+	inline bool HasArticulatedPart() const { return this->Next() != NULL && this->Next()->IsArticulatedPart(); }
+
+	inline bool IsArticulatedPart() const { return HasBit(this->subtype, GVSF_ARTICULATED_PART); }
+	inline bool IsMultiheaded() const { return HasBit(this->subtype, GVSF_MULTIHEADED); }
+
+	inline bool IsFreeWagonChain() const { return HasBit(this->subtype, GVSF_FREE_WAGON); }
+
+	// since CmdBuildTemplateVehicle(...)
+	inline void SetFrontEngine() 		{ SetBit(this->subtype, GVSF_FRONT); }
+	inline void SetEngine()			{ SetBit(this->subtype, GVSF_ENGINE); }
+	inline void SetArticulatedPart()	{ SetBit(this->subtype, GVSF_ARTICULATED_PART); }
+	inline void SetMultiheaded()	 	{ SetBit(this->subtype, GVSF_MULTIHEADED); }
+
+	inline void SetWagon() { SetBit(this->subtype, GVSF_WAGON); }
+	inline void SetFreeWagon() { SetBit(this->subtype, GVSF_FREE_WAGON); }
+
+	inline uint16 GetRealLength() const { return this->real_consist_length; }
+	inline void SetRealLength(uint16 len) { this->real_consist_length = len; }
+
+	int Length() const;
+
+	SpriteID GetImage(Direction) const;
+	//int GetDisplayImageWidth(Point *offset = NULL) const;
+	SpriteID GetSpriteID() const;
+
+	short NumGroupsUsingTemplate() const;
+
+	short CountEnginesInChain();
+
+};
+
+void appendTemplateVehicle(TemplateVehicle*, TemplateVehicle*);
+void insertTemplateVehicle(TemplateVehicle*, TemplateVehicle*, TemplateVehicle*);
+
+void NeutralizeVehicleStatus(Train*);
+void SplitVehicleRemainders(Train*);
+
+// TemplateReplacement stuff
+
+typedef Pool<TemplateReplacement, uint16, 16, 1024> TemplateReplacementPool;
+extern TemplateReplacementPool _template_replacement_pool;
+
+struct TemplateReplacement : TemplateReplacementPool::PoolItem<&_template_replacement_pool> {
+	GroupID group;
+	TemplateID sel_template;
+
+	TemplateReplacement(GroupID gid, TemplateID tid) { this->group=gid; this->sel_template=tid; }
+	TemplateReplacement() {}
+	~TemplateReplacement() {}
+
+	inline GroupID Group() { return this->group; }
+	inline GroupID Template() { return this->sel_template; }
+
+ 	inline void SetGroup(GroupID gid) { this->group = gid; }
+ 	inline void SetTemplate(TemplateID tid) { this->sel_template = tid; }
+
+ 	inline TemplateID GetTemplateVehicleID() { return sel_template; }
+ 	inline const TemplateVehicle* GetTemplateVehicle() {
+		const TemplateVehicle *tv;
+		FOR_ALL_TEMPLATES(tv) {
+			if ( tv->index == this->sel_template )
+				return tv;
+		}
+		return NULL;
+	}
+};
+
+TemplateReplacement* GetTemplateReplacementByGroupID(GroupID);
+TemplateReplacement* GetTemplateReplacementByTemplateID(TemplateID);
+bool IssueTemplateReplacement(GroupID, TemplateID);
+
+short deleteIllegalTemplateReplacements(GroupID);
+
+#endif /* TEMPLATE_VEH_H */
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/src/aaa_template_vehicle_func.cpp b/src/aaa_template_vehicle_func.cpp
new file mode 100644
index 0000000..c274a7a
--- /dev/null
+++ b/src/aaa_template_vehicle_func.cpp
@@ -0,0 +1,776 @@
+// template_vehicle_func.cpp
+
+#include "stdafx.h"
+#include "window_gui.h"
+#include "gfx_func.h"
+#include "window_func.h"
+#include "command_func.h"
+#include "vehicle_gui.h"
+#include "train.h"
+#include "strings_func.h"
+#include "vehicle_func.h"
+#include "core/geometry_type.hpp"
+#include "debug.h"
+
+#include "table/sprites.h"
+#include "table/strings.h"
+
+#include "train.h"
+#include "company_func.h"
+#include "newgrf.h"
+#include "spritecache.h"
+#include "articulated_vehicles.h"
+#include "autoreplace_func.h"
+
+#include "depot_base.h"
+
+#include "aaa_template_vehicle.h"
+#include "aaa_template_vehicle_func.h"
+
+#include <map>
+#include <stdio.h>
+
+Vehicle *vhead, *vtmp;
+static const uint MAX_ARTICULATED_PARTS = 100;
+
+
+// TODO
+void pat() {
+	TemplateVehicle *tv;
+	FOR_ALL_TEMPLATES(tv) {
+		if ( tv->Prev() ) continue;
+		ptv(tv);
+		printf("__________\n");
+	}
+}
+void pav() {
+	Train *t;
+	FOR_ALL_TRAINS(t) {
+		if ( t->Previous() ) continue;
+		pvt(t);
+		printf("__________\n");
+	}
+}
+void ptv(TemplateVehicle* tv) {
+	if (!tv) return;
+	while (tv->Next() ) {
+		printf("eid:%3d  st:%2d  tv:%x  next:%x  cargo: %d  cargo_sub: %d\n", tv->engine_type, tv->subtype, (uint32)tv, (uint32)tv->Next(), tv->cargo_type, tv->cargo_subtype);
+		tv = tv->Next();
+	}
+	printf("eid:%3d  st:%2d  tv:%x  next:%x  cargo: %d  cargo_sub: %d\n", tv->engine_type, tv->subtype, (uint32)tv, (uint32)tv->Next(),  tv->cargo_type, tv->cargo_subtype);
+}
+
+void pvt (const Train *printme) {
+	for ( const Train *tmp = printme; tmp; tmp=tmp->Next() ) {
+		if ( tmp->index <= 0 ) {
+			printf("train has weird index: %d %d %x\n", tmp->index, tmp->engine_type, tmp);
+			return;
+		}
+		printf("eid:%3d  index:%2d  subtype:%2d  vehstat: %d  cargo_t: %d   cargo_sub: %d  ref:%x\n", tmp->engine_type, tmp->index, tmp->subtype, tmp->vehstatus, tmp->cargo_type, tmp->cargo_subtype, (uint32)tmp);
+	}
+}
+
+// TODO: move this into main_gui.cpp
+void BuildTemplateGuiList(GUITemplateList *list, Scrollbar *vscroll, Owner oid, RailType railtype)
+{
+	//if (!list->NeedRebuild()) return; // TODO: reactivate ?
+	list->Clear();
+	const TemplateVehicle *tv;
+
+	FOR_ALL_TEMPLATES(tv) {
+		if (tv->owner == oid && (tv->IsPrimaryVehicle() || tv->IsFreeWagonChain()) && TemplateVehicleContainsEngineOfRailtype(tv, railtype))
+			*list->Append() = tv;
+
+	}
+
+	list->RebuildDone();
+	if (vscroll) vscroll->SetCount(list->Length());
+}
+
+Money CalculateOverallTemplateCost(const TemplateVehicle *tv)
+{
+	Money val = 0;
+
+	for (; tv; tv = tv->Next())
+		val += (Engine::Get(tv->engine_type))->GetCost();
+	return val;
+}
+
+void DrawTemplate(const TemplateVehicle *tv, int left, int right, int y)
+{
+	if ( !tv ) return;
+
+	const TemplateVehicle *t = tv;
+	int offset=left;
+
+	while (t) {
+		PaletteID pal = GetEnginePalette(t->engine_type, _current_company);
+		DrawSprite(t->cur_image, pal, offset, y+12);
+
+		offset += t->image_width;
+		t = t->Next();
+	}
+	//_cur_dpi = old_dpi;
+}
+
+// copy important stuff from the virtual vehicle to the template
+inline void SetupTemplateVehicleFromVirtual(TemplateVehicle *tmp, TemplateVehicle *prev, Train *virt)
+{
+	if (prev) {
+		prev->SetNext(tmp);
+		tmp->SetPrev(prev);
+		tmp->SetFirst(prev->First());
+	}
+	tmp->railtype = virt->railtype;
+	tmp->owner = virt->owner;
+	tmp->value = virt->value;
+
+	// set the subtype but also clear the virtual flag while doing it
+	tmp->subtype = virt->subtype & ~(1 << GVSF_VIRTUAL);
+	// set the cargo type and capacity
+	tmp->cargo_type = virt->cargo_type;
+	tmp->cargo_subtype = virt->cargo_subtype;
+	tmp->cargo_cap = virt->cargo_cap;
+
+	const GroundVehicleCache *gcache = virt->GetGroundVehicleCache();
+	tmp->max_speed = virt->GetDisplayMaxSpeed();
+	tmp->power = gcache->cached_power;
+	tmp->weight = gcache->cached_weight;
+	tmp->max_te = gcache->cached_max_te / 1000;
+
+	tmp->spritenum = virt->spritenum;
+	tmp->cur_image = virt->GetImage(DIR_W, EIT_PURCHASE);
+	Point *p = new Point();
+	tmp->image_width = virt->GetDisplayImageWidth(p);
+}
+
+// create a new virtual train as clone of a real train TODO
+Train* CloneVirtualTrainFromTrain(const Train *clicked)
+{
+	if ( !clicked ) return 0;
+	CommandCost c;
+	Train *tmp, *head, *tail;
+
+	head = CmdBuildVirtualRailVehicle(clicked->engine_type);
+	if ( !head ) return 0;
+
+	tail = head;
+	clicked = clicked->GetNextUnit();
+	while ( clicked ) {
+		tmp = CmdBuildVirtualRailVehicle(clicked->engine_type);
+		if ( tmp ) {
+			tmp->cargo_type = clicked->cargo_type;
+			tmp->cargo_subtype = clicked->cargo_subtype;
+			CmdMoveRailVehicle(0, DC_EXEC, (1<<21) | tmp->index, tail->index, 0);
+			tail = tmp;
+		}
+		clicked = clicked->GetNextUnit();
+	}
+	return head;
+}
+TemplateVehicle* CloneTemplateVehicleFromTrain(const Train *t)
+{
+	Train *clicked = Train::Get(t->index);
+	if ( !clicked )
+		return 0;
+
+	Train *init_clicked = clicked;
+
+	int len = CountVehiclesInChain(clicked);
+	if ( !TemplateVehicle::CanAllocateItem(len) )
+		// TODO: error message box ?
+		return 0;
+
+	TemplateVehicle *tmp, *prev=0;
+	for ( ; clicked; clicked=clicked->Next() ) {
+		tmp = new TemplateVehicle(clicked->engine_type);
+		SetupTemplateVehicleFromVirtual(tmp, prev, clicked);
+		prev = tmp;
+	}
+
+	tmp->First()->SetRealLength(CeilDiv(init_clicked->gcache.cached_total_length * 10, TILE_SIZE));
+	return tmp->First();
+}
+// create a full TemplateVehicle based train according to a virtual train
+TemplateVehicle* TemplateVehicleFromVirtualTrain(Train *virt)
+{
+	if ( !virt )
+		return 0;
+
+	Train *init_virt = virt;
+
+	int len = CountVehiclesInChain(virt);
+	if ( !TemplateVehicle::CanAllocateItem(len) )
+		// TODO: error message box ?
+		return 0;
+
+	TemplateVehicle *tmp, *prev=0;
+	for ( ; virt; virt=virt->Next() ) {
+		tmp = new TemplateVehicle(virt->engine_type);
+		SetupTemplateVehicleFromVirtual(tmp, prev, virt);
+		prev = tmp;
+	}
+
+	tmp->First()->SetRealLength(CeilDiv(init_virt->gcache.cached_total_length * 10, TILE_SIZE));
+	return tmp->First();
+}
+
+// attempt to buy a train after a given template vehicle
+// this might fail if the template e.g. deprecated and contains engines that are not sold anymore
+Train* VirtualTrainFromTemplateVehicle(TemplateVehicle *tv)
+{
+	if ( !tv ) return 0;
+	CommandCost c;
+	Train *tmp, *head, *tail;
+
+	head = CmdBuildVirtualRailVehicle(tv->engine_type);
+	if ( !head ) return 0;
+
+	tail = head;
+	tv = tv->GetNextUnit();
+	while ( tv ) {
+		tmp = CmdBuildVirtualRailVehicle(tv->engine_type);
+		if ( tmp ) {
+			tmp->cargo_type = tv->cargo_type;
+			tmp->cargo_subtype = tv->cargo_subtype;
+			CmdMoveRailVehicle(INVALID_TILE, DC_EXEC, (1<<21) | tmp->index, tail->index, 0);
+			tail = tmp;
+		}
+		tv = tv->GetNextUnit();
+	}
+	return head;
+}
+
+// return last in a chain (really last, so even a singular articulated part of a vehicle if the last one is artic)
+inline TemplateVehicle* Last(TemplateVehicle *chain) {
+	if ( !chain ) return 0;
+	while ( chain->Next() ) chain = chain->Next();
+	return chain;
+}
+
+inline Train* Last(Train *chain) {
+	if ( !chain ) return 0;
+	while ( chain->GetNextUnit() ) chain = chain->GetNextUnit();
+	return chain;
+}
+
+// return: pointer to former vehicle
+TemplateVehicle *DeleteTemplateVehicle(TemplateVehicle *todel)
+{
+	if ( !todel )
+		return 0;
+	TemplateVehicle *cur = todel;
+	delete todel;
+	return cur;
+}
+
+Train* DeleteVirtualTrain(Train *chain, Train *to_del) {
+	if ( chain != to_del ) {
+		CommandCost sellc = CmdSellRailWagon(DC_EXEC, to_del, 0, 0);
+		return chain;
+	}
+	else {
+		chain = chain->GetNextUnit();
+		//CommandCost cost=CmdMoveRailVehicle(0, DC_EXEC, (1<<20) | (1<<21) | to_del->index, INVALID_VEHICLE, 0);
+		CommandCost sellc = CmdSellRailWagon(DC_EXEC, to_del, 0, 0);
+		return chain;
+	}
+}
+
+// retrieve template vehicle from templatereplacement that belongs to the given group
+TemplateVehicle* GetTemplateVehicleByGroupID(GroupID gid) {
+	TemplateReplacement *tr;
+	// first try to find a templatereplacement issued for the given groupid
+	FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+		if ( tr->Group() == gid )
+			return TemplateVehicle::GetIfValid(tr->Template());		// there can be only one
+	}
+	// if that didn't work, try to find a templatereplacement for ALL_GROUP
+	if ( gid != ALL_GROUP )
+		FOR_ALL_TEMPLATE_REPLACEMENTS(tr) {
+			if ( tr->Group() == ALL_GROUP )
+				return TemplateVehicle::GetIfValid(tr->Template());
+		}
+	// if all failed, just return null
+	return 0;
+}
+
+/**
+ * Check a template consist whether it contains any engine of the given railtype
+ */
+bool TemplateVehicleContainsEngineOfRailtype(const TemplateVehicle *tv, RailType type)
+{
+	/* For standard rail engines, allow only those */
+	if ( type == RAILTYPE_BEGIN || type == RAILTYPE_RAIL ) {
+		while ( tv ) {
+		if ( tv->railtype != type )
+			return false;
+		tv = tv->GetNextUnit();
+		}
+		return true;
+	}
+	/* For electrified rail engines, standard wagons or engines are allowed to be included */
+	while ( tv ) {
+		if ( tv->railtype == type )
+			return true;
+		tv = tv->GetNextUnit();
+	}
+	return false;
+}
+
+//helper
+bool ChainContainsVehicle(Train *chain, Train *mem) {
+	for (; chain; chain=chain->Next())
+		if ( chain == mem )
+			return true;
+	return false;
+}
+
+// has O(n)
+Train* ChainContainsEngine(EngineID eid, Train *chain) {
+	for (; chain; chain=chain->GetNextUnit())
+		if (chain->engine_type == eid)
+			return chain;
+	return 0;
+}
+
+// has O(n^2)
+// TODO: switch to trains
+Train* DepotContainsEngine(TileIndex tile, EngineID eid, Train *not_in=0) {
+	Train *t;
+	FOR_ALL_TRAINS(t) {
+		// conditions: v is stopped in the given depot, has the right engine and if 'not_in' is given v must not be contained within 'not_in'
+ 		// if 'not_in' is NULL, no check is needed
+		if ( t->tile==tile
+				// If the veh belongs to a chain, wagons will not return true on IsStoppedInDepot(), only primary vehicles will
+				// in case of t not a primary veh, we demand it to be a free wagon to consider it for replacement
+				&& ((t->IsPrimaryVehicle() && t->IsStoppedInDepot()) || t->IsFreeWagon())
+				&& t->engine_type==eid
+				&& (not_in==0 || ChainContainsVehicle(not_in, t)==0))
+			return t;
+	}
+	return 0;
+}
+
+void CopyStatus(Train *from, Train *to) {
+	// TODO: remove ? used ?
+	//to->group_id = from->group_id;
+	DoCommand(to->tile, from->group_id, to->index, DC_EXEC, CMD_ADD_VEHICLE_GROUP);
+	to->cargo_type = from->cargo_type;
+	to->cargo_subtype = from->cargo_subtype;
+
+	//to->orders = from->orders;
+	//to->current_order = from->current_order;
+	//to->cur_implicit_order_index = from->cur_implicit_order_index;
+
+	// swap names
+	char *tmp = to->name;
+	to->name = from->name;
+	from->name = tmp;
+	/*if ( !from->name || !to->name ) {
+		int tmpind = from->index;
+		from->index = to->index;
+		to->index = tmpind;
+	}*/
+}
+void NeutralizeStatus(Train *t) {
+	DoCommand(t->tile, DEFAULT_GROUP, t->index, DC_EXEC, CMD_ADD_VEHICLE_GROUP);
+
+	//t->orders.list = 0;
+	//t->cur_implicit_order_index = 0;
+
+	t->name = 0;
+}
+bool TrainMatchesTemplate(const Train *t, TemplateVehicle *tv) {
+	while ( t && tv ) {
+		if ( t->engine_type != tv->engine_type )
+			return false;
+		t = t->GetNextUnit();
+		tv = tv->GetNextUnit();
+	}
+	if ( (t && !tv) || (!t && tv) )
+		return false;
+	return true;
+}
+
+
+bool TrainMatchesTemplateRefit(const Train *t, TemplateVehicle *tv)
+{
+	if ( !tv->refit_as_template )
+		return true;
+
+	while ( t && tv ) {
+		if ( t->cargo_type != tv->cargo_type || t->cargo_subtype != tv->cargo_subtype )
+			return false;
+		t = t->GetNextUnit();
+		tv = tv->GetNextUnit();
+	}
+	return true;
+}
+void BreakUpRemainders(Train *t) {
+	while ( t ) {
+		Train *move;
+		if ( HasBit(t->subtype, GVSF_ENGINE) ) {
+			move = t;
+			t = t->Next();
+			DoCommand(move->tile, move->index, INVALID_VEHICLE, DC_EXEC, CMD_MOVE_RAIL_VEHICLE);
+			NeutralizeStatus( move );
+		}
+		else
+			t = t->Next();
+	}
+}
+
+short CountEnginesInChain(Train *t)
+{
+	short count = 0;
+	for ( ; t; t=t->GetNextUnit() )
+		if ( HasBit(t->subtype, GVSF_ENGINE) )
+			count++;
+	return count;
+}
+
+int countOccurrencesInTrain(Train *t, EngineID eid) {
+	int count = 0;
+	Train *tmp = t;
+	for ( ; tmp; tmp=tmp->GetNextUnit() )
+		if ( tmp->engine_type == eid )
+			count++;
+	return count;
+}
+
+int countOccurrencesInTemplateVehicle(TemplateVehicle *contain, EngineID eid) {
+	int count = 0;
+	for ( ; contain; contain=contain->GetNextUnit() )
+		if ( contain->engine_type == eid )
+			count++;
+	return count;
+}
+
+int countOccurrencesInDepot(TileIndex tile, EngineID eid, Train *not_in=0) {
+	int count = 0;
+	Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		// conditions: v is stopped in the given depot, has the right engine and if 'not_in' is given v must not be contained within 'not_in'
+ 		// if 'not_in' is NULL, no check is needed
+		if ( v->tile==tile && v->IsStoppedInDepot() && v->engine_type==eid &&
+				(not_in==0 || ChainContainsVehicle(not_in, (Train*)v)==0))
+			count++;
+	}
+	return count;
+}
+
+// basically does the same steps as CmdTemplateReplaceVehicle but without actually moving things around
+CommandCost CalculateTemplateReplacementCost(Train *incoming) {
+	TileIndex tile = incoming->tile;
+	TemplateVehicle *tv = GetTemplateVehicleByGroupID(incoming->group_id);
+	CommandCost estimate(EXPENSES_NEW_VEHICLES);
+
+	// count for each different eid in the incoming train
+	std::map<EngineID, short> unique_eids;
+	for ( TemplateVehicle *tmp=tv; tmp; tmp=tmp->GetNextUnit() )
+		unique_eids[tmp->engine_type]++;
+	std::map<EngineID, short>::iterator it = unique_eids.begin();
+	for ( ; it!=unique_eids.end(); it++ ) {
+		it->second -= countOccurrencesInTrain(incoming, it->first);
+		it->second -= countOccurrencesInDepot(incoming->tile, it->first, incoming);
+		if ( it->second < 0 ) it->second = 0;
+	}
+
+	// get overall buying cost
+	for ( it=unique_eids.begin(); it!=unique_eids.end(); it++ ) {
+		for ( int j=0; j<it->second; j++ ) {
+			estimate.AddCost(DoCommand(tile, it->first, 0, DC_NONE, CMD_BUILD_VEHICLE));
+		}
+	}
+
+	return estimate;
+}
+
+// make sure the real train wagon has the right cargo
+void CopyWagonStatus(TemplateVehicle *from, Train *to) {
+	to->cargo_type = from->cargo_type;
+	to->cargo_subtype = from->cargo_subtype;
+}
+
+int NumTrainsNeedTemplateReplacement(GroupID g_id, TemplateVehicle *tv)
+{
+	int count = 0;
+	if ( !tv ) return count;
+
+	const Train *t;
+	FOR_ALL_TRAINS(t) {
+		if ( t->IsPrimaryVehicle() && t->group_id == g_id && (!TrainMatchesTemplate(t, tv) || !TrainMatchesTemplateRefit(t, tv)) )
+			count++;
+	}
+	return count;
+}
+// refit each vehicle in t as is in tv, assume t and tv contain the same types of vehicles
+static void RefitTrainFromTemplate(Train *t, TemplateVehicle *tv)
+{
+	while ( t && tv ) {
+		// refit t as tv
+		uint32 cb = GetCmdRefitVeh(t);
+
+		DoCommandP(t->tile, t->index, tv->cargo_type | tv->cargo_subtype << 8 | 1 << 16 , cb);
+		//CommandCost c = CmdRefitVehicle ( t->tile, DC_EXEC, t->index, tv->cargo_type | tv->cargo_subtype << 8 | 1 << 16, "" );
+
+		// next
+		t = t->GetNextUnit();
+		tv = tv->GetNextUnit();
+	}
+}
+
+/** using cmdtemplatereplacevehicle as test-function (i.e. with flag DC_NONE) is not a good idea as that function relies on
+ *  actually moving vehicles around to work properly.
+ *  We do this worst-cast test instead.
+ */
+CommandCost TestBuyAllTemplateVehiclesInChain(TemplateVehicle *tv, TileIndex tile)
+{
+	CommandCost cost(EXPENSES_NEW_VEHICLES);
+
+	for ( ; tv; tv=tv->GetNextUnit() )
+		cost.AddCost( DoCommand(tile, tv->engine_type, 0, DC_NONE, CMD_BUILD_VEHICLE) );
+
+	return cost;
+}
+
+
+void TransferCargoForTrain(Train *old_veh, Train *new_head, bool part_of_chain)
+{
+	assert(!part_of_chain || new_head->IsPrimaryVehicle());
+	/* Loop through source parts */
+	for (Train *src = old_veh; src != NULL; src = src->Next()) {
+		if (!part_of_chain &&  src != old_veh && src != old_veh->other_multiheaded_part && !src->IsArticulatedPart()) {
+			/* Skip vehicles, which do not belong to old_veh */
+			src = src->GetLastEnginePart();
+			continue;
+		}
+		if (src->cargo_type >= NUM_CARGO || src->cargo.Count() == 0) continue;
+
+		/* Find free space in the new chain */
+		for (Train *dest = new_head; dest != NULL && src->cargo.Count() > 0; dest = dest->Next()) {
+			if (!part_of_chain  && dest != new_head && dest != new_head->other_multiheaded_part && !dest->IsArticulatedPart()) {
+				/* Skip vehicles, which do not belong to new_head */
+				dest = dest->GetLastEnginePart();
+				continue;
+			}
+			if (dest->cargo_type != src->cargo_type) continue;
+
+			uint amount = min(src->cargo.Count(), dest->cargo_cap - dest->cargo.Count());
+			if (amount <= 0) continue;
+
+			src->cargo.MoveTo(&dest->cargo, amount, VehicleCargoList::MTA_UNLOAD, NULL);
+		}
+	}
+
+	/* Update train weight etc., the old vehicle will be sold anyway */
+	if (part_of_chain ) new_head->ConsistChanged(true);
+}
+
+// TODO: fit signature to regular cmd-structure
+//		 do something with move_cost, it is not used right now
+// if exec==DC_EXEC, test first and execute if sucessful
+CommandCost CmdTemplateReplaceVehicle(Train *incoming, bool stayInDepot, DoCommandFlag flags) {
+	Train	*new_chain=0,
+			*remainder_chain=0,
+			*tmp_chain=0;
+	TileIndex tile = incoming->tile;
+	TemplateVehicle *tv = GetTemplateVehicleByGroupID(incoming->group_id);
+	EngineID eid = tv->engine_type;
+
+	CommandCost buy(EXPENSES_NEW_VEHICLES);
+	CommandCost move_cost(EXPENSES_NEW_VEHICLES);
+	CommandCost tmp_result(EXPENSES_NEW_VEHICLES);
+
+
+	/* first some tests on necessity and sanity */
+	if ( !tv )
+		return buy;
+	bool need_replacement = !TrainMatchesTemplate(incoming, tv);
+	bool need_refit = !TrainMatchesTemplateRefit(incoming, tv);
+	bool use_refit = tv->refit_as_template;
+	CargoID store_refit_ct = CT_INVALID;
+	short store_refit_csubt = 0;
+	// if a train shall keep its old refit, store the refit setting of its first vehicle
+	if ( !use_refit ) {
+		for ( Train *getc=incoming; getc; getc=getc->GetNextUnit() )
+			if ( getc->cargo_type != CT_INVALID ) {
+				store_refit_ct = getc->cargo_type;
+				break;
+			}
+	}
+
+	// TODO: set result status to success/no success before returning
+	if ( !need_replacement ) {
+		if ( !need_refit || !use_refit ) {
+			/* before returning, release incoming train first if 2nd param says so */
+			if ( !stayInDepot ) incoming->vehstatus &= ~VS_STOPPED;
+			return buy;
+		}
+	} else {
+		CommandCost buyCost = TestBuyAllTemplateVehiclesInChain(tv, tile);
+		if ( !buyCost.Succeeded() || !CheckCompanyHasMoney(buyCost) ) {
+			if ( !stayInDepot ) incoming->vehstatus &= ~VS_STOPPED;
+			return buy;
+		}
+	}
+
+	/* define replacement behaviour */
+	bool reuseDepot = tv->IsSetReuseDepotVehicles();
+	bool keepRemainders = tv->IsSetKeepRemainingVehicles();
+
+	if ( need_replacement ) {
+		/// step 1: generate primary for newchain and generate remainder_chain
+			// 1. primary of incoming might already fit the template
+				// leave incoming's primary as is and move the rest to a free chain = remainder_chain
+			// 2. needed primary might be one of incoming's member vehicles
+			// 3. primary might be available as orphan vehicle in the depot
+			// 4. we need to buy a new engine for the primary
+			// all options other than 1. need to make sure to copy incoming's primary's status
+		if ( eid == incoming->engine_type ) {													// 1
+			new_chain = incoming;
+			remainder_chain = incoming->GetNextUnit();
+			if ( remainder_chain )
+				move_cost.AddCost(CmdMoveRailVehicle(tile, flags, remainder_chain->index|(1<<20), INVALID_VEHICLE, 0));
+		}
+		else if ( (tmp_chain = ChainContainsEngine(eid, incoming)) && tmp_chain!=NULL )	{		// 2
+			// new_chain is the needed engine, move it to an empty spot in the depot
+			new_chain = tmp_chain;
+			move_cost.AddCost(DoCommand(tile, new_chain->index, INVALID_VEHICLE, flags,CMD_MOVE_RAIL_VEHICLE));
+			remainder_chain = incoming;
+		}
+		else if ( reuseDepot && (tmp_chain = DepotContainsEngine(tile, eid, incoming)) && tmp_chain!=NULL ) {	// 3
+			new_chain = tmp_chain;
+			move_cost.AddCost(DoCommand(tile, new_chain->index, INVALID_VEHICLE, flags, CMD_MOVE_RAIL_VEHICLE));
+			remainder_chain = incoming;
+		}
+		else {																				// 4
+			tmp_result = DoCommand(tile, eid, 0, flags, CMD_BUILD_VEHICLE);
+			/* break up in case buying the vehicle didn't succeed */
+			if ( !tmp_result.Succeeded() )
+				return tmp_result;
+			buy.AddCost(tmp_result);
+			new_chain = Train::Get(_new_vehicle_id);
+			/* make sure the newly built engine is not attached to any free wagons inside the depot */
+			move_cost.AddCost ( DoCommand(tile, new_chain->index, INVALID_VEHICLE, flags, CMD_MOVE_RAIL_VEHICLE) );
+			/* prepare the remainder chain */
+			remainder_chain = incoming;
+		}
+		// If we bought a new engine or reused one from the depot, copy some parameters from the incoming primary engine
+		if ( incoming != new_chain && flags == DC_EXEC) {
+			CopyHeadSpecificThings(incoming, new_chain, flags);
+			NeutralizeStatus(incoming);
+			// additionally, if we don't want to use the template refit, refit as incoming
+			// the template refit will be set further down, if we use it at all
+			if ( !use_refit ) {
+				uint32 cb = GetCmdRefitVeh(new_chain);
+				DoCommandP(new_chain->tile, new_chain->index, store_refit_ct | store_refit_csubt << 8 | 1 << 16 , cb);
+			}
+
+		}
+
+		/// step 2: fill up newchain according to the template
+			// foreach member of template (after primary):
+				// 1. needed engine might be within remainder_chain already
+				// 2. needed engine might be orphaned within the depot (copy status)
+				// 3. we need to buy (again)						   (copy status)
+		TemplateVehicle *cur_tmpl = tv->GetNextUnit();
+		Train *last_veh = new_chain;
+		while (cur_tmpl) {
+			// 1. engine contained in remainder chain
+			if ( (tmp_chain = ChainContainsEngine(cur_tmpl->engine_type, remainder_chain)) && tmp_chain!=NULL )	{
+				// advance remainder_chain (if necessary) to not lose track of it
+				if ( tmp_chain == remainder_chain )
+					remainder_chain = remainder_chain->GetNextUnit();
+				move_cost.AddCost(CmdMoveRailVehicle(tile, flags, tmp_chain->index, last_veh->index, 0));
+			}
+			// 2. engine contained somewhere else in the depot
+			else if ( reuseDepot && (tmp_chain = DepotContainsEngine(tile, cur_tmpl->engine_type, new_chain)) && tmp_chain!=NULL ) {
+				move_cost.AddCost(CmdMoveRailVehicle(tile, flags, tmp_chain->index, last_veh->index, 0));
+			}
+			// 3. must buy new engine
+			else {
+				tmp_result = DoCommand(tile, cur_tmpl->engine_type, 0, flags, CMD_BUILD_VEHICLE);
+				if ( !tmp_result.Succeeded() )
+					return tmp_result;
+				buy.AddCost(tmp_result);
+				tmp_chain = Train::Get(_new_vehicle_id);
+				move_cost.AddCost(CmdMoveRailVehicle(tile, flags, tmp_chain->index, last_veh->index, 0));
+			}
+			// TODO: is this enough ? might it be that we bought a new wagon here and it now has std refit ?
+			if ( need_refit && flags == DC_EXEC ) {
+				if ( use_refit ) {
+					uint32 cb = GetCmdRefitVeh(tmp_chain);
+					DoCommandP(tmp_chain->tile, tmp_chain->index, cur_tmpl->cargo_type | cur_tmpl->cargo_subtype << 8 | 1 << 16 , cb);
+					// old
+					// CopyWagonStatus(cur_tmpl, tmp_chain);
+				} else {
+					uint32 cb = GetCmdRefitVeh(tmp_chain);
+					DoCommandP(tmp_chain->tile, tmp_chain->index, store_refit_ct | store_refit_csubt << 8 | 1 << 16 , cb);
+				}
+			}
+			cur_tmpl = cur_tmpl->GetNextUnit();
+			last_veh = tmp_chain;
+		}
+	}
+	/* no replacement done */
+	else {
+		new_chain = incoming;
+	}
+	/// step 3: reorder and neutralize the remaining vehicles from incoming
+		// wagons remaining from remainder_chain should be filled up in as few freewagonchains as possible
+		// each locos might be left as singular in the depot
+		// neutralize each remaining engine's status
+
+	// refit, only if the template option is set so
+	if ( use_refit && (need_refit || need_replacement) ) {
+		RefitTrainFromTemplate(new_chain, tv);
+	}
+
+	if ( new_chain && remainder_chain )
+		for ( Train *ct=remainder_chain; ct; ct=ct->GetNextUnit() )
+			TransferCargoForTrain(ct, new_chain, true);
+
+	// point incoming to the newly created train so that starting/stopping from the calling function can be done
+	incoming = new_chain;
+	if ( !stayInDepot && flags == DC_EXEC )
+		new_chain->vehstatus &= ~VS_STOPPED;
+
+	if ( remainder_chain && keepRemainders && flags == DC_EXEC )
+		BreakUpRemainders(remainder_chain);
+	else if ( remainder_chain ) {
+		buy.AddCost(DoCommand(tile, remainder_chain->index | (1<<20), 0, flags, CMD_SELL_VEHICLE));
+	}
+	return buy;
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
diff --git a/src/aaa_template_vehicle_func.h b/src/aaa_template_vehicle_func.h
new file mode 100644
index 0000000..6a68f9a
--- /dev/null
+++ b/src/aaa_template_vehicle_func.h
@@ -0,0 +1,68 @@
+// template_vehicle_func.h
+#ifndef TEMPLATE_VEHICLE_FUNC_H
+#define TEMPLATE_VEHICLE_FUNC_H
+
+#include "stdafx.h"
+#include "window_gui.h"
+
+#include "aaa_template_vehicle.h"
+
+static bool REPLACEMENT_IN_PROGRESS = false;
+
+//void DrawTemplateVehicle(TemplateVehicle*, int, const Rect&);
+void DrawTemplateVehicle(const TemplateVehicle*, int, int, int, VehicleID, int, VehicleID);
+
+void BuildTemplateGuiList(GUITemplateList*, Scrollbar*, Owner, RailType);
+
+Money CalculateOverallTemplateCost(const TemplateVehicle*);
+
+void DrawTemplateTrain(const TemplateVehicle*, int, int, int);
+
+SpriteID GetSpriteID(EngineID, bool);
+
+void DrawTemplate(const TemplateVehicle*, int, int, int);
+
+int GetTemplateDisplayImageWidth(EngineID);
+
+TemplateVehicle *CreateNewTemplateVehicle(EngineID);
+
+void setupVirtTrain(const TemplateVehicle*, Train*);
+
+TemplateVehicle* TemplateVehicleFromVirtualTrain(Train*);
+
+Train* VirtualTrainFromTemplateVehicle(TemplateVehicle*);
+
+inline TemplateVehicle* Last(TemplateVehicle*);
+
+TemplateVehicle *DeleteTemplateVehicle(TemplateVehicle*);
+
+Train* DeleteVirtualTrainPart(Train*, Train*);
+Train* DeleteVirtualTrain(Train*, Train *);
+
+CommandCost CmdTemplateReplaceVehicle(Train*, bool, DoCommandFlag);
+
+void pat();
+void pav();
+void ptv(TemplateVehicle*);
+void pvt(const Train*);
+// for testing
+TemplateVehicle* GetTemplateVehicleByGroupID(GroupID);
+bool ChainContainsVehicle(Train*, Train*);
+Train* ChainContainsEngine(EngineID, Train*);
+Train* DepotContainsEngine(TileIndex, EngineID, Train*);
+
+int NumTrainsNeedTemplateReplacement(GroupID, TemplateVehicle*);
+
+CommandCost TestBuyAllTemplateVehiclesInChain(Train*);
+CommandCost CalculateTemplateReplacementCost(Train*);
+
+short CountEnginesInChain(Train*);
+
+bool TemplateVehicleContainsEngineOfRailtype(const TemplateVehicle*, RailType);
+
+Train* CloneVirtualTrainFromTrain(const Train *);
+TemplateVehicle* CloneTemplateVehicleFromTrain(const Train *);
+
+void TransferCargoForTrain(Train*, Train*, bool);
+
+#endif
diff --git a/src/articulated_vehicles.cpp b/src/articulated_vehicles.cpp
index 9c9a1ba..3e53ce0 100644
--- a/src/articulated_vehicles.cpp
+++ b/src/articulated_vehicles.cpp
@@ -323,6 +323,7 @@ void AddArticulatedParts(Vehicle *first)
 	Vehicle *v = first;
 	for (uint i = 1; i < MAX_ARTICULATED_PARTS; i++) {
 		bool flip_image;
+		EngineID eid = GetNextArticulatedPart(i, first->engine_type);
 		EngineID engine_type = GetNextArticulatedPart(i, first->engine_type, first, &flip_image);
 		if (engine_type == INVALID_ENGINE) return;
 
diff --git a/src/autoreplace_cmd.cpp b/src/autoreplace_cmd.cpp
index 27d6fdd..dfcd87d 100644
--- a/src/autoreplace_cmd.cpp
+++ b/src/autoreplace_cmd.cpp
@@ -345,7 +345,7 @@ static inline CommandCost CmdMoveVehicle(const Vehicle *v, const Vehicle *after,
  * @param new_head The new head of the completely replaced vehicle chain
  * @param flags the command flags to use
  */
-static CommandCost CopyHeadSpecificThings(Vehicle *old_head, Vehicle *new_head, DoCommandFlag flags)
+CommandCost CopyHeadSpecificThings(Vehicle *old_head, Vehicle *new_head, DoCommandFlag flags)
 {
 	CommandCost cost = CommandCost();
 
diff --git a/src/autoreplace_cmd.cpp.orig b/src/autoreplace_cmd.cpp.orig
new file mode 100644
index 0000000..27d6fdd
--- /dev/null
+++ b/src/autoreplace_cmd.cpp.orig
@@ -0,0 +1,785 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file autoreplace_cmd.cpp Deals with autoreplace execution but not the setup */
+
+#include "stdafx.h"
+#include "company_func.h"
+#include "train.h"
+#include "command_func.h"
+#include "engine_func.h"
+#include "vehicle_func.h"
+#include "autoreplace_func.h"
+#include "autoreplace_gui.h"
+#include "articulated_vehicles.h"
+#include "core/random_func.hpp"
+
+#include "table/strings.h"
+
+extern void ChangeVehicleViewports(VehicleID from_index, VehicleID to_index);
+extern void ChangeVehicleNews(VehicleID from_index, VehicleID to_index);
+extern void ChangeVehicleViewWindow(VehicleID from_index, VehicleID to_index);
+
+/**
+ * Figure out if two engines got at least one type of cargo in common (refitting if needed)
+ * @param engine_a one of the EngineIDs
+ * @param engine_b the other EngineID
+ * @param type the type of the engines
+ * @return true if they can both carry the same type of cargo (or at least one of them got no capacity at all)
+ */
+static bool EnginesHaveCargoInCommon(EngineID engine_a, EngineID engine_b)
+{
+	uint32 available_cargoes_a = GetUnionOfArticulatedRefitMasks(engine_a, true);
+	uint32 available_cargoes_b = GetUnionOfArticulatedRefitMasks(engine_b, true);
+	return (available_cargoes_a == 0 || available_cargoes_b == 0 || (available_cargoes_a & available_cargoes_b) != 0);
+}
+
+/**
+ * Checks some basic properties whether autoreplace is allowed
+ * @param from Origin engine
+ * @param to Destination engine
+ * @param company Company to check for
+ * @return true if autoreplace is allowed
+ */
+bool CheckAutoreplaceValidity(EngineID from, EngineID to, CompanyID company)
+{
+	assert(Engine::IsValidID(from) && Engine::IsValidID(to));
+
+	/* we can't replace an engine into itself (that would be autorenew) */
+	if (from == to) return false;
+
+	const Engine *e_from = Engine::Get(from);
+	const Engine *e_to = Engine::Get(to);
+	VehicleType type = e_from->type;
+
+	/* check that the new vehicle type is available to the company and its type is the same as the original one */
+	if (!IsEngineBuildable(to, type, company)) return false;
+
+	switch (type) {
+		case VEH_TRAIN: {
+			/* make sure the railtypes are compatible */
+			if ((GetRailTypeInfo(e_from->u.rail.railtype)->compatible_railtypes & GetRailTypeInfo(e_to->u.rail.railtype)->compatible_railtypes) == 0) return false;
+
+			/* make sure we do not replace wagons with engines or vice versa */
+			if ((e_from->u.rail.railveh_type == RAILVEH_WAGON) != (e_to->u.rail.railveh_type == RAILVEH_WAGON)) return false;
+			break;
+		}
+
+		case VEH_ROAD:
+			/* make sure that we do not replace a tram with a normal road vehicles or vice versa */
+			if (HasBit(e_from->info.misc_flags, EF_ROAD_TRAM) != HasBit(e_to->info.misc_flags, EF_ROAD_TRAM)) return false;
+			break;
+
+		case VEH_AIRCRAFT:
+			/* make sure that we do not replace a plane with a helicopter or vice versa */
+			if ((e_from->u.air.subtype & AIR_CTOL) != (e_to->u.air.subtype & AIR_CTOL)) return false;
+			break;
+
+		default: break;
+	}
+
+	/* the engines needs to be able to carry the same cargo */
+	return EnginesHaveCargoInCommon(from, to);
+}
+
+/**
+ * Check the capacity of all vehicles in a chain and spread cargo if needed.
+ * @param v The vehicle to check.
+ * @pre You can only do this if the consist is not loading or unloading. It
+ *      must not carry reserved cargo, nor cargo to be unloaded or transferred.
+ */
+void CheckCargoCapacity(Vehicle *v)
+{
+	assert(v == NULL || v->First() == v);
+
+	for (Vehicle *src = v; src != NULL; src = src->Next()) {
+		assert(src->cargo.TotalCount() == src->cargo.ActionCount(VehicleCargoList::MTA_KEEP));
+
+		/* Do we need to more cargo away? */
+		if (src->cargo.TotalCount() <= src->cargo_cap) continue;
+
+		/* We need to move a particular amount. Try that on the other vehicles. */
+		uint to_spread = src->cargo.TotalCount() - src->cargo_cap;
+		for (Vehicle *dest = v; dest != NULL && to_spread != 0; dest = dest->Next()) {
+			assert(dest->cargo.TotalCount() == dest->cargo.ActionCount(VehicleCargoList::MTA_KEEP));
+			if (dest->cargo.TotalCount() >= dest->cargo_cap || dest->cargo_type != src->cargo_type) continue;
+
+			uint amount = min(to_spread, dest->cargo_cap - dest->cargo.TotalCount());
+			src->cargo.Shift(amount, &dest->cargo);
+			to_spread -= amount;
+		}
+
+		/* Any left-overs will be thrown away, but not their feeder share. */
+		if (src->cargo_cap < src->cargo.TotalCount()) src->cargo.Truncate(src->cargo.TotalCount() - src->cargo_cap);
+	}
+}
+
+/**
+ * Transfer cargo from a single (articulated )old vehicle to the new vehicle chain
+ * @param old_veh Old vehicle that will be sold
+ * @param new_head Head of the completely constructed new vehicle chain
+ * @param part_of_chain The vehicle is part of a train
+ * @pre You can only do this if both consists are not loading or unloading.
+ *      They must not carry reserved cargo, nor cargo to be unloaded or
+ *      transferred.
+ */
+static void TransferCargo(Vehicle *old_veh, Vehicle *new_head, bool part_of_chain)
+{
+	assert(!part_of_chain || new_head->IsPrimaryVehicle());
+	/* Loop through source parts */
+	for (Vehicle *src = old_veh; src != NULL; src = src->Next()) {
+		assert(src->cargo.TotalCount() == src->cargo.ActionCount(VehicleCargoList::MTA_KEEP));
+		if (!part_of_chain && src->type == VEH_TRAIN && src != old_veh && src != Train::From(old_veh)->other_multiheaded_part && !src->IsArticulatedPart()) {
+			/* Skip vehicles, which do not belong to old_veh */
+			src = src->GetLastEnginePart();
+			continue;
+		}
+		if (src->cargo_type >= NUM_CARGO || src->cargo.TotalCount() == 0) continue;
+
+		/* Find free space in the new chain */
+		for (Vehicle *dest = new_head; dest != NULL && src->cargo.TotalCount() > 0; dest = dest->Next()) {
+			assert(dest->cargo.TotalCount() == dest->cargo.ActionCount(VehicleCargoList::MTA_KEEP));
+			if (!part_of_chain && dest->type == VEH_TRAIN && dest != new_head && dest != Train::From(new_head)->other_multiheaded_part && !dest->IsArticulatedPart()) {
+				/* Skip vehicles, which do not belong to new_head */
+				dest = dest->GetLastEnginePart();
+				continue;
+			}
+			if (dest->cargo_type != src->cargo_type) continue;
+
+			uint amount = min(src->cargo.TotalCount(), dest->cargo_cap - dest->cargo.TotalCount());
+			if (amount <= 0) continue;
+
+			src->cargo.Shift(amount, &dest->cargo);
+		}
+	}
+
+	/* Update train weight etc., the old vehicle will be sold anyway */
+	if (part_of_chain && new_head->type == VEH_TRAIN) Train::From(new_head)->ConsistChanged(true);
+}
+
+/**
+ * Tests whether refit orders that applied to v will also apply to the new vehicle type
+ * @param v The vehicle to be replaced
+ * @param engine_type The type we want to replace with
+ * @return true iff all refit orders stay valid
+ */
+static bool VerifyAutoreplaceRefitForOrders(const Vehicle *v, EngineID engine_type)
+{
+
+	uint32 union_refit_mask_a = GetUnionOfArticulatedRefitMasks(v->engine_type, false);
+	uint32 union_refit_mask_b = GetUnionOfArticulatedRefitMasks(engine_type, false);
+
+	const Order *o;
+	const Vehicle *u = (v->type == VEH_TRAIN) ? v->First() : v;
+	FOR_VEHICLE_ORDERS(u, o) {
+		if (!o->IsRefit() || o->IsAutoRefit()) continue;
+		CargoID cargo_type = o->GetRefitCargo();
+
+		if (!HasBit(union_refit_mask_a, cargo_type)) continue;
+		if (!HasBit(union_refit_mask_b, cargo_type)) return false;
+	}
+
+	return true;
+}
+
+/**
+ * Function to find what type of cargo to refit to when autoreplacing
+ * @param *v Original vehicle that is being replaced.
+ * @param engine_type The EngineID of the vehicle that is being replaced to
+ * @param part_of_chain The vehicle is part of a train
+ * @return The cargo type to replace to
+ *    CT_NO_REFIT is returned if no refit is needed
+ *    CT_INVALID is returned when both old and new vehicle got cargo capacity and refitting the new one to the old one's cargo type isn't possible
+ */
+static CargoID GetNewCargoTypeForReplace(Vehicle *v, EngineID engine_type, bool part_of_chain)
+{
+	uint32 available_cargo_types, union_mask;
+	GetArticulatedRefitMasks(engine_type, true, &union_mask, &available_cargo_types);
+
+	if (union_mask == 0) return CT_NO_REFIT; // Don't try to refit an engine with no cargo capacity
+
+	CargoID cargo_type;
+	if (IsArticulatedVehicleCarryingDifferentCargoes(v, &cargo_type)) return CT_INVALID; // We cannot refit to mixed cargoes in an automated way
+
+	if (cargo_type == CT_INVALID) {
+		if (v->type != VEH_TRAIN) return CT_NO_REFIT; // If the vehicle does not carry anything at all, every replacement is fine.
+
+		if (!part_of_chain) return CT_NO_REFIT;
+
+		/* the old engine didn't have cargo capacity, but the new one does
+		 * now we will figure out what cargo the train is carrying and refit to fit this */
+
+		for (v = v->First(); v != NULL; v = v->Next()) {
+			if (!v->GetEngine()->CanCarryCargo()) continue;
+			/* Now we found a cargo type being carried on the train and we will see if it is possible to carry to this one */
+			if (HasBit(available_cargo_types, v->cargo_type)) return v->cargo_type;
+		}
+
+		return CT_NO_REFIT; // We failed to find a cargo type on the old vehicle and we will not refit the new one
+	} else {
+		if (!HasBit(available_cargo_types, cargo_type)) return CT_INVALID; // We can't refit the vehicle to carry the cargo we want
+
+		if (part_of_chain && !VerifyAutoreplaceRefitForOrders(v, engine_type)) return CT_INVALID; // Some refit orders lose their effect
+
+		return cargo_type;
+	}
+}
+
+/**
+ * Get the EngineID of the replacement for a vehicle
+ * @param v The vehicle to find a replacement for
+ * @param c The vehicle's owner (it's faster to forward the pointer than refinding it)
+ * @param always_replace Always replace, even if not old.
+ * @param [out] e the EngineID of the replacement. INVALID_ENGINE if no replacement is found
+ * @return Error if the engine to build is not available
+ */
+static CommandCost GetNewEngineType(const Vehicle *v, const Company *c, bool always_replace, EngineID &e)
+{
+	assert(v->type != VEH_TRAIN || !v->IsArticulatedPart());
+
+	e = INVALID_ENGINE;
+
+	if (v->type == VEH_TRAIN && Train::From(v)->IsRearDualheaded()) {
+		/* we build the rear ends of multiheaded trains with the front ones */
+		return CommandCost();
+	}
+
+	bool replace_when_old;
+	e = EngineReplacementForCompany(c, v->engine_type, v->group_id, &replace_when_old);
+	if (!always_replace && replace_when_old && !v->NeedsAutorenewing(c, false)) e = INVALID_ENGINE;
+
+	/* Autoreplace, if engine is available */
+	if (e != INVALID_ENGINE && IsEngineBuildable(e, v->type, _current_company)) {
+		return CommandCost();
+	}
+
+	/* Autorenew if needed */
+	if (v->NeedsAutorenewing(c)) e = v->engine_type;
+
+	/* Nothing to do or all is fine? */
+	if (e == INVALID_ENGINE || IsEngineBuildable(e, v->type, _current_company)) return CommandCost();
+
+	/* The engine we need is not available. Report error to user */
+	return CommandCost(STR_ERROR_RAIL_VEHICLE_NOT_AVAILABLE + v->type);
+}
+
+/**
+ * Builds and refits a replacement vehicle
+ * Important: The old vehicle is still in the original vehicle chain (used for determining the cargo when the old vehicle did not carry anything, but the new one does)
+ * @param old_veh A single (articulated/multiheaded) vehicle that shall be replaced.
+ * @param new_vehicle Returns the newly build and refitted vehicle
+ * @param part_of_chain The vehicle is part of a train
+ * @return cost or error
+ */
+static CommandCost BuildReplacementVehicle(Vehicle *old_veh, Vehicle **new_vehicle, bool part_of_chain)
+{
+	*new_vehicle = NULL;
+
+	/* Shall the vehicle be replaced? */
+	const Company *c = Company::Get(_current_company);
+	EngineID e;
+	CommandCost cost = GetNewEngineType(old_veh, c, true, e);
+	if (cost.Failed()) return cost;
+	if (e == INVALID_ENGINE) return CommandCost(); // neither autoreplace is set, nor autorenew is triggered
+
+	/* Does it need to be refitted */
+	CargoID refit_cargo = GetNewCargoTypeForReplace(old_veh, e, part_of_chain);
+	if (refit_cargo == CT_INVALID) return CommandCost(); // incompatible cargoes
+
+	/* Build the new vehicle */
+	cost = DoCommand(old_veh->tile, e, 0, DC_EXEC | DC_AUTOREPLACE, GetCmdBuildVeh(old_veh));
+	if (cost.Failed()) return cost;
+
+	Vehicle *new_veh = Vehicle::Get(_new_vehicle_id);
+	*new_vehicle = new_veh;
+
+	/* Refit the vehicle if needed */
+	if (refit_cargo != CT_NO_REFIT) {
+		byte subtype = GetBestFittingSubType(old_veh, new_veh, refit_cargo);
+
+		cost.AddCost(DoCommand(0, new_veh->index, refit_cargo | (subtype << 8), DC_EXEC, GetCmdRefitVeh(new_veh)));
+		assert(cost.Succeeded()); // This should be ensured by GetNewCargoTypeForReplace()
+	}
+
+	/* Try to reverse the vehicle, but do not care if it fails as the new type might not be reversible */
+	if (new_veh->type == VEH_TRAIN && HasBit(Train::From(old_veh)->flags, VRF_REVERSE_DIRECTION)) {
+		DoCommand(0, new_veh->index, true, DC_EXEC, CMD_REVERSE_TRAIN_DIRECTION);
+	}
+
+	return cost;
+}
+
+/**
+ * Issue a start/stop command
+ * @param v a vehicle
+ * @param evaluate_callback shall the start/stop callback be evaluated?
+ * @return success or error
+ */
+static inline CommandCost CmdStartStopVehicle(const Vehicle *v, bool evaluate_callback)
+{
+	return DoCommand(0, v->index, evaluate_callback ? 1 : 0, DC_EXEC | DC_AUTOREPLACE, CMD_START_STOP_VEHICLE);
+}
+
+/**
+ * Issue a train vehicle move command
+ * @param v The vehicle to move
+ * @param after The vehicle to insert 'v' after, or NULL to start new chain
+ * @param flags the command flags to use
+ * @param whole_chain move all vehicles following 'v' (true), or only 'v' (false)
+ * @return success or error
+ */
+static inline CommandCost CmdMoveVehicle(const Vehicle *v, const Vehicle *after, DoCommandFlag flags, bool whole_chain)
+{
+	return DoCommand(0, v->index | (whole_chain ? 1 : 0) << 20, after != NULL ? after->index : INVALID_VEHICLE, flags | DC_NO_CARGO_CAP_CHECK, CMD_MOVE_RAIL_VEHICLE);
+}
+
+/**
+ * Copy head specific things to the new vehicle chain after it was successfully constructed
+ * @param old_head The old front vehicle (no wagons attached anymore)
+ * @param new_head The new head of the completely replaced vehicle chain
+ * @param flags the command flags to use
+ */
+static CommandCost CopyHeadSpecificThings(Vehicle *old_head, Vehicle *new_head, DoCommandFlag flags)
+{
+	CommandCost cost = CommandCost();
+
+	/* Share orders */
+	if (cost.Succeeded() && old_head != new_head) cost.AddCost(DoCommand(0, new_head->index | CO_SHARE << 30, old_head->index, DC_EXEC, CMD_CLONE_ORDER));
+
+	/* Copy group membership */
+	if (cost.Succeeded() && old_head != new_head) cost.AddCost(DoCommand(0, old_head->group_id, new_head->index, DC_EXEC, CMD_ADD_VEHICLE_GROUP));
+
+	/* Perform start/stop check whether the new vehicle suits newgrf restrictions etc. */
+	if (cost.Succeeded()) {
+		/* Start the vehicle, might be denied by certain things */
+		assert((new_head->vehstatus & VS_STOPPED) != 0);
+		cost.AddCost(CmdStartStopVehicle(new_head, true));
+
+		/* Stop the vehicle again, but do not care about evil newgrfs allowing starting but not stopping :p */
+		if (cost.Succeeded()) cost.AddCost(CmdStartStopVehicle(new_head, false));
+	}
+
+	/* Last do those things which do never fail (resp. we do not care about), but which are not undo-able */
+	if (cost.Succeeded() && old_head != new_head && (flags & DC_EXEC) != 0) {
+		/* Copy other things which cannot be copied by a command and which shall not stay resetted from the build vehicle command */
+		new_head->CopyVehicleConfigAndStatistics(old_head);
+
+		/* Switch vehicle windows/news to the new vehicle, so they are not closed/deleted when the old vehicle is sold */
+		ChangeVehicleViewports(old_head->index, new_head->index);
+		ChangeVehicleViewWindow(old_head->index, new_head->index);
+		ChangeVehicleNews(old_head->index, new_head->index);
+	}
+
+	return cost;
+}
+
+/**
+ * Replace a single unit in a free wagon chain
+ * @param single_unit vehicle to let autoreplace/renew operator on
+ * @param flags command flags
+ * @param nothing_to_do is set to 'false' when something was done (only valid when not failed)
+ * @return cost or error
+ */
+static CommandCost ReplaceFreeUnit(Vehicle **single_unit, DoCommandFlag flags, bool *nothing_to_do)
+{
+	Train *old_v = Train::From(*single_unit);
+	assert(!old_v->IsArticulatedPart() && !old_v->IsRearDualheaded());
+
+	CommandCost cost = CommandCost(EXPENSES_NEW_VEHICLES, 0);
+
+	/* Build and refit replacement vehicle */
+	Vehicle *new_v = NULL;
+	cost.AddCost(BuildReplacementVehicle(old_v, &new_v, false));
+
+	/* Was a new vehicle constructed? */
+	if (cost.Succeeded() && new_v != NULL) {
+		*nothing_to_do = false;
+
+		if ((flags & DC_EXEC) != 0) {
+			/* Move the new vehicle behind the old */
+			CmdMoveVehicle(new_v, old_v, DC_EXEC, false);
+
+			/* Take over cargo
+			 * Note: We do only transfer cargo from the old to the new vehicle.
+			 *       I.e. we do not transfer remaining cargo to other vehicles.
+			 *       Else you would also need to consider moving cargo to other free chains,
+			 *       or doing the same in ReplaceChain(), which would be quite troublesome.
+			 */
+			TransferCargo(old_v, new_v, false);
+
+			*single_unit = new_v;
+		}
+
+		/* Sell the old vehicle */
+		cost.AddCost(DoCommand(0, old_v->index, 0, flags, GetCmdSellVeh(old_v)));
+
+		/* If we are not in DC_EXEC undo everything */
+		if ((flags & DC_EXEC) == 0) {
+			DoCommand(0, new_v->index, 0, DC_EXEC, GetCmdSellVeh(new_v));
+		}
+	}
+
+	return cost;
+}
+
+/**
+ * Replace a whole vehicle chain
+ * @param chain vehicle chain to let autoreplace/renew operator on
+ * @param flags command flags
+ * @param wagon_removal remove wagons when the resulting chain occupies more tiles than the old did
+ * @param nothing_to_do is set to 'false' when something was done (only valid when not failed)
+ * @return cost or error
+ */
+static CommandCost ReplaceChain(Vehicle **chain, DoCommandFlag flags, bool wagon_removal, bool *nothing_to_do)
+{
+	Vehicle *old_head = *chain;
+	assert(old_head->IsPrimaryVehicle());
+
+	CommandCost cost = CommandCost(EXPENSES_NEW_VEHICLES, 0);
+
+	if (old_head->type == VEH_TRAIN) {
+		/* Store the length of the old vehicle chain, rounded up to whole tiles */
+		uint16 old_total_length = CeilDiv(Train::From(old_head)->gcache.cached_total_length, TILE_SIZE) * TILE_SIZE;
+
+		int num_units = 0; ///< Number of units in the chain
+		for (Train *w = Train::From(old_head); w != NULL; w = w->GetNextUnit()) num_units++;
+
+		Train **old_vehs = CallocT<Train *>(num_units); ///< Will store vehicles of the old chain in their order
+		Train **new_vehs = CallocT<Train *>(num_units); ///< New vehicles corresponding to old_vehs or NULL if no replacement
+		Money *new_costs = MallocT<Money>(num_units);   ///< Costs for buying and refitting the new vehicles
+
+		/* Collect vehicles and build replacements
+		 * Note: The replacement vehicles can only successfully build as long as the old vehicles are still in their chain */
+		int i;
+		Train *w;
+		for (w = Train::From(old_head), i = 0; w != NULL; w = w->GetNextUnit(), i++) {
+			assert(i < num_units);
+			old_vehs[i] = w;
+
+			CommandCost ret = BuildReplacementVehicle(old_vehs[i], (Vehicle**)&new_vehs[i], true);
+			cost.AddCost(ret);
+			if (cost.Failed()) break;
+
+			new_costs[i] = ret.GetCost();
+			if (new_vehs[i] != NULL) *nothing_to_do = false;
+		}
+		Train *new_head = (new_vehs[0] != NULL ? new_vehs[0] : old_vehs[0]);
+
+		/* Note: When autoreplace has already failed here, old_vehs[] is not completely initialized. But it is also not needed. */
+		if (cost.Succeeded()) {
+			/* Separate the head, so we can start constructing the new chain */
+			Train *second = Train::From(old_head)->GetNextUnit();
+			if (second != NULL) cost.AddCost(CmdMoveVehicle(second, NULL, DC_EXEC | DC_AUTOREPLACE, true));
+
+			assert(Train::From(new_head)->GetNextUnit() == NULL);
+
+			/* Append engines to the new chain
+			 * We do this from back to front, so that the head of the temporary vehicle chain does not change all the time.
+			 * That way we also have less trouble when exceeding the unitnumber limit.
+			 * OTOH the vehicle attach callback is more expensive this way :s */
+			Train *last_engine = NULL; ///< Shall store the last engine unit after this step
+			if (cost.Succeeded()) {
+				for (int i = num_units - 1; i > 0; i--) {
+					Train *append = (new_vehs[i] != NULL ? new_vehs[i] : old_vehs[i]);
+
+					if (RailVehInfo(append->engine_type)->railveh_type == RAILVEH_WAGON) continue;
+
+					if (new_vehs[i] != NULL) {
+						/* Move the old engine to a separate row with DC_AUTOREPLACE. Else
+						 * moving the wagon in front may fail later due to unitnumber limit.
+						 * (We have to attach wagons without DC_AUTOREPLACE.) */
+						CmdMoveVehicle(old_vehs[i], NULL, DC_EXEC | DC_AUTOREPLACE, false);
+					}
+
+					if (last_engine == NULL) last_engine = append;
+					cost.AddCost(CmdMoveVehicle(append, new_head, DC_EXEC, false));
+					if (cost.Failed()) break;
+				}
+				if (last_engine == NULL) last_engine = new_head;
+			}
+
+			/* When wagon removal is enabled and the new engines without any wagons are already longer than the old, we have to fail */
+			if (cost.Succeeded() && wagon_removal && new_head->gcache.cached_total_length > old_total_length) cost = CommandCost(STR_ERROR_TRAIN_TOO_LONG_AFTER_REPLACEMENT);
+
+			/* Append/insert wagons into the new vehicle chain
+			 * We do this from back to front, so we can stop when wagon removal or maximum train length (i.e. from mammoth-train setting) is triggered.
+			 */
+			if (cost.Succeeded()) {
+				for (int i = num_units - 1; i > 0; i--) {
+					assert(last_engine != NULL);
+					Vehicle *append = (new_vehs[i] != NULL ? new_vehs[i] : old_vehs[i]);
+
+					if (RailVehInfo(append->engine_type)->railveh_type == RAILVEH_WAGON) {
+						/* Insert wagon after 'last_engine' */
+						CommandCost res = CmdMoveVehicle(append, last_engine, DC_EXEC, false);
+
+						/* When we allow removal of wagons, either the move failing due
+						 * to the train becoming too long, or the train becoming longer
+						 * would move the vehicle to the empty vehicle chain. */
+						if (wagon_removal && (res.Failed() ? res.GetErrorMessage() == STR_ERROR_TRAIN_TOO_LONG : new_head->gcache.cached_total_length > old_total_length)) {
+							CmdMoveVehicle(append, NULL, DC_EXEC | DC_AUTOREPLACE, false);
+							break;
+						}
+
+						cost.AddCost(res);
+						if (cost.Failed()) break;
+					} else {
+						/* We have reached 'last_engine', continue with the next engine towards the front */
+						assert(append == last_engine);
+						last_engine = last_engine->GetPrevUnit();
+					}
+				}
+			}
+
+			/* Sell superfluous new vehicles that could not be inserted. */
+			if (cost.Succeeded() && wagon_removal) {
+				assert(new_head->gcache.cached_total_length <= _settings_game.vehicle.max_train_length * TILE_SIZE);
+				for (int i = 1; i < num_units; i++) {
+					Vehicle *wagon = new_vehs[i];
+					if (wagon == NULL) continue;
+					if (wagon->First() == new_head) break;
+
+					assert(RailVehInfo(wagon->engine_type)->railveh_type == RAILVEH_WAGON);
+
+					/* Sell wagon */
+					CommandCost ret = DoCommand(0, wagon->index, 0, DC_EXEC, GetCmdSellVeh(wagon));
+					assert(ret.Succeeded());
+					new_vehs[i] = NULL;
+
+					/* Revert the money subtraction when the vehicle was built.
+					 * This value is different from the sell value, esp. because of refitting */
+					cost.AddCost(-new_costs[i]);
+				}
+			}
+
+			/* The new vehicle chain is constructed, now take over orders and everything... */
+			if (cost.Succeeded()) cost.AddCost(CopyHeadSpecificThings(old_head, new_head, flags));
+
+			if (cost.Succeeded()) {
+				/* Success ! */
+				if ((flags & DC_EXEC) != 0 && new_head != old_head) {
+					*chain = new_head;
+				}
+
+				/* Transfer cargo of old vehicles and sell them */
+				for (int i = 0; i < num_units; i++) {
+					Vehicle *w = old_vehs[i];
+					/* Is the vehicle again part of the new chain?
+					 * Note: We cannot test 'new_vehs[i] != NULL' as wagon removal might cause to remove both */
+					if (w->First() == new_head) continue;
+
+					if ((flags & DC_EXEC) != 0) TransferCargo(w, new_head, true);
+
+					/* Sell the vehicle.
+					 * Note: This might temporarly construct new trains, so use DC_AUTOREPLACE to prevent
+					 *       it from failing due to engine limits. */
+					cost.AddCost(DoCommand(0, w->index, 0, flags | DC_AUTOREPLACE, GetCmdSellVeh(w)));
+					if ((flags & DC_EXEC) != 0) {
+						old_vehs[i] = NULL;
+						if (i == 0) old_head = NULL;
+					}
+				}
+
+				if ((flags & DC_EXEC) != 0) CheckCargoCapacity(new_head);
+			}
+
+			/* If we are not in DC_EXEC undo everything, i.e. rearrange old vehicles.
+			 * We do this from back to front, so that the head of the temporary vehicle chain does not change all the time.
+			 * Note: The vehicle attach callback is disabled here :) */
+			if ((flags & DC_EXEC) == 0) {
+				/* Separate the head, so we can reattach the old vehicles */
+				Train *second = Train::From(old_head)->GetNextUnit();
+				if (second != NULL) CmdMoveVehicle(second, NULL, DC_EXEC | DC_AUTOREPLACE, true);
+
+				assert(Train::From(old_head)->GetNextUnit() == NULL);
+
+				for (int i = num_units - 1; i > 0; i--) {
+					CommandCost ret = CmdMoveVehicle(old_vehs[i], old_head, DC_EXEC | DC_AUTOREPLACE, false);
+					assert(ret.Succeeded());
+				}
+			}
+		}
+
+		/* Finally undo buying of new vehicles */
+		if ((flags & DC_EXEC) == 0) {
+			for (int i = num_units - 1; i >= 0; i--) {
+				if (new_vehs[i] != NULL) {
+					DoCommand(0, new_vehs[i]->index, 0, DC_EXEC, GetCmdSellVeh(new_vehs[i]));
+					new_vehs[i] = NULL;
+				}
+			}
+		}
+
+		free(old_vehs);
+		free(new_vehs);
+		free(new_costs);
+	} else {
+		/* Build and refit replacement vehicle */
+		Vehicle *new_head = NULL;
+		cost.AddCost(BuildReplacementVehicle(old_head, &new_head, true));
+
+		/* Was a new vehicle constructed? */
+		if (cost.Succeeded() && new_head != NULL) {
+			*nothing_to_do = false;
+
+			/* The new vehicle is constructed, now take over orders and everything... */
+			cost.AddCost(CopyHeadSpecificThings(old_head, new_head, flags));
+
+			if (cost.Succeeded()) {
+				/* The new vehicle is constructed, now take over cargo */
+				if ((flags & DC_EXEC) != 0) {
+					TransferCargo(old_head, new_head, true);
+					*chain = new_head;
+				}
+
+				/* Sell the old vehicle */
+				cost.AddCost(DoCommand(0, old_head->index, 0, flags, GetCmdSellVeh(old_head)));
+			}
+
+			/* If we are not in DC_EXEC undo everything */
+			if ((flags & DC_EXEC) == 0) {
+				DoCommand(0, new_head->index, 0, DC_EXEC, GetCmdSellVeh(new_head));
+			}
+		}
+	}
+
+	return cost;
+}
+
+/**
+ * Autoreplaces a vehicle
+ * Trains are replaced as a whole chain, free wagons in depot are replaced on their own
+ * @param tile not used
+ * @param flags type of operation
+ * @param p1 Index of vehicle
+ * @param p2 not used
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdAutoreplaceVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	Vehicle *v = Vehicle::GetIfValid(p1);
+	if (v == NULL) return CMD_ERROR;
+
+	CommandCost ret = CheckOwnership(v->owner);
+	if (ret.Failed()) return ret;
+
+	if (!v->IsChainInDepot()) return CMD_ERROR;
+	if (v->vehstatus & VS_CRASHED) return CMD_ERROR;
+
+	bool free_wagon = false;
+	if (v->type == VEH_TRAIN) {
+		Train *t = Train::From(v);
+		if (t->IsArticulatedPart() || t->IsRearDualheaded()) return CMD_ERROR;
+		free_wagon = !t->IsFrontEngine();
+		if (free_wagon && t->First()->IsFrontEngine()) return CMD_ERROR;
+	} else {
+		if (!v->IsPrimaryVehicle()) return CMD_ERROR;
+	}
+
+	const Company *c = Company::Get(_current_company);
+	bool wagon_removal = c->settings.renew_keep_length;
+
+	/* Test whether any replacement is set, before issuing a whole lot of commands that would end in nothing changed */
+	Vehicle *w = v;
+	bool any_replacements = false;
+	while (w != NULL) {
+		EngineID e;
+		CommandCost cost = GetNewEngineType(w, c, false, e);
+		if (cost.Failed()) return cost;
+		any_replacements |= (e != INVALID_ENGINE);
+		w = (!free_wagon && w->type == VEH_TRAIN ? Train::From(w)->GetNextUnit() : NULL);
+	}
+
+	CommandCost cost = CommandCost(EXPENSES_NEW_VEHICLES, 0);
+	bool nothing_to_do = true;
+
+	if (any_replacements) {
+		bool was_stopped = free_wagon || ((v->vehstatus & VS_STOPPED) != 0);
+
+		/* Stop the vehicle */
+		if (!was_stopped) cost.AddCost(CmdStartStopVehicle(v, true));
+		if (cost.Failed()) return cost;
+
+		assert(free_wagon || v->IsStoppedInDepot());
+
+		/* We have to construct the new vehicle chain to test whether it is valid.
+		 * Vehicle construction needs random bits, so we have to save the random seeds
+		 * to prevent desyncs and to replay newgrf callbacks during DC_EXEC */
+		SavedRandomSeeds saved_seeds;
+		SaveRandomSeeds(&saved_seeds);
+		if (free_wagon) {
+			cost.AddCost(ReplaceFreeUnit(&v, flags & ~DC_EXEC, &nothing_to_do));
+		} else {
+			cost.AddCost(ReplaceChain(&v, flags & ~DC_EXEC, wagon_removal, &nothing_to_do));
+		}
+		RestoreRandomSeeds(saved_seeds);
+
+		if (cost.Succeeded() && (flags & DC_EXEC) != 0) {
+			CommandCost ret;
+			if (free_wagon) {
+				ret = ReplaceFreeUnit(&v, flags, &nothing_to_do);
+			} else {
+				ret = ReplaceChain(&v, flags, wagon_removal, &nothing_to_do);
+			}
+			assert(ret.Succeeded() && ret.GetCost() == cost.GetCost());
+		}
+
+		/* Restart the vehicle */
+		if (!was_stopped) cost.AddCost(CmdStartStopVehicle(v, false));
+	}
+
+	if (cost.Succeeded() && nothing_to_do) cost = CommandCost(STR_ERROR_AUTOREPLACE_NOTHING_TO_DO);
+	return cost;
+}
+
+/**
+ * Change engine renewal parameters
+ * @param tile unused
+ * @param flags operation to perform
+ * @param p1 packed data
+ *   - bit      0 = replace when engine gets old?
+ *   - bits 16-31 = engine group
+ * @param p2 packed data
+ *   - bits  0-15 = old engine type
+ *   - bits 16-31 = new engine type
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdSetAutoReplace(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	Company *c = Company::GetIfValid(_current_company);
+	if (c == NULL) return CMD_ERROR;
+
+	EngineID old_engine_type = GB(p2, 0, 16);
+	EngineID new_engine_type = GB(p2, 16, 16);
+	GroupID id_g = GB(p1, 16, 16);
+	CommandCost cost;
+
+	if (Group::IsValidID(id_g) ? Group::Get(id_g)->owner != _current_company : !IsAllGroupID(id_g) && !IsDefaultGroupID(id_g)) return CMD_ERROR;
+	if (!Engine::IsValidID(old_engine_type)) return CMD_ERROR;
+
+	if (new_engine_type != INVALID_ENGINE) {
+		if (!Engine::IsValidID(new_engine_type)) return CMD_ERROR;
+		if (!CheckAutoreplaceValidity(old_engine_type, new_engine_type, _current_company)) return CMD_ERROR;
+
+		cost = AddEngineReplacementForCompany(c, old_engine_type, new_engine_type, id_g, HasBit(p1, 0), flags);
+	} else {
+		cost = RemoveEngineReplacementForCompany(c, old_engine_type, id_g, flags);
+	}
+
+	if (flags & DC_EXEC) {
+		GroupStatistics::UpdateAutoreplace(_current_company);
+		if (IsLocalCompany()) SetWindowDirty(WC_REPLACE_VEHICLE, Engine::Get(old_engine_type)->type);
+	}
+	if ((flags & DC_EXEC) && IsLocalCompany()) InvalidateAutoreplaceWindow(old_engine_type, id_g);
+
+	return cost;
+}
+
diff --git a/src/autoreplace_func.h b/src/autoreplace_func.h
index 3a6fc83..791962f 100644
--- a/src/autoreplace_func.h
+++ b/src/autoreplace_func.h
@@ -99,4 +99,7 @@ static inline CommandCost RemoveEngineReplacementForCompany(Company *c, EngineID
 
 bool CheckAutoreplaceValidity(EngineID from, EngineID to, CompanyID company);
 
+// MYGUI
+CommandCost CopyHeadSpecificThings(Vehicle*, Vehicle*, DoCommandFlag);
+
 #endif /* AUTOREPLACE_FUNC_H */
diff --git a/src/autoreplace_func.h.orig b/src/autoreplace_func.h.orig
new file mode 100644
index 0000000..3a6fc83
--- /dev/null
+++ b/src/autoreplace_func.h.orig
@@ -0,0 +1,102 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file autoreplace_func.h Functions related to autoreplacing. */
+
+#ifndef AUTOREPLACE_FUNC_H
+#define AUTOREPLACE_FUNC_H
+
+#include "command_type.h"
+#include "company_base.h"
+
+void RemoveAllEngineReplacement(EngineRenewList *erl);
+EngineID EngineReplacement(EngineRenewList erl, EngineID engine, GroupID group, bool *replace_when_old = NULL);
+CommandCost AddEngineReplacement(EngineRenewList *erl, EngineID old_engine, EngineID new_engine, GroupID group, bool replace_when_old, DoCommandFlag flags);
+CommandCost RemoveEngineReplacement(EngineRenewList *erl, EngineID engine, GroupID group, DoCommandFlag flags);
+
+/**
+ * Remove all engine replacement settings for the given company.
+ * @param c the company.
+ */
+static inline void RemoveAllEngineReplacementForCompany(Company *c)
+{
+	RemoveAllEngineReplacement(&c->engine_renew_list);
+}
+
+/**
+ * Retrieve the engine replacement for the given company and original engine type.
+ * @param c company.
+ * @param engine Engine type.
+ * @param group The group related to this replacement.
+ * @param[out] replace_when_old Set to true if the replacement should be done when old.
+ * @return The engine type to replace with, or INVALID_ENGINE if no
+ * replacement is in the list.
+ */
+static inline EngineID EngineReplacementForCompany(const Company *c, EngineID engine, GroupID group, bool *replace_when_old = NULL)
+{
+	return EngineReplacement(c->engine_renew_list, engine, group, replace_when_old);
+}
+
+/**
+ * Check if a company has a replacement set up for the given engine.
+ * @param c Company.
+ * @param engine Engine type to be replaced.
+ * @param group The group related to this replacement.
+ * @return true if a replacement was set up, false otherwise.
+ */
+static inline bool EngineHasReplacementForCompany(const Company *c, EngineID engine, GroupID group)
+{
+	return EngineReplacementForCompany(c, engine, group) != INVALID_ENGINE;
+}
+
+/**
+ * Check if a company has a replacement set up for the given engine when it gets old.
+ * @param c Company.
+ * @param engine Engine type to be replaced.
+ * @param group The group related to this replacement.
+ * @return True if a replacement when old was set up, false otherwise.
+ */
+static inline bool EngineHasReplacementWhenOldForCompany(const Company *c, EngineID engine, GroupID group)
+{
+	bool replace_when_old;
+	EngineReplacement(c->engine_renew_list, engine, group, &replace_when_old);
+	return replace_when_old;
+}
+
+/**
+ * Add an engine replacement for the company.
+ * @param c Company.
+ * @param old_engine The original engine type.
+ * @param new_engine The replacement engine type.
+ * @param group The group related to this replacement.
+ * @param replace_when_old Replace when old or always?
+ * @param flags The calling command flags.
+ * @return 0 on success, CMD_ERROR on failure.
+ */
+static inline CommandCost AddEngineReplacementForCompany(Company *c, EngineID old_engine, EngineID new_engine, GroupID group, bool replace_when_old, DoCommandFlag flags)
+{
+	return AddEngineReplacement(&c->engine_renew_list, old_engine, new_engine, group, replace_when_old, flags);
+}
+
+/**
+ * Remove an engine replacement for the company.
+ * @param c Company.
+ * @param engine The original engine type.
+ * @param group The group related to this replacement.
+ * @param flags The calling command flags.
+ * @return 0 on success, CMD_ERROR on failure.
+ */
+static inline CommandCost RemoveEngineReplacementForCompany(Company *c, EngineID engine, GroupID group, DoCommandFlag flags)
+{
+	return RemoveEngineReplacement(&c->engine_renew_list, engine, group, flags);
+}
+
+bool CheckAutoreplaceValidity(EngineID from, EngineID to, CompanyID company);
+
+#endif /* AUTOREPLACE_FUNC_H */
diff --git a/src/depot_gui.cpp b/src/depot_gui.cpp
index bfdf293..c9382eb 100644
--- a/src/depot_gui.cpp
+++ b/src/depot_gui.cpp
@@ -862,6 +862,7 @@ struct DepotWindow : Window {
 
 	virtual void OnMouseDrag(Point pt, int widget)
 	{
+
 		if (this->type != VEH_TRAIN || this->sel == INVALID_VEHICLE) return;
 
 		/* A rail vehicle is dragged.. */
@@ -916,6 +917,7 @@ struct DepotWindow : Window {
 
 					if (this->GetVehicleFromDepotWndPt(pt.x - nwi->pos_x, pt.y - nwi->pos_y, &v, &gdvp) == MODE_DRAG_VEHICLE && sel != INVALID_VEHICLE) {
 						if (gdvp.wagon != NULL && gdvp.wagon->index == sel && _ctrl_pressed) {
+
 							DoCommandP(Vehicle::Get(sel)->tile, Vehicle::Get(sel)->index, true,
 									CMD_REVERSE_TRAIN_DIRECTION | CMD_MSG(STR_ERROR_CAN_T_REVERSE_DIRECTION_RAIL_VEHICLE));
 						} else if (gdvp.wagon == NULL || gdvp.wagon->index != sel) {
diff --git a/src/depot_gui.cpp.orig b/src/depot_gui.cpp.orig
new file mode 100644
index 0000000..bfdf293
--- /dev/null
+++ b/src/depot_gui.cpp.orig
@@ -0,0 +1,1041 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file depot_gui.cpp The GUI for depots. */
+
+#include "stdafx.h"
+#include "train.h"
+#include "roadveh.h"
+#include "ship.h"
+#include "aircraft.h"
+#include "gui.h"
+#include "textbuf_gui.h"
+#include "viewport_func.h"
+#include "command_func.h"
+#include "depot_base.h"
+#include "spritecache.h"
+#include "strings_func.h"
+#include "vehicle_func.h"
+#include "company_func.h"
+#include "tilehighlight_func.h"
+#include "window_gui.h"
+#include "vehiclelist.h"
+#include "order_backup.h"
+#include "zoom_func.h"
+
+#include "widgets/depot_widget.h"
+
+#include "table/strings.h"
+
+/*
+ * Since all depot window sizes aren't the same, we need to modify sizes a little.
+ * It's done with the following arrays of widget indexes. Each of them tells if a widget side should be moved and in what direction.
+ * How long they should be moved and for what window types are controlled in ShowDepotWindow()
+ */
+
+/** Nested widget definition for train depots. */
+static const NWidgetPart _nested_train_depot_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_D_CAPTION), SetDataTip(STR_DEPOT_CAPTION, STR_NULL),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_MATRIX, COLOUR_GREY, WID_D_MATRIX), SetDataTip(0x0, STR_NULL), SetResize(1, 1), SetScrollbar(WID_D_V_SCROLL),
+			NWidget(NWID_SELECTION, INVALID_COLOUR, WID_D_SHOW_H_SCROLL),
+				NWidget(NWID_HSCROLLBAR, COLOUR_GREY, WID_D_H_SCROLL),
+			EndContainer(),
+		EndContainer(),
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_IMGBTN, COLOUR_GREY, WID_D_SELL), SetDataTip(0x0, STR_NULL), SetResize(0, 1), SetFill(0, 1),
+			NWidget(NWID_SELECTION, INVALID_COLOUR, WID_D_SHOW_SELL_CHAIN),
+				NWidget(WWT_IMGBTN, COLOUR_GREY, WID_D_SELL_CHAIN), SetDataTip(SPR_SELL_CHAIN_TRAIN, STR_DEPOT_DRAG_WHOLE_TRAIN_TO_SELL_TOOLTIP), SetResize(0, 1), SetFill(0, 1),
+			EndContainer(),
+			NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_D_SELL_ALL), SetDataTip(0x0, STR_NULL),
+			NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_D_AUTOREPLACE), SetDataTip(0x0, STR_NULL),
+		EndContainer(),
+		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_D_V_SCROLL),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL, NC_EQUALSIZE),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_D_BUILD), SetDataTip(0x0, STR_NULL), SetFill(1, 1), SetResize(1, 0),
+		NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_D_CLONE), SetDataTip(0x0, STR_NULL), SetFill(1, 1), SetResize(1, 0),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_D_LOCATION), SetDataTip(STR_BUTTON_LOCATION, STR_NULL), SetFill(1, 1), SetResize(1, 0),
+		NWidget(NWID_SELECTION, INVALID_COLOUR, WID_D_SHOW_RENAME), // rename button
+			NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_D_RENAME), SetDataTip(STR_BUTTON_RENAME, STR_DEPOT_RENAME_TOOLTIP), SetFill(1, 1), SetResize(1, 0),
+		EndContainer(),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_D_VEHICLE_LIST), SetDataTip(0x0, STR_NULL), SetFill(0, 1),
+		NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_D_STOP_ALL), SetDataTip(SPR_FLAG_VEH_STOPPED, STR_NULL), SetFill(0, 1),
+		NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_D_START_ALL), SetDataTip(SPR_FLAG_VEH_RUNNING, STR_NULL), SetFill(0, 1),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static const WindowDesc _train_depot_desc(
+	WDP_AUTO, 362, 123,
+	WC_VEHICLE_DEPOT, WC_NONE,
+	0,
+	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets)
+);
+
+static const WindowDesc _road_depot_desc(
+	WDP_AUTO, 316, 97,
+	WC_VEHICLE_DEPOT, WC_NONE,
+	0,
+	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets)
+);
+
+static const WindowDesc _ship_depot_desc(
+	WDP_AUTO, 306, 99,
+	WC_VEHICLE_DEPOT, WC_NONE,
+	0,
+	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets)
+);
+
+static const WindowDesc _aircraft_depot_desc(
+	WDP_AUTO, 332, 99,
+	WC_VEHICLE_DEPOT, WC_NONE,
+	0,
+	_nested_train_depot_widgets, lengthof(_nested_train_depot_widgets)
+);
+
+extern void DepotSortList(VehicleList *list);
+
+/**
+ * This is the Callback method after the cloning attempt of a vehicle
+ * @param result the result of the cloning command
+ * @param tile unused
+ * @param p1 unused
+ * @param p2 unused
+ */
+void CcCloneVehicle(const CommandCost &result, TileIndex tile, uint32 p1, uint32 p2)
+{
+	if (result.Failed()) return;
+
+	const Vehicle *v = Vehicle::Get(_new_vehicle_id);
+
+	ShowVehicleViewWindow(v);
+}
+
+static void TrainDepotMoveVehicle(const Vehicle *wagon, VehicleID sel, const Vehicle *head)
+{
+	const Vehicle *v = Vehicle::Get(sel);
+
+	if (v == wagon) return;
+
+	if (wagon == NULL) {
+		if (head != NULL) wagon = head->Last();
+	} else {
+		wagon = wagon->Previous();
+		if (wagon == NULL) return;
+	}
+
+	if (wagon == v) return;
+
+	DoCommandP(v->tile, v->index | (_ctrl_pressed ? 1 : 0) << 20, wagon == NULL ? INVALID_VEHICLE : wagon->index, CMD_MOVE_RAIL_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_MOVE_VEHICLE));
+}
+
+static VehicleCellSize _base_block_sizes_depot[VEH_COMPANY_END];    ///< Cell size for vehicle images in the depot view.
+static VehicleCellSize _base_block_sizes_purchase[VEH_COMPANY_END]; ///< Cell size for vehicle images in the purchase list.
+
+/**
+ * Get the GUI cell size for a vehicle image.
+ * @param type Vehicle type to get the size for.
+ * @param image_type Image type to get size for.
+ * @pre image_type == EIT_IN_DEPOT || image_type == EIT_PURCHASE
+ * @return Cell dimensions for the vehicle and image type.
+ */
+VehicleCellSize GetVehicleImageCellSize(VehicleType type, EngineImageType image_type)
+{
+	switch (image_type) {
+		case EIT_IN_DEPOT: return _base_block_sizes_depot[type];
+		case EIT_PURCHASE: return _base_block_sizes_purchase[type];
+		default: NOT_REACHED();
+	}
+}
+
+static void InitBlocksizeForVehicles(VehicleType type, EngineImageType image_type)
+{
+	int max_extend_left  = 0;
+	int max_extend_right = 0;
+	uint max_height = 0;
+
+	const Engine *e;
+	FOR_ALL_ENGINES_OF_TYPE(e, type) {
+		if (!e->IsEnabled()) continue;
+
+		EngineID eid = e->index;
+		uint x, y;
+		int x_offs, y_offs;
+
+		switch (type) {
+			default: NOT_REACHED();
+			case VEH_TRAIN:    GetTrainSpriteSize(   eid, x, y, x_offs, y_offs, image_type); break;
+			case VEH_ROAD:     GetRoadVehSpriteSize( eid, x, y, x_offs, y_offs, image_type); break;
+			case VEH_SHIP:     GetShipSpriteSize(    eid, x, y, x_offs, y_offs, image_type); break;
+			case VEH_AIRCRAFT: GetAircraftSpriteSize(eid, x, y, x_offs, y_offs, image_type); break;
+		}
+		if (y > max_height) max_height = y;
+		if (-x_offs > max_extend_left) max_extend_left = -x_offs;
+		if ((int)x + x_offs > max_extend_right) max_extend_right = x + x_offs;
+	}
+
+	switch (image_type) {
+		case EIT_IN_DEPOT:
+			_base_block_sizes_depot[type].height       = max(GetVehicleHeight(type), max_height);
+			_base_block_sizes_depot[type].extend_left  = Clamp(max_extend_left, 16, 98);
+			_base_block_sizes_depot[type].extend_right = Clamp(max_extend_right, 16, 98);
+			break;
+		case EIT_PURCHASE:
+			_base_block_sizes_purchase[type].height       = max(GetVehicleHeight(type), max_height);
+			_base_block_sizes_purchase[type].extend_left  = Clamp(max_extend_left, 16, 98);
+			_base_block_sizes_purchase[type].extend_right = Clamp(max_extend_right, 16, 98);
+			break;
+
+		default: NOT_REACHED();
+	}
+}
+
+/**
+ * Set the size of the blocks in the window so we can be sure that they are big enough for the vehicle sprites in the current game.
+ * @note Calling this function once for each game is enough.
+ */
+void InitDepotWindowBlockSizes()
+{
+	for (VehicleType vt = VEH_BEGIN; vt < VEH_COMPANY_END; vt++) {
+		InitBlocksizeForVehicles(vt, EIT_IN_DEPOT);
+		InitBlocksizeForVehicles(vt, EIT_PURCHASE);
+	}
+}
+
+static void DepotSellAllConfirmationCallback(Window *w, bool confirmed);
+const Sprite *GetAircraftSprite(EngineID engine);
+
+struct DepotWindow : Window {
+	VehicleID sel;
+	VehicleID vehicle_over; ///< Rail vehicle over which another one is dragged, \c INVALID_VEHICLE if none.
+	VehicleType type;
+	bool generate_list;
+	VehicleList vehicle_list;
+	VehicleList wagon_list;
+	uint num_columns;       ///< Number of columns.
+	Scrollbar *hscroll;     ///< Only for trains.
+	Scrollbar *vscroll;
+
+	DepotWindow(const WindowDesc *desc, TileIndex tile, VehicleType type) : Window()
+	{
+		assert(IsCompanyBuildableVehicleType(type)); // ensure that we make the call with a valid type
+
+		this->sel = INVALID_VEHICLE;
+		this->vehicle_over = INVALID_VEHICLE;
+		this->generate_list = true;
+		this->type = type;
+		this->num_columns = 1; // for non-trains this gets set in FinishInitNested()
+
+		this->CreateNestedTree(desc);
+		this->hscroll = (this->type == VEH_TRAIN ? this->GetScrollbar(WID_D_H_SCROLL) : NULL);
+		this->vscroll = this->GetScrollbar(WID_D_V_SCROLL);
+		/* Don't show 'rename button' of aircraft hangar */
+		this->GetWidget<NWidgetStacked>(WID_D_SHOW_RENAME)->SetDisplayedPlane(type == VEH_AIRCRAFT ? SZSP_NONE : 0);
+		/* Only train depots have a horizontal scrollbar and a 'sell chain' button */
+		this->GetWidget<NWidgetStacked>(WID_D_SHOW_H_SCROLL)->SetDisplayedPlane(type == VEH_TRAIN ? 0 : SZSP_HORIZONTAL);
+		this->GetWidget<NWidgetStacked>(WID_D_SHOW_SELL_CHAIN)->SetDisplayedPlane(type == VEH_TRAIN ? 0 : SZSP_NONE);
+		this->SetupWidgetData(type);
+		this->FinishInitNested(desc, tile);
+
+		this->owner = GetTileOwner(tile);
+		OrderBackup::Reset();
+	}
+
+	~DepotWindow()
+	{
+		DeleteWindowById(WC_BUILD_VEHICLE, this->window_number);
+		OrderBackup::Reset(this->window_number);
+	}
+
+	/**
+	 * Draw a vehicle in the depot window in the box with the top left corner at x,y.
+	 * @param v     Vehicle to draw.
+	 * @param left  Left side of the box to draw in.
+	 * @param right Right side of the box to draw in.
+	 * @param y     Top of the box to draw in.
+	 */
+	void DrawVehicleInDepot(const Vehicle *v, int left, int right, int y) const
+	{
+		bool free_wagon = false;
+		int sprite_y = y + (this->resize.step_height - GetVehicleHeight(v->type)) / 2;
+
+		bool rtl = _current_text_dir == TD_RTL;
+		int image_left  = rtl ? left  + this->count_width  : left  + this->header_width;
+		int image_right = rtl ? right - this->header_width : right - this->count_width;
+
+		switch (v->type) {
+			case VEH_TRAIN: {
+				const Train *u = Train::From(v);
+				free_wagon = u->IsFreeWagon();
+
+				uint x_space = free_wagon ? TRAININFO_DEFAULT_VEHICLE_WIDTH : 0;
+				DrawTrainImage(u, image_left + (rtl ? 0 : x_space), image_right - (rtl ? x_space : 0), sprite_y - 1,
+						this->sel, EIT_IN_DEPOT, free_wagon ? 0 : this->hscroll->GetPosition(), this->vehicle_over);
+
+				/* Length of consist in tiles with 1 fractional digit (rounded up) */
+				SetDParam(0, CeilDiv(u->gcache.cached_total_length * 10, TILE_SIZE));
+				SetDParam(1, 1);
+				DrawString(rtl ? left + WD_FRAMERECT_LEFT : right - this->count_width, rtl ? left + this->count_width : right - WD_FRAMERECT_RIGHT, y + (this->resize.step_height - FONT_HEIGHT_SMALL) / 2, STR_TINY_BLACK_DECIMAL, TC_FROMSTRING, SA_RIGHT); // Draw the counter
+				break;
+			}
+
+			case VEH_ROAD:     DrawRoadVehImage( v, image_left, image_right, sprite_y, this->sel, EIT_IN_DEPOT); break;
+			case VEH_SHIP:     DrawShipImage(    v, image_left, image_right, sprite_y, this->sel, EIT_IN_DEPOT); break;
+			case VEH_AIRCRAFT: {
+				const Sprite *spr = GetSprite(v->GetImage(DIR_W, EIT_IN_DEPOT), ST_NORMAL);
+				DrawAircraftImage(v, image_left, image_right,
+									y + max(UnScaleByZoom(spr->height, ZOOM_LVL_GUI) + UnScaleByZoom(spr->y_offs, ZOOM_LVL_GUI) - 14, 0), // tall sprites needs an y offset
+									this->sel, EIT_IN_DEPOT);
+				break;
+			}
+			default: NOT_REACHED();
+		}
+
+		uint diff_x, diff_y;
+		if (v->IsGroundVehicle()) {
+			/* Arrange unitnumber and flag horizontally */
+			diff_x = this->flag_width + WD_FRAMERECT_LEFT;
+			diff_y = (this->resize.step_height - this->flag_height) / 2 - 2;
+		} else {
+			/* Arrange unitnumber and flag vertically */
+			diff_x = WD_FRAMERECT_LEFT;
+			diff_y = FONT_HEIGHT_NORMAL + WD_PAR_VSEP_NORMAL;
+		}
+		int text_left  = rtl ? right - this->header_width - 1 : left + diff_x;
+		int text_right = rtl ? right - diff_x : left + this->header_width - 1;
+
+		if (free_wagon) {
+			DrawString(text_left, text_right, y + 2, STR_DEPOT_NO_ENGINE);
+		} else {
+			DrawSprite((v->vehstatus & VS_STOPPED) ? SPR_FLAG_VEH_STOPPED : SPR_FLAG_VEH_RUNNING, PAL_NONE, rtl ? right - this->flag_width : left + WD_FRAMERECT_LEFT, y + diff_y);
+
+			SetDParam(0, v->unitnumber);
+			DrawString(text_left, text_right, y + 2, (uint16)(v->max_age - DAYS_IN_LEAP_YEAR) >= v->age ? STR_BLACK_COMMA : STR_RED_COMMA);
+		}
+	}
+
+	void DrawWidget(const Rect &r, int widget) const
+	{
+		if (widget != WID_D_MATRIX) return;
+
+		bool rtl = _current_text_dir == TD_RTL;
+
+		/* Set the row and number of boxes in each row based on the number of boxes drawn in the matrix */
+		uint16 mat_data = this->GetWidget<NWidgetCore>(WID_D_MATRIX)->widget_data;
+		uint16 rows_in_display   = GB(mat_data, MAT_ROW_START, MAT_ROW_BITS);
+		uint16 boxes_in_each_row = GB(mat_data, MAT_COL_START, MAT_COL_BITS);
+
+		uint16 num = this->vscroll->GetPosition() * boxes_in_each_row;
+		int maxval = min(this->vehicle_list.Length(), num + (rows_in_display * boxes_in_each_row));
+		int y;
+		for (y = r.top + 1; num < maxval; y += this->resize.step_height) { // Draw the rows
+			for (byte i = 0; i < boxes_in_each_row && num < maxval; i++, num++) {
+				/* Draw all vehicles in the current row */
+				const Vehicle *v = this->vehicle_list[num];
+				if (boxes_in_each_row == 1) {
+					this->DrawVehicleInDepot(v, r.left, r.right, y);
+				} else {
+					int x = r.left + (rtl ? (boxes_in_each_row - i - 1) : i) * this->resize.step_width;
+					this->DrawVehicleInDepot(v, x, x + this->resize.step_width - 1, y);
+				}
+			}
+		}
+
+		maxval = min(this->vehicle_list.Length() + this->wagon_list.Length(), (this->vscroll->GetPosition() * boxes_in_each_row) + (rows_in_display * boxes_in_each_row));
+
+		/* Draw the train wagons without an engine in front. */
+		for (; num < maxval; num++, y += this->resize.step_height) {
+			const Vehicle *v = this->wagon_list[num - this->vehicle_list.Length()];
+			this->DrawVehicleInDepot(v, r.left, r.right, y);
+		}
+	}
+
+	void SetStringParameters(int widget) const
+	{
+		if (widget != WID_D_CAPTION) return;
+
+		/* locate the depot struct */
+		TileIndex tile = this->window_number;
+		SetDParam(0, this->type);
+		SetDParam(1, (this->type == VEH_AIRCRAFT) ? GetStationIndex(tile) : GetDepotIndex(tile));
+	}
+
+	struct GetDepotVehiclePtData {
+		const Vehicle *head;
+		const Vehicle *wagon;
+	};
+
+	enum DepotGUIAction {
+		MODE_ERROR,
+		MODE_DRAG_VEHICLE,
+		MODE_SHOW_VEHICLE,
+		MODE_START_STOP,
+	};
+
+	DepotGUIAction GetVehicleFromDepotWndPt(int x, int y, const Vehicle **veh, GetDepotVehiclePtData *d) const
+	{
+		const NWidgetCore *matrix_widget = this->GetWidget<NWidgetCore>(WID_D_MATRIX);
+		/* In case of RTL the widgets are swapped as a whole */
+		if (_current_text_dir == TD_RTL) x = matrix_widget->current_x - x;
+
+		uint xt = 0, xm = 0, ym = 0;
+		if (this->type == VEH_TRAIN) {
+			xm = x;
+		} else {
+			xt = x / this->resize.step_width;
+			xm = x % this->resize.step_width;
+			if (xt >= this->num_columns) return MODE_ERROR;
+		}
+		ym = y % this->resize.step_height;
+
+		uint row = y / this->resize.step_height;
+		if (row >= this->vscroll->GetCapacity()) return MODE_ERROR;
+
+		uint boxes_in_each_row = GB(matrix_widget->widget_data, MAT_COL_START, MAT_COL_BITS);
+		uint pos = ((row + this->vscroll->GetPosition()) * boxes_in_each_row) + xt;
+
+		if (this->vehicle_list.Length() + this->wagon_list.Length() <= pos) {
+			/* Clicking on 'line' / 'block' without a vehicle */
+			if (this->type == VEH_TRAIN) {
+				/* End the dragging */
+				d->head  = NULL;
+				d->wagon = NULL;
+				return MODE_DRAG_VEHICLE;
+			} else {
+				return MODE_ERROR; // empty block, so no vehicle is selected
+			}
+		}
+
+		bool wagon = false;
+		if (this->vehicle_list.Length() > pos) {
+			*veh = this->vehicle_list[pos];
+			/* Skip vehicles that are scrolled off the list */
+			if (this->type == VEH_TRAIN) x += this->hscroll->GetPosition();
+		} else {
+			pos -= this->vehicle_list.Length();
+			*veh = this->wagon_list[pos];
+			/* free wagons don't have an initial loco. */
+			x -= VEHICLEINFO_FULL_VEHICLE_WIDTH;
+			wagon = true;
+		}
+
+		const Train *v = NULL;
+		if (this->type == VEH_TRAIN) {
+			v = Train::From(*veh);
+			d->head = d->wagon = v;
+		}
+
+		if (xm <= this->header_width) {
+			switch (this->type) {
+				case VEH_TRAIN:
+					if (wagon) return MODE_ERROR;
+				case VEH_ROAD:
+					if (xm <= this->flag_width) return MODE_START_STOP;
+					break;
+
+				case VEH_SHIP:
+				case VEH_AIRCRAFT:
+					if (xm <= this->flag_width && ym >= (uint)(FONT_HEIGHT_NORMAL + WD_PAR_VSEP_NORMAL)) return MODE_START_STOP;
+					break;
+
+				default: NOT_REACHED();
+			}
+			return MODE_SHOW_VEHICLE;
+		}
+
+		if (this->type != VEH_TRAIN) return MODE_DRAG_VEHICLE;
+
+		/* Clicking on the counter */
+		if (xm >= matrix_widget->current_x - this->count_width) return wagon ? MODE_ERROR : MODE_SHOW_VEHICLE;
+
+		/* Account for the header */
+		x -= this->header_width;
+
+		/* find the vehicle in this row that was clicked */
+		for (; v != NULL; v = v->Next()) {
+			x -= v->GetDisplayImageWidth();
+			if (x < 0) break;
+		}
+
+		d->wagon = (v != NULL ? v->GetFirstEnginePart() : NULL);
+
+		return MODE_DRAG_VEHICLE;
+	}
+
+	/**
+	 * Handle click in the depot matrix.
+	 * @param x Horizontal position in the matrix widget in pixels.
+	 * @param y Vertical position in the matrix widget in pixels.
+	 */
+	void DepotClick(int x, int y)
+	{
+		GetDepotVehiclePtData gdvp = { NULL, NULL };
+		const Vehicle *v = NULL;
+		DepotGUIAction mode = this->GetVehicleFromDepotWndPt(x, y, &v, &gdvp);
+
+		if (this->type == VEH_TRAIN) v = gdvp.wagon;
+
+		switch (mode) {
+			case MODE_ERROR: // invalid
+				return;
+
+			case MODE_DRAG_VEHICLE: { // start dragging of vehicle
+				if (v != NULL && VehicleClicked(v)) return;
+
+				VehicleID sel = this->sel;
+
+				if (this->type == VEH_TRAIN && sel != INVALID_VEHICLE) {
+					this->sel = INVALID_VEHICLE;
+					TrainDepotMoveVehicle(v, sel, gdvp.head);
+				} else if (v != NULL) {
+					bool rtl = _current_text_dir == TD_RTL;
+					int image = v->GetImage(rtl ? DIR_E : DIR_W, EIT_IN_DEPOT);
+					SetObjectToPlaceWnd(image, GetVehiclePalette(v), HT_DRAG, this);
+
+					this->sel = v->index;
+					this->SetDirty();
+
+					_cursor.short_vehicle_offset = v->IsGroundVehicle() ? (16 - v->GetGroundVehicleCache()->cached_veh_length * 2) * (rtl ? -1 : 1) : 0;
+					_cursor.vehchain = _ctrl_pressed;
+				}
+				break;
+			}
+
+			case MODE_SHOW_VEHICLE: // show info window
+				ShowVehicleViewWindow(v);
+				break;
+
+			case MODE_START_STOP: // click start/stop flag
+				StartStopVehicle(v, false);
+				break;
+
+			default: NOT_REACHED();
+		}
+	}
+
+	/**
+	 * Function to set up vehicle specific widgets (mainly sprites and strings).
+	 * Only use this function to if the widget is used for several vehicle types and each has
+	 * different text/sprites. If the widget is only used for a single vehicle type, or the same
+	 * text/sprites are used every time, use the nested widget array to initialize the widget.
+	 */
+	void SetupWidgetData(VehicleType type)
+	{
+		this->GetWidget<NWidgetCore>(WID_D_STOP_ALL)->tool_tip     = STR_DEPOT_MASS_STOP_DEPOT_TRAIN_TOOLTIP + type;
+		this->GetWidget<NWidgetCore>(WID_D_START_ALL)->tool_tip    = STR_DEPOT_MASS_START_DEPOT_TRAIN_TOOLTIP + type;
+		this->GetWidget<NWidgetCore>(WID_D_SELL)->tool_tip         = STR_DEPOT_TRAIN_SELL_TOOLTIP + type;
+		this->GetWidget<NWidgetCore>(WID_D_SELL_ALL)->tool_tip     = STR_DEPOT_SELL_ALL_BUTTON_TRAIN_TOOLTIP + type;
+
+		this->GetWidget<NWidgetCore>(WID_D_BUILD)->SetDataTip(STR_DEPOT_TRAIN_NEW_VEHICLES_BUTTON + type, STR_DEPOT_TRAIN_NEW_VEHICLES_TOOLTIP + type);
+		this->GetWidget<NWidgetCore>(WID_D_CLONE)->SetDataTip(STR_DEPOT_CLONE_TRAIN + type, STR_DEPOT_CLONE_TRAIN_DEPOT_INFO + type);
+
+		this->GetWidget<NWidgetCore>(WID_D_LOCATION)->tool_tip     = STR_DEPOT_TRAIN_LOCATION_TOOLTIP + type;
+		this->GetWidget<NWidgetCore>(WID_D_VEHICLE_LIST)->tool_tip = STR_DEPOT_VEHICLE_ORDER_LIST_TRAIN_TOOLTIP + type;
+		this->GetWidget<NWidgetCore>(WID_D_AUTOREPLACE)->tool_tip  = STR_DEPOT_AUTOREPLACE_TRAIN_TOOLTIP + type;
+		this->GetWidget<NWidgetCore>(WID_D_MATRIX)->tool_tip       = STR_DEPOT_TRAIN_LIST_TOOLTIP + this->type;
+
+		switch (type) {
+			default: NOT_REACHED();
+
+			case VEH_TRAIN:
+				this->GetWidget<NWidgetCore>(WID_D_VEHICLE_LIST)->widget_data = STR_TRAIN;
+
+				/* Sprites */
+				this->GetWidget<NWidgetCore>(WID_D_SELL)->widget_data        = SPR_SELL_TRAIN;
+				this->GetWidget<NWidgetCore>(WID_D_SELL_ALL)->widget_data    = SPR_SELL_ALL_TRAIN;
+				this->GetWidget<NWidgetCore>(WID_D_AUTOREPLACE)->widget_data = SPR_REPLACE_TRAIN;
+				break;
+
+			case VEH_ROAD:
+				this->GetWidget<NWidgetCore>(WID_D_VEHICLE_LIST)->widget_data = STR_LORRY;
+
+				/* Sprites */
+				this->GetWidget<NWidgetCore>(WID_D_SELL)->widget_data        = SPR_SELL_ROADVEH;
+				this->GetWidget<NWidgetCore>(WID_D_SELL_ALL)->widget_data    = SPR_SELL_ALL_ROADVEH;
+				this->GetWidget<NWidgetCore>(WID_D_AUTOREPLACE)->widget_data = SPR_REPLACE_ROADVEH;
+				break;
+
+			case VEH_SHIP:
+				this->GetWidget<NWidgetCore>(WID_D_VEHICLE_LIST)->widget_data = STR_SHIP;
+
+				/* Sprites */
+				this->GetWidget<NWidgetCore>(WID_D_SELL)->widget_data        = SPR_SELL_SHIP;
+				this->GetWidget<NWidgetCore>(WID_D_SELL_ALL)->widget_data    = SPR_SELL_ALL_SHIP;
+				this->GetWidget<NWidgetCore>(WID_D_AUTOREPLACE)->widget_data = SPR_REPLACE_SHIP;
+				break;
+
+			case VEH_AIRCRAFT:
+				this->GetWidget<NWidgetCore>(WID_D_VEHICLE_LIST)->widget_data = STR_PLANE;
+
+				/* Sprites */
+				this->GetWidget<NWidgetCore>(WID_D_SELL)->widget_data        = SPR_SELL_AIRCRAFT;
+				this->GetWidget<NWidgetCore>(WID_D_SELL_ALL)->widget_data    = SPR_SELL_ALL_AIRCRAFT;
+				this->GetWidget<NWidgetCore>(WID_D_AUTOREPLACE)->widget_data = SPR_REPLACE_AIRCRAFT;
+				break;
+		}
+	}
+
+	uint count_width;
+	uint header_width;
+	uint flag_width;
+	uint flag_height;
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case WID_D_MATRIX: {
+				uint min_height = 0;
+
+				if (this->type == VEH_TRAIN) {
+					SetDParamMaxValue(0, 1000);
+					SetDParam(1, 1);
+					this->count_width = GetStringBoundingBox(STR_TINY_BLACK_DECIMAL).width + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+				} else {
+					this->count_width = 0;
+				}
+
+				Dimension unumber = { GetDigitWidth() * 4, FONT_HEIGHT_NORMAL };
+				const Sprite *spr = GetSprite(SPR_FLAG_VEH_STOPPED, ST_NORMAL);
+				this->flag_width  = UnScaleByZoom(spr->width, ZOOM_LVL_GUI) + WD_FRAMERECT_RIGHT;
+				this->flag_height = UnScaleByZoom(spr->height, ZOOM_LVL_GUI);
+
+				if (this->type == VEH_TRAIN || this->type == VEH_ROAD) {
+					min_height = max<uint>(unumber.height + WD_MATRIX_TOP, UnScaleByZoom(spr->height, ZOOM_LVL_GUI));
+					this->header_width = unumber.width + this->flag_width + WD_FRAMERECT_LEFT;
+				} else {
+					min_height = unumber.height + UnScaleByZoom(spr->height, ZOOM_LVL_GUI) + WD_MATRIX_TOP + WD_PAR_VSEP_NORMAL + WD_MATRIX_BOTTOM;
+					this->header_width = max<uint>(unumber.width, this->flag_width) + WD_FRAMERECT_RIGHT;
+				}
+				int base_width = this->count_width + this->header_width;
+
+				resize->height = max<uint>(GetVehicleImageCellSize(this->type, EIT_IN_DEPOT).height, min_height);
+				if (this->type == VEH_TRAIN) {
+					resize->width = 1;
+					size->width = base_width + 2 * 29; // about 2 parts
+					size->height = resize->height * 6;
+				} else {
+					resize->width = base_width + GetVehicleImageCellSize(this->type, EIT_IN_DEPOT).extend_left + GetVehicleImageCellSize(this->type, EIT_IN_DEPOT).extend_right;
+					size->width = resize->width * (this->type == VEH_ROAD ? 5 : 3);
+					size->height = resize->height * (this->type == VEH_ROAD ? 5 : 3);
+				}
+				fill->width = resize->width;
+				fill->height = resize->height;
+				break;
+			}
+		}
+	}
+
+	/**
+	 * Some data on this window has become invalid.
+	 * @param data Information about the changed data.
+	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+	 */
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		this->generate_list = true;
+	}
+
+	virtual void OnPaint()
+	{
+		if (this->generate_list) {
+			/* Generate the vehicle list
+			 * It's ok to use the wagon pointers for non-trains as they will be ignored */
+			BuildDepotVehicleList(this->type, this->window_number, &this->vehicle_list, &this->wagon_list);
+			this->generate_list = false;
+			DepotSortList(&this->vehicle_list);
+		}
+
+		/* determine amount of items for scroller */
+		if (this->type == VEH_TRAIN) {
+			uint max_width = VEHICLEINFO_FULL_VEHICLE_WIDTH;
+			for (uint num = 0; num < this->vehicle_list.Length(); num++) {
+				uint width = 0;
+				for (const Train *v = Train::From(this->vehicle_list[num]); v != NULL; v = v->Next()) {
+					width += v->GetDisplayImageWidth();
+				}
+				max_width = max(max_width, width);
+			}
+			/* Always have 1 empty row, so people can change the setting of the train */
+			this->vscroll->SetCount(this->vehicle_list.Length() + this->wagon_list.Length() + 1);
+			this->hscroll->SetCount(max_width);
+		} else {
+			this->vscroll->SetCount(CeilDiv(this->vehicle_list.Length(), this->num_columns));
+		}
+
+		/* Setup disabled buttons. */
+		TileIndex tile = this->window_number;
+		this->SetWidgetsDisabledState(!IsTileOwner(tile, _local_company),
+			WID_D_STOP_ALL,
+			WID_D_START_ALL,
+			WID_D_SELL,
+			WID_D_SELL_CHAIN,
+			WID_D_SELL_ALL,
+			WID_D_BUILD,
+			WID_D_CLONE,
+			WID_D_RENAME,
+			WID_D_AUTOREPLACE,
+			WIDGET_LIST_END);
+
+		this->DrawWidgets();
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch (widget) {
+			case WID_D_MATRIX: { // List
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(WID_D_MATRIX);
+				this->DepotClick(pt.x - nwi->pos_x, pt.y - nwi->pos_y);
+				break;
+			}
+
+			case WID_D_BUILD: // Build vehicle
+				ResetObjectToPlace();
+				ShowBuildVehicleWindow(this->window_number, this->type);
+				break;
+
+			case WID_D_CLONE: // Clone button
+				this->SetWidgetDirty(WID_D_CLONE);
+				this->ToggleWidgetLoweredState(WID_D_CLONE);
+
+				if (this->IsWidgetLowered(WID_D_CLONE)) {
+					static const CursorID clone_icons[] = {
+						SPR_CURSOR_CLONE_TRAIN, SPR_CURSOR_CLONE_ROADVEH,
+						SPR_CURSOR_CLONE_SHIP, SPR_CURSOR_CLONE_AIRPLANE
+					};
+
+					SetObjectToPlaceWnd(clone_icons[this->type], PAL_NONE, HT_VEHICLE, this);
+				} else {
+					ResetObjectToPlace();
+				}
+				break;
+
+			case WID_D_LOCATION:
+				if (_ctrl_pressed) {
+					ShowExtraViewPortWindow(this->window_number);
+				} else {
+					ScrollMainWindowToTile(this->window_number);
+				}
+				break;
+
+			case WID_D_RENAME: // Rename button
+				SetDParam(0, this->type);
+				SetDParam(1, Depot::GetByTile((TileIndex)this->window_number)->index);
+				ShowQueryString(STR_DEPOT_NAME, STR_DEPOT_RENAME_DEPOT_CAPTION, MAX_LENGTH_DEPOT_NAME_CHARS, this, CS_ALPHANUMERAL, QSF_ENABLE_DEFAULT | QSF_LEN_IN_CHARS);
+				break;
+
+			case WID_D_STOP_ALL:
+			case WID_D_START_ALL: {
+				VehicleListIdentifier vli(VL_DEPOT_LIST, this->type, this->owner);
+				DoCommandP(this->window_number, (widget == WID_D_START_ALL ? (1 << 0) : 0), vli.Pack(), CMD_MASS_START_STOP);
+				break;
+			}
+
+			case WID_D_SELL_ALL:
+				/* Only open the confirmation window if there are anything to sell */
+				if (this->vehicle_list.Length() != 0 || this->wagon_list.Length() != 0) {
+					TileIndex tile = this->window_number;
+					byte vehtype = this->type;
+
+					SetDParam(0, vehtype);
+					SetDParam(1, (vehtype == VEH_AIRCRAFT) ? GetStationIndex(tile) : GetDepotIndex(tile));
+					ShowQuery(
+						STR_DEPOT_CAPTION,
+						STR_DEPOT_SELL_CONFIRMATION_TEXT,
+						this,
+						DepotSellAllConfirmationCallback
+					);
+				}
+				break;
+
+			case WID_D_VEHICLE_LIST:
+				ShowVehicleListWindow(GetTileOwner(this->window_number), this->type, (TileIndex)this->window_number);
+				break;
+
+			case WID_D_AUTOREPLACE:
+				DoCommandP(this->window_number, this->type, 0, CMD_DEPOT_MASS_AUTOREPLACE);
+				break;
+
+		}
+	}
+
+	virtual void OnQueryTextFinished(char *str)
+	{
+		if (str == NULL) return;
+
+		/* Do depot renaming */
+		DoCommandP(0, GetDepotIndex(this->window_number), 0, CMD_RENAME_DEPOT | CMD_MSG(STR_ERROR_CAN_T_RENAME_DEPOT), NULL, str);
+	}
+
+	virtual bool OnRightClick(Point pt, int widget)
+	{
+		if (widget != WID_D_MATRIX) return false;
+
+		GetDepotVehiclePtData gdvp = { NULL, NULL };
+		const Vehicle *v = NULL;
+		NWidgetBase *nwi = this->GetWidget<NWidgetBase>(WID_D_MATRIX);
+		DepotGUIAction mode = this->GetVehicleFromDepotWndPt(pt.x - nwi->pos_x, pt.y - nwi->pos_y, &v, &gdvp);
+
+		if (this->type == VEH_TRAIN) v = gdvp.wagon;
+
+		if (v == NULL || mode != MODE_DRAG_VEHICLE) return false;
+
+		CargoArray capacity, loaded;
+
+		/* Display info for single (articulated) vehicle, or for whole chain starting with selected vehicle */
+		bool whole_chain = (this->type == VEH_TRAIN && _ctrl_pressed);
+
+		/* loop through vehicle chain and collect cargoes */
+		uint num = 0;
+		for (const Vehicle *w = v; w != NULL; w = w->Next()) {
+			if (w->cargo_cap > 0 && w->cargo_type < NUM_CARGO) {
+				capacity[w->cargo_type] += w->cargo_cap;
+				loaded  [w->cargo_type] += w->cargo.StoredCount();
+			}
+
+			if (w->type == VEH_TRAIN && !w->HasArticulatedPart()) {
+				num++;
+				if (!whole_chain) break;
+			}
+		}
+
+		/* Build tooltipstring */
+		static char details[1024];
+		details[0] = '\0';
+		char *pos = details;
+
+		for (CargoID cargo_type = 0; cargo_type < NUM_CARGO; cargo_type++) {
+			if (capacity[cargo_type] == 0) continue;
+
+			SetDParam(0, cargo_type);           // {CARGO} #1
+			SetDParam(1, loaded[cargo_type]);   // {CARGO} #2
+			SetDParam(2, cargo_type);           // {SHORTCARGO} #1
+			SetDParam(3, capacity[cargo_type]); // {SHORTCARGO} #2
+			pos = GetString(pos, STR_DEPOT_VEHICLE_TOOLTIP_CARGO, lastof(details));
+		}
+
+		/* Show tooltip window */
+		uint64 args[2];
+		args[0] = (whole_chain ? num : v->engine_type);
+		args[1] = (uint64)(size_t)details;
+		GuiShowTooltips(this, whole_chain ? STR_DEPOT_VEHICLE_TOOLTIP_CHAIN : STR_DEPOT_VEHICLE_TOOLTIP, 2, args, TCC_RIGHT_CLICK);
+
+		return true;
+	}
+
+	/**
+	 * Clones a vehicle
+	 * @param v the original vehicle to clone
+	 * @return Always true.
+	 */
+	virtual bool OnVehicleSelect(const Vehicle *v)
+	{
+		if (DoCommandP(this->window_number, v->index, _ctrl_pressed ? 1 : 0, CMD_CLONE_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_BUY_TRAIN + v->type), CcCloneVehicle)) {
+			ResetObjectToPlace();
+		}
+		return true;
+	}
+
+	virtual void OnPlaceObjectAbort()
+	{
+		/* abort clone */
+		this->RaiseWidget(WID_D_CLONE);
+		this->SetWidgetDirty(WID_D_CLONE);
+
+		/* abort drag & drop */
+		this->sel = INVALID_VEHICLE;
+		this->vehicle_over = INVALID_VEHICLE;
+		this->SetWidgetDirty(WID_D_MATRIX);
+	}
+
+	virtual void OnMouseDrag(Point pt, int widget)
+	{
+		if (this->type != VEH_TRAIN || this->sel == INVALID_VEHICLE) return;
+
+		/* A rail vehicle is dragged.. */
+		if (widget != WID_D_MATRIX) { // ..outside of the depot matrix.
+			if (this->vehicle_over != INVALID_VEHICLE) {
+				this->vehicle_over = INVALID_VEHICLE;
+				this->SetWidgetDirty(WID_D_MATRIX);
+			}
+			return;
+		}
+
+		NWidgetBase *matrix = this->GetWidget<NWidgetBase>(widget);
+		const Vehicle *v = NULL;
+		GetDepotVehiclePtData gdvp = {NULL, NULL};
+
+		if (this->GetVehicleFromDepotWndPt(pt.x - matrix->pos_x, pt.y - matrix->pos_y, &v, &gdvp) != MODE_DRAG_VEHICLE) return;
+
+		VehicleID new_vehicle_over = INVALID_VEHICLE;
+		if (gdvp.head != NULL) {
+			if (gdvp.wagon == NULL && gdvp.head->Last()->index != this->sel) { // ..at the end of the train.
+				/* NOTE: As a wagon can't be moved at the begin of a train, head index isn't used to mark a drag-and-drop
+				 * destination inside a train. This head index is then used to indicate that a wagon is inserted at
+				 * the end of the train.
+				 */
+				new_vehicle_over = gdvp.head->index;
+			} else if (gdvp.wagon != NULL && gdvp.head != gdvp.wagon &&
+					gdvp.wagon->index != this->sel &&
+					gdvp.wagon->Previous()->index != this->sel) { // ..over an existing wagon.
+				new_vehicle_over = gdvp.wagon->index;
+			}
+		}
+
+		if (this->vehicle_over == new_vehicle_over) return;
+
+		this->vehicle_over = new_vehicle_over;
+		this->SetWidgetDirty(widget);
+	}
+
+	virtual void OnDragDrop(Point pt, int widget)
+	{
+		switch (widget) {
+			case WID_D_MATRIX: {
+				const Vehicle *v = NULL;
+				VehicleID sel = this->sel;
+
+				this->sel = INVALID_VEHICLE;
+				this->SetDirty();
+
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(WID_D_MATRIX);
+				if (this->type == VEH_TRAIN) {
+					GetDepotVehiclePtData gdvp = { NULL, NULL };
+
+					if (this->GetVehicleFromDepotWndPt(pt.x - nwi->pos_x, pt.y - nwi->pos_y, &v, &gdvp) == MODE_DRAG_VEHICLE && sel != INVALID_VEHICLE) {
+						if (gdvp.wagon != NULL && gdvp.wagon->index == sel && _ctrl_pressed) {
+							DoCommandP(Vehicle::Get(sel)->tile, Vehicle::Get(sel)->index, true,
+									CMD_REVERSE_TRAIN_DIRECTION | CMD_MSG(STR_ERROR_CAN_T_REVERSE_DIRECTION_RAIL_VEHICLE));
+						} else if (gdvp.wagon == NULL || gdvp.wagon->index != sel) {
+							this->vehicle_over = INVALID_VEHICLE;
+							TrainDepotMoveVehicle(gdvp.wagon, sel, gdvp.head);
+						} else if (gdvp.head != NULL && gdvp.head->IsFrontEngine()) {
+							ShowVehicleViewWindow(gdvp.head);
+						}
+					}
+				} else if (this->GetVehicleFromDepotWndPt(pt.x - nwi->pos_x, pt.y - nwi->pos_y, &v, NULL) == MODE_DRAG_VEHICLE && v != NULL && sel == v->index) {
+					ShowVehicleViewWindow(v);
+				}
+				break;
+			}
+
+			case WID_D_SELL: case WID_D_SELL_CHAIN: {
+				if (this->IsWidgetDisabled(widget)) return;
+				if (this->sel == INVALID_VEHICLE) return;
+
+				this->HandleButtonClick(widget);
+
+				const Vehicle *v = Vehicle::Get(this->sel);
+				this->sel = INVALID_VEHICLE;
+				this->SetDirty();
+
+				int sell_cmd = (v->type == VEH_TRAIN && (widget == WID_D_SELL_CHAIN || _ctrl_pressed)) ? 1 : 0;
+				DoCommandP(v->tile, v->index | sell_cmd << 20 | MAKE_ORDER_BACKUP_FLAG, 0, GetCmdSellVeh(v->type));
+				break;
+			}
+
+			default:
+				this->sel = INVALID_VEHICLE;
+				this->SetDirty();
+		}
+		_cursor.vehchain = false;
+	}
+
+	virtual void OnTimeout()
+	{
+		if (!this->IsWidgetDisabled(WID_D_SELL)) {
+			this->RaiseWidget(WID_D_SELL);
+			this->SetWidgetDirty(WID_D_SELL);
+		}
+		if (this->nested_array[WID_D_SELL] != NULL && !this->IsWidgetDisabled(WID_D_SELL_CHAIN)) {
+			this->RaiseWidget(WID_D_SELL_CHAIN);
+			this->SetWidgetDirty(WID_D_SELL_CHAIN);
+		}
+	}
+
+	virtual void OnResize()
+	{
+		NWidgetCore *nwi = this->GetWidget<NWidgetCore>(WID_D_MATRIX);
+		this->vscroll->SetCapacityFromWidget(this, WID_D_MATRIX);
+		if (this->type == VEH_TRAIN) {
+			this->hscroll->SetCapacity(nwi->current_x - this->header_width - this->count_width);
+			nwi->widget_data = (this->vscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+		} else {
+			this->num_columns = nwi->current_x / nwi->resize_x;
+			nwi->widget_data = (this->vscroll->GetCapacity() << MAT_ROW_START) + (this->num_columns << MAT_COL_START);
+		}
+	}
+
+	virtual EventState OnCTRLStateChange()
+	{
+		if (this->sel != INVALID_VEHICLE) {
+			_cursor.vehchain = _ctrl_pressed;
+			this->SetWidgetDirty(WID_D_MATRIX);
+			return ES_HANDLED;
+		}
+
+		return ES_NOT_HANDLED;
+	}
+};
+
+static void DepotSellAllConfirmationCallback(Window *win, bool confirmed)
+{
+	if (confirmed) {
+		DepotWindow *w = (DepotWindow*)win;
+		TileIndex tile = w->window_number;
+		byte vehtype = w->type;
+		DoCommandP(tile, vehtype, 0, CMD_DEPOT_SELL_ALL_VEHICLES);
+	}
+}
+
+/**
+ * Opens a depot window
+ * @param tile The tile where the depot/hangar is located
+ * @param type The type of vehicles in the depot
+ */
+void ShowDepotWindow(TileIndex tile, VehicleType type)
+{
+	if (BringWindowToFrontById(WC_VEHICLE_DEPOT, tile) != NULL) return;
+
+	const WindowDesc *desc;
+	switch (type) {
+		default: NOT_REACHED();
+		case VEH_TRAIN:    desc = &_train_depot_desc;    break;
+		case VEH_ROAD:     desc = &_road_depot_desc;     break;
+		case VEH_SHIP:     desc = &_ship_depot_desc;     break;
+		case VEH_AIRCRAFT: desc = &_aircraft_depot_desc; break;
+	}
+
+	new DepotWindow(desc, tile, type);
+}
+
+/**
+ * Removes the highlight of a vehicle in a depot window
+ * @param *v Vehicle to remove all highlights from
+ */
+void DeleteDepotHighlightOfVehicle(const Vehicle *v)
+{
+	DepotWindow *w;
+
+	/* If we haven't got any vehicles on the mouse pointer, we haven't got any highlighted in any depots either
+	 * If that is the case, we can skip looping though the windows and save time
+	 */
+	if (_special_mouse_mode != WSM_DRAGDROP) return;
+
+	w = dynamic_cast<DepotWindow*>(FindWindowById(WC_VEHICLE_DEPOT, v->tile));
+	if (w != NULL) {
+		if (w->sel == v->index) ResetObjectToPlace();
+	}
+}
diff --git a/src/group_cmd.cpp b/src/group_cmd.cpp
index e86b9de..739bfb7 100644
--- a/src/group_cmd.cpp
+++ b/src/group_cmd.cpp
@@ -21,6 +21,7 @@
 #include "company_func.h"
 #include "core/pool_func.hpp"
 #include "order_backup.h"
+#include "aaa_template_vehicle.h"
 
 #include "table/strings.h"
 
@@ -135,6 +136,9 @@ void GroupStatistics::Clear()
  */
 /* static */ void GroupStatistics::CountVehicle(const Vehicle *v, int delta)
 {
+	/* make virtual trains group-neutral */
+	if ( HasBit(v->subtype, GVSF_VIRTUAL) ) return;
+
 	assert(delta == 1 || delta == -1);
 
 	GroupStatistics &stats_all = GroupStatistics::GetAllGroup(v);
@@ -330,6 +334,9 @@ CommandCost CmdDeleteGroup(TileIndex tile, DoCommandFlag flags, uint32 p1, uint3
 
 		VehicleType vt = g->vehicle_type;
 
+		/* Delete all template replacements using the just deleted group */
+		deleteIllegalTemplateReplacements(g->index);
+
 		/* Delete the Replace Vehicle Windows */
 		DeleteWindowById(WC_REPLACE_VEHICLE, g->vehicle_type);
 		delete g;
diff --git a/src/group_gui.cpp b/src/group_gui.cpp
index 3996ddc..6326c5b 100644
--- a/src/group_gui.cpp
+++ b/src/group_gui.cpp
@@ -30,6 +30,9 @@
 
 #include "table/sprites.h"
 
+// MYGUI_NOEND
+#include "aaa_template_gui_main.h"
+
 typedef GUIList<const Group*> GUIGroupList;
 
 static const NWidgetPart _nested_group_widgets[] = {
@@ -593,6 +596,7 @@ public:
 				this->vli.index = ALL_GROUP;
 
 				DoCommandP(0, group, 0, CMD_DELETE_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_DELETE));
+				InvalidateWindowData(WC_TEMPLATEGUI_MAIN, 0, 0, 0);
 				break;
 			}
 
@@ -673,6 +677,7 @@ public:
 	virtual void OnQueryTextFinished(char *str)
 	{
 		if (str != NULL) DoCommandP(0, this->group_rename, 0, CMD_RENAME_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_RENAME), NULL, str);
+		InvalidateWindowData(WC_TEMPLATEGUI_MAIN, 0, 0, 0);
 		this->group_rename = INVALID_GROUP;
 	}
 
@@ -698,6 +703,11 @@ public:
 				assert(this->vehicles.Length() != 0);
 
 				switch (index) {
+					case ADI_TEMPLATE_REPLACE: // TemplateReplace Window
+						if ( vli.vtype == VEH_TRAIN )
+							// TODO before we used vli.company in the main gui, maybe retrieve it here and pass it as param to the gui ?
+							ShowTemplateReplaceWindow(this->unitnumber_digits, this->resize.step_height);
+						break;
 					case ADI_REPLACE: // Replace window
 						ShowReplaceGroupVehicleWindow(this->vli.index, this->vli.vtype);
 						break;
diff --git a/src/group_gui.cpp.orig b/src/group_gui.cpp.orig
new file mode 100644
index 0000000..3996ddc
--- /dev/null
+++ b/src/group_gui.cpp.orig
@@ -0,0 +1,889 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file group_gui.cpp GUI for the group window. */
+
+#include "stdafx.h"
+#include "textbuf_gui.h"
+#include "command_func.h"
+#include "vehicle_gui.h"
+#include "vehicle_base.h"
+#include "string_func.h"
+#include "strings_func.h"
+#include "window_func.h"
+#include "vehicle_func.h"
+#include "autoreplace_gui.h"
+#include "company_func.h"
+#include "widgets/dropdown_func.h"
+#include "tilehighlight_func.h"
+#include "vehicle_gui_base.h"
+#include "core/geometry_func.hpp"
+#include "company_base.h"
+
+#include "widgets/group_widget.h"
+
+#include "table/sprites.h"
+
+typedef GUIList<const Group*> GUIGroupList;
+
+static const NWidgetPart _nested_group_widgets[] = {
+	NWidget(NWID_HORIZONTAL), // Window header
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_GL_CAPTION),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		/* left part */
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_PANEL, COLOUR_GREY), SetMinimalTextLines(1, WD_DROPDOWNTEXT_TOP + WD_DROPDOWNTEXT_BOTTOM), SetFill(1, 0), EndContainer(),
+			NWidget(WWT_PANEL, COLOUR_GREY, WID_GL_ALL_VEHICLES), SetFill(1, 0), EndContainer(),
+			NWidget(WWT_PANEL, COLOUR_GREY, WID_GL_DEFAULT_VEHICLES), SetFill(1, 0), EndContainer(),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_MATRIX, COLOUR_GREY, WID_GL_LIST_GROUP), SetDataTip(0x701, STR_GROUPS_CLICK_ON_GROUP_FOR_TOOLTIP),
+						SetFill(1, 0), SetResize(0, 1), SetScrollbar(WID_GL_LIST_GROUP_SCROLLBAR),
+				NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_GL_LIST_GROUP_SCROLLBAR),
+			EndContainer(),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_GL_CREATE_GROUP), SetFill(0, 1),
+						SetDataTip(SPR_GROUP_CREATE_TRAIN, STR_GROUP_CREATE_TOOLTIP),
+				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_GL_DELETE_GROUP), SetFill(0, 1),
+						SetDataTip(SPR_GROUP_DELETE_TRAIN, STR_GROUP_DELETE_TOOLTIP),
+				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_GL_RENAME_GROUP), SetFill(0, 1),
+						SetDataTip(SPR_GROUP_RENAME_TRAIN, STR_GROUP_RENAME_TOOLTIP),
+				NWidget(WWT_PANEL, COLOUR_GREY), SetFill(1, 1), EndContainer(),
+				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_GL_REPLACE_PROTECTION), SetFill(0, 1),
+						SetDataTip(SPR_GROUP_REPLACE_OFF_TRAIN, STR_GROUP_REPLACE_PROTECTION_TOOLTIP),
+			EndContainer(),
+		EndContainer(),
+		/* right part */
+		NWidget(NWID_VERTICAL),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_GL_SORT_BY_ORDER), SetMinimalSize(81, 12), SetDataTip(STR_BUTTON_SORT_BY, STR_TOOLTIP_SORT_ORDER),
+				NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_GL_SORT_BY_DROPDOWN), SetMinimalSize(167, 12), SetDataTip(0x0, STR_TOOLTIP_SORT_CRITERIA),
+				NWidget(WWT_PANEL, COLOUR_GREY), SetMinimalSize(12, 12), SetResize(1, 0), EndContainer(),
+			EndContainer(),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_MATRIX, COLOUR_GREY, WID_GL_LIST_VEHICLE), SetMinimalSize(248, 0), SetDataTip(0x701, STR_NULL), SetResize(1, 1), SetFill(1, 0), SetScrollbar(WID_GL_LIST_VEHICLE_SCROLLBAR),
+				NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_GL_LIST_VEHICLE_SCROLLBAR),
+			EndContainer(),
+			NWidget(WWT_PANEL, COLOUR_GREY), SetMinimalSize(1, 0), SetFill(1, 1), SetResize(1, 0), EndContainer(),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_GL_AVAILABLE_VEHICLES), SetMinimalSize(106, 12), SetFill(0, 1),
+						SetDataTip(STR_BLACK_STRING, STR_VEHICLE_LIST_AVAILABLE_ENGINES_TOOLTIP),
+				NWidget(WWT_PANEL, COLOUR_GREY), SetMinimalSize(0, 12), SetFill(1, 1), SetResize(1, 0), EndContainer(),
+				NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_GL_MANAGE_VEHICLES_DROPDOWN), SetMinimalSize(118, 12), SetFill(0, 1),
+						SetDataTip(STR_VEHICLE_LIST_MANAGE_LIST, STR_VEHICLE_LIST_MANAGE_LIST_TOOLTIP),
+				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_GL_STOP_ALL), SetMinimalSize(12, 12), SetFill(0, 1),
+						SetDataTip(SPR_FLAG_VEH_STOPPED, STR_VEHICLE_LIST_MASS_STOP_LIST_TOOLTIP),
+				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_GL_START_ALL), SetMinimalSize(12, 12), SetFill(0, 1),
+						SetDataTip(SPR_FLAG_VEH_RUNNING, STR_VEHICLE_LIST_MASS_START_LIST_TOOLTIP),
+				NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+			EndContainer(),
+		EndContainer(),
+	EndContainer(),
+};
+
+class VehicleGroupWindow : public BaseVehicleListWindow {
+private:
+	/* Columns in the group list */
+	enum ListColumns {
+		VGC_NAME,          ///< Group name.
+		VGC_PROTECT,       ///< Autoreplace protect icon.
+		VGC_AUTOREPLACE,   ///< Autoreplace active icon.
+		VGC_PROFIT,        ///< Profit icon.
+		VGC_NUMBER,        ///< Number of vehicles in the group.
+
+		VGC_END
+	};
+
+	VehicleID vehicle_sel; ///< Selected vehicle
+	GroupID group_rename;  ///< Group being renamed, INVALID_GROUP if none
+	GroupID group_over;    ///< Group over which a vehicle is dragged, INVALID_GROUP if none
+	GUIGroupList groups;   ///< List of groups
+	uint tiny_step_height; ///< Step height for the group list
+	Scrollbar *group_sb;
+
+	Dimension column_size[VGC_END]; ///< Size of the columns in the group list.
+
+	/**
+	 * (Re)Build the group list.
+	 *
+	 * @param owner The owner of the window
+	 */
+	void BuildGroupList(Owner owner)
+	{
+		if (!this->groups.NeedRebuild()) return;
+
+		this->groups.Clear();
+
+		const Group *g;
+		FOR_ALL_GROUPS(g) {
+			if (g->owner == owner && g->vehicle_type == this->vli.vtype) {
+				*this->groups.Append() = g;
+			}
+		}
+
+		this->groups.Compact();
+		this->groups.RebuildDone();
+	}
+
+	/** Sort the groups by their name */
+	static int CDECL GroupNameSorter(const Group * const *a, const Group * const *b)
+	{
+		static const Group *last_group[2] = { NULL, NULL };
+		static char         last_name[2][64] = { "", "" };
+
+		if (*a != last_group[0]) {
+			last_group[0] = *a;
+			SetDParam(0, (*a)->index);
+			GetString(last_name[0], STR_GROUP_NAME, lastof(last_name[0]));
+		}
+
+		if (*b != last_group[1]) {
+			last_group[1] = *b;
+			SetDParam(0, (*b)->index);
+			GetString(last_name[1], STR_GROUP_NAME, lastof(last_name[1]));
+		}
+
+		int r = strnatcmp(last_name[0], last_name[1]); // Sort by name (natural sorting).
+		if (r == 0) return (*a)->index - (*b)->index;
+		return r;
+	}
+
+	/**
+	 * Compute tiny_step_height and column_size
+	 * @return Total width required for the group list.
+	 */
+	uint ComputeGroupInfoSize()
+	{
+		this->column_size[VGC_NAME] = maxdim(GetStringBoundingBox(STR_GROUP_DEFAULT_TRAINS + this->vli.vtype), GetStringBoundingBox(STR_GROUP_ALL_TRAINS + this->vli.vtype));
+		this->column_size[VGC_NAME].width = max(170u, this->column_size[VGC_NAME].width);
+		this->tiny_step_height = this->column_size[VGC_NAME].height;
+
+		this->column_size[VGC_PROTECT] = GetSpriteSize(SPR_GROUP_REPLACE_PROTECT);
+		this->tiny_step_height = max(this->tiny_step_height, this->column_size[VGC_PROTECT].height);
+
+		this->column_size[VGC_AUTOREPLACE] = GetSpriteSize(SPR_GROUP_REPLACE_ACTIVE);
+		this->tiny_step_height = max(this->tiny_step_height, this->column_size[VGC_AUTOREPLACE].height);
+
+		this->column_size[VGC_PROFIT].width = 0;
+		this->column_size[VGC_PROFIT].height = 0;
+		static const SpriteID profit_sprites[] = {SPR_PROFIT_NA, SPR_PROFIT_NEGATIVE, SPR_PROFIT_SOME, SPR_PROFIT_LOT};
+		for (uint i = 0; i < lengthof(profit_sprites); i++) {
+			Dimension d = GetSpriteSize(profit_sprites[i]);
+			this->column_size[VGC_PROFIT] = maxdim(this->column_size[VGC_PROFIT], d);
+		}
+		this->tiny_step_height = max(this->tiny_step_height, this->column_size[VGC_PROFIT].height);
+
+		SetDParamMaxValue(0, GroupStatistics::Get(this->vli.company, ALL_GROUP, this->vli.vtype).num_vehicle, 3);
+		this->column_size[VGC_NUMBER] = GetStringBoundingBox(STR_TINY_COMMA);
+		this->tiny_step_height = max(this->tiny_step_height, this->column_size[VGC_NUMBER].height);
+
+		this->tiny_step_height += WD_MATRIX_TOP;
+
+		return WD_FRAMERECT_LEFT + 8 +
+			this->column_size[VGC_NAME].width + 8 +
+			this->column_size[VGC_PROTECT].width + 2 +
+			this->column_size[VGC_AUTOREPLACE].width + 2 +
+			this->column_size[VGC_PROFIT].width + 2 +
+			this->column_size[VGC_NUMBER].width + 2 +
+			WD_FRAMERECT_RIGHT;
+	}
+
+	/**
+	 * Draw a row in the group list.
+	 * @param y Top of the row.
+	 * @param left Left of the row.
+	 * @param right Right of the row.
+	 * @param g_id Group to list.
+	 * @param protection Whether autoreplace protection is set.
+	 */
+	void DrawGroupInfo(int y, int left, int right, GroupID g_id, bool protection = false) const
+	{
+		/* Highlight the group if a vehicle is dragged over it */
+		if (g_id == this->group_over) {
+			GfxFillRect(left + WD_FRAMERECT_LEFT, y + WD_FRAMERECT_TOP, right - WD_FRAMERECT_RIGHT, y + this->tiny_step_height - WD_FRAMERECT_BOTTOM - WD_MATRIX_TOP, _colour_gradient[COLOUR_GREY][7]);
+		}
+
+		if (g_id == NEW_GROUP) return;
+
+		/* draw the selected group in white, else we draw it in black */
+		TextColour colour = g_id == this->vli.index ? TC_WHITE : TC_BLACK;
+		const GroupStatistics &stats = GroupStatistics::Get(this->vli.company, g_id, this->vli.vtype);
+		bool rtl = _current_text_dir == TD_RTL;
+
+		/* draw group name */
+		StringID str;
+		if (IsAllGroupID(g_id)) {
+			str = STR_GROUP_ALL_TRAINS + this->vli.vtype;
+		} else if (IsDefaultGroupID(g_id)) {
+			str = STR_GROUP_DEFAULT_TRAINS + this->vli.vtype;
+		} else {
+			SetDParam(0, g_id);
+			str = STR_GROUP_NAME;
+		}
+		int x = rtl ? right - WD_FRAMERECT_RIGHT - 8 - this->column_size[VGC_NAME].width + 1 : left + WD_FRAMERECT_LEFT + 8;
+		DrawString(x, x + this->column_size[VGC_NAME].width - 1, y + (this->tiny_step_height - this->column_size[VGC_NAME].height) / 2, str, colour);
+
+		/* draw autoreplace protection */
+		x = rtl ? x - 8 - this->column_size[VGC_PROTECT].width : x + 8 + this->column_size[VGC_NAME].width;
+		if (protection) DrawSprite(SPR_GROUP_REPLACE_PROTECT, PAL_NONE, x, y + (this->tiny_step_height - this->column_size[VGC_PROTECT].height) / 2);
+
+		/* draw autoreplace status */
+		x = rtl ? x - 2 - this->column_size[VGC_AUTOREPLACE].width : x + 2 + this->column_size[VGC_PROTECT].width;
+		if (stats.autoreplace_defined) DrawSprite(SPR_GROUP_REPLACE_ACTIVE, stats.autoreplace_finished ? PALETTE_CRASH : PAL_NONE, x, y + (this->tiny_step_height - this->column_size[VGC_AUTOREPLACE].height) / 2);
+
+		/* draw the profit icon */
+		x = rtl ? x - 2 - this->column_size[VGC_PROFIT].width : x + 2 + this->column_size[VGC_AUTOREPLACE].width;
+		SpriteID spr;
+		if (stats.num_profit_vehicle == 0) {
+			spr = SPR_PROFIT_NA;
+		} else if (stats.profit_last_year < 0) {
+			spr = SPR_PROFIT_NEGATIVE;
+		} else if (stats.profit_last_year < 10000 * stats.num_profit_vehicle) { // TODO magic number
+			spr = SPR_PROFIT_SOME;
+		} else {
+			spr = SPR_PROFIT_LOT;
+		}
+		DrawSprite(spr, PAL_NONE, x, y + (this->tiny_step_height - this->column_size[VGC_PROFIT].height) / 2);
+
+		/* draw the number of vehicles of the group */
+		x = rtl ? x - 2 - this->column_size[VGC_NUMBER].width : x + 2 + this->column_size[VGC_PROFIT].width;
+		SetDParam(0, stats.num_vehicle);
+		DrawString(x, x + this->column_size[VGC_NUMBER].width - 1, y + (this->tiny_step_height - this->column_size[VGC_NUMBER].height) / 2, STR_TINY_COMMA, colour, SA_RIGHT | SA_FORCE);
+	}
+
+	/**
+	 * Mark the widget containing the currently highlighted group as dirty.
+	 */
+	void DirtyHighlightedGroupWidget()
+	{
+		if (this->group_over == INVALID_GROUP) return;
+
+		if (IsAllGroupID(this->group_over)) {
+			this->SetWidgetDirty(WID_GL_ALL_VEHICLES);
+		} else if (IsDefaultGroupID(this->group_over)) {
+			this->SetWidgetDirty(WID_GL_DEFAULT_VEHICLES);
+		} else {
+			this->SetWidgetDirty(WID_GL_LIST_GROUP);
+		}
+	}
+
+public:
+	VehicleGroupWindow(const WindowDesc *desc, WindowNumber window_number) : BaseVehicleListWindow(window_number)
+	{
+		this->CreateNestedTree(desc);
+
+		this->vscroll = this->GetScrollbar(WID_GL_LIST_VEHICLE_SCROLLBAR);
+		this->group_sb = this->GetScrollbar(WID_GL_LIST_GROUP_SCROLLBAR);
+
+		switch (this->vli.vtype) {
+			default: NOT_REACHED();
+			case VEH_TRAIN:    this->sorting = &_sorting.train;    break;
+			case VEH_ROAD:     this->sorting = &_sorting.roadveh;  break;
+			case VEH_SHIP:     this->sorting = &_sorting.ship;     break;
+			case VEH_AIRCRAFT: this->sorting = &_sorting.aircraft; break;
+		}
+
+		this->vli.index = ALL_GROUP;
+		this->vehicle_sel = INVALID_VEHICLE;
+		this->group_rename = INVALID_GROUP;
+		this->group_over = INVALID_GROUP;
+
+		this->vehicles.SetListing(*this->sorting);
+		this->vehicles.ForceRebuild();
+		this->vehicles.NeedResort();
+
+		this->BuildVehicleList();
+		this->SortVehicleList();
+
+		this->groups.ForceRebuild();
+		this->groups.NeedResort();
+		this->BuildGroupList(vli.company);
+		this->groups.Sort(&GroupNameSorter);
+
+		this->GetWidget<NWidgetCore>(WID_GL_CAPTION)->widget_data = STR_VEHICLE_LIST_TRAIN_CAPTION + this->vli.vtype;
+		this->GetWidget<NWidgetCore>(WID_GL_LIST_VEHICLE)->tool_tip = STR_VEHICLE_LIST_TRAIN_LIST_TOOLTIP + this->vli.vtype;
+
+		this->GetWidget<NWidgetCore>(WID_GL_CREATE_GROUP)->widget_data += this->vli.vtype;
+		this->GetWidget<NWidgetCore>(WID_GL_RENAME_GROUP)->widget_data += this->vli.vtype;
+		this->GetWidget<NWidgetCore>(WID_GL_DELETE_GROUP)->widget_data += this->vli.vtype;
+		this->GetWidget<NWidgetCore>(WID_GL_REPLACE_PROTECTION)->widget_data += this->vli.vtype;
+
+		this->FinishInitNested(desc, window_number);
+		this->owner = vli.company;
+	}
+
+	~VehicleGroupWindow()
+	{
+		*this->sorting = this->vehicles.GetListing();
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case WID_GL_LIST_GROUP: {
+				size->width = this->ComputeGroupInfoSize();
+				resize->height = this->tiny_step_height;
+
+				/* Minimum height is the height of the list widget minus all and default vehicles... */
+				size->height =  4 * GetVehicleListHeight(this->vli.vtype, this->tiny_step_height) - 2 * this->tiny_step_height;
+
+				/* ... minus the buttons at the bottom ... */
+				uint max_icon_height = GetSpriteSize(this->GetWidget<NWidgetCore>(WID_GL_CREATE_GROUP)->widget_data).height;
+				max_icon_height = max(max_icon_height, GetSpriteSize(this->GetWidget<NWidgetCore>(WID_GL_RENAME_GROUP)->widget_data).height);
+				max_icon_height = max(max_icon_height, GetSpriteSize(this->GetWidget<NWidgetCore>(WID_GL_DELETE_GROUP)->widget_data).height);
+				max_icon_height = max(max_icon_height, GetSpriteSize(this->GetWidget<NWidgetCore>(WID_GL_REPLACE_PROTECTION)->widget_data).height);
+
+				/* Get a multiple of tiny_step_height of that amount */
+				size->height = Ceil(size->height - max_icon_height, tiny_step_height);
+				break;
+			}
+
+			case WID_GL_ALL_VEHICLES:
+			case WID_GL_DEFAULT_VEHICLES:
+				size->width = this->ComputeGroupInfoSize();
+				size->height = this->tiny_step_height;
+				break;
+
+			case WID_GL_SORT_BY_ORDER: {
+				Dimension d = GetStringBoundingBox(this->GetWidget<NWidgetCore>(widget)->widget_data);
+				d.width += padding.width + WD_SORTBUTTON_ARROW_WIDTH * 2; // Doubled since the string is centred and it also looks better.
+				d.height += padding.height;
+				*size = maxdim(*size, d);
+				break;
+			}
+
+			case WID_GL_LIST_VEHICLE:
+				this->ComputeGroupInfoSize();
+				resize->height = GetVehicleListHeight(this->vli.vtype, this->tiny_step_height);
+				size->height = 4 * resize->height;
+				break;
+
+			case WID_GL_MANAGE_VEHICLES_DROPDOWN: {
+				Dimension d = this->GetActionDropdownSize(true, true);
+				d.height += padding.height;
+				d.width  += padding.width;
+				*size = maxdim(*size, d);
+				break;
+			}
+		}
+	}
+
+	/**
+	 * Some data on this window has become invalid.
+	 * @param data Information about the changed data.
+	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+	 */
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		if (data == 0) {
+			/* This needs to be done in command-scope to enforce rebuilding before resorting invalid data */
+			this->vehicles.ForceRebuild();
+			this->groups.ForceRebuild();
+		} else {
+			this->vehicles.ForceResort();
+			this->groups.ForceResort();
+		}
+
+		/* Process ID-invalidation in command-scope as well */
+		if (this->group_rename != INVALID_GROUP && !Group::IsValidID(this->group_rename)) {
+			DeleteWindowByClass(WC_QUERY_STRING);
+			this->group_rename = INVALID_GROUP;
+		}
+
+		if (!(IsAllGroupID(this->vli.index) || IsDefaultGroupID(this->vli.index) || Group::IsValidID(this->vli.index))) {
+			this->vli.index = ALL_GROUP;
+			HideDropDownMenu(this);
+		}
+		this->SetDirty();
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			case WID_GL_AVAILABLE_VEHICLES:
+				SetDParam(0, STR_VEHICLE_LIST_AVAILABLE_TRAINS + this->vli.vtype);
+				break;
+
+			case WID_GL_CAPTION:
+				/* If selected_group == DEFAULT_GROUP || ALL_GROUP, draw the standard caption
+				 * We list all vehicles or ungrouped vehicles */
+				if (IsDefaultGroupID(this->vli.index) || IsAllGroupID(this->vli.index)) {
+					SetDParam(0, STR_COMPANY_NAME);
+					SetDParam(1, this->vli.company);
+					SetDParam(2, this->vehicles.Length());
+					SetDParam(3, this->vehicles.Length());
+				} else {
+					const Group *g = Group::Get(this->vli.index);
+
+					SetDParam(0, STR_GROUP_NAME);
+					SetDParam(1, g->index);
+					SetDParam(2, g->statistics.num_vehicle);
+					SetDParam(3, g->statistics.num_vehicle);
+				}
+				break;
+		}
+	}
+
+	virtual void OnPaint()
+	{
+		/* If we select the all vehicles, this->list will contain all vehicles of the owner
+		 * else this->list will contain all vehicles which belong to the selected group */
+		this->BuildVehicleList();
+		this->SortVehicleList();
+
+		this->BuildGroupList(this->owner);
+		this->groups.Sort(&GroupNameSorter);
+
+		this->group_sb->SetCount(this->groups.Length());
+		this->vscroll->SetCount(this->vehicles.Length());
+
+		/* The drop down menu is out, *but* it may not be used, retract it. */
+		if (this->vehicles.Length() == 0 && this->IsWidgetLowered(WID_GL_MANAGE_VEHICLES_DROPDOWN)) {
+			this->RaiseWidget(WID_GL_MANAGE_VEHICLES_DROPDOWN);
+			HideDropDownMenu(this);
+		}
+
+		/* Disable all lists management button when the list is empty */
+		this->SetWidgetsDisabledState(this->vehicles.Length() == 0 || _local_company != this->vli.company,
+				WID_GL_STOP_ALL,
+				WID_GL_START_ALL,
+				WID_GL_MANAGE_VEHICLES_DROPDOWN,
+				WIDGET_LIST_END);
+
+		/* Disable the group specific function when we select the default group or all vehicles */
+		this->SetWidgetsDisabledState(IsDefaultGroupID(this->vli.index) || IsAllGroupID(this->vli.index) || _local_company != this->vli.company,
+				WID_GL_DELETE_GROUP,
+				WID_GL_RENAME_GROUP,
+				WID_GL_REPLACE_PROTECTION,
+				WIDGET_LIST_END);
+
+		/* Disable remaining buttons for non-local companies
+		 * Needed while changing _local_company, eg. by cheats
+		 * All procedures (eg. move vehicle to another group)
+		 *  verify, whether you are the owner of the vehicle,
+		 *  so it doesn't have to be disabled
+		 */
+		this->SetWidgetsDisabledState(_local_company != this->vli.company,
+				WID_GL_CREATE_GROUP,
+				WID_GL_AVAILABLE_VEHICLES,
+				WIDGET_LIST_END);
+
+		/* If not a default group and the group has replace protection, show an enabled replace sprite. */
+		uint16 protect_sprite = SPR_GROUP_REPLACE_OFF_TRAIN;
+		if (!IsDefaultGroupID(this->vli.index) && !IsAllGroupID(this->vli.index) && Group::Get(this->vli.index)->replace_protection) protect_sprite = SPR_GROUP_REPLACE_ON_TRAIN;
+		this->GetWidget<NWidgetCore>(WID_GL_REPLACE_PROTECTION)->widget_data = protect_sprite + this->vli.vtype;
+
+		/* Set text of sort by dropdown */
+		this->GetWidget<NWidgetCore>(WID_GL_SORT_BY_DROPDOWN)->widget_data = this->vehicle_sorter_names[this->vehicles.SortType()];
+
+		this->DrawWidgets();
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch (widget) {
+			case WID_GL_ALL_VEHICLES:
+				DrawGroupInfo(r.top + WD_FRAMERECT_TOP, r.left, r.right, ALL_GROUP);
+				break;
+
+			case WID_GL_DEFAULT_VEHICLES:
+				DrawGroupInfo(r.top + WD_FRAMERECT_TOP, r.left, r.right, DEFAULT_GROUP);
+				break;
+
+			case WID_GL_LIST_GROUP: {
+				int y1 = r.top + WD_FRAMERECT_TOP;
+				int max = min(this->group_sb->GetPosition() + this->group_sb->GetCapacity(), this->groups.Length());
+				for (int i = this->group_sb->GetPosition(); i < max; ++i) {
+					const Group *g = this->groups[i];
+
+					assert(g->owner == this->owner);
+
+					DrawGroupInfo(y1, r.left, r.right, g->index, g->replace_protection);
+
+					y1 += this->tiny_step_height;
+				}
+				if ((uint)this->group_sb->GetPosition() + this->group_sb->GetCapacity() > this->groups.Length()) {
+					DrawGroupInfo(y1, r.left, r.right, NEW_GROUP);
+				}
+				break;
+			}
+
+			case WID_GL_SORT_BY_ORDER:
+				this->DrawSortButtonState(WID_GL_SORT_BY_ORDER, this->vehicles.IsDescSortOrder() ? SBS_DOWN : SBS_UP);
+				break;
+
+			case WID_GL_LIST_VEHICLE:
+				this->DrawVehicleListItems(this->vehicle_sel, this->resize.step_height, r);
+				break;
+		}
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch (widget) {
+			case WID_GL_SORT_BY_ORDER: // Flip sorting method ascending/descending
+				this->vehicles.ToggleSortOrder();
+				this->SetDirty();
+				break;
+
+			case WID_GL_SORT_BY_DROPDOWN: // Select sorting criteria dropdown menu
+				ShowDropDownMenu(this, this->vehicle_sorter_names, this->vehicles.SortType(),  WID_GL_SORT_BY_DROPDOWN, 0, (this->vli.vtype == VEH_TRAIN || this->vli.vtype == VEH_ROAD) ? 0 : (1 << 10));
+				return;
+
+			case WID_GL_ALL_VEHICLES: // All vehicles button
+				if (!IsAllGroupID(this->vli.index)) {
+					this->vli.index = ALL_GROUP;
+					this->vehicles.ForceRebuild();
+					this->SetDirty();
+				}
+				break;
+
+			case WID_GL_DEFAULT_VEHICLES: // Ungrouped vehicles button
+				if (!IsDefaultGroupID(this->vli.index)) {
+					this->vli.index = DEFAULT_GROUP;
+					this->vehicles.ForceRebuild();
+					this->SetDirty();
+				}
+				break;
+
+			case WID_GL_LIST_GROUP: { // Matrix Group
+				uint id_g = this->group_sb->GetScrolledRowFromWidget(pt.y, this, WID_GL_LIST_GROUP, 0, this->tiny_step_height);
+				if (id_g >= this->groups.Length()) return;
+
+				this->vli.index = this->groups[id_g]->index;
+
+				this->vehicles.ForceRebuild();
+				this->SetDirty();
+				break;
+			}
+
+			case WID_GL_LIST_VEHICLE: { // Matrix Vehicle
+				uint id_v = this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_GL_LIST_VEHICLE);
+				if (id_v >= this->vehicles.Length()) return; // click out of list bound
+
+				const Vehicle *v = this->vehicles[id_v];
+				if (VehicleClicked(v)) break;
+
+				this->vehicle_sel = v->index;
+
+				int image = v->GetImage(_current_text_dir == TD_RTL ? DIR_E : DIR_W, EIT_IN_LIST);
+				SetObjectToPlaceWnd(image, GetVehiclePalette(v), HT_DRAG, this);
+				_cursor.vehchain = true;
+
+				this->SetDirty();
+				break;
+			}
+
+			case WID_GL_CREATE_GROUP: { // Create a new group
+				DoCommandP(0, this->vli.vtype, 0, CMD_CREATE_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_CREATE), CcCreateGroup);
+				break;
+			}
+
+			case WID_GL_DELETE_GROUP: { // Delete the selected group
+				GroupID group = this->vli.index;
+				this->vli.index = ALL_GROUP;
+
+				DoCommandP(0, group, 0, CMD_DELETE_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_DELETE));
+				break;
+			}
+
+			case WID_GL_RENAME_GROUP: // Rename the selected roup
+				this->ShowRenameGroupWindow(this->vli.index, false);
+				break;
+
+			case WID_GL_AVAILABLE_VEHICLES:
+				ShowBuildVehicleWindow(INVALID_TILE, this->vli.vtype);
+				break;
+
+			case WID_GL_MANAGE_VEHICLES_DROPDOWN: {
+				DropDownList *list = this->BuildActionDropdownList(true, Group::IsValidID(this->vli.index));
+				ShowDropDownList(this, list, 0, WID_GL_MANAGE_VEHICLES_DROPDOWN);
+				break;
+			}
+
+			case WID_GL_START_ALL:
+			case WID_GL_STOP_ALL: { // Start/stop all vehicles of the list
+				DoCommandP(0, (1 << 1) | (widget == WID_GL_START_ALL ? (1 << 0) : 0), this->vli.Pack(), CMD_MASS_START_STOP);
+				break;
+			}
+
+			case WID_GL_REPLACE_PROTECTION: {
+				const Group *g = Group::GetIfValid(this->vli.index);
+				if (g != NULL) {
+					DoCommandP(0, this->vli.index, !g->replace_protection, CMD_SET_GROUP_REPLACE_PROTECTION);
+				}
+				break;
+			}
+		}
+	}
+
+	virtual void OnDragDrop(Point pt, int widget)
+	{
+		switch (widget) {
+			case WID_GL_DEFAULT_VEHICLES: // Ungrouped vehicles
+				DoCommandP(0, DEFAULT_GROUP, this->vehicle_sel | (_ctrl_pressed ? 1 << 31 : 0), CMD_ADD_VEHICLE_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_ADD_VEHICLE));
+
+				this->vehicle_sel = INVALID_VEHICLE;
+				this->group_over = INVALID_GROUP;
+
+				this->SetDirty();
+				break;
+
+			case WID_GL_LIST_GROUP: { // Matrix group
+				const VehicleID vindex = this->vehicle_sel;
+				this->vehicle_sel = INVALID_VEHICLE;
+				this->group_over = INVALID_GROUP;
+				this->SetDirty();
+
+				uint id_g = this->group_sb->GetScrolledRowFromWidget(pt.y, this, WID_GL_LIST_GROUP, 0, this->tiny_step_height);
+				GroupID new_g = id_g >= this->groups.Length() ? NEW_GROUP : this->groups[id_g]->index;
+
+				DoCommandP(0, new_g, vindex | (_ctrl_pressed ? 1 << 31 : 0), CMD_ADD_VEHICLE_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_ADD_VEHICLE), new_g == NEW_GROUP ? CcAddVehicleNewGroup : NULL);
+				break;
+			}
+
+			case WID_GL_LIST_VEHICLE: { // Matrix vehicle
+				const VehicleID vindex = this->vehicle_sel;
+				this->vehicle_sel = INVALID_VEHICLE;
+				this->group_over = INVALID_GROUP;
+				this->SetDirty();
+
+				uint id_v = this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_GL_LIST_VEHICLE);
+				if (id_v >= this->vehicles.Length()) return; // click out of list bound
+
+				const Vehicle *v = this->vehicles[id_v];
+				if (!VehicleClicked(v) && vindex == v->index) {
+					ShowVehicleViewWindow(v);
+				}
+				break;
+			}
+		}
+		_cursor.vehchain = false;
+	}
+
+	virtual void OnQueryTextFinished(char *str)
+	{
+		if (str != NULL) DoCommandP(0, this->group_rename, 0, CMD_RENAME_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_RENAME), NULL, str);
+		this->group_rename = INVALID_GROUP;
+	}
+
+	virtual void OnResize()
+	{
+		NWidgetCore *nwi = this->GetWidget<NWidgetCore>(WID_GL_LIST_GROUP);
+		this->group_sb->SetCapacity(nwi->current_y / this->tiny_step_height);
+		nwi->widget_data = (this->group_sb->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+
+		nwi = this->GetWidget<NWidgetCore>(WID_GL_LIST_VEHICLE);
+		this->vscroll->SetCapacityFromWidget(this, WID_GL_LIST_VEHICLE);
+		nwi->widget_data = (this->vscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		switch (widget) {
+			case WID_GL_SORT_BY_DROPDOWN:
+				this->vehicles.SetSortType(index);
+				break;
+
+			case WID_GL_MANAGE_VEHICLES_DROPDOWN:
+				assert(this->vehicles.Length() != 0);
+
+				switch (index) {
+					case ADI_REPLACE: // Replace window
+						ShowReplaceGroupVehicleWindow(this->vli.index, this->vli.vtype);
+						break;
+					case ADI_SERVICE: // Send for servicing
+					case ADI_DEPOT: { // Send to Depots
+						DoCommandP(0, DEPOT_MASS_SEND | (index == ADI_SERVICE ? DEPOT_SERVICE : 0U), this->vli.Pack(), GetCmdSendToDepot(this->vli.vtype));
+						break;
+					}
+
+					case ADI_ADD_SHARED: // Add shared Vehicles
+						assert(Group::IsValidID(this->vli.index));
+
+						DoCommandP(0, this->vli.index, this->vli.vtype, CMD_ADD_SHARED_VEHICLE_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_ADD_SHARED_VEHICLE));
+						break;
+					case ADI_REMOVE_ALL: // Remove all Vehicles from the selected group
+						assert(Group::IsValidID(this->vli.index));
+
+						DoCommandP(0, this->vli.index, 0, CMD_REMOVE_ALL_VEHICLES_GROUP | CMD_MSG(STR_ERROR_GROUP_CAN_T_REMOVE_ALL_VEHICLES));
+						break;
+					default: NOT_REACHED();
+				}
+				break;
+
+			default: NOT_REACHED();
+		}
+
+		this->SetDirty();
+	}
+
+	virtual void OnTick()
+	{
+		if (_pause_mode != PM_UNPAUSED) return;
+		if (this->groups.NeedResort() || this->vehicles.NeedResort()) {
+			this->SetDirty();
+		}
+	}
+
+	virtual void OnPlaceObjectAbort()
+	{
+		/* abort drag & drop */
+		this->vehicle_sel = INVALID_VEHICLE;
+		this->DirtyHighlightedGroupWidget();
+		this->group_over = INVALID_GROUP;
+		this->SetWidgetDirty(WID_GL_LIST_VEHICLE);
+	}
+
+	virtual void OnMouseDrag(Point pt, int widget)
+	{
+		if (this->vehicle_sel == INVALID_VEHICLE) return;
+
+		/* A vehicle is dragged over... */
+		GroupID new_group_over = INVALID_GROUP;
+		switch (widget) {
+			case WID_GL_DEFAULT_VEHICLES: // ... the 'default' group.
+				new_group_over = DEFAULT_GROUP;
+				break;
+
+			case WID_GL_LIST_GROUP: { // ... the list of custom groups.
+				uint id_g = this->group_sb->GetScrolledRowFromWidget(pt.y, this, WID_GL_LIST_GROUP, 0, this->tiny_step_height);
+				new_group_over = id_g >= this->groups.Length() ? NEW_GROUP : this->groups[id_g]->index;
+				break;
+			}
+		}
+
+		/* Do not highlight when dragging over the current group */
+		if (Vehicle::Get(vehicle_sel)->group_id == new_group_over) new_group_over = INVALID_GROUP;
+
+		/* Mark widgets as dirty if the group changed. */
+		if (new_group_over != this->group_over) {
+			this->DirtyHighlightedGroupWidget();
+			this->group_over = new_group_over;
+			this->DirtyHighlightedGroupWidget();
+		}
+	}
+
+	void ShowRenameGroupWindow(GroupID group, bool empty)
+	{
+		assert(Group::IsValidID(group));
+		this->group_rename = group;
+		/* Show empty query for new groups */
+		StringID str = STR_EMPTY;
+		if (!empty) {
+			SetDParam(0, group);
+			str = STR_GROUP_NAME;
+		}
+		ShowQueryString(str, STR_GROUP_RENAME_CAPTION, MAX_LENGTH_GROUP_NAME_CHARS, this, CS_ALPHANUMERAL, QSF_ENABLE_DEFAULT | QSF_LEN_IN_CHARS);
+	}
+
+	/**
+	 * Tests whether a given vehicle is selected in the window, and unselects it if necessary.
+	 * Called when the vehicle is deleted.
+	 * @param vehicle Vehicle that is going to be deleted
+	 */
+	void UnselectVehicle(VehicleID vehicle)
+	{
+		if (this->vehicle_sel == vehicle) ResetObjectToPlace();
+	}
+};
+
+
+static WindowDesc _other_group_desc(
+	WDP_AUTO, 460, 246,
+	WC_INVALID, WC_NONE,
+	0,
+	_nested_group_widgets, lengthof(_nested_group_widgets)
+);
+
+static const WindowDesc _train_group_desc(
+	WDP_AUTO, 525, 246,
+	WC_TRAINS_LIST, WC_NONE,
+	0,
+	_nested_group_widgets, lengthof(_nested_group_widgets)
+);
+
+/**
+ * Show the group window for the given company and vehicle type.
+ * @param company The company to show the window for.
+ * @param vehicle_type The type of vehicle to show it for.
+ */
+void ShowCompanyGroup(CompanyID company, VehicleType vehicle_type)
+{
+	if (!Company::IsValidID(company)) return;
+
+	WindowNumber num = VehicleListIdentifier(VL_GROUP_LIST, vehicle_type, company).Pack();
+	if (vehicle_type == VEH_TRAIN) {
+		AllocateWindowDescFront<VehicleGroupWindow>(&_train_group_desc, num);
+	} else {
+		_other_group_desc.cls = GetWindowClassForVehicleType(vehicle_type);
+		AllocateWindowDescFront<VehicleGroupWindow>(&_other_group_desc, num);
+	}
+}
+
+/**
+ * Finds a group list window determined by vehicle type and owner
+ * @param vt vehicle type
+ * @param owner owner of groups
+ * @return pointer to VehicleGroupWindow, NULL if not found
+ */
+static inline VehicleGroupWindow *FindVehicleGroupWindow(VehicleType vt, Owner owner)
+{
+	return (VehicleGroupWindow *)FindWindowById(GetWindowClassForVehicleType(vt), VehicleListIdentifier(VL_GROUP_LIST, vt, owner).Pack());
+}
+
+/**
+ * Opens a 'Rename group' window for newly created group
+ * @param success did command succeed?
+ * @param tile unused
+ * @param p1 vehicle type
+ * @param p2 unused
+ * @see CmdCreateGroup
+ */
+void CcCreateGroup(const CommandCost &result, TileIndex tile, uint32 p1, uint32 p2)
+{
+	if (result.Failed()) return;
+	assert(p1 <= VEH_AIRCRAFT);
+
+	VehicleGroupWindow *w = FindVehicleGroupWindow((VehicleType)p1, _current_company);
+	if (w != NULL) w->ShowRenameGroupWindow(_new_group_id, true);
+}
+
+/**
+ * Open rename window after adding a vehicle to a new group via drag and drop.
+ * @param success Did command succeed?
+ * @param tile Unused.
+ * @param p1 Unused.
+ * @param p2 Bit 0-19: Vehicle ID.
+ */
+void CcAddVehicleNewGroup(const CommandCost &result, TileIndex tile, uint32 p1, uint32 p2)
+{
+	if (result.Failed()) return;
+	assert(Vehicle::IsValidID(GB(p2, 0, 20)));
+
+	CcCreateGroup(result, 0, Vehicle::Get(GB(p2, 0, 20))->type, 0);
+}
+
+/**
+ * Removes the highlight of a vehicle in a group window
+ * @param *v Vehicle to remove all highlights from
+ */
+void DeleteGroupHighlightOfVehicle(const Vehicle *v)
+{
+	/* If we haven't got any vehicles on the mouse pointer, we haven't got any highlighted in any group windows either
+	 * If that is the case, we can skip looping though the windows and save time
+	 */
+	if (_special_mouse_mode != WSM_DRAGDROP) return;
+
+	VehicleGroupWindow *w = FindVehicleGroupWindow(v->type, v->owner);
+	if (w != NULL) w->UnselectVehicle(v->index);
+}
diff --git a/src/lang/english.txt b/src/lang/english.txt
index beb6652..88e4cc7 100644
--- a/src/lang/english.txt
+++ b/src/lang/english.txt
@@ -4731,3 +4731,62 @@ STR_PLANE                                                       :{BLACK}{PLANE}
 STR_SHIP                                                        :{BLACK}{SHIP}
 
 STR_TOOLBAR_RAILTYPE_VELOCITY                                   :{STRING} ({VELOCITY})
+
+STR_TMPL_RPL_TITLE												:{WHITE}Template Replacement
+STR_TMPL_TEMPLATE_REPLACEMENT									:Template Replacement
+STR_TMPL_TRAINS_IN_GROUP										:{BLACK}Trains in group
+STR_TMPL_AVAILABLE_TEMPLATES									:{BLACK}Available Templates
+STR_TMPL_DEFINE_TEMPLATE										:{BLACK}New
+STR_TMPL_EDIT_TEMPLATE											:{BLACK}Edit
+STR_TMPL_CREATE_CLONE_VEH										:{BLACK}Clone
+STR_TMPL_DELETE_TEMPLATE										:{BLACK}Delete
+STR_TMPL_RPL_ALL_TMPL											:{BLACK}Replace All Templates
+STR_TMPL_NEW_VEHICLE											:{BLACK}New Vehicle
+STR_TMPL_CONFIRM												:{BLACK}Ok
+STR_TMPL_CANCEL													:{BLACK}Cancel
+STR_TMPL_NEW													:{BLACK}New Template Vehicle
+STR_TMPL_REFIT													:{BLACK}Refit
+STR_TMPL_GROUP_INFO												:{BLACK}Group Info: {ORANGE}
+STR_TMPL_TEMPLATE_INFO											:{BLACK}Template Info: {ORANGE}
+STR_TMPL_RPL_START												:{BLACK}Start replacing
+STR_TMPL_RPL_STOP												:{BLACK}Stop replacing
+STR_TMPL_TRAIN_OVR_VALUE										:{TINY_FONT}{BLACK}Train Value: {CURRENCY_SHORT}
+STR_TMPL_TEMPLATE_OVR_VALUE										:{TINY_FONT}{BLACK}Buying Cost: {GOLD}{CURRENCY_LONG}
+STR_TMPL_TEMPLATE_OVR_VALUE_nogold								:{TINY_FONT}{BLACK}Buying Cost: {CURRENCY_LONG}
+STR_TMPL_TEMPLATE_OVR_VALUE_nogoldandcurrency					:{TINY_FONT}{BLACK}Buying Cost:
+STR_TMPL_TEMPLATE_OVR_VALUE_notinyfont							:{BLACK}Buying Cost: {GOLD}{CURRENCY_LONG}
+STR_TMPL_TEMPLATE_OVR_VALUE_notinyfontandblack					:Buying Cost: {GOLD}{CURRENCY_LONG}
+STR_TMPL_WARNING_FREE_WAGON										:{RED}Free Chain: not runnable!
+STR_TMPL_TEST													:{ORANGE}Test String: {RAW_STRING} {RAW_STRING}
+STR_TMPL_GROUP_USES_TEMPLATE									:{BLACK}Template in use: {NUM}
+STR_TMP_TEMPLATE_IN_USE											:Template is in use
+STR_TMPL_GROUP_NUM_TRAINS										:{BLACK}{NUM}
+STR_TMPL_CREATEGUI_TITLE										:{WHITE}Create/Edit Template Vehicle
+STR_TMPL_MAINGUI_DEFINEDGROUPS									:{BLACK}Defined Groups for Company
+STR_TMPL_TMPLRPL_EX_DIFF_RAILTYPE								:Uses Template of different rail type
+
+STR_TMPL_SET_USEDEPOT											:{BLACK}Use vehicles in depot
+STR_TMPL_SET_USEDEPOT_TIP										:{BLACK}Use vehicles inside the depot that are in a neutral and idle state to compose trains on template replacement in order to reduce buying costs
+STR_TMPL_SET_KEEPREMAINDERS										:{BLACK}Keep remainders
+STR_TMPL_SET_KEEPREMAINDERS_TIP									:{BLACK}After finishing template replacement keep all remaining vehicles from the old train in a neutral and idle state for later use
+STR_TMPL_SET_REFIT												:{BLACK}Use Refit
+STR_TMPL_SET_REFIT_TIP											:{BLACK}If set, the train will use exactly the cargo refit specified by the template. If not every wagon that is to be newly bought or retrieved from the depot, will *attempt* to be refitted as the old one was. Standard refit if this is impossible.
+
+STR_TMPL_CONFIG_USEDEPOT										:use depot
+STR_TMPL_CONFIG_KEEPREMAINDERS									:keep rem
+STR_TMPL_CONFIG_REFIT											:refit
+
+STR_TMPL_NUM_TRAINS_NEED_RPL									:# trains to replace:
+
+STR_TMPL_CARGO_SUMMARY											:{CARGO_LONG}
+STR_TMPL_CARGO_SUMMARY_MULTI									:{CARGO_LONG} (x{NUM})
+
+STR_TMPL_RPLALLGUI_TITLE										:{WHITE}Replace all Templace Vehicles
+STR_TMPL_RPLALLGUI_INSET_TOP									:{BLACK}Choose Vehicle Type and Replacement
+STR_TMPL_RPLALLGUI_INSET_TOP_1									:{BLACK}Template Engines
+STR_TMPL_RPLALLGUI_INSET_TOP_2									:{BLACK}Buyable Engines
+STR_TMPL_RPLALLGUI_INSET_BOTTOM									:{BLACK}Current Template List (updated only after replacement)
+STR_TMPL_RPLALLGUI_BUTTON_RPLALL								:{BLACK}Replace All
+STR_TMPL_RPLALLGUI_BUTTON_APPLY									:{BLACK}Apply
+STR_TMPL_RPLALLGUI_BUTTON_CANCEL								:{BLACK}Cancel
+STR_TMPL_RPLALLGUI_USE_TIP										:{BLACK}Select a vehicle type from each list and press 'Replace All'. If you are happy with the result displayed in the template list, press 'Apply' to actually apply these changes.
\ No newline at end of file
diff --git a/src/newgrf.h b/src/newgrf.h
index 9058aea..7692069 100644
--- a/src/newgrf.h
+++ b/src/newgrf.h
@@ -195,4 +195,6 @@ bool GetGlobalVariable(byte param, uint32 *value, const GRFFile *grffile);
 StringID MapGRFStringID(uint32 grfid, StringID str);
 void ShowNewGRFError();
 
+struct TemplateVehicle;
+
 #endif /* NEWGRF_H */
diff --git a/src/newgrf.h.orig b/src/newgrf.h.orig
new file mode 100644
index 0000000..9058aea
--- /dev/null
+++ b/src/newgrf.h.orig
@@ -0,0 +1,198 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file newgrf.h Base for the NewGRF implementation. */
+
+#ifndef NEWGRF_H
+#define NEWGRF_H
+
+#include "cargotype.h"
+#include "rail_type.h"
+#include "fileio_type.h"
+#include "core/bitmath_func.hpp"
+#include "core/alloc_type.hpp"
+#include "core/smallvec_type.hpp"
+
+/**
+ * List of different canal 'features'.
+ * Each feature gets an entry in the canal spritegroup table
+ */
+enum CanalFeature {
+	CF_WATERSLOPE,
+	CF_LOCKS,
+	CF_DIKES,
+	CF_ICON,
+	CF_DOCKS,
+	CF_RIVER_SLOPE,
+	CF_RIVER_EDGE,
+	CF_RIVER_GUI,
+	CF_BUOY,
+	CF_END,
+};
+
+/** Canal properties local to the NewGRF */
+struct CanalProperties {
+	uint8 callback_mask;  ///< Bitmask of canal callbacks that have to be called.
+	uint8 flags;          ///< Flags controlling display.
+};
+
+enum GrfLoadingStage {
+	GLS_FILESCAN,
+	GLS_SAFETYSCAN,
+	GLS_LABELSCAN,
+	GLS_INIT,
+	GLS_RESERVE,
+	GLS_ACTIVATION,
+	GLS_END,
+};
+
+DECLARE_POSTFIX_INCREMENT(GrfLoadingStage)
+
+enum GrfMiscBit {
+	GMB_DESERT_TREES_FIELDS    = 0, // Unsupported.
+	GMB_DESERT_PAVED_ROADS     = 1,
+	GMB_FIELD_BOUNDING_BOX     = 2, // Unsupported.
+	GMB_TRAIN_WIDTH_32_PIXELS  = 3, ///< Use 32 pixels per train vehicle in depot gui and vehicle details. Never set in the global variable; @see GRFFile::traininfo_vehicle_width
+	GMB_AMBIENT_SOUND_CALLBACK = 4,
+	GMB_CATENARY_ON_3RD_TRACK  = 5, // Unsupported.
+};
+
+enum GrfSpecFeature {
+	GSF_TRAINS,
+	GSF_ROADVEHICLES,
+	GSF_SHIPS,
+	GSF_AIRCRAFT,
+	GSF_STATIONS,
+	GSF_CANALS,
+	GSF_BRIDGES,
+	GSF_HOUSES,
+	GSF_GLOBALVAR,
+	GSF_INDUSTRYTILES,
+	GSF_INDUSTRIES,
+	GSF_CARGOES,
+	GSF_SOUNDFX,
+	GSF_AIRPORTS,
+	GSF_SIGNALS,
+	GSF_OBJECTS,
+	GSF_RAILTYPES,
+	GSF_AIRPORTTILES,
+	GSF_END,
+
+	GSF_FAKE_TOWNS = GSF_END, ///< Fake town GrfSpecFeature for NewGRF debugging (parent scope)
+	GSF_FAKE_END,             ///< End of the fake features
+
+	GSF_INVALID = 0xFF,       ///< An invalid spec feature
+};
+
+static const uint32 INVALID_GRFID = 0xFFFFFFFF;
+
+struct GRFLabel {
+	byte label;
+	uint32 nfo_line;
+	size_t pos;
+	struct GRFLabel *next;
+};
+
+/** Dynamic data of a loaded NewGRF */
+struct GRFFile : ZeroedMemoryAllocator {
+	char *filename;
+	bool is_ottdfile;
+	uint32 grfid;
+	byte grf_version;
+
+	uint sound_offset;
+	uint16 num_sounds;
+
+	struct StationSpec **stations;
+	struct HouseSpec **housespec;
+	struct IndustrySpec **industryspec;
+	struct IndustryTileSpec **indtspec;
+	struct ObjectSpec **objectspec;
+	struct AirportSpec **airportspec;
+	struct AirportTileSpec **airtspec;
+
+	uint32 param[0x80];
+	uint param_end;  ///< one more than the highest set parameter
+
+	GRFLabel *label; ///< Pointer to the first label. This is a linked list, not an array.
+
+	SmallVector<CargoLabel, 4> cargo_list;          ///< Cargo translation table (local ID -> label)
+	uint8 cargo_map[NUM_CARGO];                     ///< Inverse cargo translation table (CargoID -> local ID)
+
+	SmallVector<RailTypeLabel, 4> railtype_list;    ///< Railtype translation table
+	RailType railtype_map[RAILTYPE_END];
+
+	CanalProperties canal_local_properties[CF_END]; ///< Canal properties as set by this NewGRF
+
+	struct LanguageMap *language_map; ///< Mappings related to the languages.
+
+	int traininfo_vehicle_pitch;  ///< Vertical offset for draing train images in depot GUI and vehicle details
+	uint traininfo_vehicle_width; ///< Width (in pixels) of a 8/8 train vehicle in depot GUI and vehicle details
+
+	uint32 grf_features;                     ///< Bitset of GrfSpecFeature the grf uses
+	PriceMultipliers price_base_multipliers; ///< Price base multipliers as set by the grf.
+
+	GRFFile(const struct GRFConfig *config);
+	~GRFFile();
+
+	/** Get GRF Parameter with range checking */
+	uint32 GetParam(uint number) const
+	{
+		/* Note: We implicitly test for number < lengthof(this->param) and return 0 for invalid parameters.
+		 *       In fact this is the more important test, as param is zeroed anyway. */
+		assert(this->param_end <= lengthof(this->param));
+		return (number < this->param_end) ? this->param[number] : 0;
+	}
+};
+
+enum ShoreReplacement {
+	SHORE_REPLACE_NONE,       ///< No shore sprites were replaced.
+	SHORE_REPLACE_ACTION_5,   ///< Shore sprites were replaced by Action5.
+	SHORE_REPLACE_ACTION_A,   ///< Shore sprites were replaced by ActionA (using grass tiles for the corner-shores).
+	SHORE_REPLACE_ONLY_NEW,   ///< Only corner-shores were loaded by Action5 (openttd(w/d).grf only).
+};
+
+struct GRFLoadedFeatures {
+	bool has_2CC;             ///< Set if any vehicle is loaded which uses 2cc (two company colours).
+	uint64 used_liveries;     ///< Bitmask of #LiveryScheme used by the defined engines.
+	bool has_newhouses;       ///< Set if there are any newhouses loaded.
+	bool has_newindustries;   ///< Set if there are any newindustries loaded.
+	ShoreReplacement shore;   ///< It which way shore sprites were replaced.
+};
+
+/**
+ * Check for grf miscellaneous bits
+ * @param bit The bit to check.
+ * @return Whether the bit is set.
+ */
+static inline bool HasGrfMiscBit(GrfMiscBit bit)
+{
+	extern byte _misc_grf_features;
+	return HasBit(_misc_grf_features, bit);
+}
+
+/* Indicates which are the newgrf features currently loaded ingame */
+extern GRFLoadedFeatures _loaded_newgrf_features;
+
+byte GetGRFContainerVersion();
+
+void LoadNewGRFFile(struct GRFConfig *config, uint file_index, GrfLoadingStage stage, Subdirectory subdir);
+void LoadNewGRF(uint load_index, uint file_index);
+void ReloadNewGRFData(); // in saveload/afterload.cpp
+void ResetNewGRFData();
+void ResetPersistentNewGRFData();
+
+void CDECL grfmsg(int severity, const char *str, ...) WARN_FORMAT(2, 3);
+
+bool GetGlobalVariable(byte param, uint32 *value, const GRFFile *grffile);
+
+StringID MapGRFStringID(uint32 grfid, StringID str);
+void ShowNewGRFError();
+
+#endif /* NEWGRF_H */
diff --git a/src/newgrf_engine.cpp b/src/newgrf_engine.cpp
index 0c2e190..3cbe0e1 100644
--- a/src/newgrf_engine.cpp
+++ b/src/newgrf_engine.cpp
@@ -905,7 +905,6 @@ static uint32 VehicleGetVariable(Vehicle *v, const VehicleScopeResolver *object,
 	return VehicleGetVariable(const_cast<Vehicle*>(this->v), this, variable, parameter, available);
 }
 
-
 /* virtual */ const SpriteGroup *VehicleResolverObject::ResolveReal(const RealSpriteGroup *group) const
 {
 	const Vehicle *v = this->self_scope.v;
@@ -1045,6 +1044,10 @@ SpriteID GetRotorOverrideSprite(EngineID engine, const Aircraft *v, bool info_vi
 	return group->GetResult() + (info_view ? 0 : (v->Next()->Next()->state % group->GetNumResults()));
 }
 
+void NewVehicleResolverWrapper(ResolverObject *res, EngineID eid)
+{
+	NewVehicleResolver(res, eid, 0);
+}
 
 /**
  * Check if a wagon is currently using a wagon override
@@ -1307,3 +1310,114 @@ void FillNewGRFVehicleCache(const Vehicle *v)
 	/* Make sure really all bits are set. */
 	assert(v->grf_cache.cache_valid == (1 << NCVV_END) - 1);
 }
+
+// TODO MYGUI
+/*
+uint16 SimulateLengthCallback(EngineID eid) {
+	Engine *e = Engine::Get(eid);
+
+	// callback stuff
+	const SpriteGroup *group;
+	ResolverObject object;
+
+	// setup the newvehicleresolver
+	object.GetRandomBits = &VehicleGetRandomBits;
+	object.GetTriggers   = &VehicleGetTriggers;
+	object.SetTriggers   = &VehicleSetTriggers;
+	object.GetVariable   = &VehicleGetVariable;
+	object.ResolveReal   = &VehicleResolveReal;
+	object.u.vehicle.self   = 0;
+	object.u.vehicle.parent = 0;
+	object.u.vehicle.self_type = eid;
+ 	object.u.vehicle.info_view = false;
+	object.ResetState();
+	object.grffile         = (e != NULL ? e->grf_prop.grffile : NULL);
+
+	// more setup from train_cmd.cpp
+	object.callback        = CBID_VEHICLE_LENGTH;
+	object.callback_param1 = 0;
+	object.callback_param2 = 0;
+
+	group = e->grf_prop.spritegroup[CT_DEFAULT];
+	group = SpriteGroup::Resolve(group, &object);
+
+	if (group == NULL) return CALLBACK_FAILED;
+	return group->GetCallbackResult();
+}
+
+
+
+SpriteID GetTemplateImage(EngineID eid, uint8 sprnum) {
+	uint8 spritenum = sprnum;
+	SpriteID sprite;
+
+	//if (HasBit(tv->flags, VRF_REVERSE_DIRECTION)) direction = ReverseDir(direction);
+
+	if (is_custom_sprite(spritenum)) {
+		const SpriteGroup *group;
+
+		ResolverObject object;
+		// resolver
+		object.GetRandomBits = &VehicleGetRandomBits;
+		object.GetTriggers   = &VehicleGetTriggers;
+		object.SetTriggers   = &VehicleSetTriggers;
+		object.GetVariable   = &VehicleGetVariable;
+		object.ResolveReal   = &VehicleResolveReal;
+		object.u.vehicle.self   = 0;
+		object.u.vehicle.parent = 0;
+		object.u.vehicle.self_type = eid;
+		object.u.vehicle.info_view = false;
+		object.callback        = CBID_NO_CALLBACK;
+		object.callback_param1 = 0;
+		object.callback_param2 = 0;
+		object.ResetState();
+		const Engine *e = Engine::Get(eid);
+		object.grffile         = (e != NULL ? e->grf_prop.grffile : NULL);
+
+		group = SpriteGroup::Resolve(e->grf_prop.spritegroup[CT_DEFAULT], &object);
+		if (group == NULL || group->GetNumResults() == 0) sprite=0;
+		sprite = group->GetResult() + (DIR_W % group->GetNumResults());
+
+		if (sprite != 0) return sprite;
+
+		spritenum = Engine::Get(eid)->original_image_index;
+	}
+	//sprite = GetDefaultTrainSprite(spritenum, direction);
+};*/
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+// TODO
+
diff --git a/src/newgrf_engine.cpp.orig b/src/newgrf_engine.cpp.orig
new file mode 100644
index 0000000..0c2e190
--- /dev/null
+++ b/src/newgrf_engine.cpp.orig
@@ -0,0 +1,1309 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file newgrf_engine.cpp NewGRF handling of engines. */
+
+#include "stdafx.h"
+#include "debug.h"
+#include "train.h"
+#include "roadveh.h"
+#include "company_func.h"
+#include "newgrf_cargo.h"
+#include "newgrf_spritegroup.h"
+#include "date_func.h"
+#include "vehicle_func.h"
+#include "core/random_func.hpp"
+#include "aircraft.h"
+#include "station_base.h"
+#include "company_base.h"
+#include "newgrf_railtype.h"
+#include "ship.h"
+
+struct WagonOverride {
+	EngineID *train_id;
+	uint trains;
+	CargoID cargo;
+	const SpriteGroup *group;
+};
+
+void SetWagonOverrideSprites(EngineID engine, CargoID cargo, const SpriteGroup *group, EngineID *train_id, uint trains)
+{
+	Engine *e = Engine::Get(engine);
+	WagonOverride *wo;
+
+	assert(cargo < NUM_CARGO + 2); // Include CT_DEFAULT and CT_PURCHASE pseudo cargoes.
+
+	e->overrides_count++;
+	e->overrides = ReallocT(e->overrides, e->overrides_count);
+
+	wo = &e->overrides[e->overrides_count - 1];
+	wo->group = group;
+	wo->cargo = cargo;
+	wo->trains = trains;
+	wo->train_id = MallocT<EngineID>(trains);
+	memcpy(wo->train_id, train_id, trains * sizeof *train_id);
+}
+
+const SpriteGroup *GetWagonOverrideSpriteSet(EngineID engine, CargoID cargo, EngineID overriding_engine)
+{
+	const Engine *e = Engine::Get(engine);
+
+	/* XXX: This could turn out to be a timesink on profiles. We could
+	 * always just dedicate 65535 bytes for an [engine][train] trampoline
+	 * for O(1). Or O(logMlogN) and searching binary tree or smt. like
+	 * that. --pasky */
+
+	for (uint i = 0; i < e->overrides_count; i++) {
+		const WagonOverride *wo = &e->overrides[i];
+
+		if (wo->cargo != cargo && wo->cargo != CT_DEFAULT) continue;
+
+		for (uint j = 0; j < wo->trains; j++) {
+			if (wo->train_id[j] == overriding_engine) return wo->group;
+		}
+	}
+	return NULL;
+}
+
+/**
+ * Unload all wagon override sprite groups.
+ */
+void UnloadWagonOverrides(Engine *e)
+{
+	for (uint i = 0; i < e->overrides_count; i++) {
+		WagonOverride *wo = &e->overrides[i];
+		free(wo->train_id);
+	}
+	free(e->overrides);
+	e->overrides_count = 0;
+	e->overrides = NULL;
+}
+
+
+void SetCustomEngineSprites(EngineID engine, byte cargo, const SpriteGroup *group)
+{
+	Engine *e = Engine::Get(engine);
+	assert(cargo < lengthof(e->grf_prop.spritegroup));
+
+	if (e->grf_prop.spritegroup[cargo] != NULL) {
+		grfmsg(6, "SetCustomEngineSprites: engine %d cargo %d already has group -- replacing", engine, cargo);
+	}
+	e->grf_prop.spritegroup[cargo] = group;
+}
+
+
+/**
+ * Tie a GRFFile entry to an engine, to allow us to retrieve GRF parameters
+ * etc during a game.
+ * @param engine Engine ID to tie the GRFFile to.
+ * @param file   Pointer of GRFFile to tie.
+ */
+void SetEngineGRF(EngineID engine, const GRFFile *file)
+{
+	Engine *e = Engine::Get(engine);
+	e->grf_prop.grffile = file;
+}
+
+
+static int MapOldSubType(const Vehicle *v)
+{
+	switch (v->type) {
+		case VEH_TRAIN:
+			if (Train::From(v)->IsEngine()) return 0;
+			if (Train::From(v)->IsFreeWagon()) return 4;
+			return 2;
+		case VEH_ROAD:
+		case VEH_SHIP:     return 0;
+		case VEH_AIRCRAFT:
+		case VEH_DISASTER: return v->subtype;
+		case VEH_EFFECT:   return v->subtype << 1;
+		default: NOT_REACHED();
+	}
+}
+
+
+/* TTDP style aircraft movement states for GRF Action 2 Var 0xE2 */
+enum TTDPAircraftMovementStates {
+	AMS_TTDP_HANGAR,
+	AMS_TTDP_TO_HANGAR,
+	AMS_TTDP_TO_PAD1,
+	AMS_TTDP_TO_PAD2,
+	AMS_TTDP_TO_PAD3,
+	AMS_TTDP_TO_ENTRY_2_AND_3,
+	AMS_TTDP_TO_ENTRY_2_AND_3_AND_H,
+	AMS_TTDP_TO_JUNCTION,
+	AMS_TTDP_LEAVE_RUNWAY,
+	AMS_TTDP_TO_INWAY,
+	AMS_TTDP_TO_RUNWAY,
+	AMS_TTDP_TO_OUTWAY,
+	AMS_TTDP_WAITING,
+	AMS_TTDP_TAKEOFF,
+	AMS_TTDP_TO_TAKEOFF,
+	AMS_TTDP_CLIMBING,
+	AMS_TTDP_FLIGHT_APPROACH,
+	AMS_TTDP_UNUSED_0x11,
+	AMS_TTDP_FLIGHT_TO_TOWER,
+	AMS_TTDP_UNUSED_0x13,
+	AMS_TTDP_FLIGHT_FINAL,
+	AMS_TTDP_FLIGHT_DESCENT,
+	AMS_TTDP_BRAKING,
+	AMS_TTDP_HELI_TAKEOFF_AIRPORT,
+	AMS_TTDP_HELI_TO_TAKEOFF_AIRPORT,
+	AMS_TTDP_HELI_LAND_AIRPORT,
+	AMS_TTDP_HELI_TAKEOFF_HELIPORT,
+	AMS_TTDP_HELI_TO_TAKEOFF_HELIPORT,
+	AMS_TTDP_HELI_LAND_HELIPORT,
+};
+
+
+/**
+ * Map OTTD aircraft movement states to TTDPatch style movement states
+ * (VarAction 2 Variable 0xE2)
+ */
+static byte MapAircraftMovementState(const Aircraft *v)
+{
+	const Station *st = GetTargetAirportIfValid(v);
+	if (st == NULL) return AMS_TTDP_FLIGHT_TO_TOWER;
+
+	const AirportFTAClass *afc = st->airport.GetFTA();
+	uint16 amdflag = afc->MovingData(v->pos)->flag;
+
+	switch (v->state) {
+		case HANGAR:
+			/* The international airport is a special case as helicopters can land in
+			 * front of the hanger. Helicopters also change their air.state to
+			 * AMED_HELI_LOWER some time before actually descending. */
+
+			/* This condition only occurs for helicopters, during descent,
+			 * to a landing by the hanger of an international airport. */
+			if (amdflag & AMED_HELI_LOWER) return AMS_TTDP_HELI_LAND_AIRPORT;
+
+			/* This condition only occurs for helicopters, before starting descent,
+			 * to a landing by the hanger of an international airport. */
+			if (amdflag & AMED_SLOWTURN) return AMS_TTDP_FLIGHT_TO_TOWER;
+
+			/* The final two conditions apply to helicopters or aircraft.
+			 * Has reached hanger? */
+			if (amdflag & AMED_EXACTPOS) return AMS_TTDP_HANGAR;
+
+			/* Still moving towards hanger. */
+			return AMS_TTDP_TO_HANGAR;
+
+		case TERM1:
+			if (amdflag & AMED_EXACTPOS) return AMS_TTDP_TO_PAD1;
+			return AMS_TTDP_TO_JUNCTION;
+
+		case TERM2:
+			if (amdflag & AMED_EXACTPOS) return AMS_TTDP_TO_PAD2;
+			return AMS_TTDP_TO_ENTRY_2_AND_3_AND_H;
+
+		case TERM3:
+		case TERM4:
+		case TERM5:
+		case TERM6:
+		case TERM7:
+		case TERM8:
+			/* TTDPatch only has 3 terminals, so treat these states the same */
+			if (amdflag & AMED_EXACTPOS) return AMS_TTDP_TO_PAD3;
+			return AMS_TTDP_TO_ENTRY_2_AND_3_AND_H;
+
+		case HELIPAD1:
+		case HELIPAD2:
+		case HELIPAD3:
+			/* Will only occur for helicopters.*/
+			if (amdflag & AMED_HELI_LOWER) return AMS_TTDP_HELI_LAND_AIRPORT; // Descending.
+			if (amdflag & AMED_SLOWTURN)   return AMS_TTDP_FLIGHT_TO_TOWER;   // Still hasn't started descent.
+			return AMS_TTDP_TO_JUNCTION; // On the ground.
+
+		case TAKEOFF: // Moving to takeoff position.
+			return AMS_TTDP_TO_OUTWAY;
+
+		case STARTTAKEOFF: // Accelerating down runway.
+			return AMS_TTDP_TAKEOFF;
+
+		case ENDTAKEOFF: // Ascent
+			return AMS_TTDP_CLIMBING;
+
+		case HELITAKEOFF: // Helicopter is moving to take off position.
+			if (afc->delta_z == 0) {
+				return amdflag & AMED_HELI_RAISE ?
+					AMS_TTDP_HELI_TAKEOFF_AIRPORT : AMS_TTDP_TO_JUNCTION;
+			} else {
+				return AMS_TTDP_HELI_TAKEOFF_HELIPORT;
+			}
+
+		case FLYING:
+			return amdflag & AMED_HOLD ? AMS_TTDP_FLIGHT_APPROACH : AMS_TTDP_FLIGHT_TO_TOWER;
+
+		case LANDING: // Descent
+			return AMS_TTDP_FLIGHT_DESCENT;
+
+		case ENDLANDING: // On the runway braking
+			if (amdflag & AMED_BRAKE) return AMS_TTDP_BRAKING;
+			/* Landed - moving off runway */
+			return AMS_TTDP_TO_INWAY;
+
+		case HELILANDING:
+		case HELIENDLANDING: // Helicoptor is decending.
+			if (amdflag & AMED_HELI_LOWER) {
+				return afc->delta_z == 0 ?
+					AMS_TTDP_HELI_LAND_AIRPORT : AMS_TTDP_HELI_LAND_HELIPORT;
+			} else {
+				return AMS_TTDP_FLIGHT_TO_TOWER;
+			}
+
+		default:
+			return AMS_TTDP_HANGAR;
+	}
+}
+
+
+/* TTDP style aircraft movement action for GRF Action 2 Var 0xE6 */
+enum TTDPAircraftMovementActions {
+	AMA_TTDP_IN_HANGAR,
+	AMA_TTDP_ON_PAD1,
+	AMA_TTDP_ON_PAD2,
+	AMA_TTDP_ON_PAD3,
+	AMA_TTDP_HANGAR_TO_PAD1,
+	AMA_TTDP_HANGAR_TO_PAD2,
+	AMA_TTDP_HANGAR_TO_PAD3,
+	AMA_TTDP_LANDING_TO_PAD1,
+	AMA_TTDP_LANDING_TO_PAD2,
+	AMA_TTDP_LANDING_TO_PAD3,
+	AMA_TTDP_PAD1_TO_HANGAR,
+	AMA_TTDP_PAD2_TO_HANGAR,
+	AMA_TTDP_PAD3_TO_HANGAR,
+	AMA_TTDP_PAD1_TO_TAKEOFF,
+	AMA_TTDP_PAD2_TO_TAKEOFF,
+	AMA_TTDP_PAD3_TO_TAKEOFF,
+	AMA_TTDP_HANGAR_TO_TAKOFF,
+	AMA_TTDP_LANDING_TO_HANGAR,
+	AMA_TTDP_IN_FLIGHT,
+};
+
+
+/**
+ * Map OTTD aircraft movement states to TTDPatch style movement actions
+ * (VarAction 2 Variable 0xE6)
+ * This is not fully supported yet but it's enough for Planeset.
+ */
+static byte MapAircraftMovementAction(const Aircraft *v)
+{
+	switch (v->state) {
+		case HANGAR:
+			return (v->cur_speed > 0) ? AMA_TTDP_LANDING_TO_HANGAR : AMA_TTDP_IN_HANGAR;
+
+		case TERM1:
+		case HELIPAD1:
+			return (v->current_order.IsType(OT_LOADING)) ? AMA_TTDP_ON_PAD1 : AMA_TTDP_LANDING_TO_PAD1;
+
+		case TERM2:
+		case HELIPAD2:
+			return (v->current_order.IsType(OT_LOADING)) ? AMA_TTDP_ON_PAD2 : AMA_TTDP_LANDING_TO_PAD2;
+
+		case TERM3:
+		case TERM4:
+		case TERM5:
+		case TERM6:
+		case TERM7:
+		case TERM8:
+		case HELIPAD3:
+			return (v->current_order.IsType(OT_LOADING)) ? AMA_TTDP_ON_PAD3 : AMA_TTDP_LANDING_TO_PAD3;
+
+		case TAKEOFF:      // Moving to takeoff position
+		case STARTTAKEOFF: // Accelerating down runway
+		case ENDTAKEOFF:   // Ascent
+		case HELITAKEOFF:
+			/* @todo Need to find which terminal (or hanger) we've come from. How? */
+			return AMA_TTDP_PAD1_TO_TAKEOFF;
+
+		case FLYING:
+			return AMA_TTDP_IN_FLIGHT;
+
+		case LANDING:    // Descent
+		case ENDLANDING: // On the runway braking
+		case HELILANDING:
+		case HELIENDLANDING:
+			/* @todo Need to check terminal we're landing to. Is it known yet? */
+			return (v->current_order.IsType(OT_GOTO_DEPOT)) ?
+				AMA_TTDP_LANDING_TO_HANGAR : AMA_TTDP_LANDING_TO_PAD1;
+
+		default:
+			return AMA_TTDP_IN_HANGAR;
+	}
+}
+
+
+/* virtual */ uint32 VehicleScopeResolver::GetRandomBits() const
+{
+	return this->v == NULL ? 0 : this->v->random_bits;
+}
+
+/* virtual */ uint32 VehicleScopeResolver::GetTriggers() const
+{
+	return this->v == NULL ? 0 : this->v->waiting_triggers;
+}
+
+/* virtual */ void VehicleScopeResolver::SetTriggers(int triggers) const
+{
+	/* Evil cast to get around const-ness. This used to be achieved by an
+	 * innocent looking function pointer cast... Currently I cannot see a
+	 * way of avoiding this without removing consts deep within gui code.
+	 */
+	Vehicle *v = const_cast<Vehicle *>(this->v);
+
+	/* This function must only be called when processing triggers -- any
+	 * other time is an error. */
+	assert(this->ro->trigger != 0);
+
+	if (v != NULL) v->waiting_triggers = triggers;
+}
+
+
+/* virtual */ ScopeResolver *VehicleResolverObject::GetScope(VarSpriteGroupScope scope, byte relative)
+{
+	switch (scope) {
+		case VSG_SCOPE_SELF:   return &this->self_scope;
+		case VSG_SCOPE_PARENT: return &this->parent_scope;
+		case VSG_SCOPE_RELATIVE: {
+			int32 count = GB(relative, 0, 4);
+			if (this->self_scope.v != NULL && (relative != this->cached_relative_count || count == 0)) {
+				/* Note: This caching only works as long as the VSG_SCOPE_RELATIVE cannot be used in
+				 *       VarAct2 with procedure calls. */
+				if (count == 0) count = GetRegister(0x100);
+
+				const Vehicle *v = NULL;
+				switch (GB(relative, 6, 2)) {
+					default: NOT_REACHED();
+					case 0x00: // count back (away from the engine), starting at this vehicle
+						v = this->self_scope.v;
+						break;
+					case 0x01: // count forward (toward the engine), starting at this vehicle
+						v = this->self_scope.v;
+						count = -count;
+						break;
+					case 0x02: // count back, starting at the engine
+						v = this->parent_scope.v;
+						break;
+					case 0x03: { // count back, starting at the first vehicle in this chain of vehicles with the same ID, as for vehicle variable 41
+						const Vehicle *self = this->self_scope.v;
+						for (const Vehicle *u = self->First(); u != self; u = u->Next()) {
+							if (u->engine_type != self->engine_type) {
+								v = NULL;
+							} else {
+								if (v == NULL) v = u;
+							}
+						}
+						if (v == NULL) v = self;
+						break;
+					}
+				}
+				this->relative_scope.SetVehicle(v->Move(count));
+			}
+			return &this->relative_scope;
+		}
+		default: return ResolverObject::GetScope(scope, relative);
+	}
+}
+
+/**
+ * Determines the livery of an engine.
+ *
+ * This always uses dual company colours independent of GUI settings. So it is desync-safe.
+ *
+ * @param engine Engine type
+ * @param v Vehicle, NULL in purchase list.
+ * @return Livery to use
+ */
+static const Livery *LiveryHelper(EngineID engine, const Vehicle *v)
+{
+	const Livery *l;
+
+	if (v == NULL) {
+		if (!Company::IsValidID(_current_company)) return NULL;
+		l = GetEngineLivery(engine, _current_company, INVALID_ENGINE, NULL, LIT_ALL);
+	} else if (v->IsGroundVehicle()) {
+		l = GetEngineLivery(v->engine_type, v->owner, v->GetGroundVehicleCache()->first_engine, v, LIT_ALL);
+	} else {
+		l = GetEngineLivery(v->engine_type, v->owner, INVALID_ENGINE, v, LIT_ALL);
+	}
+
+	return l;
+}
+
+/**
+ * Helper to get the position of a vehicle within a chain of vehicles.
+ * @param v the vehicle to get the position of.
+ * @param consecutive whether to look at the whole chain or the vehicles
+ *                    with the same 'engine type'.
+ * @return the position in the chain from front and tail and chain length.
+ */
+static uint32 PositionHelper(const Vehicle *v, bool consecutive)
+{
+	const Vehicle *u;
+	byte chain_before = 0;
+	byte chain_after  = 0;
+
+	for (u = v->First(); u != v; u = u->Next()) {
+		chain_before++;
+		if (consecutive && u->engine_type != v->engine_type) chain_before = 0;
+	}
+
+	while (u->Next() != NULL && (!consecutive || u->Next()->engine_type == v->engine_type)) {
+		chain_after++;
+		u = u->Next();
+	}
+
+	return chain_before | chain_after << 8 | (chain_before + chain_after + consecutive) << 16;
+}
+
+static uint32 VehicleGetVariable(Vehicle *v, const VehicleScopeResolver *object, byte variable, uint32 parameter, bool *available)
+{
+	/* Calculated vehicle parameters */
+	switch (variable) {
+		case 0x25: // Get engine GRF ID
+			return v->GetGRFID();
+
+		case 0x40: // Get length of consist
+			if (!HasBit(v->grf_cache.cache_valid, NCVV_POSITION_CONSIST_LENGTH)) {
+				v->grf_cache.position_consist_length = PositionHelper(v, false);
+				SetBit(v->grf_cache.cache_valid, NCVV_POSITION_CONSIST_LENGTH);
+			}
+			return v->grf_cache.position_consist_length;
+
+		case 0x41: // Get length of same consecutive wagons
+			if (!HasBit(v->grf_cache.cache_valid, NCVV_POSITION_SAME_ID_LENGTH)) {
+				v->grf_cache.position_same_id_length = PositionHelper(v, true);
+				SetBit(v->grf_cache.cache_valid, NCVV_POSITION_SAME_ID_LENGTH);
+			}
+			return v->grf_cache.position_same_id_length;
+
+		case 0x42: { // Consist cargo information
+			if (!HasBit(v->grf_cache.cache_valid, NCVV_CONSIST_CARGO_INFORMATION)) {
+				const Vehicle *u;
+				byte cargo_classes = 0;
+				uint8 common_cargoes[NUM_CARGO];
+				uint8 common_subtypes[256];
+				byte user_def_data = 0;
+				CargoID common_cargo_type = CT_INVALID;
+				uint8 common_subtype = 0xFF; // Return 0xFF if nothing is carried
+
+				/* Reset our arrays */
+				memset(common_cargoes, 0, sizeof(common_cargoes));
+				memset(common_subtypes, 0, sizeof(common_subtypes));
+
+				for (u = v; u != NULL; u = u->Next()) {
+					if (v->type == VEH_TRAIN) user_def_data |= Train::From(u)->tcache.user_def_data;
+
+					/* Skip empty engines */
+					if (!u->GetEngine()->CanCarryCargo()) continue;
+
+					cargo_classes |= CargoSpec::Get(u->cargo_type)->classes;
+					common_cargoes[u->cargo_type]++;
+				}
+
+				/* Pick the most common cargo type */
+				uint common_cargo_best_amount = 0;
+				for (CargoID cargo = 0; cargo < NUM_CARGO; cargo++) {
+					if (common_cargoes[cargo] > common_cargo_best_amount) {
+						common_cargo_best_amount = common_cargoes[cargo];
+						common_cargo_type = cargo;
+					}
+				}
+
+				/* Count subcargo types of common_cargo_type */
+				for (u = v; u != NULL; u = u->Next()) {
+					/* Skip empty engines and engines not carrying common_cargo_type */
+					if (u->cargo_type != common_cargo_type || !u->GetEngine()->CanCarryCargo()) continue;
+
+					common_subtypes[u->cargo_subtype]++;
+				}
+
+				/* Pick the most common subcargo type*/
+				uint common_subtype_best_amount = 0;
+				for (uint i = 0; i < lengthof(common_subtypes); i++) {
+					if (common_subtypes[i] > common_subtype_best_amount) {
+						common_subtype_best_amount = common_subtypes[i];
+						common_subtype = i;
+					}
+				}
+
+				/* Note: We have to store the untranslated cargotype in the cache as the cache can be read by different NewGRFs,
+				 *       which will need different translations */
+				v->grf_cache.consist_cargo_information = cargo_classes | (common_cargo_type << 8) | (common_subtype << 16) | (user_def_data << 24);
+				SetBit(v->grf_cache.cache_valid, NCVV_CONSIST_CARGO_INFORMATION);
+			}
+
+			/* The cargo translation is specific to the accessing GRF, and thus cannot be cached. */
+			CargoID common_cargo_type = (v->grf_cache.consist_cargo_information >> 8) & 0xFF;
+
+			/* Unlike everywhere else the cargo translation table is only used since grf version 8, not 7.
+			 * Note: The grffile == NULL case only happens if this function is called for default vehicles.
+			 *       And this is only done by CheckCaches(). */
+			const GRFFile *grffile = object->ro->grffile;
+			uint8 common_bitnum = (common_cargo_type == CT_INVALID) ? 0xFF :
+				(grffile == NULL || grffile->grf_version < 8) ? CargoSpec::Get(common_cargo_type)->bitnum : grffile->cargo_map[common_cargo_type];
+
+			return (v->grf_cache.consist_cargo_information & 0xFFFF00FF) | common_bitnum << 8;
+		}
+
+		case 0x43: // Company information
+			if (!HasBit(v->grf_cache.cache_valid, NCVV_COMPANY_INFORMATION)) {
+				v->grf_cache.company_information = GetCompanyInfo(v->owner, LiveryHelper(v->engine_type, v));
+				SetBit(v->grf_cache.cache_valid, NCVV_COMPANY_INFORMATION);
+			}
+			return v->grf_cache.company_information;
+
+		case 0x44: // Aircraft information
+			if (v->type != VEH_AIRCRAFT || !Aircraft::From(v)->IsNormalAircraft()) return UINT_MAX;
+
+			{
+				const Vehicle *w = v->Next();
+				uint16 altitude = v->z_pos - w->z_pos; // Aircraft height - shadow height
+				byte airporttype = ATP_TTDP_LARGE;
+
+				const Station *st = GetTargetAirportIfValid(Aircraft::From(v));
+
+				if (st != NULL && st->airport.tile != INVALID_TILE) {
+					airporttype = st->airport.GetSpec()->ttd_airport_type;
+				}
+
+				return (Clamp(altitude, 0, 0xFF) << 8) | airporttype;
+			}
+
+		case 0x45: { // Curvature info
+			/* Format: xxxTxBxF
+			 * F - previous wagon to current wagon, 0 if vehicle is first
+			 * B - current wagon to next wagon, 0 if wagon is last
+			 * T - previous wagon to next wagon, 0 in an S-bend
+			 */
+			if (!v->IsGroundVehicle()) return 0;
+
+			const Vehicle *u_p = v->Previous();
+			const Vehicle *u_n = v->Next();
+			DirDiff f = (u_p == NULL) ?  DIRDIFF_SAME : DirDifference(u_p->direction, v->direction);
+			DirDiff b = (u_n == NULL) ?  DIRDIFF_SAME : DirDifference(v->direction, u_n->direction);
+			DirDiff t = ChangeDirDiff(f, b);
+
+			return ((t > DIRDIFF_REVERSE ? t | 8 : t) << 16) |
+			       ((b > DIRDIFF_REVERSE ? b | 8 : b) <<  8) |
+			       ( f > DIRDIFF_REVERSE ? f | 8 : f);
+		}
+
+		case 0x46: // Motion counter
+			return v->motion_counter;
+
+		case 0x47: { // Vehicle cargo info
+			/* Format: ccccwwtt
+			 * tt - the cargo type transported by the vehicle,
+			 *     translated if a translation table has been installed.
+			 * ww - cargo unit weight in 1/16 tons, same as cargo prop. 0F.
+			 * cccc - the cargo class value of the cargo transported by the vehicle.
+			 */
+			const CargoSpec *cs = CargoSpec::Get(v->cargo_type);
+
+			return (cs->classes << 16) | (cs->weight << 8) | v->GetGRF()->cargo_map[v->cargo_type];
+		}
+
+		case 0x48: return v->GetEngine()->flags; // Vehicle Type Info
+		case 0x49: return v->build_year;
+
+		case 0x4A: {
+			if (v->type != VEH_TRAIN) return 0;
+			RailType rt = GetTileRailType(v->tile);
+			return (HasPowerOnRail(Train::From(v)->railtype, rt) ? 0x100 : 0) | GetReverseRailTypeTranslation(rt, object->ro->grffile);
+		}
+
+		case 0x4B: // Long date of last service
+			return v->date_of_last_service;
+
+		case 0x4C: // Current maximum speed in NewGRF units
+			if (!v->IsPrimaryVehicle()) return 0;
+			return v->GetCurrentMaxSpeed();
+
+		/* Variables which use the parameter */
+		case 0x60: // Count consist's engine ID occurrence
+			if (v->type != VEH_TRAIN) return v->GetEngine()->grf_prop.local_id == parameter ? 1 : 0;
+
+			{
+				uint count = 0;
+				for (; v != NULL; v = v->Next()) {
+					if (v->GetEngine()->grf_prop.local_id == parameter) count++;
+				}
+				return count;
+			}
+
+		case 0x61: // Get variable of n-th vehicle in chain [signed number relative to vehicle]
+			if (!v->IsGroundVehicle() || parameter == 0x61) return 0;
+
+			/* Only allow callbacks that don't change properties to avoid circular dependencies. */
+			if (object->ro->callback == CBID_NO_CALLBACK || object->ro->callback == CBID_RANDOM_TRIGGER || object->ro->callback == CBID_TRAIN_ALLOW_WAGON_ATTACH ||
+					object->ro->callback == CBID_VEHICLE_START_STOP_CHECK || object->ro->callback == CBID_VEHICLE_32DAY_CALLBACK || object->ro->callback == CBID_VEHICLE_COLOUR_MAPPING) {
+				Vehicle *u = v->Move((int32)GetRegister(0x10F));
+				if (u == NULL) return 0;
+
+				if (parameter == 0x5F) {
+					/* This seems to be the only variable that makes sense to access via var 61, but is not handled by VehicleGetVariable */
+					return (u->random_bits << 8) | u->waiting_triggers;
+				} else {
+					return VehicleGetVariable(u, object, parameter, GetRegister(0x10E), available);
+				}
+			}
+			return 0;
+
+		case 0x62: { // Curvature/position difference for n-th vehicle in chain [signed number relative to vehicle]
+			/* Format: zzyyxxFD
+			 * zz - Signed difference of z position between the selected and this vehicle.
+			 * yy - Signed difference of y position between the selected and this vehicle.
+			 * xx - Signed difference of x position between the selected and this vehicle.
+			 * F  - Flags, bit 7 corresponds to VS_HIDDEN.
+			 * D  - Dir difference, like in 0x45.
+			 */
+			if (!v->IsGroundVehicle()) return 0;
+
+			const Vehicle *u = v->Move((int8)parameter);
+			if (u == NULL) return 0;
+
+			/* Get direction difference. */
+			bool prev = (int8)parameter < 0;
+			uint32 ret = prev ? DirDifference(u->direction, v->direction) : DirDifference(v->direction, u->direction);
+			if (ret > DIRDIFF_REVERSE) ret |= 0x08;
+
+			if (u->vehstatus & VS_HIDDEN) ret |= 0x80;
+
+			/* Get position difference. */
+			ret |= ((prev ? u->x_pos - v->x_pos : v->x_pos - u->x_pos) & 0xFF) << 8;
+			ret |= ((prev ? u->y_pos - v->y_pos : v->y_pos - u->y_pos) & 0xFF) << 16;
+			ret |= ((prev ? u->z_pos - v->z_pos : v->z_pos - u->z_pos) & 0xFF) << 24;
+
+			return ret;
+		}
+
+		case 0xFE:
+		case 0xFF: {
+			uint16 modflags = 0;
+
+			if (v->type == VEH_TRAIN) {
+				const Train *t = Train::From(v);
+				bool is_powered_wagon = HasBit(t->flags, VRF_POWEREDWAGON);
+				const Train *u = is_powered_wagon ? t->First() : t; // for powered wagons the engine defines the type of engine (i.e. railtype)
+				RailType railtype = GetRailType(v->tile);
+				bool powered = t->IsEngine() || is_powered_wagon;
+				bool has_power = HasPowerOnRail(u->railtype, railtype);
+
+				if (powered && has_power) SetBit(modflags, 5);
+				if (powered && !has_power) SetBit(modflags, 6);
+				if (HasBit(t->flags, VRF_TOGGLE_REVERSE)) SetBit(modflags, 8);
+			}
+			if (HasBit(v->vehicle_flags, VF_BUILT_AS_PROTOTYPE)) SetBit(modflags, 10);
+
+			return variable == 0xFE ? modflags : GB(modflags, 8, 8);
+		}
+	}
+
+	/* General vehicle properties */
+	switch (variable - 0x80) {
+		case 0x00: return v->type + 0x10;
+		case 0x01: return MapOldSubType(v);
+		case 0x04: return v->index;
+		case 0x05: return GB(v->index, 8, 8);
+		case 0x0A: return v->current_order.MapOldOrder();
+		case 0x0B: return v->current_order.GetDestination();
+		case 0x0C: return v->GetNumOrders();
+		case 0x0D: return v->cur_real_order_index;
+		case 0x10:
+		case 0x11: {
+			uint ticks;
+			if (v->current_order.IsType(OT_LOADING)) {
+				ticks = v->load_unload_ticks;
+			} else {
+				switch (v->type) {
+					case VEH_TRAIN:    ticks = Train::From(v)->wait_counter; break;
+					case VEH_AIRCRAFT: ticks = Aircraft::From(v)->turn_counter; break;
+					default:           ticks = 0; break;
+				}
+			}
+			return (variable - 0x80) == 0x10 ? ticks : GB(ticks, 8, 8);
+		}
+		case 0x12: return Clamp(v->date_of_last_service - DAYS_TILL_ORIGINAL_BASE_YEAR, 0, 0xFFFF);
+		case 0x13: return GB(Clamp(v->date_of_last_service - DAYS_TILL_ORIGINAL_BASE_YEAR, 0, 0xFFFF), 8, 8);
+		case 0x14: return v->GetServiceInterval();
+		case 0x15: return GB(v->GetServiceInterval(), 8, 8);
+		case 0x16: return v->last_station_visited;
+		case 0x17: return v->tick_counter;
+		case 0x18:
+		case 0x19: {
+			uint max_speed;
+			switch (v->type) {
+				case VEH_AIRCRAFT:
+					max_speed = Aircraft::From(v)->GetSpeedOldUnits(); // Convert to old units.
+					break;
+
+				default:
+					max_speed = v->vcache.cached_max_speed;
+					break;
+			}
+			return (variable - 0x80) == 0x18 ? max_speed : GB(max_speed, 8, 8);
+		}
+		case 0x1A: return v->x_pos;
+		case 0x1B: return GB(v->x_pos, 8, 8);
+		case 0x1C: return v->y_pos;
+		case 0x1D: return GB(v->y_pos, 8, 8);
+		case 0x1E: return v->z_pos;
+		case 0x1F: return object->info_view ? DIR_W : v->direction;
+		case 0x28: return 0; // cur_image is a potential desyncer due to Action1 in static NewGRFs.
+		case 0x29: return 0; // cur_image is a potential desyncer due to Action1 in static NewGRFs.
+		case 0x32: return v->vehstatus;
+		case 0x33: return 0; // non-existent high byte of vehstatus
+		case 0x34: return v->type == VEH_AIRCRAFT ? (v->cur_speed * 10) / 128 : v->cur_speed;
+		case 0x35: return GB(v->type == VEH_AIRCRAFT ? (v->cur_speed * 10) / 128 : v->cur_speed, 8, 8);
+		case 0x36: return v->subspeed;
+		case 0x37: return v->acceleration;
+		case 0x39: return v->cargo_type;
+		case 0x3A: return v->cargo_cap;
+		case 0x3B: return GB(v->cargo_cap, 8, 8);
+		case 0x3C: return ClampToU16(v->cargo.StoredCount());
+		case 0x3D: return GB(ClampToU16(v->cargo.StoredCount()), 8, 8);
+		case 0x3E: return v->cargo.Source();
+		case 0x3F: return ClampU(v->cargo.DaysInTransit(), 0, 0xFF);
+		case 0x40: return ClampToU16(v->age);
+		case 0x41: return GB(ClampToU16(v->age), 8, 8);
+		case 0x42: return ClampToU16(v->max_age);
+		case 0x43: return GB(ClampToU16(v->max_age), 8, 8);
+		case 0x44: return Clamp(v->build_year, ORIGINAL_BASE_YEAR, ORIGINAL_MAX_YEAR) - ORIGINAL_BASE_YEAR;
+		case 0x45: return v->unitnumber;
+		case 0x46: return v->GetEngine()->grf_prop.local_id;
+		case 0x47: return GB(v->GetEngine()->grf_prop.local_id, 8, 8);
+		case 0x48:
+			if (v->type != VEH_TRAIN || v->spritenum != 0xFD) return v->spritenum;
+			return HasBit(Train::From(v)->flags, VRF_REVERSE_DIRECTION) ? 0xFE : 0xFD;
+
+		case 0x49: return v->day_counter;
+		case 0x4A: return v->breakdowns_since_last_service;
+		case 0x4B: return v->breakdown_ctr;
+		case 0x4C: return v->breakdown_delay;
+		case 0x4D: return v->breakdown_chance;
+		case 0x4E: return v->reliability;
+		case 0x4F: return GB(v->reliability, 8, 8);
+		case 0x50: return v->reliability_spd_dec;
+		case 0x51: return GB(v->reliability_spd_dec, 8, 8);
+		case 0x52: return ClampToI32(v->GetDisplayProfitThisYear());
+		case 0x53: return GB(ClampToI32(v->GetDisplayProfitThisYear()),  8, 24);
+		case 0x54: return GB(ClampToI32(v->GetDisplayProfitThisYear()), 16, 16);
+		case 0x55: return GB(ClampToI32(v->GetDisplayProfitThisYear()), 24,  8);
+		case 0x56: return ClampToI32(v->GetDisplayProfitLastYear());
+		case 0x57: return GB(ClampToI32(v->GetDisplayProfitLastYear()),  8, 24);
+		case 0x58: return GB(ClampToI32(v->GetDisplayProfitLastYear()), 16, 16);
+		case 0x59: return GB(ClampToI32(v->GetDisplayProfitLastYear()), 24,  8);
+		case 0x5A: return v->Next() == NULL ? INVALID_VEHICLE : v->Next()->index;
+		case 0x5C: return ClampToI32(v->value);
+		case 0x5D: return GB(ClampToI32(v->value),  8, 24);
+		case 0x5E: return GB(ClampToI32(v->value), 16, 16);
+		case 0x5F: return GB(ClampToI32(v->value), 24,  8);
+		case 0x72: return v->cargo_subtype;
+		case 0x7A: return v->random_bits;
+		case 0x7B: return v->waiting_triggers;
+	}
+
+	/* Vehicle specific properties */
+	switch (v->type) {
+		case VEH_TRAIN: {
+			Train *t = Train::From(v);
+			switch (variable - 0x80) {
+				case 0x62: return t->track;
+				case 0x66: return t->railtype;
+				case 0x73: return 0x80 + VEHICLE_LENGTH - t->gcache.cached_veh_length;
+				case 0x74: return t->gcache.cached_power;
+				case 0x75: return GB(t->gcache.cached_power,  8, 24);
+				case 0x76: return GB(t->gcache.cached_power, 16, 16);
+				case 0x77: return GB(t->gcache.cached_power, 24,  8);
+				case 0x7C: return t->First()->index;
+				case 0x7D: return GB(t->First()->index, 8, 8);
+				case 0x7F: return 0; // Used for vehicle reversing hack in TTDP
+			}
+			break;
+		}
+
+		case VEH_ROAD: {
+			RoadVehicle *rv = RoadVehicle::From(v);
+			switch (variable - 0x80) {
+				case 0x62: return rv->state;
+				case 0x64: return rv->blocked_ctr;
+				case 0x65: return GB(rv->blocked_ctr, 8, 8);
+				case 0x66: return rv->overtaking;
+				case 0x67: return rv->overtaking_ctr;
+				case 0x68: return rv->crashed_ctr;
+				case 0x69: return GB(rv->crashed_ctr, 8, 8);
+			}
+			break;
+		}
+
+		case VEH_SHIP: {
+			Ship *s = Ship::From(v);
+			switch (variable - 0x80) {
+				case 0x62: return s->state;
+			}
+			break;
+		}
+
+		case VEH_AIRCRAFT: {
+			Aircraft *a = Aircraft::From(v);
+			switch (variable - 0x80) {
+				case 0x62: return MapAircraftMovementState(a);  // Current movement state
+				case 0x63: return a->targetairport;             // Airport to which the action refers
+				case 0x66: return MapAircraftMovementAction(a); // Current movement action
+			}
+			break;
+		}
+
+		default: break;
+	}
+
+	DEBUG(grf, 1, "Unhandled vehicle variable 0x%X, type 0x%X", variable, (uint)v->type);
+
+	*available = false;
+	return UINT_MAX;
+}
+
+/* virtual */ uint32 VehicleScopeResolver::GetVariable(byte variable, uint32 parameter, bool *available) const
+{
+	if (this->v == NULL) {
+		/* Vehicle does not exist, so we're in a purchase list */
+		switch (variable) {
+			case 0x43: return GetCompanyInfo(_current_company, LiveryHelper(this->self_type, NULL)); // Owner information
+			case 0x46: return 0;               // Motion counter
+			case 0x47: { // Vehicle cargo info
+				const Engine *e = Engine::Get(this->self_type);
+				CargoID cargo_type = e->GetDefaultCargoType();
+				if (cargo_type != CT_INVALID) {
+					const CargoSpec *cs = CargoSpec::Get(cargo_type);
+					return (cs->classes << 16) | (cs->weight << 8) | e->GetGRF()->cargo_map[cargo_type];
+				} else {
+					return 0x000000FF;
+				}
+			}
+			case 0x48: return Engine::Get(this->self_type)->flags; // Vehicle Type Info
+			case 0x49: return _cur_year; // 'Long' format build year
+			case 0x4B: return _date; // Long date of last service
+			case 0x92: return Clamp(_date - DAYS_TILL_ORIGINAL_BASE_YEAR, 0, 0xFFFF); // Date of last service
+			case 0x93: return GB(Clamp(_date - DAYS_TILL_ORIGINAL_BASE_YEAR, 0, 0xFFFF), 8, 8);
+			case 0xC4: return Clamp(_cur_year, ORIGINAL_BASE_YEAR, ORIGINAL_MAX_YEAR) - ORIGINAL_BASE_YEAR; // Build year
+			case 0xDA: return INVALID_VEHICLE; // Next vehicle
+			case 0xF2: return 0; // Cargo subtype
+		}
+
+		*available = false;
+		return UINT_MAX;
+	}
+
+	return VehicleGetVariable(const_cast<Vehicle*>(this->v), this, variable, parameter, available);
+}
+
+
+/* virtual */ const SpriteGroup *VehicleResolverObject::ResolveReal(const RealSpriteGroup *group) const
+{
+	const Vehicle *v = this->self_scope.v;
+
+	if (v == NULL) {
+		if (group->num_loading > 0) return group->loading[0];
+		if (group->num_loaded  > 0) return group->loaded[0];
+		return NULL;
+	}
+
+	bool in_motion = !v->First()->current_order.IsType(OT_LOADING);
+
+	uint totalsets = in_motion ? group->num_loaded : group->num_loading;
+
+	if (totalsets == 0) return NULL;
+
+	uint set = (v->cargo.StoredCount() * totalsets) / max((uint16)1, v->cargo_cap);
+	set = min(set, totalsets - 1);
+
+	return in_motion ? group->loaded[set] : group->loading[set];
+}
+
+/**
+ * Scope resolver of a single vehicle.
+ * @param ro Surrounding resolver.
+ * @param engine_type Engine type
+ * @param v %Vehicle being resolved.
+ * @param info_view Indicates if the item is being drawn in an info window.
+ */
+VehicleScopeResolver::VehicleScopeResolver(ResolverObject *ro, EngineID engine_type, const Vehicle *v, bool info_view)
+		: ScopeResolver(ro)
+{
+	this->v = v;
+	this->self_type = engine_type;
+	this->info_view = info_view;
+}
+
+/**
+ * Get the grf file associated with an engine type.
+ * @param engine_type Engine to query.
+ * @return grf file associated with the engine.
+ */
+static const GRFFile *GetEngineGrfFile(EngineID engine_type)
+{
+	const Engine *e = Engine::Get(engine_type);
+	return (e != NULL) ? e->GetGRF() : NULL;
+}
+
+/**
+ * Resolver of a vehicle (chain).
+ * @param engine_type Engine type
+ * @param v %Vehicle being resolved.
+ * @param info_view Indicates if the item is being drawn in an info window.
+ * @param callback Callback ID.
+ * @param callback_param1 First parameter (var 10) of the callback.
+ * @param callback_param2 Second parameter (var 18) of the callback.
+ */
+VehicleResolverObject::VehicleResolverObject(EngineID engine_type, const Vehicle *v, bool info_view,
+		CallbackID callback, uint32 callback_param1, uint32 callback_param2)
+	: ResolverObject(GetEngineGrfFile(engine_type), callback, callback_param1, callback_param2),
+	self_scope(this, engine_type, v, info_view),
+	parent_scope(this, engine_type, ((v != NULL) ? v->First() : v), info_view),
+	relative_scope(this, engine_type, v, info_view),
+	cached_relative_count(0)
+{
+}
+
+/**
+ * Retrieve the SpriteGroup for the specified vehicle.
+ * If the vehicle is not specified, the purchase list group for the engine is
+ * chosen. For trains, an additional engine override lookup is performed.
+ * @param engine    Engine type of the vehicle.
+ * @param v         The vehicle itself.
+ * @param use_cache Use cached override
+ * @returns         The selected SpriteGroup for the vehicle.
+ */
+static const SpriteGroup *GetVehicleSpriteGroup(EngineID engine, const Vehicle *v, bool use_cache = true)
+{
+	const SpriteGroup *group;
+	CargoID cargo;
+
+	if (v == NULL) {
+		cargo = CT_PURCHASE;
+	} else {
+		cargo = v->cargo_type;
+
+		if (v->IsGroundVehicle()) {
+			/* For trains we always use cached value, except for callbacks because the override spriteset
+			 * to use may be different than the one cached. It happens for callback 0x15 (refit engine),
+			 * as v->cargo_type is temporary changed to the new type */
+			if (use_cache && v->type == VEH_TRAIN) {
+				group = Train::From(v)->tcache.cached_override;
+			} else {
+				group = GetWagonOverrideSpriteSet(v->engine_type, v->cargo_type, v->GetGroundVehicleCache()->first_engine);
+			}
+			if (group != NULL) return group;
+		}
+	}
+
+	const Engine *e = Engine::Get(engine);
+
+	assert(cargo < lengthof(e->grf_prop.spritegroup));
+	group = e->grf_prop.spritegroup[cargo];
+	if (group != NULL) return group;
+
+	/* Fall back to the default set if the selected cargo type is not defined */
+	return e->grf_prop.spritegroup[CT_DEFAULT];
+}
+
+
+SpriteID GetCustomEngineSprite(EngineID engine, const Vehicle *v, Direction direction, EngineImageType image_type)
+{
+	VehicleResolverObject object(engine, v, false, CBID_NO_CALLBACK, image_type);
+	const SpriteGroup *group = SpriteGroup::Resolve(GetVehicleSpriteGroup(engine, v), &object);
+	if (group == NULL || group->GetNumResults() == 0) return 0;
+
+	return group->GetResult() + (direction % group->GetNumResults());
+}
+
+
+SpriteID GetRotorOverrideSprite(EngineID engine, const Aircraft *v, bool info_view, EngineImageType image_type)
+{
+	const Engine *e = Engine::Get(engine);
+
+	/* Only valid for helicopters */
+	assert(e->type == VEH_AIRCRAFT);
+	assert(!(e->u.air.subtype & AIR_CTOL));
+
+	VehicleResolverObject object(engine, v, info_view, CBID_NO_CALLBACK, image_type);
+	const SpriteGroup *group = GetWagonOverrideSpriteSet(engine, CT_DEFAULT, engine);
+	group = SpriteGroup::Resolve(group, &object);
+
+	if (group == NULL || group->GetNumResults() == 0) return 0;
+
+	if (v == NULL) return group->GetResult();
+
+	return group->GetResult() + (info_view ? 0 : (v->Next()->Next()->state % group->GetNumResults()));
+}
+
+
+/**
+ * Check if a wagon is currently using a wagon override
+ * @param v The wagon to check
+ * @return true if it is using an override, false otherwise
+ */
+bool UsesWagonOverride(const Vehicle *v)
+{
+	assert(v->type == VEH_TRAIN);
+	return Train::From(v)->tcache.cached_override != NULL;
+}
+
+/**
+ * Evaluate a newgrf callback for vehicles
+ * @param callback The callback to evaluate
+ * @param param1   First parameter of the callback
+ * @param param2   Second parameter of the callback
+ * @param engine   Engine type of the vehicle to evaluate the callback for
+ * @param v        The vehicle to evaluate the callback for, or NULL if it doesnt exist yet
+ * @return The value the callback returned, or CALLBACK_FAILED if it failed
+ */
+uint16 GetVehicleCallback(CallbackID callback, uint32 param1, uint32 param2, EngineID engine, const Vehicle *v)
+{
+	VehicleResolverObject object(engine, v, false, callback, param1, param2);
+	const SpriteGroup *group = SpriteGroup::Resolve(GetVehicleSpriteGroup(engine, v, false), &object);
+	if (group == NULL) return CALLBACK_FAILED;
+
+	return group->GetCallbackResult();
+}
+
+/**
+ * Evaluate a newgrf callback for vehicles with a different vehicle for parent scope.
+ * @param callback The callback to evaluate
+ * @param param1   First parameter of the callback
+ * @param param2   Second parameter of the callback
+ * @param engine   Engine type of the vehicle to evaluate the callback for
+ * @param v        The vehicle to evaluate the callback for, or NULL if it doesn't exist yet
+ * @param parent   The vehicle to use for parent scope
+ * @return The value the callback returned, or CALLBACK_FAILED if it failed
+ */
+uint16 GetVehicleCallbackParent(CallbackID callback, uint32 param1, uint32 param2, EngineID engine, const Vehicle *v, const Vehicle *parent)
+{
+	VehicleResolverObject object(engine, v, false, callback, param1, param2);
+	object.parent_scope.SetVehicle(parent);
+
+	const SpriteGroup *group = SpriteGroup::Resolve(GetVehicleSpriteGroup(engine, v, false), &object);
+	if (group == NULL) return CALLBACK_FAILED;
+
+	return group->GetCallbackResult();
+}
+
+
+/* Callback 36 handlers */
+uint GetVehicleProperty(const Vehicle *v, PropertyID property, uint orig_value)
+{
+	return GetEngineProperty(v->engine_type, property, orig_value, v);
+}
+
+
+uint GetEngineProperty(EngineID engine, PropertyID property, uint orig_value, const Vehicle *v)
+{
+	uint16 callback = GetVehicleCallback(CBID_VEHICLE_MODIFY_PROPERTY, property, 0, engine, v);
+	if (callback != CALLBACK_FAILED) return callback;
+
+	return orig_value;
+}
+
+
+static void DoTriggerVehicle(Vehicle *v, VehicleTrigger trigger, byte base_random_bits, bool first)
+{
+	/* We can't trigger a non-existent vehicle... */
+	assert(v != NULL);
+
+	VehicleResolverObject object(v->engine_type, v, false, CBID_RANDOM_TRIGGER);
+	object.trigger = trigger;
+
+	const SpriteGroup *group = SpriteGroup::Resolve(GetVehicleSpriteGroup(v->engine_type, v), &object);
+	if (group == NULL) return;
+
+	byte new_random_bits = Random();
+	uint32 reseed = object.GetReseedSum(); // The scope only affects triggers, not the reseeding
+	v->random_bits &= ~reseed;
+	v->random_bits |= (first ? new_random_bits : base_random_bits) & reseed;
+
+	switch (trigger) {
+		case VEHICLE_TRIGGER_NEW_CARGO:
+			/* All vehicles in chain get ANY_NEW_CARGO trigger now.
+			 * So we call it for the first one and they will recurse.
+			 * Indexing part of vehicle random bits needs to be
+			 * same for all triggered vehicles in the chain (to get
+			 * all the random-cargo wagons carry the same cargo,
+			 * i.e.), so we give them all the NEW_CARGO triggered
+			 * vehicle's portion of random bits. */
+			assert(first);
+			DoTriggerVehicle(v->First(), VEHICLE_TRIGGER_ANY_NEW_CARGO, new_random_bits, false);
+			break;
+
+		case VEHICLE_TRIGGER_DEPOT:
+			/* We now trigger the next vehicle in chain recursively.
+			 * The random bits portions may be different for each
+			 * vehicle in chain. */
+			if (v->Next() != NULL) DoTriggerVehicle(v->Next(), trigger, 0, true);
+			break;
+
+		case VEHICLE_TRIGGER_EMPTY:
+			/* We now trigger the next vehicle in chain
+			 * recursively.  The random bits portions must be same
+			 * for each vehicle in chain, so we give them all
+			 * first chained vehicle's portion of random bits. */
+			if (v->Next() != NULL) DoTriggerVehicle(v->Next(), trigger, first ? new_random_bits : base_random_bits, false);
+			break;
+
+		case VEHICLE_TRIGGER_ANY_NEW_CARGO:
+			/* Now pass the trigger recursively to the next vehicle
+			 * in chain. */
+			assert(!first);
+			if (v->Next() != NULL) DoTriggerVehicle(v->Next(), VEHICLE_TRIGGER_ANY_NEW_CARGO, base_random_bits, false);
+			break;
+
+		case VEHICLE_TRIGGER_CALLBACK_32:
+			/* Do not do any recursion */
+			break;
+	}
+}
+
+void TriggerVehicle(Vehicle *v, VehicleTrigger trigger)
+{
+	if (trigger == VEHICLE_TRIGGER_DEPOT) {
+		/* store that the vehicle entered a depot this tick */
+		VehicleEnteredDepotThisTick(v);
+	}
+
+	v->InvalidateNewGRFCacheOfChain();
+	DoTriggerVehicle(v, trigger, 0, true);
+	v->InvalidateNewGRFCacheOfChain();
+}
+
+/* Functions for changing the order of vehicle purchase lists */
+
+struct ListOrderChange {
+	EngineID engine;
+	uint target;      ///< local ID
+};
+
+static SmallVector<ListOrderChange, 16> _list_order_changes;
+
+/**
+ * Record a vehicle ListOrderChange.
+ * @param engine Engine to move
+ * @param target Local engine ID to move \a engine in front of
+ * @note All sorting is done later in CommitVehicleListOrderChanges
+ */
+void AlterVehicleListOrder(EngineID engine, uint target)
+{
+	/* Add the list order change to a queue */
+	ListOrderChange *loc = _list_order_changes.Append();
+	loc->engine = engine;
+	loc->target = target;
+}
+
+/**
+ * Comparator function to sort engines via scope-GRFID and local ID.
+ * @param a left side
+ * @param b right side
+ * @return comparison result
+ */
+static int CDECL EnginePreSort(const EngineID *a, const EngineID *b)
+{
+	const EngineIDMapping *id_a = _engine_mngr.Get(*a);
+	const EngineIDMapping *id_b = _engine_mngr.Get(*b);
+
+	/* 1. Sort by engine type */
+	if (id_a->type != id_b->type) return (int)id_a->type - (int)id_b->type;
+
+	/* 2. Sort by scope-GRFID */
+	if (id_a->grfid != id_b->grfid) return id_a->grfid < id_b->grfid ? -1 : 1;
+
+	/* 3. Sort by local ID */
+	return (int)id_a->internal_id - (int)id_b->internal_id;
+}
+
+/**
+ * Deternine default engine sorting and execute recorded ListOrderChanges from AlterVehicleListOrder.
+ */
+void CommitVehicleListOrderChanges()
+{
+	/* Pre-sort engines by scope-grfid and local index */
+	SmallVector<EngineID, 16> ordering;
+	Engine *e;
+	FOR_ALL_ENGINES(e) {
+		*ordering.Append() = e->index;
+	}
+	QSortT(ordering.Begin(), ordering.Length(), EnginePreSort);
+
+	/* Apply Insertion-Sort operations */
+	const ListOrderChange *end = _list_order_changes.End();
+	for (const ListOrderChange *it = _list_order_changes.Begin(); it != end; ++it) {
+		EngineID source = it->engine;
+		uint local_target = it->target;
+
+		const EngineIDMapping *id_source = _engine_mngr.Get(source);
+		if (id_source->internal_id == local_target) continue;
+
+		EngineID target = _engine_mngr.GetID(id_source->type, local_target, id_source->grfid);
+		if (target == INVALID_ENGINE) continue;
+
+		int source_index = ordering.FindIndex(source);
+		int target_index = ordering.FindIndex(target);
+
+		assert(source_index >= 0 && target_index >= 0);
+		assert(source_index != target_index);
+
+		EngineID *list = ordering.Begin();
+		if (source_index < target_index) {
+			--target_index;
+			for (int i = source_index; i < target_index; ++i) list[i] = list[i + 1];
+			list[target_index] = source;
+		} else {
+			for (int i = source_index; i > target_index; --i) list[i] = list[i - 1];
+			list[target_index] = source;
+		}
+	}
+
+	/* Store final sort-order */
+	const EngineID *idend = ordering.End();
+	uint index = 0;
+	for (const EngineID *it = ordering.Begin(); it != idend; ++it, ++index) {
+		Engine::Get(*it)->list_position = index;
+	}
+
+	/* Clear out the queue */
+	_list_order_changes.Reset();
+}
+
+/**
+ * Fill the grf_cache of the given vehicle.
+ * @param v The vehicle to fill the cache for.
+ */
+void FillNewGRFVehicleCache(const Vehicle *v)
+{
+	VehicleResolverObject ro(v->engine_type, v);
+
+	/* These variables we have to check; these are the ones with a cache. */
+	static const int cache_entries[][2] = {
+		{ 0x40, NCVV_POSITION_CONSIST_LENGTH },
+		{ 0x41, NCVV_POSITION_SAME_ID_LENGTH },
+		{ 0x42, NCVV_CONSIST_CARGO_INFORMATION },
+		{ 0x43, NCVV_COMPANY_INFORMATION },
+	};
+	assert_compile(NCVV_END == lengthof(cache_entries));
+
+	/* Resolve all the variables, so their caches are set. */
+	for (size_t i = 0; i < lengthof(cache_entries); i++) {
+		/* Only resolve when the cache isn't valid. */
+		if (HasBit(v->grf_cache.cache_valid, cache_entries[i][1])) continue;
+		bool stub;
+		ro.GetScope(VSG_SCOPE_SELF)->GetVariable(cache_entries[i][0], 0, &stub);
+	}
+
+	/* Make sure really all bits are set. */
+	assert(v->grf_cache.cache_valid == (1 << NCVV_END) - 1);
+}
diff --git a/src/newgrf_engine.cpp.rej b/src/newgrf_engine.cpp.rej
new file mode 100644
index 0000000..d4153a4
--- /dev/null
+++ b/src/newgrf_engine.cpp.rej
@@ -0,0 +1,10 @@
+--- src/newgrf_engine.cpp	(revision 24056)
++++ src/newgrf_engine.cpp	(working copy)
+@@ -908,7 +908,6 @@
+ 	return in_motion ? group->loaded[set] : group->loading[set];
+ }
+ 
+-
+ static inline void NewVehicleResolver(ResolverObject *res, EngineID engine_type, const Vehicle *v)
+ {
+ 	res->GetRandomBits = &VehicleGetRandomBits;
diff --git a/src/newgrf_engine.h b/src/newgrf_engine.h
index 7eb65f1..b1dd5f1 100644
--- a/src/newgrf_engine.h
+++ b/src/newgrf_engine.h
@@ -99,6 +99,9 @@ void UnloadWagonOverrides(Engine *e);
 void AlterVehicleListOrder(EngineID engine, uint target);
 void CommitVehicleListOrderChanges();
 
+struct ResolverObject;
+void NewVehicleResolverWrapper(ResolverObject*, EngineID);
+
 EngineID GetNewEngineID(const GRFFile *file, VehicleType type, uint16 internal_id);
 
 #endif /* NEWGRF_ENGINE_H */
diff --git a/src/newgrf_engine.h.orig b/src/newgrf_engine.h.orig
new file mode 100644
index 0000000..7eb65f1
--- /dev/null
+++ b/src/newgrf_engine.h.orig
@@ -0,0 +1,104 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file newgrf_engine.h Functions for NewGRF engines. */
+
+#ifndef NEWGRF_ENGINE_H
+#define NEWGRF_ENGINE_H
+
+#include "direction_type.h"
+#include "newgrf_callbacks.h"
+#include "newgrf_properties.h"
+#include "vehicle_type.h"
+#include "engine_type.h"
+#include "gfx_type.h"
+#include "newgrf_spritegroup.h"
+
+/** Resolver for a vehicle scope. */
+struct VehicleScopeResolver : public ScopeResolver {
+	const struct Vehicle *v; ///< The vehicle being resolved.
+	EngineID self_type;      ///< Type of the vehicle.
+	bool info_view;          ///< Indicates if the item is being drawn in an info window.
+
+	VehicleScopeResolver(ResolverObject *ro, EngineID engine_type, const Vehicle *v, bool info_view);
+
+	void SetVehicle(const Vehicle *v) { this->v = v; }
+
+	/* virtual */ uint32 GetRandomBits() const;
+	/* virtual */ uint32 GetVariable(byte variable, uint32 parameter, bool *available) const;
+	/* virtual */ uint32 GetTriggers() const;
+	/* virtual */ void SetTriggers(int triggers) const;
+};
+
+/** Resolver for a vehicle (chain) */
+struct VehicleResolverObject : public ResolverObject {
+	VehicleScopeResolver self_scope;     ///< Scope resolver for the indicated vehicle.
+	VehicleScopeResolver parent_scope;   ///< Scope resolver for its parent vehicle.
+
+	VehicleScopeResolver relative_scope; ///< Scope resolver for an other vehicle in the chain.
+	byte cached_relative_count;          ///< Relative position of the other vehicle.
+
+	VehicleResolverObject(EngineID engine_type, const Vehicle *v, bool info_view = false,
+			CallbackID callback = CBID_NO_CALLBACK, uint32 callback_param1 = 0, uint32 callback_param2 = 0);
+
+	/* virtual */ ScopeResolver *GetScope(VarSpriteGroupScope scope = VSG_SCOPE_SELF, byte relative = 0);
+
+	/* virtual */ const SpriteGroup *ResolveReal(const RealSpriteGroup *group) const;
+};
+
+static const uint TRAININFO_DEFAULT_VEHICLE_WIDTH   = 29;
+static const uint ROADVEHINFO_DEFAULT_VEHICLE_WIDTH = 32;
+static const uint VEHICLEINFO_FULL_VEHICLE_WIDTH    = 32;
+
+void SetWagonOverrideSprites(EngineID engine, CargoID cargo, const struct SpriteGroup *group, EngineID *train_id, uint trains);
+const SpriteGroup *GetWagonOverrideSpriteSet(EngineID engine, CargoID cargo, EngineID overriding_engine);
+void SetCustomEngineSprites(EngineID engine, byte cargo, const struct SpriteGroup *group);
+SpriteID GetCustomEngineSprite(EngineID engine, const Vehicle *v, Direction direction, EngineImageType image_type);
+SpriteID GetRotorOverrideSprite(EngineID engine, const struct Aircraft *v, bool info_view, EngineImageType image_type);
+#define GetCustomRotorSprite(v, i, image_type) GetRotorOverrideSprite(v->engine_type, v, i, image_type)
+#define GetCustomRotorIcon(et, image_type) GetRotorOverrideSprite(et, NULL, true, image_type)
+
+/* Forward declaration of GRFFile, to avoid unnecessary inclusion of newgrf.h
+ * elsewhere... */
+struct GRFFile;
+
+void SetEngineGRF(EngineID engine, const struct GRFFile *file);
+
+uint16 GetVehicleCallback(CallbackID callback, uint32 param1, uint32 param2, EngineID engine, const Vehicle *v);
+uint16 GetVehicleCallbackParent(CallbackID callback, uint32 param1, uint32 param2, EngineID engine, const Vehicle *v, const Vehicle *parent);
+bool UsesWagonOverride(const Vehicle *v);
+#define GetCustomVehicleSprite(v, direction, image_type) GetCustomEngineSprite(v->engine_type, v, direction, image_type)
+#define GetCustomVehicleIcon(et, direction, image_type) GetCustomEngineSprite(et, NULL, direction, image_type)
+
+/* Handler to Evaluate callback 36. If the callback fails (i.e. most of the
+ * time) orig_value is returned */
+uint GetVehicleProperty(const Vehicle *v, PropertyID property, uint orig_value);
+uint GetEngineProperty(EngineID engine, PropertyID property, uint orig_value, const Vehicle *v = NULL);
+
+enum VehicleTrigger {
+	VEHICLE_TRIGGER_NEW_CARGO     = 0x01,
+	/* Externally triggered only for the first vehicle in chain */
+	VEHICLE_TRIGGER_DEPOT         = 0x02,
+	/* Externally triggered only for the first vehicle in chain, only if whole chain is empty */
+	VEHICLE_TRIGGER_EMPTY         = 0x04,
+	/* Not triggered externally (called for the whole chain if we got NEW_CARGO) */
+	VEHICLE_TRIGGER_ANY_NEW_CARGO = 0x08,
+	/* Externally triggered for each vehicle in chain */
+	VEHICLE_TRIGGER_CALLBACK_32   = 0x10,
+};
+void TriggerVehicle(Vehicle *veh, VehicleTrigger trigger);
+
+void UnloadWagonOverrides(Engine *e);
+
+void AlterVehicleListOrder(EngineID engine, uint target);
+void CommitVehicleListOrderChanges();
+
+EngineID GetNewEngineID(const GRFFile *file, VehicleType type, uint16 internal_id);
+
+#endif /* NEWGRF_ENGINE_H */
diff --git a/src/newgrf_spritegroup.cpp b/src/newgrf_spritegroup.cpp
index 7e60e82..ed4e064 100644
--- a/src/newgrf_spritegroup.cpp
+++ b/src/newgrf_spritegroup.cpp
@@ -170,7 +170,6 @@ static uint32 RotateRight(uint32 val, uint32 rot)
 	return (val >> rot) | (val << (32 - rot));
 }
 
-
 /* Evaluate an adjustment for a variable of the given size.
  * U is the unsigned type and S is the signed type to use. */
 template <typename U, typename S>
diff --git a/src/newgrf_spritegroup.cpp.orig b/src/newgrf_spritegroup.cpp.orig
new file mode 100644
index 0000000..7e60e82
--- /dev/null
+++ b/src/newgrf_spritegroup.cpp.orig
@@ -0,0 +1,338 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file newgrf_spritegroup.cpp Handling of primarily NewGRF action 2. */
+
+#include "stdafx.h"
+#include "debug.h"
+#include "newgrf_spritegroup.h"
+#include "core/pool_func.hpp"
+
+SpriteGroupPool _spritegroup_pool("SpriteGroup");
+INSTANTIATE_POOL_METHODS(SpriteGroup)
+
+RealSpriteGroup::~RealSpriteGroup()
+{
+	free(this->loaded);
+	free(this->loading);
+}
+
+DeterministicSpriteGroup::~DeterministicSpriteGroup()
+{
+	free(this->adjusts);
+	free(this->ranges);
+}
+
+RandomizedSpriteGroup::~RandomizedSpriteGroup()
+{
+	free(this->groups);
+}
+
+TemporaryStorageArray<int32, 0x110> _temp_store;
+
+
+static inline uint32 GetVariable(const ResolverObject *object, ScopeResolver *scope, byte variable, uint32 parameter, bool *available)
+{
+	/* First handle variables common with Action7/9/D */
+	uint32 value;
+	if (GetGlobalVariable(variable, &value, object->grffile)) return value;
+
+	/* Non-common variable */
+	switch (variable) {
+		case 0x0C: return object->callback;
+		case 0x10: return object->callback_param1;
+		case 0x18: return object->callback_param2;
+		case 0x1C: return object->last_value;
+
+		case 0x5F: return (scope->GetRandomBits() << 8) | scope->GetTriggers();
+
+		case 0x7D: return _temp_store.GetValue(parameter);
+
+		case 0x7F:
+			if (object == NULL || object->grffile == NULL) return 0;
+			return object->grffile->GetParam(parameter);
+
+		/* Not a common variable, so evaluate the feature specific variables */
+		default: return scope->GetVariable(variable, parameter, available);
+	}
+}
+
+ScopeResolver::ScopeResolver(ResolverObject *ro)
+{
+	this->ro = ro;
+}
+
+ScopeResolver::~ScopeResolver() {}
+
+/**
+ * Get a few random bits. Default implementation has no random bits.
+ * @return Random bits.
+ */
+/* virtual */ uint32 ScopeResolver::GetRandomBits() const
+{
+	return 0;
+}
+
+/**
+ * Get the triggers. Base class returns \c 0 to prevent trouble.
+ * @return The triggers.
+ */
+/* virtual */ uint32 ScopeResolver::GetTriggers() const
+{
+	return 0;
+}
+
+/**
+ * Set the triggers. Base class implementation does nothing.
+ * @param triggers Triggers to set.
+ */
+/* virtual */ void ScopeResolver::SetTriggers(int triggers) const {}
+
+/**
+ * Get a variable value. Default implementation has no available variables.
+ * @param variable Variable to read
+ * @param parameter Parameter for 60+x variables
+ * @param[out] available Set to false, in case the variable does not exist.
+ * @return Value
+ */
+/* virtual */ uint32 ScopeResolver::GetVariable(byte variable, uint32 parameter, bool *available) const
+{
+	DEBUG(grf, 1, "Unhandled scope variable 0x%X", variable);
+	*available = false;
+	return UINT_MAX;
+}
+
+/**
+ * Store a value into the persistent storage area (PSA). Default implementation does nothing (for newgrf classes without storage).
+ * @param pos Position to store into.
+ * @param value Value to store.
+ */
+/* virtual */ void ScopeResolver::StorePSA(uint reg, int32 value) {}
+
+/**
+ * Resolver constructor.
+ * @param grffile NewGRF file associated with the object (or \c NULL if none).
+ * @param callback Callback code being resolved (default value is #CBID_NO_CALLBACK).
+ * @param callback_param1 First parameter (var 10) of the callback (only used when \a callback is also set).
+ * @param callback_param2 Second parameter (var 18) of the callback (only used when \a callback is also set).
+ */
+ResolverObject::ResolverObject(const GRFFile *grffile, CallbackID callback, uint32 callback_param1, uint32 callback_param2)
+		: default_scope(this)
+{
+	this->callback = callback;
+	this->callback_param1 = callback_param1;
+	this->callback_param2 = callback_param2;
+	this->ResetState();
+
+	this->grffile = grffile;
+}
+
+ResolverObject::~ResolverObject() {}
+
+/**
+ * Get the real sprites of the grf.
+ * @param group Group to get.
+ * @return The available sprite group.
+ */
+/* virtual */ const SpriteGroup *ResolverObject::ResolveReal(const RealSpriteGroup *group) const
+{
+	return NULL;
+}
+
+/**
+ * Get a resolver for the \a scope.
+ * @param scope Scope to return.
+ * @param relative Additional parameter for #VSG_SCOPE_RELATIVE.
+ * @return The resolver for the requested scope.
+ */
+/* virtual */ ScopeResolver *ResolverObject::GetScope(VarSpriteGroupScope scope, byte relative)
+{
+	return &this->default_scope;
+}
+
+/**
+ * Rotate val rot times to the right
+ * @param val the value to rotate
+ * @param rot the amount of times to rotate
+ * @return the rotated value
+ */
+static uint32 RotateRight(uint32 val, uint32 rot)
+{
+	/* Do not rotate more than necessary */
+	rot %= 32;
+
+	return (val >> rot) | (val << (32 - rot));
+}
+
+
+/* Evaluate an adjustment for a variable of the given size.
+ * U is the unsigned type and S is the signed type to use. */
+template <typename U, typename S>
+static U EvalAdjustT(const DeterministicSpriteGroupAdjust *adjust, ScopeResolver *scope, U last_value, uint32 value)
+{
+	value >>= adjust->shift_num;
+	value  &= adjust->and_mask;
+
+	if (adjust->type != DSGA_TYPE_NONE) value += (S)adjust->add_val;
+
+	switch (adjust->type) {
+		case DSGA_TYPE_DIV:  value /= (S)adjust->divmod_val; break;
+		case DSGA_TYPE_MOD:  value %= (U)adjust->divmod_val; break;
+		case DSGA_TYPE_NONE: break;
+	}
+
+	switch (adjust->operation) {
+		case DSGA_OP_ADD:  return last_value + value;
+		case DSGA_OP_SUB:  return last_value - value;
+		case DSGA_OP_SMIN: return min((S)last_value, (S)value);
+		case DSGA_OP_SMAX: return max((S)last_value, (S)value);
+		case DSGA_OP_UMIN: return min((U)last_value, (U)value);
+		case DSGA_OP_UMAX: return max((U)last_value, (U)value);
+		case DSGA_OP_SDIV: return value == 0 ? (S)last_value : (S)last_value / (S)value;
+		case DSGA_OP_SMOD: return value == 0 ? (S)last_value : (S)last_value % (S)value;
+		case DSGA_OP_UDIV: return value == 0 ? (U)last_value : (U)last_value / (U)value;
+		case DSGA_OP_UMOD: return value == 0 ? (U)last_value : (U)last_value % (U)value;
+		case DSGA_OP_MUL:  return last_value * value;
+		case DSGA_OP_AND:  return last_value & value;
+		case DSGA_OP_OR:   return last_value | value;
+		case DSGA_OP_XOR:  return last_value ^ value;
+		case DSGA_OP_STO:  _temp_store.StoreValue((U)value, (S)last_value); return last_value;
+		case DSGA_OP_RST:  return value;
+		case DSGA_OP_STOP: scope->StorePSA((U)value, (S)last_value); return last_value;
+		case DSGA_OP_ROR:  return RotateRight(last_value, value);
+		case DSGA_OP_SCMP: return ((S)last_value == (S)value) ? 1 : ((S)last_value < (S)value ? 0 : 2);
+		case DSGA_OP_UCMP: return ((U)last_value == (U)value) ? 1 : ((U)last_value < (U)value ? 0 : 2);
+		case DSGA_OP_SHL:  return (U)last_value << ((U)value & 0x1F); // mask 'value' to 5 bits, which should behave the same on all architectures.
+		case DSGA_OP_SHR:  return (U)last_value >> ((U)value & 0x1F);
+		case DSGA_OP_SAR:  return (S)last_value >> ((U)value & 0x1F);
+		default:           return value;
+	}
+}
+
+
+const SpriteGroup *DeterministicSpriteGroup::Resolve(ResolverObject *object) const
+{
+	uint32 last_value = 0;
+	uint32 value = 0;
+	uint i;
+
+	ScopeResolver *scope = object->GetScope(this->var_scope);
+
+	for (i = 0; i < this->num_adjusts; i++) {
+		DeterministicSpriteGroupAdjust *adjust = &this->adjusts[i];
+
+		/* Try to get the variable. We shall assume it is available, unless told otherwise. */
+		bool available = true;
+		if (adjust->variable == 0x7E) {
+			const SpriteGroup *subgroup = SpriteGroup::Resolve(adjust->subroutine, object);
+			if (subgroup == NULL) {
+				value = CALLBACK_FAILED;
+			} else {
+				value = subgroup->GetCallbackResult();
+			}
+
+			/* Note: 'last_value' and 'reseed' are shared between the main chain and the procedure */
+		} else if (adjust->variable == 0x7B) {
+			value = GetVariable(object, scope, adjust->parameter, last_value, &available);
+		} else {
+			value = GetVariable(object, scope, adjust->variable, adjust->parameter, &available);
+		}
+
+		if (!available) {
+			/* Unsupported variable: skip further processing and return either
+			 * the group from the first range or the default group. */
+			return SpriteGroup::Resolve(this->num_ranges > 0 ? this->ranges[0].group : this->default_group, object);
+		}
+
+		switch (this->size) {
+			case DSG_SIZE_BYTE:  value = EvalAdjustT<uint8,  int8> (adjust, scope, last_value, value); break;
+			case DSG_SIZE_WORD:  value = EvalAdjustT<uint16, int16>(adjust, scope, last_value, value); break;
+			case DSG_SIZE_DWORD: value = EvalAdjustT<uint32, int32>(adjust, scope, last_value, value); break;
+			default: NOT_REACHED();
+		}
+		last_value = value;
+	}
+
+	object->last_value = last_value;
+
+	if (this->num_ranges == 0) {
+		/* nvar == 0 is a special case -- we turn our value into a callback result */
+		if (value != CALLBACK_FAILED) value = GB(value, 0, 15);
+		static CallbackResultSpriteGroup nvarzero(0, true);
+		nvarzero.result = value;
+		return &nvarzero;
+	}
+
+	for (i = 0; i < this->num_ranges; i++) {
+		if (this->ranges[i].low <= value && value <= this->ranges[i].high) {
+			return SpriteGroup::Resolve(this->ranges[i].group, object);
+		}
+	}
+
+	return SpriteGroup::Resolve(this->default_group, object);
+}
+
+
+const SpriteGroup *RandomizedSpriteGroup::Resolve(ResolverObject *object) const
+{
+	ScopeResolver *scope = object->GetScope(this->var_scope, this->count);
+	if (object->trigger != 0) {
+		/* Handle triggers */
+		/* Magic code that may or may not do the right things... */
+		byte waiting_triggers = scope->GetTriggers();
+		byte match = this->triggers & (waiting_triggers | object->trigger);
+		bool res = (this->cmp_mode == RSG_CMP_ANY) ? (match != 0) : (match == this->triggers);
+
+		if (res) {
+			waiting_triggers &= ~match;
+			object->reseed[this->var_scope] |= (this->num_groups - 1) << this->lowest_randbit;
+		} else {
+			waiting_triggers |= object->trigger;
+		}
+
+		scope->SetTriggers(waiting_triggers);
+	}
+
+	uint32 mask  = (this->num_groups - 1) << this->lowest_randbit;
+	byte index = (scope->GetRandomBits() & mask) >> this->lowest_randbit;
+
+	return SpriteGroup::Resolve(this->groups[index], object);
+}
+
+
+const SpriteGroup *RealSpriteGroup::Resolve(ResolverObject *object) const
+{
+	return object->ResolveReal(this);
+}
+
+/**
+ * Process registers and the construction stage into the sprite layout.
+ * The passed construction stage might get reset to zero, if it gets incorporated into the layout
+ * during the preprocessing.
+ * @param [in, out] stage Construction stage (0-3), or NULL if not applicable.
+ * @return sprite layout to draw.
+ */
+const DrawTileSprites *TileLayoutSpriteGroup::ProcessRegisters(uint8 *stage) const
+{
+	if (!this->dts.NeedsPreprocessing()) {
+		if (stage != NULL && this->dts.consistent_max_offset > 0) *stage = GetConstructionStageOffset(*stage, this->dts.consistent_max_offset);
+		return &this->dts;
+	}
+
+	static DrawTileSprites result;
+	uint8 actual_stage = stage != NULL ? *stage : 0;
+	this->dts.PrepareLayout(0, 0, 0, actual_stage, false);
+	this->dts.ProcessRegisters(0, 0, false);
+	result.seq = this->dts.GetLayout(&result.ground);
+
+	/* Stage has been processed by PrepareLayout(), set it to zero. */
+	if (stage != NULL) *stage = 0;
+
+	return &result;
+}
diff --git a/src/saveload/afterload.cpp b/src/saveload/afterload.cpp
index a4be617..49723d6 100644
--- a/src/saveload/afterload.cpp
+++ b/src/saveload/afterload.cpp
@@ -689,6 +689,9 @@ bool AfterLoadGame()
 	/* Update all vehicles */
 	AfterLoadVehicles(true);
 
+	// MYGUI
+	AfterLoadTemplateVehicles();
+
 	/* Make sure there is an AI attached to an AI company */
 	{
 		Company *c;
diff --git a/src/saveload/saveload.cpp b/src/saveload/saveload.cpp
index 69b42da..831bcd7 100644
--- a/src/saveload/saveload.cpp
+++ b/src/saveload/saveload.cpp
@@ -42,6 +42,8 @@
 #include "../fios.h"
 #include "../error.h"
 
+#include "../aaa_template_vehicle.h" //MYGUI
+
 #include "table/strings.h"
 
 #include "saveload_internal.h"
@@ -428,6 +430,8 @@ extern const ChunkHandler _labelmaps_chunk_handlers[];
 extern const ChunkHandler _airport_chunk_handlers[];
 extern const ChunkHandler _object_chunk_handlers[];
 extern const ChunkHandler _persistent_storage_chunk_handlers[];
+extern const ChunkHandler _template_replacement_chunk_handlers[]; //MYGUI
+extern const ChunkHandler _template_vehicle_chunk_handlers[]; //MYGUI
 
 /** Array of all chunks in a savegame, \c NULL terminated. */
 static const ChunkHandler * const _chunk_handlers[] = {
@@ -462,6 +466,8 @@ static const ChunkHandler * const _chunk_handlers[] = {
 	_airport_chunk_handlers,
 	_object_chunk_handlers,
 	_persistent_storage_chunk_handlers,
+	_template_replacement_chunk_handlers,			// MYGUI
+	_template_vehicle_chunk_handlers,				// MYGUI
 	NULL,
 };
 
@@ -1208,6 +1214,7 @@ static size_t ReferenceToInt(const void *obj, SLRefType rt)
 	switch (rt) {
 		case REF_VEHICLE_OLD: // Old vehicles we save as new ones
 		case REF_VEHICLE:   return ((const  Vehicle*)obj)->index + 1;
+		case REF_TEMPLATE_VEHICLE: return ((const TemplateVehicle*)obj)->index + 1;	// MYGUI
 		case REF_STATION:   return ((const  Station*)obj)->index + 1;
 		case REF_TOWN:      return ((const     Town*)obj)->index + 1;
 		case REF_ORDER:     return ((const    Order*)obj)->index + 1;
@@ -1265,6 +1272,10 @@ static void *IntToReference(size_t index, SLRefType rt)
 			if (Vehicle::IsValidID(index)) return Vehicle::Get(index);
 			SlErrorCorrupt("Referencing invalid Vehicle");
 
+		case REF_TEMPLATE_VEHICLE:						// MYGUI
+			if (TemplateVehicle::IsValidID(index)) return TemplateVehicle::Get(index);
+			SlErrorCorrupt("Referencing invalid TemplateVehicle");
+
 		case REF_STATION:
 			if (Station::IsValidID(index)) return Station::Get(index);
 			SlErrorCorrupt("Referencing invalid Station");
diff --git a/src/saveload/saveload.h b/src/saveload/saveload.h
index c5ffbef..2b67d9c 100644
--- a/src/saveload/saveload.h
+++ b/src/saveload/saveload.h
@@ -83,6 +83,7 @@ enum SLRefType {
 	REF_CARGO_PACKET  = 7, ///< Load/save a reference to a cargo packet.
 	REF_ORDERLIST     = 8, ///< Load/save a reference to an orderlist.
 	REF_STORAGE       = 9, ///< Load/save a reference to a persistent storage.
+	REF_TEMPLATE_VEHICLE = 10, ///< Load/save a reference to a template vehicle     // MYGUI
 };
 
 /** Highest possible savegame version. */
diff --git a/src/saveload/saveload_internal.h b/src/saveload/saveload_internal.h
index 5217db1..dbcbcfd 100644
--- a/src/saveload/saveload_internal.h
+++ b/src/saveload/saveload_internal.h
@@ -28,6 +28,7 @@ const SaveLoad *GetBaseStationDescription();
 
 void AfterLoadVehicles(bool part_of_load);
 void FixupTrainLengths();
+void AfterLoadTemplateVehicles(); //MYGUI
 void AfterLoadStations();
 void AfterLoadRoadStops();
 void AfterLoadLabelMaps();
diff --git a/src/train.h b/src/train.h
index 8f4bc2a..1fd2d54 100644
--- a/src/train.h
+++ b/src/train.h
@@ -104,6 +104,9 @@ struct Train FINAL : public GroundVehicle<Train, VEH_TRAIN> {
 	Money GetRunningCost() const;
 	int GetDisplayImageWidth(Point *offset = NULL) const;
 	bool IsInDepot() const { return this->track == TRACK_BIT_DEPOT; }
+	// MYGUI
+	Money CalculateCurrentOverallValue() const;
+	// ENDMYGUI
 	bool Tick();
 	void OnNewDay();
 	uint Crash(bool flooded = false);
@@ -147,6 +150,13 @@ struct Train FINAL : public GroundVehicle<Train, VEH_TRAIN> {
 		return v;
 	}
 
+	// MYGUI
+	inline Train *GetLastUnit() {
+		Train *tmp = this;
+		while ( tmp->GetNextUnit() ) tmp = tmp->GetNextUnit();
+		return tmp;
+	}
+
 	/**
 	 * Calculate the offset from this vehicle's center to the following center taking the vehicle lengths into account.
 	 * @return Offset from center to center.
@@ -320,6 +330,16 @@ protected: // These functions should not be called outside acceleration code.
 	}
 };
 
+
+// TODO
+CommandCost CmdBuildRailVehicle(TileIndex, DoCommandFlag, const Engine *, uint16, Vehicle**);
+CommandCost CmdMoveRailVehicle(TileIndex, DoCommandFlag , uint32, uint32, const char *);
+CommandCost CmdMoveVirtualRailVehicle(TileIndex, DoCommandFlag, uint32, uint32, const char*);
+
+Train* CmdBuildVirtualRailWagon(const Engine*);
+Train* CmdBuildVirtualRailVehicle(EngineID);
+CommandCost CmdSellRailWagon(DoCommandFlag, Vehicle*, uint16, uint32);
+
 #define FOR_ALL_TRAINS(var) FOR_ALL_VEHICLES_OF_TYPE(Train, var)
 
 #endif /* TRAIN_H */
diff --git a/src/train.h.orig b/src/train.h.orig
new file mode 100644
index 0000000..8f4bc2a
--- /dev/null
+++ b/src/train.h.orig
@@ -0,0 +1,325 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file train.h Base for the train class. */
+
+#ifndef TRAIN_H
+#define TRAIN_H
+
+#include "newgrf_engine.h"
+#include "cargotype.h"
+#include "rail.h"
+#include "engine_base.h"
+#include "rail_map.h"
+#include "ground_vehicle.hpp"
+
+struct Train;
+
+/** Rail vehicle flags. */
+enum VehicleRailFlags {
+	VRF_REVERSING                     = 0,
+	VRF_POWEREDWAGON                  = 3, ///< Wagon is powered.
+	VRF_REVERSE_DIRECTION             = 4, ///< Reverse the visible direction of the vehicle.
+
+	VRF_EL_ENGINE_ALLOWED_NORMAL_RAIL = 6, ///< Electric train engine is allowed to run on normal rail. */
+	VRF_TOGGLE_REVERSE                = 7, ///< Used for vehicle var 0xFE bit 8 (toggled each time the train is reversed, accurate for first vehicle only).
+	VRF_TRAIN_STUCK                   = 8, ///< Train can't get a path reservation.
+	VRF_LEAVING_STATION               = 9, ///< Train is just leaving a station.
+};
+
+/** Modes for ignoring signals. */
+enum TrainForceProceeding {
+	TFP_NONE   = 0,    ///< Normal operation.
+	TFP_STUCK  = 1,    ///< Proceed till next signal, but ignore being stuck till then. This includes force leaving depots.
+	TFP_SIGNAL = 2,    ///< Ignore next signal, after the signal ignore being stuck.
+};
+typedef SimpleTinyEnumT<TrainForceProceeding, byte> TrainForceProceedingByte;
+
+byte FreightWagonMult(CargoID cargo);
+
+void CheckTrainsLengths();
+
+void FreeTrainTrackReservation(const Train *v, TileIndex origin = INVALID_TILE, Trackdir orig_td = INVALID_TRACKDIR);
+bool TryPathReserve(Train *v, bool mark_as_stuck = false, bool first_tile_okay = false);
+
+int GetTrainStopLocation(StationID station_id, TileIndex tile, const Train *v, int *station_ahead, int *station_length);
+
+void GetTrainSpriteSize(EngineID engine, uint &width, uint &height, int &xoffs, int &yoffs, EngineImageType image_type);
+
+/** Variables that are cached to improve performance and such */
+struct TrainCache {
+	/* Cached wagon override spritegroup */
+	const struct SpriteGroup *cached_override;
+
+	/* cached values, recalculated on load and each time a vehicle is added to/removed from the consist. */
+	bool cached_tilt;           ///< train can tilt; feature provides a bonus in curves
+
+	byte user_def_data;         ///< Cached property 0x25. Can be set by Callback 0x36.
+
+	/* cached max. speed / acceleration data */
+	int cached_max_curve_speed; ///< max consist speed limited by curves
+};
+
+/**
+ * 'Train' is either a loco or a wagon.
+ */
+struct Train FINAL : public GroundVehicle<Train, VEH_TRAIN> {
+	TrainCache tcache;
+
+	/* Link between the two ends of a multiheaded engine */
+	Train *other_multiheaded_part;
+
+	uint16 crash_anim_pos; ///< Crash animation counter.
+
+	uint16 flags;
+	TrackBitsByte track;
+	TrainForceProceedingByte force_proceed;
+	RailTypeByte railtype;
+	RailTypes compatible_railtypes;
+
+	/** Ticks waiting in front of a signal, ticks being stuck or a counter for forced proceeding through signals. */
+	uint16 wait_counter;
+
+	/** We don't want GCC to zero our struct! It already is zeroed and has an index! */
+	Train() : GroundVehicleBase() {}
+	/** We want to 'destruct' the right class. */
+	virtual ~Train() { this->PreDestructor(); }
+
+	friend struct GroundVehicle<Train, VEH_TRAIN>; // GroundVehicle needs to use the acceleration functions defined at Train.
+
+	void MarkDirty();
+	void UpdateDeltaXY(Direction direction);
+	ExpensesType GetExpenseType(bool income) const { return income ? EXPENSES_TRAIN_INC : EXPENSES_TRAIN_RUN; }
+	void PlayLeaveStationSound() const;
+	bool IsPrimaryVehicle() const { return this->IsFrontEngine(); }
+	SpriteID GetImage(Direction direction, EngineImageType image_type) const;
+	int GetDisplaySpeed() const { return this->gcache.last_speed; }
+	int GetDisplayMaxSpeed() const { return this->vcache.cached_max_speed; }
+	Money GetRunningCost() const;
+	int GetDisplayImageWidth(Point *offset = NULL) const;
+	bool IsInDepot() const { return this->track == TRACK_BIT_DEPOT; }
+	bool Tick();
+	void OnNewDay();
+	uint Crash(bool flooded = false);
+	Trackdir GetVehicleTrackdir() const;
+	TileIndex GetOrderStationLocation(StationID station);
+	bool FindClosestDepot(TileIndex *location, DestinationID *destination, bool *reverse);
+
+	void ReserveTrackUnderConsist() const;
+
+	int GetCurveSpeedLimit() const;
+
+	void ConsistChanged(bool same_length);
+
+	int UpdateSpeed();
+
+	void UpdateAcceleration();
+
+	int GetCurrentMaxSpeed() const;
+
+	/**
+	 * Get the next real (non-articulated part and non rear part of dualheaded engine) vehicle in the consist.
+	 * @return Next vehicle in the consist.
+	 */
+	inline Train *GetNextUnit() const
+	{
+		Train *v = this->GetNextVehicle();
+		if (v != NULL && v->IsRearDualheaded()) v = v->GetNextVehicle();
+
+		return v;
+	}
+
+	/**
+	 * Get the previous real (non-articulated part and non rear part of dualheaded engine) vehicle in the consist.
+	 * @return Previous vehicle in the consist.
+	 */
+	inline Train *GetPrevUnit()
+	{
+		Train *v = this->GetPrevVehicle();
+		if (v != NULL && v->IsRearDualheaded()) v = v->GetPrevVehicle();
+
+		return v;
+	}
+
+	/**
+	 * Calculate the offset from this vehicle's center to the following center taking the vehicle lengths into account.
+	 * @return Offset from center to center.
+	 */
+	int CalcNextVehicleOffset() const
+	{
+		/* For vehicles with odd lengths the part before the center will be one unit
+		 * longer than the part after the center. This means we have to round up the
+		 * length of the next vehicle but may not round the length of the current
+		 * vehicle. */
+		return this->gcache.cached_veh_length / 2 + (this->Next() != NULL ? this->Next()->gcache.cached_veh_length + 1 : 0) / 2;
+	}
+
+protected: // These functions should not be called outside acceleration code.
+
+	/**
+	 * Allows to know the power value that this vehicle will use.
+	 * @return Power value from the engine in HP, or zero if the vehicle is not powered.
+	 */
+	inline uint16 GetPower() const
+	{
+		/* Power is not added for articulated parts */
+		if (!this->IsArticulatedPart() && HasPowerOnRail(this->railtype, GetRailType(this->tile))) {
+			uint16 power = GetVehicleProperty(this, PROP_TRAIN_POWER, RailVehInfo(this->engine_type)->power);
+			/* Halve power for multiheaded parts */
+			if (this->IsMultiheaded()) power /= 2;
+			return power;
+		}
+
+		return 0;
+	}
+
+	/**
+	 * Returns a value if this articulated part is powered.
+	 * @return Power value from the articulated part in HP, or zero if it is not powered.
+	 */
+	inline uint16 GetPoweredPartPower(const Train *head) const
+	{
+		/* For powered wagons the engine defines the type of engine (i.e. railtype) */
+		if (HasBit(this->flags, VRF_POWEREDWAGON) && HasPowerOnRail(head->railtype, GetRailType(this->tile))) {
+			return RailVehInfo(this->gcache.first_engine)->pow_wag_power;
+		}
+
+		return 0;
+	}
+
+	/**
+	 * Allows to know the weight value that this vehicle will use.
+	 * @return Weight value from the engine in tonnes.
+	 */
+	inline uint16 GetWeight() const
+	{
+		uint16 weight = (CargoSpec::Get(this->cargo_type)->weight * this->cargo.StoredCount() * FreightWagonMult(this->cargo_type)) / 16;
+
+		/* Vehicle weight is not added for articulated parts. */
+		if (!this->IsArticulatedPart()) {
+			weight += GetVehicleProperty(this, PROP_TRAIN_WEIGHT, RailVehInfo(this->engine_type)->weight);
+		}
+
+		/* Powered wagons have extra weight added. */
+		if (HasBit(this->flags, VRF_POWEREDWAGON)) {
+			weight += RailVehInfo(this->gcache.first_engine)->pow_wag_weight;
+		}
+
+		return weight;
+	}
+
+	/**
+	 * Allows to know the tractive effort value that this vehicle will use.
+	 * @return Tractive effort value from the engine.
+	 */
+	inline byte GetTractiveEffort() const
+	{
+		return GetVehicleProperty(this, PROP_TRAIN_TRACTIVE_EFFORT, RailVehInfo(this->engine_type)->tractive_effort);
+	}
+
+	/**
+	 * Gets the area used for calculating air drag.
+	 * @return Area of the engine in m^2.
+	 */
+	inline byte GetAirDragArea() const
+	{
+		/* Air drag is higher in tunnels due to the limited cross-section. */
+		return (this->track == TRACK_BIT_WORMHOLE && this->vehstatus & VS_HIDDEN) ? 28 : 14;
+	}
+
+	/**
+	 * Gets the air drag coefficient of this vehicle.
+	 * @return Air drag value from the engine.
+	 */
+	inline byte GetAirDrag() const
+	{
+		return RailVehInfo(this->engine_type)->air_drag;
+	}
+
+	/**
+	 * Checks the current acceleration status of this vehicle.
+	 * @return Acceleration status.
+	 */
+	inline AccelStatus GetAccelerationStatus() const
+	{
+		return (this->vehstatus & VS_STOPPED) || HasBit(this->flags, VRF_REVERSING) || HasBit(this->flags, VRF_TRAIN_STUCK) ? AS_BRAKE : AS_ACCEL;
+	}
+
+	/**
+	 * Calculates the current speed of this vehicle.
+	 * @return Current speed in km/h-ish.
+	 */
+	inline uint16 GetCurrentSpeed() const
+	{
+		return this->cur_speed;
+	}
+
+	/**
+	 * Returns the rolling friction coefficient of this vehicle.
+	 * @return Rolling friction coefficient in [1e-4].
+	 */
+	inline uint32 GetRollingFriction() const
+	{
+		/* Rolling friction for steel on steel is between 0.1% and 0.2%.
+		 * The friction coefficient increases with speed in a way that
+		 * it doubles at 512 km/h, triples at 1024 km/h and so on. */
+		return 15 * (512 + this->GetCurrentSpeed()) / 512;
+	}
+
+	/**
+	 * Allows to know the acceleration type of a vehicle.
+	 * @return Acceleration type of the vehicle.
+	 */
+	inline int GetAccelerationType() const
+	{
+		return GetRailTypeInfo(this->railtype)->acceleration_type;
+	}
+
+	/**
+	 * Returns the slope steepness used by this vehicle.
+	 * @return Slope steepness used by the vehicle.
+	 */
+	inline uint32 GetSlopeSteepness() const
+	{
+		return _settings_game.vehicle.train_slope_steepness;
+	}
+
+	/**
+	 * Gets the maximum speed allowed by the track for this vehicle.
+	 * @return Maximum speed allowed.
+	 */
+	inline uint16 GetMaxTrackSpeed() const
+	{
+		return GetRailTypeInfo(GetRailType(this->tile))->max_speed;
+	}
+
+	/**
+	 * Checks if the vehicle is at a tile that can be sloped.
+	 * @return True if the tile can be sloped.
+	 */
+	inline bool TileMayHaveSlopedTrack() const
+	{
+		/* Any track that isn't TRACK_BIT_X or TRACK_BIT_Y cannot be sloped. */
+		return this->track == TRACK_BIT_X || this->track == TRACK_BIT_Y;
+	}
+
+	/**
+	 * Trains can always use the faster algorithm because they
+	 * have always the same direction as the track under them.
+	 * @return false
+	 */
+	inline bool HasToUseGetSlopePixelZ()
+	{
+		return false;
+	}
+};
+
+#define FOR_ALL_TRAINS(var) FOR_ALL_VEHICLES_OF_TYPE(Train, var)
+
+#endif /* TRAIN_H */
diff --git a/src/train.h.rej b/src/train.h.rej
new file mode 100644
index 0000000..acd2988
--- /dev/null
+++ b/src/train.h.rej
@@ -0,0 +1,12 @@
+--- src/train.h	(revision 24056)
++++ src/train.h	(working copy)
+@@ -103,6 +103,9 @@
+ 	int GetDisplayImageWidth(Point *offset = NULL) const;
+ 	bool IsInDepot() const;
+ 	bool IsStoppedInDepot() const;
++	// MYGUI
++	Money CalculateCurrentOverallValue() const;
++	// ENDMYGUI
+ 	bool Tick();
+ 	void OnNewDay();
+ 	uint Crash(bool flooded = false);
diff --git a/src/train_cmd.cpp b/src/train_cmd.cpp
index 0d12fe8..84b0fe0 100644
--- a/src/train_cmd.cpp
+++ b/src/train_cmd.cpp
@@ -38,6 +38,8 @@
 #include "table/strings.h"
 #include "table/train_cmd.h"
 
+#include "engine_func.h" //MYGUI
+
 static Track ChooseTrainTrack(Train *v, TileIndex tile, DiagDirection enterdir, TrackBits tracks, bool force_res, bool *got_reservation, bool mark_stuck);
 static bool TrainCheckIfLineEnds(Train *v, bool reverse = true);
 bool TrainController(Train *v, Vehicle *nomove, bool reverse = true); // Also used in vehicle_sl.cpp.
@@ -241,6 +243,7 @@ void Train::ConsistChanged(bool same_length)
 	if (this->IsFrontEngine()) {
 		this->UpdateAcceleration();
 		SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
+		if ( !HasBit(this->subtype, GVSF_VIRTUAL) ) SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
 		InvalidateWindowData(WC_VEHICLE_REFIT, this->index, VIWD_CONSIST_CHANGED);
 		InvalidateWindowData(WC_VEHICLE_ORDERS, this->index, VIWD_CONSIST_CHANGED);
 	}
@@ -447,6 +450,7 @@ int Train::GetDisplayImageWidth(Point *offset) const
 		offset->x = reference_width / 2;
 		offset->y = vehicle_pitch;
 	}
+	//printf("  refwid:%d  gdiw.cachedvehlen(%d):%d  ", reference_width, this->engine_type, this->gcache.cached_veh_length);
 	return this->gcache.cached_veh_length * reference_width / VEHICLE_LENGTH;
 }
 
@@ -1128,6 +1132,7 @@ static void NormaliseTrainHead(Train *head)
  * @param p1 various bitstuffed elements
  * - p1 (bit  0 - 19) source vehicle index
  * - p1 (bit      20) move all vehicles following the source vehicle
+ * - p1 (bit	  21) this is a virtual vehicle (for creating TemplateVehicles) MYGUI
  * @param p2 what wagon to put the source wagon AFTER, XXX - INVALID_VEHICLE to make a new line
  * @param text unused
  * @return the cost of this operation or an error
@@ -1192,10 +1197,14 @@ CommandCost CmdMoveRailVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, u
 	if (!move_chain && dst != NULL && dst->IsRearDualheaded() && src == dst->other_multiheaded_part) return CommandCost();
 
 	/* Check if all vehicles in the source train are stopped inside a depot. */
-	if (!src_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
+	/* Do this check only if the vehicle to be moved is non-virtual */ //MYGUI
+	if ( !HasBit(p1, 21) )
+		if (!src_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
 
 	/* Check if all vehicles in the destination train are stopped inside a depot. */
-	if (dst_head != NULL && !dst_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
+	/* Do this check only if the destination vehicle is non-virtual */ //MYGUI
+	if ( !HasBit(p1, 21) )
+		if (dst_head != NULL && !dst_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
 
 	/* First make a backup of the order of the trains. That way we can do
 	 * whatever we want with the order and later on easily revert. */
@@ -1298,8 +1307,11 @@ CommandCost CmdMoveRailVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, u
 		}
 
 		/* We are undoubtedly changing something in the depot and train list. */
-		InvalidateWindowData(WC_VEHICLE_DEPOT, src->tile);
-		InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+		/* But only if the moved vehicle is not virtual */ // MYGUI
+		if ( !HasBit(src->subtype, GVSF_VIRTUAL) ) {
+			InvalidateWindowData(WC_VEHICLE_DEPOT, src->tile);
+			InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+		}
 	} else {
 		/* We don't want to execute what we're just tried. */
 		RestoreTrainBackup(original_src);
@@ -1386,8 +1398,11 @@ CommandCost CmdSellRailWagon(DoCommandFlag flags, Vehicle *t, uint16 data, uint3
 		NormaliseTrainHead(new_head);
 
 		/* We are undoubtedly changing something in the depot and train list. */
-		InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
-		InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+		/* Unless its a virtual train */ //MYGUI
+		if ( !HasBit(v->subtype, GVSF_VIRTUAL) ) {
+			InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
+			InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+		}
 
 		/* Actually delete the sold 'goods' */
 		delete sell_head;
@@ -3702,6 +3717,17 @@ static bool TrainCheckIfLineEnds(Train *v, bool reverse)
 	return true;
 }
 
+// MYGUI
+Money Train::CalculateCurrentOverallValue() const
+{
+	Money ovr_value = 0;
+	const Train *v = this;
+	do {
+		ovr_value += v->value;
+	} while ( (v=v->GetNextVehicle()) != NULL );
+	return ovr_value;
+}
+// ENDMYGUI
 
 static bool TrainLocoHandler(Train *v, bool mode)
 {
@@ -3996,3 +4022,176 @@ Trackdir Train::GetVehicleTrackdir() const
 
 	return TrackDirectionToTrackdir(FindFirstTrack(this->track), this->direction);
 }
+
+// MYGUI inserted as global functions (previously only member funcitons)
+/*SpriteID GetImage(Train *t)
+{
+	Direction direction = DIR_W;
+	uint8 spritenum = t->spritenum;
+	SpriteID sprite;
+
+	if (HasBit(t->flags, VRF_REVERSE_DIRECTION)) direction = ReverseDir(direction);
+
+	if (is_custom_sprite(spritenum)) {
+		sprite = GetCustomVehicleSprite(t, (Direction)(direction + 4 * IS_CUSTOM_SECONDHEAD_SPRITE(spritenum)));
+		if (sprite != 0) return sprite;
+
+		spritenum = Engine::Get(t->engine_type)->original_image_index;
+	}
+
+	sprite = GetDefaultTrainSprite(spritenum, direction);
+
+	if (t->cargo.Count() >= t->cargo_cap / 2U) sprite += _wagon_full_adder[spritenum];
+
+	return sprite;
+}*/
+int GetDisplayImageWidth(Train *t, Point *offset)
+{
+	int reference_width = TRAININFO_DEFAULT_VEHICLE_WIDTH;
+	int vehicle_pitch = 0;
+
+	const Engine *e = Engine::Get(t->engine_type);
+	if (e->grf_prop.grffile != NULL && is_custom_sprite(e->u.rail.image_index)) {
+		reference_width = e->grf_prop.grffile->traininfo_vehicle_width;
+		vehicle_pitch = e->grf_prop.grffile->traininfo_vehicle_pitch;
+	}
+
+	if (offset != NULL) {
+		offset->x = reference_width / 2;
+		offset->y = vehicle_pitch;
+	}
+	//printf("  refwid:%d  gdiw.cachedvehlen(%d):%d  ", reference_width, this->engine_type, this->gcache.cached_veh_length);
+	return t->gcache.cached_veh_length * reference_width / VEHICLE_LENGTH;
+}
+
+Train* CmdBuildVirtualRailWagon(const Engine *e)
+{
+	const RailVehicleInfo *rvi = &e->u.rail;
+
+	Train *v = new Train();
+
+	v->x_pos = 0;
+	v->y_pos = 0;
+
+	v->spritenum = rvi->image_index;
+
+	v->engine_type = e->index;
+	v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
+
+	v->direction = DIR_W;
+	v->tile = 0;//INVALID_TILE;
+
+	v->owner = _current_company;
+	v->track = TRACK_BIT_DEPOT;
+	v->vehstatus = VS_HIDDEN | VS_DEFPAL;
+
+	v->SetWagon();
+	v->SetFreeWagon();
+
+	v->cargo_type = e->GetDefaultCargoType();
+	v->cargo_cap = rvi->capacity;
+
+	v->railtype = rvi->railtype;
+
+	v->build_year = _cur_year;
+	v->cur_image = SPR_IMG_QUERY;
+	v->random_bits = VehicleRandomBits();
+
+	v->group_id = DEFAULT_GROUP;
+
+	AddArticulatedParts(v);
+
+	_new_vehicle_id = v->index;
+
+	// from revision r22xxx
+	// VehicleMove(v, false);
+	// new
+	VehicleUpdateViewport(v, false);
+
+	v->First()->ConsistChanged(false);
+	//UpdateTrainGroupID(v->First());
+
+	CheckConsistencyOfArticulatedVehicle(v);
+
+	/* The GVSF_VIRTUAL flag is used to prevent depot-tile sanity checks */
+	SetBit(v->subtype, GVSF_VIRTUAL);
+
+// 	GroupStatistics::CountVehicle( v, -1 );
+
+	return v;
+}
+
+/**
+ * Build a railroad vehicle.
+ * @param tile     tile of the depot where rail-vehicle is built.
+ * @param flags    type of operation.
+ * @param e        the engine to build.
+ * @param data     bit 0 prevents any free cars from being added to the train.
+ * @param ret[out] the vehicle that has been built.
+ * @return the cost of this operation or an error.
+ */
+Train* CmdBuildVirtualRailVehicle(EngineID eid)
+{
+	if ( !IsEngineBuildable(eid, VEH_TRAIN, _current_company) ) return 0;
+	const Engine* e = Engine::Get(eid);
+	const RailVehicleInfo *rvi = &e->u.rail;
+
+	int num_vehicles = (e->u.rail.railveh_type == RAILVEH_MULTIHEAD ? 2 : 1) + CountArticulatedParts(eid, false);
+	if ( !Train::CanAllocateItem(num_vehicles) ) return 0;
+	if (rvi->railveh_type == RAILVEH_WAGON) return CmdBuildVirtualRailWagon(e);
+
+	Train *v = new Train();
+
+	v->x_pos = 0;
+	v->y_pos = 0;
+
+	v->direction = DIR_W;
+	v->tile = 0;//INVALID_TILE;
+	v->owner = _current_company;
+	v->track = TRACK_BIT_DEPOT;
+	v->vehstatus = VS_HIDDEN | VS_STOPPED | VS_DEFPAL;
+	v->spritenum = rvi->image_index;
+	v->cargo_type = e->GetDefaultCargoType();
+	v->cargo_cap = rvi->capacity;
+	v->last_station_visited = INVALID_STATION;
+
+	v->engine_type = e->index;
+	v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
+
+	v->reliability = e->reliability;
+	v->reliability_spd_dec = e->reliability_spd_dec;
+	v->max_age = e->GetLifeLengthInDays();
+
+	v->railtype = rvi->railtype;
+	_new_vehicle_id = v->index;
+
+	v->cur_image = SPR_IMG_QUERY;
+	v->random_bits = VehicleRandomBits();
+
+	v->group_id = DEFAULT_GROUP;
+
+	v->SetFrontEngine();
+	v->SetEngine();
+
+	// from revision r22xxx
+//	VehicleMove(v, false);
+	//	new
+	VehicleUpdateViewport(v, false);
+
+	if (rvi->railveh_type == RAILVEH_MULTIHEAD) {
+		AddRearEngineToMultiheadedTrain(v);
+	} else {
+		AddArticulatedParts(v);
+	}
+
+	v->ConsistChanged(false);
+	//UpdateTrainGroupID(v);
+
+	CheckConsistencyOfArticulatedVehicle(v);
+
+	SetBit(v->subtype, GVSF_VIRTUAL);
+
+// 	GroupStatistics::CountVehicle( v, -1 );
+
+	return v;
+}
diff --git a/src/train_cmd.cpp.orig b/src/train_cmd.cpp.orig
new file mode 100644
index 0000000..0d12fe8
--- /dev/null
+++ b/src/train_cmd.cpp.orig
@@ -0,0 +1,3998 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file train_cmd.cpp Handling of trains. */
+
+#include "stdafx.h"
+#include "error.h"
+#include "articulated_vehicles.h"
+#include "command_func.h"
+#include "pathfinder/npf/npf_func.h"
+#include "pathfinder/yapf/yapf.hpp"
+#include "news_func.h"
+#include "company_func.h"
+#include "newgrf_sound.h"
+#include "newgrf_text.h"
+#include "strings_func.h"
+#include "viewport_func.h"
+#include "vehicle_func.h"
+#include "sound_func.h"
+#include "ai/ai.hpp"
+#include "game/game.hpp"
+#include "newgrf_station.h"
+#include "effectvehicle_func.h"
+#include "network/network.h"
+#include "spritecache.h"
+#include "core/random_func.hpp"
+#include "company_base.h"
+#include "newgrf.h"
+#include "order_backup.h"
+#include "zoom_func.h"
+
+#include "table/strings.h"
+#include "table/train_cmd.h"
+
+static Track ChooseTrainTrack(Train *v, TileIndex tile, DiagDirection enterdir, TrackBits tracks, bool force_res, bool *got_reservation, bool mark_stuck);
+static bool TrainCheckIfLineEnds(Train *v, bool reverse = true);
+bool TrainController(Train *v, Vehicle *nomove, bool reverse = true); // Also used in vehicle_sl.cpp.
+static TileIndex TrainApproachingCrossingTile(const Train *v);
+static void CheckIfTrainNeedsService(Train *v);
+static void CheckNextTrainTile(Train *v);
+
+static const byte _vehicle_initial_x_fract[4] = {10, 8, 4,  8};
+static const byte _vehicle_initial_y_fract[4] = { 8, 4, 8, 10};
+
+
+/**
+ * Determine the side in which the train will leave the tile
+ *
+ * @param direction vehicle direction
+ * @param track vehicle track bits
+ * @return side of tile the train will leave
+ */
+static inline DiagDirection TrainExitDir(Direction direction, TrackBits track)
+{
+	static const TrackBits state_dir_table[DIAGDIR_END] = { TRACK_BIT_RIGHT, TRACK_BIT_LOWER, TRACK_BIT_LEFT, TRACK_BIT_UPPER };
+
+	DiagDirection diagdir = DirToDiagDir(direction);
+
+	/* Determine the diagonal direction in which we will exit this tile */
+	if (!HasBit(direction, 0) && track != state_dir_table[diagdir]) {
+		diagdir = ChangeDiagDir(diagdir, DIAGDIRDIFF_90LEFT);
+	}
+
+	return diagdir;
+}
+
+
+/**
+ * Return the cargo weight multiplier to use for a rail vehicle
+ * @param cargo Cargo type to get multiplier for
+ * @return Cargo weight multiplier
+ */
+byte FreightWagonMult(CargoID cargo)
+{
+	if (!CargoSpec::Get(cargo)->is_freight) return 1;
+	return _settings_game.vehicle.freight_trains;
+}
+
+/** Checks if lengths of all rail vehicles are valid. If not, shows an error message. */
+void CheckTrainsLengths()
+{
+	const Train *v;
+	bool first = true;
+
+	FOR_ALL_TRAINS(v) {
+		if (v->First() == v && !(v->vehstatus & VS_CRASHED)) {
+			for (const Train *u = v, *w = v->Next(); w != NULL; u = w, w = w->Next()) {
+				if (u->track != TRACK_BIT_DEPOT) {
+					if ((w->track != TRACK_BIT_DEPOT &&
+							max(abs(u->x_pos - w->x_pos), abs(u->y_pos - w->y_pos)) != u->CalcNextVehicleOffset()) ||
+							(w->track == TRACK_BIT_DEPOT && TicksToLeaveDepot(u) <= 0)) {
+						SetDParam(0, v->index);
+						SetDParam(1, v->owner);
+						ShowErrorMessage(STR_BROKEN_VEHICLE_LENGTH, INVALID_STRING_ID, WL_CRITICAL);
+
+						if (!_networking && first) {
+							first = false;
+							DoCommandP(0, PM_PAUSED_ERROR, 1, CMD_PAUSE);
+						}
+						/* Break so we warn only once for each train. */
+						break;
+					}
+				}
+			}
+		}
+	}
+}
+
+/**
+ * Recalculates the cached stuff of a train. Should be called each time a vehicle is added
+ * to/removed from the chain, and when the game is loaded.
+ * Note: this needs to be called too for 'wagon chains' (in the depot, without an engine)
+ * @param same_length should length of vehicles stay the same?
+ */
+void Train::ConsistChanged(bool same_length)
+{
+	uint16 max_speed = UINT16_MAX;
+
+	assert(this->IsFrontEngine() || this->IsFreeWagon());
+
+	const RailVehicleInfo *rvi_v = RailVehInfo(this->engine_type);
+	EngineID first_engine = this->IsFrontEngine() ? this->engine_type : INVALID_ENGINE;
+	this->gcache.cached_total_length = 0;
+	this->compatible_railtypes = RAILTYPES_NONE;
+
+	bool train_can_tilt = true;
+
+	for (Train *u = this; u != NULL; u = u->Next()) {
+		const RailVehicleInfo *rvi_u = RailVehInfo(u->engine_type);
+
+		/* Check the this->first cache. */
+		assert(u->First() == this);
+
+		/* update the 'first engine' */
+		u->gcache.first_engine = this == u ? INVALID_ENGINE : first_engine;
+		u->railtype = rvi_u->railtype;
+
+		if (u->IsEngine()) first_engine = u->engine_type;
+
+		/* Set user defined data to its default value */
+		u->tcache.user_def_data = rvi_u->user_def_data;
+		this->InvalidateNewGRFCache();
+		u->InvalidateNewGRFCache();
+	}
+
+	for (Train *u = this; u != NULL; u = u->Next()) {
+		/* Update user defined data (must be done before other properties) */
+		u->tcache.user_def_data = GetVehicleProperty(u, PROP_TRAIN_USER_DATA, u->tcache.user_def_data);
+		this->InvalidateNewGRFCache();
+		u->InvalidateNewGRFCache();
+	}
+
+	for (Train *u = this; u != NULL; u = u->Next()) {
+		const Engine *e_u = u->GetEngine();
+		const RailVehicleInfo *rvi_u = &e_u->u.rail;
+
+		if (!HasBit(e_u->info.misc_flags, EF_RAIL_TILTS)) train_can_tilt = false;
+
+		/* Cache wagon override sprite group. NULL is returned if there is none */
+		u->tcache.cached_override = GetWagonOverrideSpriteSet(u->engine_type, u->cargo_type, u->gcache.first_engine);
+
+		/* Reset colour map */
+		u->colourmap = PAL_NONE;
+
+		/* Update powered-wagon-status and visual effect */
+		u->UpdateVisualEffect(true);
+
+		if (rvi_v->pow_wag_power != 0 && rvi_u->railveh_type == RAILVEH_WAGON &&
+				UsesWagonOverride(u) && !HasBit(u->vcache.cached_vis_effect, VE_DISABLE_WAGON_POWER)) {
+			/* wagon is powered */
+			SetBit(u->flags, VRF_POWEREDWAGON); // cache 'powered' status
+		} else {
+			ClrBit(u->flags, VRF_POWEREDWAGON);
+		}
+
+		if (!u->IsArticulatedPart()) {
+			/* Do not count powered wagons for the compatible railtypes, as wagons always
+			   have railtype normal */
+			if (rvi_u->power > 0) {
+				this->compatible_railtypes |= GetRailTypeInfo(u->railtype)->powered_railtypes;
+			}
+
+			/* Some electric engines can be allowed to run on normal rail. It happens to all
+			 * existing electric engines when elrails are disabled and then re-enabled */
+			if (HasBit(u->flags, VRF_EL_ENGINE_ALLOWED_NORMAL_RAIL)) {
+				u->railtype = RAILTYPE_RAIL;
+				u->compatible_railtypes |= RAILTYPES_RAIL;
+			}
+
+			/* max speed is the minimum of the speed limits of all vehicles in the consist */
+			if ((rvi_u->railveh_type != RAILVEH_WAGON || _settings_game.vehicle.wagon_speed_limits) && !UsesWagonOverride(u)) {
+				uint16 speed = GetVehicleProperty(u, PROP_TRAIN_SPEED, rvi_u->max_speed);
+				if (speed != 0) max_speed = min(speed, max_speed);
+			}
+		}
+
+		u->cargo_cap = e_u->DetermineCapacity(u);
+		u->vcache.cached_cargo_age_period = GetVehicleProperty(u, PROP_TRAIN_CARGO_AGE_PERIOD, e_u->info.cargo_age_period);
+
+		/* check the vehicle length (callback) */
+		uint16 veh_len = CALLBACK_FAILED;
+		if (e_u->GetGRF() != NULL && e_u->GetGRF()->grf_version >= 8) {
+			/* Use callback 36 */
+			veh_len = GetVehicleProperty(u, PROP_TRAIN_SHORTEN_FACTOR, CALLBACK_FAILED);
+
+			if (veh_len != CALLBACK_FAILED && veh_len >= VEHICLE_LENGTH) {
+				ErrorUnknownCallbackResult(e_u->GetGRFID(), CBID_VEHICLE_LENGTH, veh_len);
+			}
+		} else if (HasBit(e_u->info.callback_mask, CBM_VEHICLE_LENGTH)) {
+			/* Use callback 11 */
+			veh_len = GetVehicleCallback(CBID_VEHICLE_LENGTH, 0, 0, u->engine_type, u);
+		}
+		if (veh_len == CALLBACK_FAILED) veh_len = rvi_u->shorten_factor;
+		veh_len = VEHICLE_LENGTH - Clamp(veh_len, 0, VEHICLE_LENGTH - 1);
+
+		/* verify length hasn't changed */
+		if (same_length && veh_len != u->gcache.cached_veh_length) VehicleLengthChanged(u);
+
+		/* update vehicle length? */
+		if (!same_length) u->gcache.cached_veh_length = veh_len;
+
+		this->gcache.cached_total_length += u->gcache.cached_veh_length;
+		this->InvalidateNewGRFCache();
+		u->InvalidateNewGRFCache();
+	}
+
+	/* store consist weight/max speed in cache */
+	this->vcache.cached_max_speed = max_speed;
+	this->tcache.cached_tilt = train_can_tilt;
+	this->tcache.cached_max_curve_speed = this->GetCurveSpeedLimit();
+
+	/* recalculate cached weights and power too (we do this *after* the rest, so it is known which wagons are powered and need extra weight added) */
+	this->CargoChanged();
+
+	if (this->IsFrontEngine()) {
+		this->UpdateAcceleration();
+		SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
+		InvalidateWindowData(WC_VEHICLE_REFIT, this->index, VIWD_CONSIST_CHANGED);
+		InvalidateWindowData(WC_VEHICLE_ORDERS, this->index, VIWD_CONSIST_CHANGED);
+	}
+}
+
+/**
+ * Get the stop location of (the center) of the front vehicle of a train at
+ * a platform of a station.
+ * @param station_id     the ID of the station where we're stopping
+ * @param tile           the tile where the vehicle currently is
+ * @param v              the vehicle to get the stop location of
+ * @param station_ahead  'return' the amount of 1/16th tiles in front of the train
+ * @param station_length 'return' the station length in 1/16th tiles
+ * @return the location, calculated from the begin of the station to stop at.
+ */
+int GetTrainStopLocation(StationID station_id, TileIndex tile, const Train *v, int *station_ahead, int *station_length)
+{
+	const Station *st = Station::Get(station_id);
+	*station_ahead  = st->GetPlatformLength(tile, DirToDiagDir(v->direction)) * TILE_SIZE;
+	*station_length = st->GetPlatformLength(tile) * TILE_SIZE;
+
+	/* Default to the middle of the station for stations stops that are not in
+	 * the order list like intermediate stations when non-stop is disabled */
+	OrderStopLocation osl = OSL_PLATFORM_MIDDLE;
+	if (v->gcache.cached_total_length >= *station_length) {
+		/* The train is longer than the station, make it stop at the far end of the platform */
+		osl = OSL_PLATFORM_FAR_END;
+	} else if (v->current_order.IsType(OT_GOTO_STATION) && v->current_order.GetDestination() == station_id) {
+		osl = v->current_order.GetStopLocation();
+	}
+
+	/* The stop location of the FRONT! of the train */
+	int stop;
+	switch (osl) {
+		default: NOT_REACHED();
+
+		case OSL_PLATFORM_NEAR_END:
+			stop = v->gcache.cached_total_length;
+			break;
+
+		case OSL_PLATFORM_MIDDLE:
+			stop = *station_length - (*station_length - v->gcache.cached_total_length) / 2;
+			break;
+
+		case OSL_PLATFORM_FAR_END:
+			stop = *station_length;
+			break;
+	}
+
+	/* Subtract half the front vehicle length of the train so we get the real
+	 * stop location of the train. */
+	return stop - (v->gcache.cached_veh_length + 1) / 2;
+}
+
+
+/**
+ * Computes train speed limit caused by curves
+ * @return imposed speed limit
+ */
+int Train::GetCurveSpeedLimit() const
+{
+	assert(this->First() == this);
+
+	static const int absolute_max_speed = UINT16_MAX;
+	int max_speed = absolute_max_speed;
+
+	if (_settings_game.vehicle.train_acceleration_model == AM_ORIGINAL) return max_speed;
+
+	int curvecount[2] = {0, 0};
+
+	/* first find the curve speed limit */
+	int numcurve = 0;
+	int sum = 0;
+	int pos = 0;
+	int lastpos = -1;
+	for (const Vehicle *u = this; u->Next() != NULL; u = u->Next(), pos++) {
+		Direction this_dir = u->direction;
+		Direction next_dir = u->Next()->direction;
+
+		DirDiff dirdiff = DirDifference(this_dir, next_dir);
+		if (dirdiff == DIRDIFF_SAME) continue;
+
+		if (dirdiff == DIRDIFF_45LEFT) curvecount[0]++;
+		if (dirdiff == DIRDIFF_45RIGHT) curvecount[1]++;
+		if (dirdiff == DIRDIFF_45LEFT || dirdiff == DIRDIFF_45RIGHT) {
+			if (lastpos != -1) {
+				numcurve++;
+				sum += pos - lastpos;
+				if (pos - lastpos == 1 && max_speed > 88) {
+					max_speed = 88;
+				}
+			}
+			lastpos = pos;
+		}
+
+		/* if we have a 90 degree turn, fix the speed limit to 60 */
+		if (dirdiff == DIRDIFF_90LEFT || dirdiff == DIRDIFF_90RIGHT) {
+			max_speed = 61;
+		}
+	}
+
+	if (numcurve > 0 && max_speed > 88) {
+		if (curvecount[0] == 1 && curvecount[1] == 1) {
+			max_speed = absolute_max_speed;
+		} else {
+			sum /= numcurve;
+			max_speed = 232 - (13 - Clamp(sum, 1, 12)) * (13 - Clamp(sum, 1, 12));
+		}
+	}
+
+	if (max_speed != absolute_max_speed) {
+		/* Apply the engine's rail type curve speed advantage, if it slowed by curves */
+		const RailtypeInfo *rti = GetRailTypeInfo(this->railtype);
+		max_speed += (max_speed / 2) * rti->curve_speed;
+
+		if (this->tcache.cached_tilt) {
+			/* Apply max_speed bonus of 20% for a tilting train */
+			max_speed += max_speed / 5;
+		}
+	}
+
+	return max_speed;
+}
+
+/**
+ * Calculates the maximum speed of the vehicle under its current conditions.
+ * @return Maximum speed of the vehicle.
+ */
+int Train::GetCurrentMaxSpeed() const
+{
+	int max_speed = _settings_game.vehicle.train_acceleration_model == AM_ORIGINAL ?
+			this->gcache.cached_max_track_speed :
+			this->tcache.cached_max_curve_speed;
+
+	if (_settings_game.vehicle.train_acceleration_model == AM_REALISTIC && IsRailStationTile(this->tile)) {
+		StationID sid = GetStationIndex(this->tile);
+		if (this->current_order.ShouldStopAtStation(this, sid)) {
+			int station_ahead;
+			int station_length;
+			int stop_at = GetTrainStopLocation(sid, this->tile, this, &station_ahead, &station_length);
+
+			/* The distance to go is whatever is still ahead of the train minus the
+			 * distance from the train's stop location to the end of the platform */
+			int distance_to_go = station_ahead / TILE_SIZE - (station_length - stop_at) / TILE_SIZE;
+
+			if (distance_to_go > 0) {
+				int st_max_speed = 120;
+
+				int delta_v = this->cur_speed / (distance_to_go + 1);
+				if (max_speed > (this->cur_speed - delta_v)) {
+					st_max_speed = this->cur_speed - (delta_v / 10);
+				}
+
+				st_max_speed = max(st_max_speed, 25 * distance_to_go);
+				max_speed = min(max_speed, st_max_speed);
+			}
+		}
+	}
+
+	for (const Train *u = this; u != NULL; u = u->Next()) {
+		if (_settings_game.vehicle.train_acceleration_model == AM_REALISTIC && u->track == TRACK_BIT_DEPOT) {
+			max_speed = min(max_speed, 61);
+			break;
+		}
+
+		/* Vehicle is on the middle part of a bridge. */
+		if (u->track == TRACK_BIT_WORMHOLE && !(u->vehstatus & VS_HIDDEN)) {
+			max_speed = min(max_speed, GetBridgeSpec(GetBridgeType(u->tile))->speed);
+		}
+	}
+
+	max_speed = min(max_speed, this->current_order.max_speed);
+	return min(max_speed, this->gcache.cached_max_track_speed);
+}
+
+/** Update acceleration of the train from the cached power and weight. */
+void Train::UpdateAcceleration()
+{
+	assert(this->IsFrontEngine());
+
+	uint power = this->gcache.cached_power;
+	uint weight = this->gcache.cached_weight;
+	assert(weight != 0);
+	this->acceleration = Clamp(power / weight * 4, 1, 255);
+}
+
+/**
+ * Get the width of a train vehicle image in the GUI.
+ * @param offset Additional offset for positioning the sprite; set to NULL if not needed
+ * @return Width in pixels
+ */
+int Train::GetDisplayImageWidth(Point *offset) const
+{
+	int reference_width = TRAININFO_DEFAULT_VEHICLE_WIDTH;
+	int vehicle_pitch = 0;
+
+	const Engine *e = this->GetEngine();
+	if (e->GetGRF() != NULL && is_custom_sprite(e->u.rail.image_index)) {
+		reference_width = e->GetGRF()->traininfo_vehicle_width;
+		vehicle_pitch = e->GetGRF()->traininfo_vehicle_pitch;
+	}
+
+	if (offset != NULL) {
+		offset->x = reference_width / 2;
+		offset->y = vehicle_pitch;
+	}
+	return this->gcache.cached_veh_length * reference_width / VEHICLE_LENGTH;
+}
+
+static SpriteID GetDefaultTrainSprite(uint8 spritenum, Direction direction)
+{
+	return ((direction + _engine_sprite_add[spritenum]) & _engine_sprite_and[spritenum]) + _engine_sprite_base[spritenum];
+}
+
+/**
+ * Get the sprite to display the train.
+ * @param direction Direction of view/travel.
+ * @param image_type Visualisation context.
+ * @return Sprite to display.
+ */
+SpriteID Train::GetImage(Direction direction, EngineImageType image_type) const
+{
+	uint8 spritenum = this->spritenum;
+	SpriteID sprite;
+
+	if (HasBit(this->flags, VRF_REVERSE_DIRECTION)) direction = ReverseDir(direction);
+
+	if (is_custom_sprite(spritenum)) {
+		sprite = GetCustomVehicleSprite(this, (Direction)(direction + 4 * IS_CUSTOM_SECONDHEAD_SPRITE(spritenum)), image_type);
+		if (sprite != 0) return sprite;
+
+		spritenum = this->GetEngine()->original_image_index;
+	}
+
+	sprite = GetDefaultTrainSprite(spritenum, direction);
+
+	if (this->cargo.StoredCount() >= this->cargo_cap / 2U) sprite += _wagon_full_adder[spritenum];
+
+	return sprite;
+}
+
+static SpriteID GetRailIcon(EngineID engine, bool rear_head, int &y, EngineImageType image_type)
+{
+	const Engine *e = Engine::Get(engine);
+	Direction dir = rear_head ? DIR_E : DIR_W;
+	uint8 spritenum = e->u.rail.image_index;
+
+	if (is_custom_sprite(spritenum)) {
+		SpriteID sprite = GetCustomVehicleIcon(engine, dir, image_type);
+		if (sprite != 0) {
+			if (e->GetGRF() != NULL) {
+				y += e->GetGRF()->traininfo_vehicle_pitch;
+			}
+			return sprite;
+		}
+
+		spritenum = Engine::Get(engine)->original_image_index;
+	}
+
+	if (rear_head) spritenum++;
+
+	return GetDefaultTrainSprite(spritenum, DIR_W);
+}
+
+void DrawTrainEngine(int left, int right, int preferred_x, int y, EngineID engine, PaletteID pal, EngineImageType image_type)
+{
+	if (RailVehInfo(engine)->railveh_type == RAILVEH_MULTIHEAD) {
+		int yf = y;
+		int yr = y;
+
+		SpriteID spritef = GetRailIcon(engine, false, yf, image_type);
+		SpriteID spriter = GetRailIcon(engine, true, yr, image_type);
+		const Sprite *real_spritef = GetSprite(spritef, ST_NORMAL);
+		const Sprite *real_spriter = GetSprite(spriter, ST_NORMAL);
+
+		preferred_x = Clamp(preferred_x, left - UnScaleByZoom(real_spritef->x_offs, ZOOM_LVL_GUI) + 14, right - UnScaleByZoom(real_spriter->width, ZOOM_LVL_GUI) - UnScaleByZoom(real_spriter->x_offs, ZOOM_LVL_GUI) - 15);
+
+		DrawSprite(spritef, pal, preferred_x - 14, yf);
+		DrawSprite(spriter, pal, preferred_x + 15, yr);
+	} else {
+		SpriteID sprite = GetRailIcon(engine, false, y, image_type);
+		const Sprite *real_sprite = GetSprite(sprite, ST_NORMAL);
+		preferred_x = Clamp(preferred_x, left - UnScaleByZoom(real_sprite->x_offs, ZOOM_LVL_GUI), right - UnScaleByZoom(real_sprite->width, ZOOM_LVL_GUI) - UnScaleByZoom(real_sprite->x_offs, ZOOM_LVL_GUI));
+		DrawSprite(sprite, pal, preferred_x, y);
+	}
+}
+
+/**
+ * Get the size of the sprite of a train sprite heading west, or both heads (used for lists).
+ * @param engine The engine to get the sprite from.
+ * @param[out] width The width of the sprite.
+ * @param[out] height The height of the sprite.
+ * @param[out] xoffs Number of pixels to shift the sprite to the right.
+ * @param[out] yoffs Number of pixels to shift the sprite downwards.
+ * @param image_type Context the sprite is used in.
+ */
+void GetTrainSpriteSize(EngineID engine, uint &width, uint &height, int &xoffs, int &yoffs, EngineImageType image_type)
+{
+	int y = 0;
+
+	SpriteID sprite = GetRailIcon(engine, false, y, image_type);
+	const Sprite *real_sprite = GetSprite(sprite, ST_NORMAL);
+
+	width  = UnScaleByZoom(real_sprite->width, ZOOM_LVL_GUI);
+	height = UnScaleByZoom(real_sprite->height, ZOOM_LVL_GUI);
+	xoffs  = UnScaleByZoom(real_sprite->x_offs, ZOOM_LVL_GUI);
+	yoffs  = UnScaleByZoom(real_sprite->y_offs, ZOOM_LVL_GUI);
+
+	if (RailVehInfo(engine)->railveh_type == RAILVEH_MULTIHEAD) {
+		sprite = GetRailIcon(engine, true, y, image_type);
+		real_sprite = GetSprite(sprite, ST_NORMAL);
+
+		/* Calculate values relative to an imaginary center between the two sprites. */
+		width = TRAININFO_DEFAULT_VEHICLE_WIDTH + UnScaleByZoom(real_sprite->width, ZOOM_LVL_GUI) + UnScaleByZoom(real_sprite->x_offs, ZOOM_LVL_GUI) - xoffs;
+		height = max<uint>(height, UnScaleByZoom(real_sprite->height, ZOOM_LVL_GUI));
+		xoffs  = xoffs - TRAININFO_DEFAULT_VEHICLE_WIDTH / 2;
+		yoffs  = min(yoffs, UnScaleByZoom(real_sprite->y_offs, ZOOM_LVL_GUI));
+	}
+}
+
+/**
+ * Build a railroad wagon.
+ * @param tile     tile of the depot where rail-vehicle is built.
+ * @param flags    type of operation.
+ * @param e        the engine to build.
+ * @param ret[out] the vehicle that has been built.
+ * @return the cost of this operation or an error.
+ */
+static CommandCost CmdBuildRailWagon(TileIndex tile, DoCommandFlag flags, const Engine *e, Vehicle **ret)
+{
+	const RailVehicleInfo *rvi = &e->u.rail;
+
+	/* Check that the wagon can drive on the track in question */
+	if (!IsCompatibleRail(rvi->railtype, GetRailType(tile))) return CMD_ERROR;
+
+	if (flags & DC_EXEC) {
+		Train *v = new Train();
+		*ret = v;
+		v->spritenum = rvi->image_index;
+
+		v->engine_type = e->index;
+		v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
+
+		DiagDirection dir = GetRailDepotDirection(tile);
+
+		v->direction = DiagDirToDir(dir);
+		v->tile = tile;
+
+		int x = TileX(tile) * TILE_SIZE | _vehicle_initial_x_fract[dir];
+		int y = TileY(tile) * TILE_SIZE | _vehicle_initial_y_fract[dir];
+
+		v->x_pos = x;
+		v->y_pos = y;
+		v->z_pos = GetSlopePixelZ(x, y);
+		v->owner = _current_company;
+		v->track = TRACK_BIT_DEPOT;
+		v->vehstatus = VS_HIDDEN | VS_DEFPAL;
+
+		v->SetWagon();
+
+		v->SetFreeWagon();
+		InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
+
+		v->cargo_type = e->GetDefaultCargoType();
+		v->cargo_cap = rvi->capacity;
+
+		v->railtype = rvi->railtype;
+
+		v->build_year = _cur_year;
+		v->cur_image = SPR_IMG_QUERY;
+		v->random_bits = VehicleRandomBits();
+
+		v->group_id = DEFAULT_GROUP;
+
+		AddArticulatedParts(v);
+
+		_new_vehicle_id = v->index;
+
+		VehicleUpdatePosition(v);
+		v->First()->ConsistChanged(false);
+		UpdateTrainGroupID(v->First());
+
+		CheckConsistencyOfArticulatedVehicle(v);
+
+		/* Try to connect the vehicle to one of free chains of wagons. */
+		Train *w;
+		FOR_ALL_TRAINS(w) {
+			if (w->tile == tile &&              ///< Same depot
+					w->IsFreeWagon() &&             ///< A free wagon chain
+					w->engine_type == e->index &&   ///< Same type
+					w->First() != v &&              ///< Don't connect to ourself
+					!(w->vehstatus & VS_CRASHED)) { ///< Not crashed/flooded
+				DoCommand(0, v->index | 1 << 20, w->Last()->index, DC_EXEC, CMD_MOVE_RAIL_VEHICLE);
+				break;
+			}
+		}
+	}
+
+	return CommandCost();
+}
+
+/** Move all free vehicles in the depot to the train */
+static void NormalizeTrainVehInDepot(const Train *u)
+{
+	const Train *v;
+	FOR_ALL_TRAINS(v) {
+		if (v->IsFreeWagon() && v->tile == u->tile &&
+				v->track == TRACK_BIT_DEPOT) {
+			if (DoCommand(0, v->index | 1 << 20, u->index, DC_EXEC,
+					CMD_MOVE_RAIL_VEHICLE).Failed())
+				break;
+		}
+	}
+}
+
+static void AddRearEngineToMultiheadedTrain(Train *v)
+{
+	Train *u = new Train();
+	v->value >>= 1;
+	u->value = v->value;
+	u->direction = v->direction;
+	u->owner = v->owner;
+	u->tile = v->tile;
+	u->x_pos = v->x_pos;
+	u->y_pos = v->y_pos;
+	u->z_pos = v->z_pos;
+	u->track = TRACK_BIT_DEPOT;
+	u->vehstatus = v->vehstatus & ~VS_STOPPED;
+	u->spritenum = v->spritenum + 1;
+	u->cargo_type = v->cargo_type;
+	u->cargo_subtype = v->cargo_subtype;
+	u->cargo_cap = v->cargo_cap;
+	u->railtype = v->railtype;
+	u->engine_type = v->engine_type;
+	u->build_year = v->build_year;
+	u->cur_image = SPR_IMG_QUERY;
+	u->random_bits = VehicleRandomBits();
+	v->SetMultiheaded();
+	u->SetMultiheaded();
+	v->SetNext(u);
+	VehicleUpdatePosition(u);
+
+	/* Now we need to link the front and rear engines together */
+	v->other_multiheaded_part = u;
+	u->other_multiheaded_part = v;
+}
+
+/**
+ * Build a railroad vehicle.
+ * @param tile     tile of the depot where rail-vehicle is built.
+ * @param flags    type of operation.
+ * @param e        the engine to build.
+ * @param data     bit 0 prevents any free cars from being added to the train.
+ * @param ret[out] the vehicle that has been built.
+ * @return the cost of this operation or an error.
+ */
+CommandCost CmdBuildRailVehicle(TileIndex tile, DoCommandFlag flags, const Engine *e, uint16 data, Vehicle **ret)
+{
+	const RailVehicleInfo *rvi = &e->u.rail;
+
+	if (rvi->railveh_type == RAILVEH_WAGON) return CmdBuildRailWagon(tile, flags, e, ret);
+
+	/* Check if depot and new engine uses the same kind of tracks *
+	 * We need to see if the engine got power on the tile to avoid electric engines in non-electric depots */
+	if (!HasPowerOnRail(rvi->railtype, GetRailType(tile))) return CMD_ERROR;
+
+	if (flags & DC_EXEC) {
+		DiagDirection dir = GetRailDepotDirection(tile);
+		int x = TileX(tile) * TILE_SIZE + _vehicle_initial_x_fract[dir];
+		int y = TileY(tile) * TILE_SIZE + _vehicle_initial_y_fract[dir];
+
+		Train *v = new Train();
+		*ret = v;
+		v->direction = DiagDirToDir(dir);
+		v->tile = tile;
+		v->owner = _current_company;
+		v->x_pos = x;
+		v->y_pos = y;
+		v->z_pos = GetSlopePixelZ(x, y);
+		v->track = TRACK_BIT_DEPOT;
+		v->vehstatus = VS_HIDDEN | VS_STOPPED | VS_DEFPAL;
+		v->spritenum = rvi->image_index;
+		v->cargo_type = e->GetDefaultCargoType();
+		v->cargo_cap = rvi->capacity;
+		v->last_station_visited = INVALID_STATION;
+
+		v->engine_type = e->index;
+		v->gcache.first_engine = INVALID_ENGINE; // needs to be set before first callback
+
+		v->reliability = e->reliability;
+		v->reliability_spd_dec = e->reliability_spd_dec;
+		v->max_age = e->GetLifeLengthInDays();
+
+		v->railtype = rvi->railtype;
+		_new_vehicle_id = v->index;
+
+		v->SetServiceInterval(Company::Get(_current_company)->settings.vehicle.servint_trains);
+		v->date_of_last_service = _date;
+		v->build_year = _cur_year;
+		v->cur_image = SPR_IMG_QUERY;
+		v->random_bits = VehicleRandomBits();
+
+		if (e->flags & ENGINE_EXCLUSIVE_PREVIEW) SetBit(v->vehicle_flags, VF_BUILT_AS_PROTOTYPE);
+		v->SetServiceIntervalIsPercent(Company::Get(_current_company)->settings.vehicle.servint_ispercent);
+
+		v->group_id = DEFAULT_GROUP;
+
+		v->SetFrontEngine();
+		v->SetEngine();
+
+		VehicleUpdatePosition(v);
+
+		if (rvi->railveh_type == RAILVEH_MULTIHEAD) {
+			AddRearEngineToMultiheadedTrain(v);
+		} else {
+			AddArticulatedParts(v);
+		}
+
+		v->ConsistChanged(false);
+		UpdateTrainGroupID(v);
+
+		if (!HasBit(data, 0) && !(flags & DC_AUTOREPLACE)) { // check if the cars should be added to the new vehicle
+			NormalizeTrainVehInDepot(v);
+		}
+
+		CheckConsistencyOfArticulatedVehicle(v);
+	}
+
+	return CommandCost();
+}
+
+static Train *FindGoodVehiclePos(const Train *src)
+{
+	EngineID eng = src->engine_type;
+	TileIndex tile = src->tile;
+
+	Train *dst;
+	FOR_ALL_TRAINS(dst) {
+		if (dst->IsFreeWagon() && dst->tile == tile && !(dst->vehstatus & VS_CRASHED)) {
+			/* check so all vehicles in the line have the same engine. */
+			Train *t = dst;
+			while (t->engine_type == eng) {
+				t = t->Next();
+				if (t == NULL) return dst;
+			}
+		}
+	}
+
+	return NULL;
+}
+
+/** Helper type for lists/vectors of trains */
+typedef SmallVector<Train *, 16> TrainList;
+
+/**
+ * Make a backup of a train into a train list.
+ * @param list to make the backup in
+ * @param t    the train to make the backup of
+ */
+static void MakeTrainBackup(TrainList &list, Train *t)
+{
+	for (; t != NULL; t = t->Next()) *list.Append() = t;
+}
+
+/**
+ * Restore the train from the backup list.
+ * @param list the train to restore.
+ */
+static void RestoreTrainBackup(TrainList &list)
+{
+	/* No train, nothing to do. */
+	if (list.Length() == 0) return;
+
+	Train *prev = NULL;
+	/* Iterate over the list and rebuild it. */
+	for (Train **iter = list.Begin(); iter != list.End(); iter++) {
+		Train *t = *iter;
+		if (prev != NULL) {
+			prev->SetNext(t);
+		} else if (t->Previous() != NULL) {
+			/* Make sure the head of the train is always the first in the chain. */
+			t->Previous()->SetNext(NULL);
+		}
+		prev = t;
+	}
+}
+
+/**
+ * Remove the given wagon from its consist.
+ * @param part the part of the train to remove.
+ * @param chain whether to remove the whole chain.
+ */
+static void RemoveFromConsist(Train *part, bool chain = false)
+{
+	Train *tail = chain ? part->Last() : part->GetLastEnginePart();
+
+	/* Unlink at the front, but make it point to the next
+	 * vehicle after the to be remove part. */
+	if (part->Previous() != NULL) part->Previous()->SetNext(tail->Next());
+
+	/* Unlink at the back */
+	tail->SetNext(NULL);
+}
+
+/**
+ * Inserts a chain into the train at dst.
+ * @param dst   the place where to append after.
+ * @param chain the chain to actually add.
+ */
+static void InsertInConsist(Train *dst, Train *chain)
+{
+	/* We do not want to add something in the middle of an articulated part. */
+	assert(dst->Next() == NULL || !dst->Next()->IsArticulatedPart());
+
+	chain->Last()->SetNext(dst->Next());
+	dst->SetNext(chain);
+}
+
+/**
+ * Normalise the dual heads in the train, i.e. if one is
+ * missing move that one to this train.
+ * @param t the train to normalise.
+ */
+static void NormaliseDualHeads(Train *t)
+{
+	for (; t != NULL; t = t->GetNextVehicle()) {
+		if (!t->IsMultiheaded() || !t->IsEngine()) continue;
+
+		/* Make sure that there are no free cars before next engine */
+		Train *u;
+		for (u = t; u->Next() != NULL && !u->Next()->IsEngine(); u = u->Next()) {}
+
+		if (u == t->other_multiheaded_part) continue;
+
+		/* Remove the part from the 'wrong' train */
+		RemoveFromConsist(t->other_multiheaded_part);
+		/* And add it to the 'right' train */
+		InsertInConsist(u, t->other_multiheaded_part);
+	}
+}
+
+/**
+ * Normalise the sub types of the parts in this chain.
+ * @param chain the chain to normalise.
+ */
+static void NormaliseSubtypes(Train *chain)
+{
+	/* Nothing to do */
+	if (chain == NULL) return;
+
+	/* We must be the first in the chain. */
+	assert(chain->Previous() == NULL);
+
+	/* Set the appropriate bits for the first in the chain. */
+	if (chain->IsWagon()) {
+		chain->SetFreeWagon();
+	} else {
+		assert(chain->IsEngine());
+		chain->SetFrontEngine();
+	}
+
+	/* Now clear the bits for the rest of the chain */
+	for (Train *t = chain->Next(); t != NULL; t = t->Next()) {
+		t->ClearFreeWagon();
+		t->ClearFrontEngine();
+	}
+}
+
+/**
+ * Check/validate whether we may actually build a new train.
+ * @note All vehicles are/were 'heads' of their chains.
+ * @param original_dst The original destination chain.
+ * @param dst          The destination chain after constructing the train.
+ * @param original_dst The original source chain.
+ * @param dst          The source chain after constructing the train.
+ * @return possible error of this command.
+ */
+static CommandCost CheckNewTrain(Train *original_dst, Train *dst, Train *original_src, Train *src)
+{
+	/* Just add 'new' engines and subtract the original ones.
+	 * If that's less than or equal to 0 we can be sure we did
+	 * not add any engines (read: trains) along the way. */
+	if ((src          != NULL && src->IsEngine()          ? 1 : 0) +
+			(dst          != NULL && dst->IsEngine()          ? 1 : 0) -
+			(original_src != NULL && original_src->IsEngine() ? 1 : 0) -
+			(original_dst != NULL && original_dst->IsEngine() ? 1 : 0) <= 0) {
+		return CommandCost();
+	}
+
+	/* Get a free unit number and check whether it's within the bounds.
+	 * There will always be a maximum of one new train. */
+	if (GetFreeUnitNumber(VEH_TRAIN) <= _settings_game.vehicle.max_trains) return CommandCost();
+
+	return_cmd_error(STR_ERROR_TOO_MANY_VEHICLES_IN_GAME);
+}
+
+/**
+ * Check whether the train parts can be attached.
+ * @param t the train to check
+ * @return possible error of this command.
+ */
+static CommandCost CheckTrainAttachment(Train *t)
+{
+	/* No multi-part train, no need to check. */
+	if (t == NULL || t->Next() == NULL || !t->IsEngine()) return CommandCost();
+
+	/* The maximum length for a train. For each part we decrease this by one
+	 * and if the result is negative the train is simply too long. */
+	int allowed_len = _settings_game.vehicle.max_train_length * TILE_SIZE - t->gcache.cached_veh_length;
+
+	Train *head = t;
+	Train *prev = t;
+
+	/* Break the prev -> t link so it always holds within the loop. */
+	t = t->Next();
+	prev->SetNext(NULL);
+
+	/* Make sure the cache is cleared. */
+	head->InvalidateNewGRFCache();
+
+	while (t != NULL) {
+		allowed_len -= t->gcache.cached_veh_length;
+
+		Train *next = t->Next();
+
+		/* Unlink the to-be-added piece; it is already unlinked from the previous
+		 * part due to the fact that the prev -> t link is broken. */
+		t->SetNext(NULL);
+
+		/* Don't check callback for articulated or rear dual headed parts */
+		if (!t->IsArticulatedPart() && !t->IsRearDualheaded()) {
+			/* Back up and clear the first_engine data to avoid using wagon override group */
+			EngineID first_engine = t->gcache.first_engine;
+			t->gcache.first_engine = INVALID_ENGINE;
+
+			/* We don't want the cache to interfere. head's cache is cleared before
+			 * the loop and after each callback does not need to be cleared here. */
+			t->InvalidateNewGRFCache();
+
+			uint16 callback = GetVehicleCallbackParent(CBID_TRAIN_ALLOW_WAGON_ATTACH, 0, 0, head->engine_type, t, head);
+
+			/* Restore original first_engine data */
+			t->gcache.first_engine = first_engine;
+
+			/* We do not want to remember any cached variables from the test run */
+			t->InvalidateNewGRFCache();
+			head->InvalidateNewGRFCache();
+
+			if (callback != CALLBACK_FAILED) {
+				/* A failing callback means everything is okay */
+				StringID error = STR_NULL;
+
+				if (head->GetGRF()->grf_version < 8) {
+					if (callback == 0xFD) error = STR_ERROR_INCOMPATIBLE_RAIL_TYPES;
+					if (callback  < 0xFD) error = GetGRFStringID(head->GetGRFID(), 0xD000 + callback);
+					if (callback >= 0x100) ErrorUnknownCallbackResult(head->GetGRFID(), CBID_TRAIN_ALLOW_WAGON_ATTACH, callback);
+				} else {
+					if (callback < 0x400) {
+						error = GetGRFStringID(head->GetGRFID(), 0xD000 + callback);
+					} else {
+						switch (callback) {
+							case 0x400: // allow if railtypes match (always the case for OpenTTD)
+							case 0x401: // allow
+								break;
+
+							default:    // unknown reason -> disallow
+							case 0x402: // disallow attaching
+								error = STR_ERROR_INCOMPATIBLE_RAIL_TYPES;
+								break;
+						}
+					}
+				}
+
+				if (error != STR_NULL) return_cmd_error(error);
+			}
+		}
+
+		/* And link it to the new part. */
+		prev->SetNext(t);
+		prev = t;
+		t = next;
+	}
+
+	if (allowed_len < 0) return_cmd_error(STR_ERROR_TRAIN_TOO_LONG);
+	return CommandCost();
+}
+
+/**
+ * Validate whether we are going to create valid trains.
+ * @note All vehicles are/were 'heads' of their chains.
+ * @param original_dst The original destination chain.
+ * @param dst          The destination chain after constructing the train.
+ * @param original_dst The original source chain.
+ * @param dst          The source chain after constructing the train.
+ * @param check_limit  Whether to check the vehicle limit.
+ * @return possible error of this command.
+ */
+static CommandCost ValidateTrains(Train *original_dst, Train *dst, Train *original_src, Train *src, bool check_limit)
+{
+	/* Check whether we may actually construct the trains. */
+	CommandCost ret = CheckTrainAttachment(src);
+	if (ret.Failed()) return ret;
+	ret = CheckTrainAttachment(dst);
+	if (ret.Failed()) return ret;
+
+	/* Check whether we need to build a new train. */
+	return check_limit ? CheckNewTrain(original_dst, dst, original_src, src) : CommandCost();
+}
+
+/**
+ * Arrange the trains in the wanted way.
+ * @param dst_head   The destination chain of the to be moved vehicle.
+ * @param dst        The destination for the to be moved vehicle.
+ * @param src_head   The source chain of the to be moved vehicle.
+ * @param src        The to be moved vehicle.
+ * @param move_chain Whether to move all vehicles after src or not.
+ */
+static void ArrangeTrains(Train **dst_head, Train *dst, Train **src_head, Train *src, bool move_chain)
+{
+	/* First determine the front of the two resulting trains */
+	if (*src_head == *dst_head) {
+		/* If we aren't moving part(s) to a new train, we are just moving the
+		 * front back and there is not destination head. */
+		*dst_head = NULL;
+	} else if (*dst_head == NULL) {
+		/* If we are moving to a new train the head of the move train would become
+		 * the head of the new vehicle. */
+		*dst_head = src;
+	}
+
+	if (src == *src_head) {
+		/* If we are moving the front of a train then we are, in effect, creating
+		 * a new head for the train. Point to that. Unless we are moving the whole
+		 * train in which case there is not 'source' train anymore.
+		 * In case we are a multiheaded part we want the complete thing to come
+		 * with us, so src->GetNextUnit(), however... when we are e.g. a wagon
+		 * that is followed by a rear multihead we do not want to include that. */
+		*src_head = move_chain ? NULL :
+				(src->IsMultiheaded() ? src->GetNextUnit() : src->GetNextVehicle());
+	}
+
+	/* Now it's just simply removing the part that we are going to move from the
+	 * source train and *if* the destination is a not a new train add the chain
+	 * at the destination location. */
+	RemoveFromConsist(src, move_chain);
+	if (*dst_head != src) InsertInConsist(dst, src);
+
+	/* Now normalise the dual heads, that is move the dual heads around in such
+	 * a way that the head and rear of a dual head are in the same train */
+	NormaliseDualHeads(*src_head);
+	NormaliseDualHeads(*dst_head);
+}
+
+/**
+ * Normalise the head of the train again, i.e. that is tell the world that
+ * we have changed and update all kinds of variables.
+ * @param head the train to update.
+ */
+static void NormaliseTrainHead(Train *head)
+{
+	/* Not much to do! */
+	if (head == NULL) return;
+
+	/* Tell the 'world' the train changed. */
+	head->ConsistChanged(false);
+	UpdateTrainGroupID(head);
+
+	/* Not a front engine, i.e. a free wagon chain. No need to do more. */
+	if (!head->IsFrontEngine()) return;
+
+	/* Update the refit button and window */
+	InvalidateWindowData(WC_VEHICLE_REFIT, head->index, VIWD_CONSIST_CHANGED);
+	SetWindowWidgetDirty(WC_VEHICLE_VIEW, head->index, WID_VV_REFIT);
+
+	/* If we don't have a unit number yet, set one. */
+	if (head->unitnumber != 0) return;
+	head->unitnumber = GetFreeUnitNumber(VEH_TRAIN);
+}
+
+/**
+ * Move a rail vehicle around inside the depot.
+ * @param tile unused
+ * @param flags type of operation
+ *              Note: DC_AUTOREPLACE is set when autoreplace tries to undo its modifications or moves vehicles to temporary locations inside the depot.
+ * @param p1 various bitstuffed elements
+ * - p1 (bit  0 - 19) source vehicle index
+ * - p1 (bit      20) move all vehicles following the source vehicle
+ * @param p2 what wagon to put the source wagon AFTER, XXX - INVALID_VEHICLE to make a new line
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdMoveRailVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	VehicleID s = GB(p1, 0, 20);
+	VehicleID d = GB(p2, 0, 20);
+	bool move_chain = HasBit(p1, 20);
+
+	Train *src = Train::GetIfValid(s);
+	if (src == NULL) return CMD_ERROR;
+
+	CommandCost ret = CheckOwnership(src->owner);
+	if (ret.Failed()) return ret;
+
+	/* Do not allow moving crashed vehicles inside the depot, it is likely to cause asserts later */
+	if (src->vehstatus & VS_CRASHED) return CMD_ERROR;
+
+	/* if nothing is selected as destination, try and find a matching vehicle to drag to. */
+	Train *dst;
+	if (d == INVALID_VEHICLE) {
+		dst = src->IsEngine() ? NULL : FindGoodVehiclePos(src);
+	} else {
+		dst = Train::GetIfValid(d);
+		if (dst == NULL) return CMD_ERROR;
+
+		CommandCost ret = CheckOwnership(dst->owner);
+		if (ret.Failed()) return ret;
+
+		/* Do not allow appending to crashed vehicles, too */
+		if (dst->vehstatus & VS_CRASHED) return CMD_ERROR;
+	}
+
+	/* if an articulated part is being handled, deal with its parent vehicle */
+	src = src->GetFirstEnginePart();
+	if (dst != NULL) {
+		dst = dst->GetFirstEnginePart();
+	}
+
+	/* don't move the same vehicle.. */
+	if (src == dst) return CommandCost();
+
+	/* locate the head of the two chains */
+	Train *src_head = src->First();
+	Train *dst_head;
+	if (dst != NULL) {
+		dst_head = dst->First();
+		if (dst_head->tile != src_head->tile) return CMD_ERROR;
+		/* Now deal with articulated part of destination wagon */
+		dst = dst->GetLastEnginePart();
+	} else {
+		dst_head = NULL;
+	}
+
+	if (src->IsRearDualheaded()) return_cmd_error(STR_ERROR_REAR_ENGINE_FOLLOW_FRONT);
+
+	/* When moving all wagons, we can't have the same src_head and dst_head */
+	if (move_chain && src_head == dst_head) return CommandCost();
+
+	/* When moving a multiheaded part to be place after itself, bail out. */
+	if (!move_chain && dst != NULL && dst->IsRearDualheaded() && src == dst->other_multiheaded_part) return CommandCost();
+
+	/* Check if all vehicles in the source train are stopped inside a depot. */
+	if (!src_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
+
+	/* Check if all vehicles in the destination train are stopped inside a depot. */
+	if (dst_head != NULL && !dst_head->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
+
+	/* First make a backup of the order of the trains. That way we can do
+	 * whatever we want with the order and later on easily revert. */
+	TrainList original_src;
+	TrainList original_dst;
+
+	MakeTrainBackup(original_src, src_head);
+	MakeTrainBackup(original_dst, dst_head);
+
+	/* Also make backup of the original heads as ArrangeTrains can change them.
+	 * For the destination head we do not care if it is the same as the source
+	 * head because in that case it's just a copy. */
+	Train *original_src_head = src_head;
+	Train *original_dst_head = (dst_head == src_head ? NULL : dst_head);
+
+	/* We want this information from before the rearrangement, but execute this after the validation. */
+	bool original_src_head_front_engine = original_src_head != NULL && original_src_head->IsFrontEngine();
+	bool original_dst_head_front_engine = original_dst_head != NULL && original_dst_head->IsFrontEngine();
+
+	/* (Re)arrange the trains in the wanted arrangement. */
+	ArrangeTrains(&dst_head, dst, &src_head, src, move_chain);
+
+	if ((flags & DC_AUTOREPLACE) == 0) {
+		/* If the autoreplace flag is set we do not need to test for the validity
+		 * because we are going to revert the train to its original state. As we
+		 * assume the original state was correct autoreplace can skip this. */
+		CommandCost ret = ValidateTrains(original_dst_head, dst_head, original_src_head, src_head, true);
+		if (ret.Failed()) {
+			/* Restore the train we had. */
+			RestoreTrainBackup(original_src);
+			RestoreTrainBackup(original_dst);
+			return ret;
+		}
+	}
+
+	/* do it? */
+	if (flags & DC_EXEC) {
+		/* Remove old heads from the statistics */
+		if (original_src_head_front_engine) GroupStatistics::CountVehicle(original_src_head, -1);
+		if (original_dst_head_front_engine) GroupStatistics::CountVehicle(original_dst_head, -1);
+
+		/* First normalise the sub types of the chains. */
+		NormaliseSubtypes(src_head);
+		NormaliseSubtypes(dst_head);
+
+		/* There are 14 different cases:
+		 *  1) front engine gets moved to a new train, it stays a front engine.
+		 *     a) the 'next' part is a wagon that becomes a free wagon chain.
+		 *     b) the 'next' part is an engine that becomes a front engine.
+		 *     c) there is no 'next' part, nothing else happens
+		 *  2) front engine gets moved to another train, it is not a front engine anymore
+		 *     a) the 'next' part is a wagon that becomes a free wagon chain.
+		 *     b) the 'next' part is an engine that becomes a front engine.
+		 *     c) there is no 'next' part, nothing else happens
+		 *  3) front engine gets moved to later in the current train, it is not a front engine anymore.
+		 *     a) the 'next' part is a wagon that becomes a free wagon chain.
+		 *     b) the 'next' part is an engine that becomes a front engine.
+		 *  4) free wagon gets moved
+		 *     a) the 'next' part is a wagon that becomes a free wagon chain.
+		 *     b) the 'next' part is an engine that becomes a front engine.
+		 *     c) there is no 'next' part, nothing else happens
+		 *  5) non front engine gets moved and becomes a new train, nothing else happens
+		 *  6) non front engine gets moved within a train / to another train, nothing hapens
+		 *  7) wagon gets moved, nothing happens
+		 */
+		if (src == original_src_head && src->IsEngine() && !src->IsFrontEngine()) {
+			/* Cases #2 and #3: the front engine gets trashed. */
+			DeleteWindowById(WC_VEHICLE_VIEW, src->index);
+			DeleteWindowById(WC_VEHICLE_ORDERS, src->index);
+			DeleteWindowById(WC_VEHICLE_REFIT, src->index);
+			DeleteWindowById(WC_VEHICLE_DETAILS, src->index);
+			DeleteWindowById(WC_VEHICLE_TIMETABLE, src->index);
+			SetWindowDirty(WC_COMPANY, _current_company);
+
+			/* Delete orders, group stuff and the unit number as we're not the
+			 * front of any vehicle anymore. */
+			DeleteVehicleOrders(src);
+			RemoveVehicleFromGroup(src);
+			src->unitnumber = 0;
+		}
+
+		/* We weren't a front engine but are becoming one. So
+		 * we should be put in the default group. */
+		if (original_src_head != src && dst_head == src) {
+			SetTrainGroupID(src, DEFAULT_GROUP);
+			SetWindowDirty(WC_COMPANY, _current_company);
+		}
+
+		/* Add new heads to statistics */
+		if (src_head != NULL && src_head->IsFrontEngine()) GroupStatistics::CountVehicle(src_head, 1);
+		if (dst_head != NULL && dst_head->IsFrontEngine()) GroupStatistics::CountVehicle(dst_head, 1);
+
+		/* Handle 'new engine' part of cases #1b, #2b, #3b, #4b and #5 in NormaliseTrainHead. */
+		NormaliseTrainHead(src_head);
+		NormaliseTrainHead(dst_head);
+
+		if ((flags & DC_NO_CARGO_CAP_CHECK) == 0) {
+			CheckCargoCapacity(src_head);
+			CheckCargoCapacity(dst_head);
+		}
+
+		/* We are undoubtedly changing something in the depot and train list. */
+		InvalidateWindowData(WC_VEHICLE_DEPOT, src->tile);
+		InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+	} else {
+		/* We don't want to execute what we're just tried. */
+		RestoreTrainBackup(original_src);
+		RestoreTrainBackup(original_dst);
+	}
+
+	return CommandCost();
+}
+
+/**
+ * Sell a (single) train wagon/engine.
+ * @param flags type of operation
+ * @param t     the train wagon to sell
+ * @param data  the selling mode
+ * - data = 0: only sell the single dragged wagon/engine (and any belonging rear-engines)
+ * - data = 1: sell the vehicle and all vehicles following it in the chain
+ *             if the wagon is dragged, don't delete the possibly belonging rear-engine to some front
+ * @param user  the user for the order backup.
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdSellRailWagon(DoCommandFlag flags, Vehicle *t, uint16 data, uint32 user)
+{
+	/* Check if we deleted a vehicle window */
+	Window *w = NULL;
+
+	/* Sell a chain of vehicles or not? */
+	bool sell_chain = HasBit(data, 0);
+
+	Train *v = Train::From(t)->GetFirstEnginePart();
+	Train *first = v->First();
+
+	if (v->IsRearDualheaded()) return_cmd_error(STR_ERROR_REAR_ENGINE_FOLLOW_FRONT);
+
+	/* First make a backup of the order of the train. That way we can do
+	 * whatever we want with the order and later on easily revert. */
+	TrainList original;
+	MakeTrainBackup(original, first);
+
+	/* We need to keep track of the new head and the head of what we're going to sell. */
+	Train *new_head = first;
+	Train *sell_head = NULL;
+
+	/* Split the train in the wanted way. */
+	ArrangeTrains(&sell_head, NULL, &new_head, v, sell_chain);
+
+	/* We don't need to validate the second train; it's going to be sold. */
+	CommandCost ret = ValidateTrains(NULL, NULL, first, new_head, (flags & DC_AUTOREPLACE) == 0);
+	if (ret.Failed()) {
+		/* Restore the train we had. */
+		RestoreTrainBackup(original);
+		return ret;
+	}
+
+	CommandCost cost(EXPENSES_NEW_VEHICLES);
+	for (Train *t = sell_head; t != NULL; t = t->Next()) cost.AddCost(-t->value);
+
+	if (first->orders.list == NULL && !OrderList::CanAllocateItem()) {
+		return_cmd_error(STR_ERROR_NO_MORE_SPACE_FOR_ORDERS);
+	}
+
+	/* do it? */
+	if (flags & DC_EXEC) {
+		/* First normalise the sub types of the chain. */
+		NormaliseSubtypes(new_head);
+
+		if (v == first && v->IsEngine() && !sell_chain && new_head != NULL && new_head->IsFrontEngine()) {
+			/* We are selling the front engine. In this case we want to
+			 * 'give' the order, unit number and such to the new head. */
+			new_head->orders.list = first->orders.list;
+			new_head->AddToShared(first);
+			DeleteVehicleOrders(first);
+
+			/* Copy other important data from the front engine */
+			new_head->CopyVehicleConfigAndStatistics(first);
+			GroupStatistics::CountVehicle(new_head, 1); // after copying over the profit
+
+			/* If we deleted a window then open a new one for the 'new' train */
+			if (IsLocalCompany() && w != NULL) ShowVehicleViewWindow(new_head);
+		} else if (v->IsPrimaryVehicle() && data & (MAKE_ORDER_BACKUP_FLAG >> 20)) {
+			OrderBackup::Backup(v, user);
+		}
+
+		/* We need to update the information about the train. */
+		NormaliseTrainHead(new_head);
+
+		/* We are undoubtedly changing something in the depot and train list. */
+		InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
+		InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+
+		/* Actually delete the sold 'goods' */
+		delete sell_head;
+	} else {
+		/* We don't want to execute what we're just tried. */
+		RestoreTrainBackup(original);
+	}
+
+	return cost;
+}
+
+void Train::UpdateDeltaXY(Direction direction)
+{
+	/* Set common defaults. */
+	this->x_offs    = -1;
+	this->y_offs    = -1;
+	this->x_extent  =  3;
+	this->y_extent  =  3;
+	this->z_extent  =  6;
+	this->x_bb_offs =  0;
+	this->y_bb_offs =  0;
+
+	if (!IsDiagonalDirection(direction)) {
+		static const int _sign_table[] =
+		{
+			// x, y
+			-1, -1, // DIR_N
+			-1,  1, // DIR_E
+			 1,  1, // DIR_S
+			 1, -1, // DIR_W
+		};
+
+		int half_shorten = (VEHICLE_LENGTH - this->gcache.cached_veh_length) / 2;
+
+		/* For all straight directions, move the bound box to the centre of the vehicle, but keep the size. */
+		this->x_offs -= half_shorten * _sign_table[direction];
+		this->y_offs -= half_shorten * _sign_table[direction + 1];
+		this->x_extent += this->x_bb_offs = half_shorten * _sign_table[direction];
+		this->y_extent += this->y_bb_offs = half_shorten * _sign_table[direction + 1];
+	} else {
+		switch (direction) {
+				/* Shorten southern corner of the bounding box according the vehicle length
+				 * and center the bounding box on the vehicle. */
+			case DIR_NE:
+				this->x_offs    = 1 - (this->gcache.cached_veh_length + 1) / 2;
+				this->x_extent  = this->gcache.cached_veh_length - 1;
+				this->x_bb_offs = -1;
+				break;
+
+			case DIR_NW:
+				this->y_offs    = 1 - (this->gcache.cached_veh_length + 1) / 2;
+				this->y_extent  = this->gcache.cached_veh_length - 1;
+				this->y_bb_offs = -1;
+				break;
+
+				/* Move northern corner of the bounding box down according to vehicle length
+				 * and center the bounding box on the vehicle. */
+			case DIR_SW:
+				this->x_offs    = 1 + (this->gcache.cached_veh_length + 1) / 2 - VEHICLE_LENGTH;
+				this->x_extent  = VEHICLE_LENGTH - 1;
+				this->x_bb_offs = VEHICLE_LENGTH - this->gcache.cached_veh_length - 1;
+				break;
+
+			case DIR_SE:
+				this->y_offs    = 1 + (this->gcache.cached_veh_length + 1) / 2 - VEHICLE_LENGTH;
+				this->y_extent  = VEHICLE_LENGTH - 1;
+				this->y_bb_offs = VEHICLE_LENGTH - this->gcache.cached_veh_length - 1;
+				break;
+
+			default:
+				NOT_REACHED();
+		}
+	}
+}
+
+/**
+ * Mark a train as stuck and stop it if it isn't stopped right now.
+ * @param v %Train to mark as being stuck.
+ */
+static void MarkTrainAsStuck(Train *v)
+{
+	if (!HasBit(v->flags, VRF_TRAIN_STUCK)) {
+		/* It is the first time the problem occurred, set the "train stuck" flag. */
+		SetBit(v->flags, VRF_TRAIN_STUCK);
+
+		v->wait_counter = 0;
+
+		/* Stop train */
+		v->cur_speed = 0;
+		v->subspeed = 0;
+		v->SetLastSpeed();
+
+		SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);
+	}
+}
+
+/**
+ * Swap the two up/down flags in two ways:
+ * - Swap values of \a swap_flag1 and \a swap_flag2, and
+ * - If going up previously (#GVF_GOINGUP_BIT set), the #GVF_GOINGDOWN_BIT is set, and vice versa.
+ * @param swap_flag1 [inout] First train flag.
+ * @param swap_flag2 [inout] Second train flag.
+ */
+static void SwapTrainFlags(uint16 *swap_flag1, uint16 *swap_flag2)
+{
+	uint16 flag1 = *swap_flag1;
+	uint16 flag2 = *swap_flag2;
+
+	/* Clear the flags */
+	ClrBit(*swap_flag1, GVF_GOINGUP_BIT);
+	ClrBit(*swap_flag1, GVF_GOINGDOWN_BIT);
+	ClrBit(*swap_flag2, GVF_GOINGUP_BIT);
+	ClrBit(*swap_flag2, GVF_GOINGDOWN_BIT);
+
+	/* Reverse the rail-flags (if needed) */
+	if (HasBit(flag1, GVF_GOINGUP_BIT)) {
+		SetBit(*swap_flag2, GVF_GOINGDOWN_BIT);
+	} else if (HasBit(flag1, GVF_GOINGDOWN_BIT)) {
+		SetBit(*swap_flag2, GVF_GOINGUP_BIT);
+	}
+	if (HasBit(flag2, GVF_GOINGUP_BIT)) {
+		SetBit(*swap_flag1, GVF_GOINGDOWN_BIT);
+	} else if (HasBit(flag2, GVF_GOINGDOWN_BIT)) {
+		SetBit(*swap_flag1, GVF_GOINGUP_BIT);
+	}
+}
+
+/**
+ * Updates some variables after swapping the vehicle.
+ * @param v swapped vehicle
+ */
+static void UpdateStatusAfterSwap(Train *v)
+{
+	/* Reverse the direction. */
+	if (v->track != TRACK_BIT_DEPOT) v->direction = ReverseDir(v->direction);
+
+	/* Call the proper EnterTile function unless we are in a wormhole. */
+	if (v->track != TRACK_BIT_WORMHOLE) {
+		VehicleEnterTile(v, v->tile, v->x_pos, v->y_pos);
+	} else {
+		/* VehicleEnter_TunnelBridge() sets TRACK_BIT_WORMHOLE when the vehicle
+		 * is on the last bit of the bridge head (frame == TILE_SIZE - 1).
+		 * If we were swapped with such a vehicle, we have set TRACK_BIT_WORMHOLE,
+		 * when we shouldn't have. Check if this is the case. */
+		TileIndex vt = TileVirtXY(v->x_pos, v->y_pos);
+		if (IsTileType(vt, MP_TUNNELBRIDGE)) {
+			VehicleEnterTile(v, vt, v->x_pos, v->y_pos);
+			if (v->track != TRACK_BIT_WORMHOLE && IsBridgeTile(v->tile)) {
+				/* We have just left the wormhole, possibly set the
+				 * "goingdown" bit. UpdateInclination() can be used
+				 * because we are at the border of the tile. */
+				VehicleUpdatePosition(v);
+				v->UpdateInclination(true, true);
+				return;
+			}
+		}
+	}
+
+	VehicleUpdatePosition(v);
+	v->UpdateViewport(true, true);
+}
+
+/**
+ * Swap vehicles \a l and \a r in consist \a v, and reverse their direction.
+ * @param v Consist to change.
+ * @param l %Vehicle index in the consist of the first vehicle.
+ * @param r %Vehicle index in the consist of the second vehicle.
+ */
+void ReverseTrainSwapVeh(Train *v, int l, int r)
+{
+	Train *a, *b;
+
+	/* locate vehicles to swap */
+	for (a = v; l != 0; l--) a = a->Next();
+	for (b = v; r != 0; r--) b = b->Next();
+
+	if (a != b) {
+		/* swap the hidden bits */
+		{
+			uint16 tmp = (a->vehstatus & ~VS_HIDDEN) | (b->vehstatus & VS_HIDDEN);
+			b->vehstatus = (b->vehstatus & ~VS_HIDDEN) | (a->vehstatus & VS_HIDDEN);
+			a->vehstatus = tmp;
+		}
+
+		Swap(a->track, b->track);
+		Swap(a->direction, b->direction);
+		Swap(a->x_pos, b->x_pos);
+		Swap(a->y_pos, b->y_pos);
+		Swap(a->tile,  b->tile);
+		Swap(a->z_pos, b->z_pos);
+
+		SwapTrainFlags(&a->gv_flags, &b->gv_flags);
+
+		UpdateStatusAfterSwap(a);
+		UpdateStatusAfterSwap(b);
+	} else {
+		/* Swap GVF_GOINGUP_BIT/GVF_GOINGDOWN_BIT.
+		 * This is a little bit redundant way, a->gv_flags will
+		 * be (re)set twice, but it reduces code duplication */
+		SwapTrainFlags(&a->gv_flags, &a->gv_flags);
+		UpdateStatusAfterSwap(a);
+	}
+}
+
+
+/**
+ * Check if the vehicle is a train
+ * @param v vehicle on tile
+ * @return v if it is a train, NULL otherwise
+ */
+static Vehicle *TrainOnTileEnum(Vehicle *v, void *)
+{
+	return (v->type == VEH_TRAIN) ? v : NULL;
+}
+
+
+/**
+ * Checks if a train is approaching a rail-road crossing
+ * @param v vehicle on tile
+ * @param data tile with crossing we are testing
+ * @return v if it is approaching a crossing, NULL otherwise
+ */
+static Vehicle *TrainApproachingCrossingEnum(Vehicle *v, void *data)
+{
+	if (v->type != VEH_TRAIN || (v->vehstatus & VS_CRASHED)) return NULL;
+
+	Train *t = Train::From(v);
+	if (!t->IsFrontEngine()) return NULL;
+
+	TileIndex tile = *(TileIndex *)data;
+
+	if (TrainApproachingCrossingTile(t) != tile) return NULL;
+
+	return t;
+}
+
+
+/**
+ * Finds a vehicle approaching rail-road crossing
+ * @param tile tile to test
+ * @return true if a vehicle is approaching the crossing
+ * @pre tile is a rail-road crossing
+ */
+static bool TrainApproachingCrossing(TileIndex tile)
+{
+	assert(IsLevelCrossingTile(tile));
+
+	DiagDirection dir = AxisToDiagDir(GetCrossingRailAxis(tile));
+	TileIndex tile_from = tile + TileOffsByDiagDir(dir);
+
+	if (HasVehicleOnPos(tile_from, &tile, &TrainApproachingCrossingEnum)) return true;
+
+	dir = ReverseDiagDir(dir);
+	tile_from = tile + TileOffsByDiagDir(dir);
+
+	return HasVehicleOnPos(tile_from, &tile, &TrainApproachingCrossingEnum);
+}
+
+
+/**
+ * Sets correct crossing state
+ * @param tile tile to update
+ * @param sound should we play sound?
+ * @pre tile is a rail-road crossing
+ */
+void UpdateLevelCrossing(TileIndex tile, bool sound)
+{
+	assert(IsLevelCrossingTile(tile));
+
+	/* train on crossing || train approaching crossing || reserved */
+	bool new_state = HasVehicleOnPos(tile, NULL, &TrainOnTileEnum) || TrainApproachingCrossing(tile) || HasCrossingReservation(tile);
+
+	if (new_state != IsCrossingBarred(tile)) {
+		if (new_state && sound) {
+			if (_settings_client.sound.ambient) SndPlayTileFx(SND_0E_LEVEL_CROSSING, tile);
+		}
+		SetCrossingBarred(tile, new_state);
+		MarkTileDirtyByTile(tile);
+	}
+}
+
+
+/**
+ * Bars crossing and plays ding-ding sound if not barred already
+ * @param tile tile with crossing
+ * @pre tile is a rail-road crossing
+ */
+static inline void MaybeBarCrossingWithSound(TileIndex tile)
+{
+	if (!IsCrossingBarred(tile)) {
+		BarCrossing(tile);
+		if (_settings_client.sound.ambient) SndPlayTileFx(SND_0E_LEVEL_CROSSING, tile);
+		MarkTileDirtyByTile(tile);
+	}
+}
+
+
+/**
+ * Advances wagons for train reversing, needed for variable length wagons.
+ * This one is called before the train is reversed.
+ * @param v First vehicle in chain
+ */
+static void AdvanceWagonsBeforeSwap(Train *v)
+{
+	Train *base = v;
+	Train *first = base; // first vehicle to move
+	Train *last = v->Last(); // last vehicle to move
+	uint length = CountVehiclesInChain(v);
+
+	while (length > 2) {
+		last = last->Previous();
+		first = first->Next();
+
+		int differential = base->CalcNextVehicleOffset() - last->CalcNextVehicleOffset();
+
+		/* do not update images now
+		 * negative differential will be handled in AdvanceWagonsAfterSwap() */
+		for (int i = 0; i < differential; i++) TrainController(first, last->Next());
+
+		base = first; // == base->Next()
+		length -= 2;
+	}
+}
+
+
+/**
+ * Advances wagons for train reversing, needed for variable length wagons.
+ * This one is called after the train is reversed.
+ * @param v First vehicle in chain
+ */
+static void AdvanceWagonsAfterSwap(Train *v)
+{
+	/* first of all, fix the situation when the train was entering a depot */
+	Train *dep = v; // last vehicle in front of just left depot
+	while (dep->Next() != NULL && (dep->track == TRACK_BIT_DEPOT || dep->Next()->track != TRACK_BIT_DEPOT)) {
+		dep = dep->Next(); // find first vehicle outside of a depot, with next vehicle inside a depot
+	}
+
+	Train *leave = dep->Next(); // first vehicle in a depot we are leaving now
+
+	if (leave != NULL) {
+		/* 'pull' next wagon out of the depot, so we won't miss it (it could stay in depot forever) */
+		int d = TicksToLeaveDepot(dep);
+
+		if (d <= 0) {
+			leave->vehstatus &= ~VS_HIDDEN; // move it out of the depot
+			leave->track = TrackToTrackBits(GetRailDepotTrack(leave->tile));
+			for (int i = 0; i >= d; i--) TrainController(leave, NULL); // maybe move it, and maybe let another wagon leave
+		}
+	} else {
+		dep = NULL; // no vehicle in a depot, so no vehicle leaving a depot
+	}
+
+	Train *base = v;
+	Train *first = base; // first vehicle to move
+	Train *last = v->Last(); // last vehicle to move
+	uint length = CountVehiclesInChain(v);
+
+	/* We have to make sure all wagons that leave a depot because of train reversing are moved correctly
+	 * they have already correct spacing, so we have to make sure they are moved how they should */
+	bool nomove = (dep == NULL); // If there is no vehicle leaving a depot, limit the number of wagons moved immediately.
+
+	while (length > 2) {
+		/* we reached vehicle (originally) in front of a depot, stop now
+		 * (we would move wagons that are already moved with new wagon length). */
+		if (base == dep) break;
+
+		/* the last wagon was that one leaving a depot, so do not move it anymore */
+		if (last == dep) nomove = true;
+
+		last = last->Previous();
+		first = first->Next();
+
+		int differential = last->CalcNextVehicleOffset() - base->CalcNextVehicleOffset();
+
+		/* do not update images now */
+		for (int i = 0; i < differential; i++) TrainController(first, (nomove ? last->Next() : NULL));
+
+		base = first; // == base->Next()
+		length -= 2;
+	}
+}
+
+/**
+ * Turn a train around.
+ * @param v %Train to turn around.
+ */
+void ReverseTrainDirection(Train *v)
+{
+	if (IsRailDepotTile(v->tile)) {
+		InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
+	}
+
+	/* Clear path reservation in front if train is not stuck. */
+	if (!HasBit(v->flags, VRF_TRAIN_STUCK)) FreeTrainTrackReservation(v);
+
+	/* Check if we were approaching a rail/road-crossing */
+	TileIndex crossing = TrainApproachingCrossingTile(v);
+
+	/* count number of vehicles */
+	int r = CountVehiclesInChain(v) - 1;  // number of vehicles - 1
+
+	AdvanceWagonsBeforeSwap(v);
+
+	/* swap start<>end, start+1<>end-1, ... */
+	int l = 0;
+	do {
+		ReverseTrainSwapVeh(v, l++, r--);
+	} while (l <= r);
+
+	AdvanceWagonsAfterSwap(v);
+
+	if (IsRailDepotTile(v->tile)) {
+		InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
+	}
+
+	ToggleBit(v->flags, VRF_TOGGLE_REVERSE);
+
+	ClrBit(v->flags, VRF_REVERSING);
+
+	/* recalculate cached data */
+	v->ConsistChanged(true);
+
+	/* update all images */
+	for (Train *u = v; u != NULL; u = u->Next()) u->UpdateViewport(false, false);
+
+	/* update crossing we were approaching */
+	if (crossing != INVALID_TILE) UpdateLevelCrossing(crossing);
+
+	/* maybe we are approaching crossing now, after reversal */
+	crossing = TrainApproachingCrossingTile(v);
+	if (crossing != INVALID_TILE) MaybeBarCrossingWithSound(crossing);
+
+	/* If we are inside a depot after reversing, don't bother with path reserving. */
+	if (v->track == TRACK_BIT_DEPOT) {
+		/* Can't be stuck here as inside a depot is always a safe tile. */
+		if (HasBit(v->flags, VRF_TRAIN_STUCK)) SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);
+		ClrBit(v->flags, VRF_TRAIN_STUCK);
+		return;
+	}
+
+	/* TrainExitDir does not always produce the desired dir for depots and
+	 * tunnels/bridges that is needed for UpdateSignalsOnSegment. */
+	DiagDirection dir = TrainExitDir(v->direction, v->track);
+	if (IsRailDepotTile(v->tile) || IsTileType(v->tile, MP_TUNNELBRIDGE)) dir = INVALID_DIAGDIR;
+
+	if (UpdateSignalsOnSegment(v->tile, dir, v->owner) == SIGSEG_PBS || _settings_game.pf.reserve_paths) {
+		/* If we are currently on a tile with conventional signals, we can't treat the
+		 * current tile as a safe tile or we would enter a PBS block without a reservation. */
+		bool first_tile_okay = !(IsTileType(v->tile, MP_RAILWAY) &&
+			HasSignalOnTrackdir(v->tile, v->GetVehicleTrackdir()) &&
+			!IsPbsSignal(GetSignalType(v->tile, FindFirstTrack(v->track))));
+
+		/* If we are on a depot tile facing outwards, do not treat the current tile as safe. */
+		if (IsRailDepotTile(v->tile) && TrackdirToExitdir(v->GetVehicleTrackdir()) == GetRailDepotDirection(v->tile)) first_tile_okay = false;
+
+		if (IsRailStationTile(v->tile)) SetRailStationPlatformReservation(v->tile, TrackdirToExitdir(v->GetVehicleTrackdir()), true);
+		if (TryPathReserve(v, false, first_tile_okay)) {
+			/* Do a look-ahead now in case our current tile was already a safe tile. */
+			CheckNextTrainTile(v);
+		} else if (v->current_order.GetType() != OT_LOADING) {
+			/* Do not wait for a way out when we're still loading */
+			MarkTrainAsStuck(v);
+		}
+	} else if (HasBit(v->flags, VRF_TRAIN_STUCK)) {
+		/* A train not inside a PBS block can't be stuck. */
+		ClrBit(v->flags, VRF_TRAIN_STUCK);
+		v->wait_counter = 0;
+	}
+}
+
+/**
+ * Reverse train.
+ * @param tile unused
+ * @param flags type of operation
+ * @param p1 train to reverse
+ * @param p2 if true, reverse a unit in a train (needs to be in a depot)
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdReverseTrainDirection(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	Train *v = Train::GetIfValid(p1);
+	if (v == NULL) return CMD_ERROR;
+
+	CommandCost ret = CheckOwnership(v->owner);
+	if (ret.Failed()) return ret;
+
+	if (p2 != 0) {
+		/* turn a single unit around */
+
+		if (v->IsMultiheaded() || HasBit(EngInfo(v->engine_type)->callback_mask, CBM_VEHICLE_ARTIC_ENGINE)) {
+			return_cmd_error(STR_ERROR_CAN_T_REVERSE_DIRECTION_RAIL_VEHICLE_MULTIPLE_UNITS);
+		}
+		if (!HasBit(EngInfo(v->engine_type)->misc_flags, EF_RAIL_FLIPS)) return CMD_ERROR;
+
+		Train *front = v->First();
+		/* make sure the vehicle is stopped in the depot */
+		if (!front->IsStoppedInDepot()) {
+			return_cmd_error(STR_ERROR_TRAINS_CAN_ONLY_BE_ALTERED_INSIDE_A_DEPOT);
+		}
+
+		if (flags & DC_EXEC) {
+			ToggleBit(v->flags, VRF_REVERSE_DIRECTION);
+
+			front->ConsistChanged(false);
+			SetWindowDirty(WC_VEHICLE_DEPOT, front->tile);
+			SetWindowDirty(WC_VEHICLE_DETAILS, front->index);
+			SetWindowDirty(WC_VEHICLE_VIEW, front->index);
+			SetWindowClassesDirty(WC_TRAINS_LIST);
+		}
+	} else {
+		/* turn the whole train around */
+		if ((v->vehstatus & VS_CRASHED) || v->breakdown_ctr != 0) return CMD_ERROR;
+
+		if (flags & DC_EXEC) {
+			/* Properly leave the station if we are loading and won't be loading anymore */
+			if (v->current_order.IsType(OT_LOADING)) {
+				const Vehicle *last = v;
+				while (last->Next() != NULL) last = last->Next();
+
+				/* not a station || different station --> leave the station */
+				if (!IsTileType(last->tile, MP_STATION) || GetStationIndex(last->tile) != GetStationIndex(v->tile)) {
+					v->LeaveStation();
+				}
+			}
+
+			/* We cancel any 'skip signal at dangers' here */
+			v->force_proceed = TFP_NONE;
+			SetWindowDirty(WC_VEHICLE_VIEW, v->index);
+
+			if (_settings_game.vehicle.train_acceleration_model != AM_ORIGINAL && v->cur_speed != 0) {
+				ToggleBit(v->flags, VRF_REVERSING);
+			} else {
+				v->cur_speed = 0;
+				v->SetLastSpeed();
+				HideFillingPercent(&v->fill_percent_te_id);
+				ReverseTrainDirection(v);
+			}
+		}
+	}
+	return CommandCost();
+}
+
+/**
+ * Force a train through a red signal
+ * @param tile unused
+ * @param flags type of operation
+ * @param p1 train to ignore the red signal
+ * @param p2 unused
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdForceTrainProceed(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	Train *t = Train::GetIfValid(p1);
+	if (t == NULL) return CMD_ERROR;
+
+	if (!t->IsPrimaryVehicle()) return CMD_ERROR;
+
+	CommandCost ret = CheckOwnership(t->owner);
+	if (ret.Failed()) return ret;
+
+
+	if (flags & DC_EXEC) {
+		/* If we are forced to proceed, cancel that order.
+		 * If we are marked stuck we would want to force the train
+		 * to proceed to the next signal. In the other cases we
+		 * would like to pass the signal at danger and run till the
+		 * next signal we encounter. */
+		t->force_proceed = t->force_proceed == TFP_SIGNAL ? TFP_NONE : HasBit(t->flags, VRF_TRAIN_STUCK) || t->IsChainInDepot() ? TFP_STUCK : TFP_SIGNAL;
+		SetWindowDirty(WC_VEHICLE_VIEW, t->index);
+	}
+
+	return CommandCost();
+}
+
+/**
+ * Try to find a depot nearby.
+ * @param v %Train that wants a depot.
+ * @param max_distance Maximal search distance.
+ * @return Information where the closest train depot is located.
+ * @pre The given vehicle must not be crashed!
+ */
+static FindDepotData FindClosestTrainDepot(Train *v, int max_distance)
+{
+	assert(!(v->vehstatus & VS_CRASHED));
+
+	if (IsRailDepotTile(v->tile)) return FindDepotData(v->tile, 0);
+
+	PBSTileInfo origin = FollowTrainReservation(v);
+	if (IsRailDepotTile(origin.tile)) return FindDepotData(origin.tile, 0);
+
+	switch (_settings_game.pf.pathfinder_for_trains) {
+		case VPF_NPF: return NPFTrainFindNearestDepot(v, max_distance);
+		case VPF_YAPF: return YapfTrainFindNearestDepot(v, max_distance);
+
+		default: NOT_REACHED();
+	}
+}
+
+/**
+ * Locate the closest depot for this consist, and return the information to the caller.
+ * @param location [out]    If not \c NULL and a depot is found, store its location in the given address.
+ * @param destination [out] If not \c NULL and a depot is found, store its index in the given address.
+ * @param reverse [out]     If not \c NULL and a depot is found, store reversal information in the given address.
+ * @return A depot has been found.
+ */
+bool Train::FindClosestDepot(TileIndex *location, DestinationID *destination, bool *reverse)
+{
+	FindDepotData tfdd = FindClosestTrainDepot(this, 0);
+	if (tfdd.best_length == UINT_MAX) return false;
+
+	if (location    != NULL) *location    = tfdd.tile;
+	if (destination != NULL) *destination = GetDepotIndex(tfdd.tile);
+	if (reverse     != NULL) *reverse     = tfdd.reverse;
+
+	return true;
+}
+
+/** Play a sound for a train leaving the station. */
+void Train::PlayLeaveStationSound() const
+{
+	static const SoundFx sfx[] = {
+		SND_04_TRAIN,
+		SND_0A_TRAIN_HORN,
+		SND_0A_TRAIN_HORN,
+		SND_47_MAGLEV_2,
+		SND_41_MAGLEV
+	};
+
+	if (PlayVehicleSound(this, VSE_START)) return;
+
+	EngineID engtype = this->engine_type;
+	SndPlayVehicleFx(sfx[RailVehInfo(engtype)->engclass], this);
+}
+
+/**
+ * Check if the train is on the last reserved tile and try to extend the path then.
+ * @param v %Train that needs its path extended.
+ */
+static void CheckNextTrainTile(Train *v)
+{
+	/* Don't do any look-ahead if path_backoff_interval is 255. */
+	if (_settings_game.pf.path_backoff_interval == 255) return;
+
+	/* Exit if we are inside a depot. */
+	if (v->track == TRACK_BIT_DEPOT) return;
+
+	switch (v->current_order.GetType()) {
+		/* Exit if we reached our destination depot. */
+		case OT_GOTO_DEPOT:
+			if (v->tile == v->dest_tile) return;
+			break;
+
+		case OT_GOTO_WAYPOINT:
+			/* If we reached our waypoint, make sure we see that. */
+			if (IsRailWaypointTile(v->tile) && GetStationIndex(v->tile) == v->current_order.GetDestination()) ProcessOrders(v);
+			break;
+
+		case OT_NOTHING:
+		case OT_LEAVESTATION:
+		case OT_LOADING:
+			/* Exit if the current order doesn't have a destination, but the train has orders. */
+			if (v->GetNumOrders() > 0) return;
+			break;
+
+		default:
+			break;
+	}
+	/* Exit if we are on a station tile and are going to stop. */
+	if (IsRailStationTile(v->tile) && v->current_order.ShouldStopAtStation(v, GetStationIndex(v->tile))) return;
+
+	Trackdir td = v->GetVehicleTrackdir();
+
+	/* On a tile with a red non-pbs signal, don't look ahead. */
+	if (IsTileType(v->tile, MP_RAILWAY) && HasSignalOnTrackdir(v->tile, td) &&
+			!IsPbsSignal(GetSignalType(v->tile, TrackdirToTrack(td))) &&
+			GetSignalStateByTrackdir(v->tile, td) == SIGNAL_STATE_RED) return;
+
+	CFollowTrackRail ft(v);
+	if (!ft.Follow(v->tile, td)) return;
+
+	if (!HasReservedTracks(ft.m_new_tile, TrackdirBitsToTrackBits(ft.m_new_td_bits))) {
+		/* Next tile is not reserved. */
+		if (KillFirstBit(ft.m_new_td_bits) == TRACKDIR_BIT_NONE) {
+			if (HasPbsSignalOnTrackdir(ft.m_new_tile, FindFirstTrackdir(ft.m_new_td_bits))) {
+				/* If the next tile is a PBS signal, try to make a reservation. */
+				TrackBits tracks = TrackdirBitsToTrackBits(ft.m_new_td_bits);
+				if (_settings_game.pf.forbid_90_deg) {
+					tracks &= ~TrackCrossesTracks(TrackdirToTrack(ft.m_old_td));
+				}
+				ChooseTrainTrack(v, ft.m_new_tile, ft.m_exitdir, tracks, false, NULL, false);
+			}
+		}
+	}
+}
+
+/**
+ * Will the train stay in the depot the next tick?
+ * @param v %Train to check.
+ * @return True if it stays in the depot, false otherwise.
+ */
+static bool CheckTrainStayInDepot(Train *v)
+{
+	/* bail out if not all wagons are in the same depot or not in a depot at all */
+	for (const Train *u = v; u != NULL; u = u->Next()) {
+		if (u->track != TRACK_BIT_DEPOT || u->tile != v->tile) return false;
+	}
+
+	/* if the train got no power, then keep it in the depot */
+	if (v->gcache.cached_power == 0) {
+		v->vehstatus |= VS_STOPPED;
+		SetWindowDirty(WC_VEHICLE_DEPOT, v->tile);
+		return true;
+	}
+
+	SigSegState seg_state;
+
+	if (v->force_proceed == TFP_NONE) {
+		/* force proceed was not pressed */
+		if (++v->wait_counter < 37) {
+			SetWindowClassesDirty(WC_TRAINS_LIST);
+			return true;
+		}
+
+		v->wait_counter = 0;
+
+		seg_state = _settings_game.pf.reserve_paths ? SIGSEG_PBS : UpdateSignalsOnSegment(v->tile, INVALID_DIAGDIR, v->owner);
+		if (seg_state == SIGSEG_FULL || HasDepotReservation(v->tile)) {
+			/* Full and no PBS signal in block or depot reserved, can't exit. */
+			SetWindowClassesDirty(WC_TRAINS_LIST);
+			return true;
+		}
+	} else {
+		seg_state = _settings_game.pf.reserve_paths ? SIGSEG_PBS : UpdateSignalsOnSegment(v->tile, INVALID_DIAGDIR, v->owner);
+	}
+
+	/* We are leaving a depot, but have to go to the exact same one; re-enter */
+	if (v->current_order.IsType(OT_GOTO_DEPOT) && v->tile == v->dest_tile) {
+		/* We need to have a reservation for this to work. */
+		if (HasDepotReservation(v->tile)) return true;
+		SetDepotReservation(v->tile, true);
+		VehicleEnterDepot(v);
+		return true;
+	}
+
+	/* Only leave when we can reserve a path to our destination. */
+	if (seg_state == SIGSEG_PBS && !TryPathReserve(v) && v->force_proceed == TFP_NONE) {
+		/* No path and no force proceed. */
+		SetWindowClassesDirty(WC_TRAINS_LIST);
+		MarkTrainAsStuck(v);
+		return true;
+	}
+
+	SetDepotReservation(v->tile, true);
+	if (_settings_client.gui.show_track_reservation) MarkTileDirtyByTile(v->tile);
+
+	VehicleServiceInDepot(v);
+	SetWindowClassesDirty(WC_TRAINS_LIST);
+	v->PlayLeaveStationSound();
+
+	v->track = TRACK_BIT_X;
+	if (v->direction & 2) v->track = TRACK_BIT_Y;
+
+	v->vehstatus &= ~VS_HIDDEN;
+	v->cur_speed = 0;
+
+	v->UpdateViewport(true, true);
+	VehicleUpdatePosition(v);
+	UpdateSignalsOnSegment(v->tile, INVALID_DIAGDIR, v->owner);
+	v->UpdateAcceleration();
+	InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
+
+	return false;
+}
+
+/**
+ * Clear the reservation of \a tile that was just left by a wagon on \a track_dir.
+ * @param v %Train owning the reservation.
+ * @param tile Tile with reservation to clear.
+ * @param track_dir Track direction to clear.
+ */
+static void ClearPathReservation(const Train *v, TileIndex tile, Trackdir track_dir)
+{
+	DiagDirection dir = TrackdirToExitdir(track_dir);
+
+	if (IsTileType(tile, MP_TUNNELBRIDGE)) {
+		/* Are we just leaving a tunnel/bridge? */
+		if (GetTunnelBridgeDirection(tile) == ReverseDiagDir(dir)) {
+			TileIndex end = GetOtherTunnelBridgeEnd(tile);
+
+			if (TunnelBridgeIsFree(tile, end, v).Succeeded()) {
+				/* Free the reservation only if no other train is on the tiles. */
+				SetTunnelBridgeReservation(tile, false);
+				SetTunnelBridgeReservation(end, false);
+
+				if (_settings_client.gui.show_track_reservation) {
+					MarkTileDirtyByTile(tile);
+					MarkTileDirtyByTile(end);
+				}
+			}
+		}
+	} else if (IsRailStationTile(tile)) {
+		TileIndex new_tile = TileAddByDiagDir(tile, dir);
+		/* If the new tile is not a further tile of the same station, we
+		 * clear the reservation for the whole platform. */
+		if (!IsCompatibleTrainStationTile(new_tile, tile)) {
+			SetRailStationPlatformReservation(tile, ReverseDiagDir(dir), false);
+		}
+	} else {
+		/* Any other tile */
+		UnreserveRailTrack(tile, TrackdirToTrack(track_dir));
+	}
+}
+
+/**
+ * Free the reserved path in front of a vehicle.
+ * @param v %Train owning the reserved path.
+ * @param origin %Tile to start clearing (if #INVALID_TILE, use the current tile of \a v).
+ * @param orig_td Track direction (if #INVALID_TRACKDIR, use the track direction of \a v).
+ */
+void FreeTrainTrackReservation(const Train *v, TileIndex origin, Trackdir orig_td)
+{
+	assert(v->IsFrontEngine());
+
+	TileIndex tile = origin != INVALID_TILE ? origin : v->tile;
+	Trackdir  td = orig_td != INVALID_TRACKDIR ? orig_td : v->GetVehicleTrackdir();
+	bool      free_tile = tile != v->tile || !(IsRailStationTile(v->tile) || IsTileType(v->tile, MP_TUNNELBRIDGE));
+	StationID station_id = IsRailStationTile(v->tile) ? GetStationIndex(v->tile) : INVALID_STATION;
+
+	/* Can't be holding a reservation if we enter a depot. */
+	if (IsRailDepotTile(tile) && TrackdirToExitdir(td) != GetRailDepotDirection(tile)) return;
+	if (v->track == TRACK_BIT_DEPOT) {
+		/* Front engine is in a depot. We enter if some part is not in the depot. */
+		for (const Train *u = v; u != NULL; u = u->Next()) {
+			if (u->track != TRACK_BIT_DEPOT || u->tile != v->tile) return;
+		}
+	}
+	/* Don't free reservation if it's not ours. */
+	if (TracksOverlap(GetReservedTrackbits(tile) | TrackToTrackBits(TrackdirToTrack(td)))) return;
+
+	CFollowTrackRail ft(v, GetRailTypeInfo(v->railtype)->compatible_railtypes);
+	while (ft.Follow(tile, td)) {
+		tile = ft.m_new_tile;
+		TrackdirBits bits = ft.m_new_td_bits & TrackBitsToTrackdirBits(GetReservedTrackbits(tile));
+		td = RemoveFirstTrackdir(&bits);
+		assert(bits == TRACKDIR_BIT_NONE);
+
+		if (!IsValidTrackdir(td)) break;
+
+		if (IsTileType(tile, MP_RAILWAY)) {
+			if (HasSignalOnTrackdir(tile, td) && !IsPbsSignal(GetSignalType(tile, TrackdirToTrack(td)))) {
+				/* Conventional signal along trackdir: remove reservation and stop. */
+				UnreserveRailTrack(tile, TrackdirToTrack(td));
+				break;
+			}
+			if (HasPbsSignalOnTrackdir(tile, td)) {
+				if (GetSignalStateByTrackdir(tile, td) == SIGNAL_STATE_RED) {
+					/* Red PBS signal? Can't be our reservation, would be green then. */
+					break;
+				} else {
+					/* Turn the signal back to red. */
+					SetSignalStateByTrackdir(tile, td, SIGNAL_STATE_RED);
+					MarkTileDirtyByTile(tile);
+				}
+			} else if (HasSignalOnTrackdir(tile, ReverseTrackdir(td)) && IsOnewaySignal(tile, TrackdirToTrack(td))) {
+				break;
+			}
+		}
+
+		/* Don't free first station/bridge/tunnel if we are on it. */
+		if (free_tile || (!(ft.m_is_station && GetStationIndex(ft.m_new_tile) == station_id) && !ft.m_is_tunnel && !ft.m_is_bridge)) ClearPathReservation(v, tile, td);
+
+		free_tile = true;
+	}
+}
+
+static const byte _initial_tile_subcoord[6][4][3] = {
+{{ 15, 8, 1 }, { 0, 0, 0 }, { 0, 8, 5 }, { 0,  0, 0 }},
+{{  0, 0, 0 }, { 8, 0, 3 }, { 0, 0, 0 }, { 8, 15, 7 }},
+{{  0, 0, 0 }, { 7, 0, 2 }, { 0, 7, 6 }, { 0,  0, 0 }},
+{{ 15, 8, 2 }, { 0, 0, 0 }, { 0, 0, 0 }, { 8, 15, 6 }},
+{{ 15, 7, 0 }, { 8, 0, 4 }, { 0, 0, 0 }, { 0,  0, 0 }},
+{{  0, 0, 0 }, { 0, 0, 0 }, { 0, 8, 4 }, { 7, 15, 0 }},
+};
+
+/**
+ * Perform pathfinding for a train.
+ *
+ * @param v The train
+ * @param tile The tile the train is about to enter
+ * @param enterdir Diagonal direction the train is coming from
+ * @param tracks Usable tracks on the new tile
+ * @param path_found [out] Whether a path has been found or not.
+ * @param do_track_reservation Path reservation is requested
+ * @param dest [out] State and destination of the requested path
+ * @return The best track the train should follow
+ */
+static Track DoTrainPathfind(const Train *v, TileIndex tile, DiagDirection enterdir, TrackBits tracks, bool &path_found, bool do_track_reservation, PBSTileInfo *dest)
+{
+	switch (_settings_game.pf.pathfinder_for_trains) {
+		case VPF_NPF: return NPFTrainChooseTrack(v, tile, enterdir, tracks, path_found, do_track_reservation, dest);
+		case VPF_YAPF: return YapfTrainChooseTrack(v, tile, enterdir, tracks, path_found, do_track_reservation, dest);
+
+		default: NOT_REACHED();
+	}
+}
+
+/**
+ * Extend a train path as far as possible. Stops on encountering a safe tile,
+ * another reservation or a track choice.
+ * @return INVALID_TILE indicates that the reservation failed.
+ */
+static PBSTileInfo ExtendTrainReservation(const Train *v, TrackBits *new_tracks, DiagDirection *enterdir)
+{
+	PBSTileInfo origin = FollowTrainReservation(v);
+
+	CFollowTrackRail ft(v);
+
+	TileIndex tile = origin.tile;
+	Trackdir  cur_td = origin.trackdir;
+	while (ft.Follow(tile, cur_td)) {
+		if (KillFirstBit(ft.m_new_td_bits) == TRACKDIR_BIT_NONE) {
+			/* Possible signal tile. */
+			if (HasOnewaySignalBlockingTrackdir(ft.m_new_tile, FindFirstTrackdir(ft.m_new_td_bits))) break;
+		}
+
+		if (_settings_game.pf.forbid_90_deg) {
+			ft.m_new_td_bits &= ~TrackdirCrossesTrackdirs(ft.m_old_td);
+			if (ft.m_new_td_bits == TRACKDIR_BIT_NONE) break;
+		}
+
+		/* Station, depot or waypoint are a possible target. */
+		bool target_seen = ft.m_is_station || (IsTileType(ft.m_new_tile, MP_RAILWAY) && !IsPlainRail(ft.m_new_tile));
+		if (target_seen || KillFirstBit(ft.m_new_td_bits) != TRACKDIR_BIT_NONE) {
+			/* Choice found or possible target encountered.
+			 * On finding a possible target, we need to stop and let the pathfinder handle the
+			 * remaining path. This is because we don't know if this target is in one of our
+			 * orders, so we might cause pathfinding to fail later on if we find a choice.
+			 * This failure would cause a bogous call to TryReserveSafePath which might reserve
+			 * a wrong path not leading to our next destination. */
+			if (HasReservedTracks(ft.m_new_tile, TrackdirBitsToTrackBits(TrackdirReachesTrackdirs(ft.m_old_td)))) break;
+
+			/* If we did skip some tiles, backtrack to the first skipped tile so the pathfinder
+			 * actually starts its search at the first unreserved tile. */
+			if (ft.m_tiles_skipped != 0) ft.m_new_tile -= TileOffsByDiagDir(ft.m_exitdir) * ft.m_tiles_skipped;
+
+			/* Choice found, path valid but not okay. Save info about the choice tile as well. */
+			if (new_tracks != NULL) *new_tracks = TrackdirBitsToTrackBits(ft.m_new_td_bits);
+			if (enterdir != NULL) *enterdir = ft.m_exitdir;
+			return PBSTileInfo(ft.m_new_tile, ft.m_old_td, false);
+		}
+
+		tile = ft.m_new_tile;
+		cur_td = FindFirstTrackdir(ft.m_new_td_bits);
+
+		if (IsSafeWaitingPosition(v, tile, cur_td, true, _settings_game.pf.forbid_90_deg)) {
+			bool wp_free = IsWaitingPositionFree(v, tile, cur_td, _settings_game.pf.forbid_90_deg);
+			if (!(wp_free && TryReserveRailTrack(tile, TrackdirToTrack(cur_td)))) break;
+			/* Safe position is all good, path valid and okay. */
+			return PBSTileInfo(tile, cur_td, true);
+		}
+
+		if (!TryReserveRailTrack(tile, TrackdirToTrack(cur_td))) break;
+	}
+
+	if (ft.m_err == CFollowTrackRail::EC_OWNER || ft.m_err == CFollowTrackRail::EC_NO_WAY) {
+		/* End of line, path valid and okay. */
+		return PBSTileInfo(ft.m_old_tile, ft.m_old_td, true);
+	}
+
+	/* Sorry, can't reserve path, back out. */
+	tile = origin.tile;
+	cur_td = origin.trackdir;
+	TileIndex stopped = ft.m_old_tile;
+	Trackdir  stopped_td = ft.m_old_td;
+	while (tile != stopped || cur_td != stopped_td) {
+		if (!ft.Follow(tile, cur_td)) break;
+
+		if (_settings_game.pf.forbid_90_deg) {
+			ft.m_new_td_bits &= ~TrackdirCrossesTrackdirs(ft.m_old_td);
+			assert(ft.m_new_td_bits != TRACKDIR_BIT_NONE);
+		}
+		assert(KillFirstBit(ft.m_new_td_bits) == TRACKDIR_BIT_NONE);
+
+		tile = ft.m_new_tile;
+		cur_td = FindFirstTrackdir(ft.m_new_td_bits);
+
+		UnreserveRailTrack(tile, TrackdirToTrack(cur_td));
+	}
+
+	/* Path invalid. */
+	return PBSTileInfo();
+}
+
+/**
+ * Try to reserve any path to a safe tile, ignoring the vehicle's destination.
+ * Safe tiles are tiles in front of a signal, depots and station tiles at end of line.
+ *
+ * @param v The vehicle.
+ * @param tile The tile the search should start from.
+ * @param td The trackdir the search should start from.
+ * @param override_railtype Whether all physically compatible railtypes should be followed.
+ * @return True if a path to a safe stopping tile could be reserved.
+ */
+static bool TryReserveSafeTrack(const Train *v, TileIndex tile, Trackdir td, bool override_tailtype)
+{
+	switch (_settings_game.pf.pathfinder_for_trains) {
+		case VPF_NPF: return NPFTrainFindNearestSafeTile(v, tile, td, override_tailtype);
+		case VPF_YAPF: return YapfTrainFindNearestSafeTile(v, tile, td, override_tailtype);
+
+		default: NOT_REACHED();
+	}
+}
+
+/** This class will save the current order of a vehicle and restore it on destruction. */
+class VehicleOrderSaver {
+private:
+	Train          *v;
+	Order          old_order;
+	TileIndex      old_dest_tile;
+	StationID      old_last_station_visited;
+	VehicleOrderID index;
+	bool           suppress_implicit_orders;
+
+public:
+	VehicleOrderSaver(Train *_v) :
+		v(_v),
+		old_order(_v->current_order),
+		old_dest_tile(_v->dest_tile),
+		old_last_station_visited(_v->last_station_visited),
+		index(_v->cur_real_order_index),
+		suppress_implicit_orders(HasBit(_v->gv_flags, GVF_SUPPRESS_IMPLICIT_ORDERS))
+	{
+	}
+
+	~VehicleOrderSaver()
+	{
+		this->v->current_order = this->old_order;
+		this->v->dest_tile = this->old_dest_tile;
+		this->v->last_station_visited = this->old_last_station_visited;
+		SB(this->v->gv_flags, GVF_SUPPRESS_IMPLICIT_ORDERS, 1, suppress_implicit_orders ? 1: 0);
+	}
+
+	/**
+	 * Set the current vehicle order to the next order in the order list.
+	 * @param skip_first Shall the first (i.e. active) order be skipped?
+	 * @return True if a suitable next order could be found.
+	 */
+	bool SwitchToNextOrder(bool skip_first)
+	{
+		if (this->v->GetNumOrders() == 0) return false;
+
+		if (skip_first) ++this->index;
+
+		int depth = 0;
+
+		do {
+			/* Wrap around. */
+			if (this->index >= this->v->GetNumOrders()) this->index = 0;
+
+			Order *order = this->v->GetOrder(this->index);
+			assert(order != NULL);
+
+			switch (order->GetType()) {
+				case OT_GOTO_DEPOT:
+					/* Skip service in depot orders when the train doesn't need service. */
+					if ((order->GetDepotOrderType() & ODTFB_SERVICE) && !this->v->NeedsServicing()) break;
+				case OT_GOTO_STATION:
+				case OT_GOTO_WAYPOINT:
+					this->v->current_order = *order;
+					return UpdateOrderDest(this->v, order, 0, true);
+				case OT_CONDITIONAL: {
+					VehicleOrderID next = ProcessConditionalOrder(order, this->v);
+					if (next != INVALID_VEH_ORDER_ID) {
+						depth++;
+						this->index = next;
+						/* Don't increment next, so no break here. */
+						continue;
+					}
+					break;
+				}
+				default:
+					break;
+			}
+			/* Don't increment inside the while because otherwise conditional
+			 * orders can lead to an infinite loop. */
+			++this->index;
+			depth++;
+		} while (this->index != this->v->cur_real_order_index && depth < this->v->GetNumOrders());
+
+		return false;
+	}
+};
+
+/* choose a track */
+static Track ChooseTrainTrack(Train *v, TileIndex tile, DiagDirection enterdir, TrackBits tracks, bool force_res, bool *got_reservation, bool mark_stuck)
+{
+	Track best_track = INVALID_TRACK;
+	bool do_track_reservation = _settings_game.pf.reserve_paths || force_res;
+	bool changed_signal = false;
+
+	assert((tracks & ~TRACK_BIT_MASK) == 0);
+
+	if (got_reservation != NULL) *got_reservation = false;
+
+	/* Don't use tracks here as the setting to forbid 90 deg turns might have been switched between reservation and now. */
+	TrackBits res_tracks = (TrackBits)(GetReservedTrackbits(tile) & DiagdirReachesTracks(enterdir));
+	/* Do we have a suitable reserved track? */
+	if (res_tracks != TRACK_BIT_NONE) return FindFirstTrack(res_tracks);
+
+	/* Quick return in case only one possible track is available */
+	if (KillFirstBit(tracks) == TRACK_BIT_NONE) {
+		Track track = FindFirstTrack(tracks);
+		/* We need to check for signals only here, as a junction tile can't have signals. */
+		if (track != INVALID_TRACK && HasPbsSignalOnTrackdir(tile, TrackEnterdirToTrackdir(track, enterdir))) {
+			do_track_reservation = true;
+			changed_signal = true;
+			SetSignalStateByTrackdir(tile, TrackEnterdirToTrackdir(track, enterdir), SIGNAL_STATE_GREEN);
+		} else if (!do_track_reservation) {
+			return track;
+		}
+		best_track = track;
+	}
+
+	PBSTileInfo   res_dest(tile, INVALID_TRACKDIR, false);
+	DiagDirection dest_enterdir = enterdir;
+	if (do_track_reservation) {
+		res_dest = ExtendTrainReservation(v, &tracks, &dest_enterdir);
+		if (res_dest.tile == INVALID_TILE) {
+			/* Reservation failed? */
+			if (mark_stuck) MarkTrainAsStuck(v);
+			if (changed_signal) SetSignalStateByTrackdir(tile, TrackEnterdirToTrackdir(best_track, enterdir), SIGNAL_STATE_RED);
+			return FindFirstTrack(tracks);
+		}
+		if (res_dest.okay) {
+			/* Got a valid reservation that ends at a safe target, quick exit. */
+			if (got_reservation != NULL) *got_reservation = true;
+			if (changed_signal) MarkTileDirtyByTile(tile);
+			TryReserveRailTrack(v->tile, TrackdirToTrack(v->GetVehicleTrackdir()));
+			return best_track;
+		}
+
+		/* Check if the train needs service here, so it has a chance to always find a depot.
+		 * Also check if the current order is a service order so we don't reserve a path to
+		 * the destination but instead to the next one if service isn't needed. */
+		CheckIfTrainNeedsService(v);
+		if (v->current_order.IsType(OT_DUMMY) || v->current_order.IsType(OT_CONDITIONAL) || v->current_order.IsType(OT_GOTO_DEPOT)) ProcessOrders(v);
+	}
+
+	/* Save the current train order. The destructor will restore the old order on function exit. */
+	VehicleOrderSaver orders(v);
+
+	/* If the current tile is the destination of the current order and
+	 * a reservation was requested, advance to the next order.
+	 * Don't advance on a depot order as depots are always safe end points
+	 * for a path and no look-ahead is necessary. This also avoids a
+	 * problem with depot orders not part of the order list when the
+	 * order list itself is empty. */
+	if (v->current_order.IsType(OT_LEAVESTATION)) {
+		orders.SwitchToNextOrder(false);
+	} else if (v->current_order.IsType(OT_LOADING) || (!v->current_order.IsType(OT_GOTO_DEPOT) && (
+			v->current_order.IsType(OT_GOTO_STATION) ?
+			IsRailStationTile(v->tile) && v->current_order.GetDestination() == GetStationIndex(v->tile) :
+			v->tile == v->dest_tile))) {
+		orders.SwitchToNextOrder(true);
+	}
+
+	if (res_dest.tile != INVALID_TILE && !res_dest.okay) {
+		/* Pathfinders are able to tell that route was only 'guessed'. */
+		bool      path_found = true;
+		TileIndex new_tile = res_dest.tile;
+
+		Track next_track = DoTrainPathfind(v, new_tile, dest_enterdir, tracks, path_found, do_track_reservation, &res_dest);
+		if (new_tile == tile) best_track = next_track;
+		v->HandlePathfindingResult(path_found);
+	}
+
+	/* No track reservation requested -> finished. */
+	if (!do_track_reservation) return best_track;
+
+	/* A path was found, but could not be reserved. */
+	if (res_dest.tile != INVALID_TILE && !res_dest.okay) {
+		if (mark_stuck) MarkTrainAsStuck(v);
+		FreeTrainTrackReservation(v);
+		return best_track;
+	}
+
+	/* No possible reservation target found, we are probably lost. */
+	if (res_dest.tile == INVALID_TILE) {
+		/* Try to find any safe destination. */
+		PBSTileInfo origin = FollowTrainReservation(v);
+		if (TryReserveSafeTrack(v, origin.tile, origin.trackdir, false)) {
+			TrackBits res = GetReservedTrackbits(tile) & DiagdirReachesTracks(enterdir);
+			best_track = FindFirstTrack(res);
+			TryReserveRailTrack(v->tile, TrackdirToTrack(v->GetVehicleTrackdir()));
+			if (got_reservation != NULL) *got_reservation = true;
+			if (changed_signal) MarkTileDirtyByTile(tile);
+		} else {
+			FreeTrainTrackReservation(v);
+			if (mark_stuck) MarkTrainAsStuck(v);
+		}
+		return best_track;
+	}
+
+	if (got_reservation != NULL) *got_reservation = true;
+
+	/* Reservation target found and free, check if it is safe. */
+	while (!IsSafeWaitingPosition(v, res_dest.tile, res_dest.trackdir, true, _settings_game.pf.forbid_90_deg)) {
+		/* Extend reservation until we have found a safe position. */
+		DiagDirection exitdir = TrackdirToExitdir(res_dest.trackdir);
+		TileIndex     next_tile = TileAddByDiagDir(res_dest.tile, exitdir);
+		TrackBits     reachable = TrackdirBitsToTrackBits((TrackdirBits)(GetTileTrackStatus(next_tile, TRANSPORT_RAIL, 0))) & DiagdirReachesTracks(exitdir);
+		if (_settings_game.pf.forbid_90_deg) {
+			reachable &= ~TrackCrossesTracks(TrackdirToTrack(res_dest.trackdir));
+		}
+
+		/* Get next order with destination. */
+		if (orders.SwitchToNextOrder(true)) {
+			PBSTileInfo cur_dest;
+			bool path_found;
+			DoTrainPathfind(v, next_tile, exitdir, reachable, path_found, true, &cur_dest);
+			if (cur_dest.tile != INVALID_TILE) {
+				res_dest = cur_dest;
+				if (res_dest.okay) continue;
+				/* Path found, but could not be reserved. */
+				FreeTrainTrackReservation(v);
+				if (mark_stuck) MarkTrainAsStuck(v);
+				if (got_reservation != NULL) *got_reservation = false;
+				changed_signal = false;
+				break;
+			}
+		}
+		/* No order or no safe position found, try any position. */
+		if (!TryReserveSafeTrack(v, res_dest.tile, res_dest.trackdir, true)) {
+			FreeTrainTrackReservation(v);
+			if (mark_stuck) MarkTrainAsStuck(v);
+			if (got_reservation != NULL) *got_reservation = false;
+			changed_signal = false;
+		}
+		break;
+	}
+
+	TryReserveRailTrack(v->tile, TrackdirToTrack(v->GetVehicleTrackdir()));
+
+	if (changed_signal) MarkTileDirtyByTile(tile);
+
+	return best_track;
+}
+
+/**
+ * Try to reserve a path to a safe position.
+ *
+ * @param v The vehicle
+ * @param mark_as_stuck Should the train be marked as stuck on a failed reservation?
+ * @param first_tile_okay True if no path should be reserved if the current tile is a safe position.
+ * @return True if a path could be reserved.
+ */
+bool TryPathReserve(Train *v, bool mark_as_stuck, bool first_tile_okay)
+{
+	assert(v->IsFrontEngine());
+
+	/* We have to handle depots specially as the track follower won't look
+	 * at the depot tile itself but starts from the next tile. If we are still
+	 * inside the depot, a depot reservation can never be ours. */
+	if (v->track == TRACK_BIT_DEPOT) {
+		if (HasDepotReservation(v->tile)) {
+			if (mark_as_stuck) MarkTrainAsStuck(v);
+			return false;
+		} else {
+			/* Depot not reserved, but the next tile might be. */
+			TileIndex next_tile = TileAddByDiagDir(v->tile, GetRailDepotDirection(v->tile));
+			if (HasReservedTracks(next_tile, DiagdirReachesTracks(GetRailDepotDirection(v->tile)))) return false;
+		}
+	}
+
+	Vehicle *other_train = NULL;
+	PBSTileInfo origin = FollowTrainReservation(v, &other_train);
+	/* The path we are driving on is already blocked by some other train.
+	 * This can only happen in certain situations when mixing path and
+	 * block signals or when changing tracks and/or signals.
+	 * Exit here as doing any further reservations will probably just
+	 * make matters worse. */
+	if (other_train != NULL && other_train->index != v->index) {
+		if (mark_as_stuck) MarkTrainAsStuck(v);
+		return false;
+	}
+	/* If we have a reserved path and the path ends at a safe tile, we are finished already. */
+	if (origin.okay && (v->tile != origin.tile || first_tile_okay)) {
+		/* Can't be stuck then. */
+		if (HasBit(v->flags, VRF_TRAIN_STUCK)) SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);
+		ClrBit(v->flags, VRF_TRAIN_STUCK);
+		return true;
+	}
+
+	/* If we are in a depot, tentatively reserve the depot. */
+	if (v->track == TRACK_BIT_DEPOT) {
+		SetDepotReservation(v->tile, true);
+		if (_settings_client.gui.show_track_reservation) MarkTileDirtyByTile(v->tile);
+	}
+
+	DiagDirection exitdir = TrackdirToExitdir(origin.trackdir);
+	TileIndex     new_tile = TileAddByDiagDir(origin.tile, exitdir);
+	TrackBits     reachable = TrackdirBitsToTrackBits(TrackStatusToTrackdirBits(GetTileTrackStatus(new_tile, TRANSPORT_RAIL, 0)) & DiagdirReachesTrackdirs(exitdir));
+
+	if (_settings_game.pf.forbid_90_deg) reachable &= ~TrackCrossesTracks(TrackdirToTrack(origin.trackdir));
+
+	bool res_made = false;
+	ChooseTrainTrack(v, new_tile, exitdir, reachable, true, &res_made, mark_as_stuck);
+
+	if (!res_made) {
+		/* Free the depot reservation as well. */
+		if (v->track == TRACK_BIT_DEPOT) SetDepotReservation(v->tile, false);
+		return false;
+	}
+
+	if (HasBit(v->flags, VRF_TRAIN_STUCK)) {
+		v->wait_counter = 0;
+		SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);
+	}
+	ClrBit(v->flags, VRF_TRAIN_STUCK);
+	return true;
+}
+
+
+static bool CheckReverseTrain(const Train *v)
+{
+	if (_settings_game.difficulty.line_reverse_mode != 0 ||
+			v->track == TRACK_BIT_DEPOT || v->track == TRACK_BIT_WORMHOLE ||
+			!(v->direction & 1)) {
+		return false;
+	}
+
+	assert(v->track != TRACK_BIT_NONE);
+
+	switch (_settings_game.pf.pathfinder_for_trains) {
+		case VPF_NPF: return NPFTrainCheckReverse(v);
+		case VPF_YAPF: return YapfTrainCheckReverse(v);
+
+		default: NOT_REACHED();
+	}
+}
+
+/**
+ * Get the location of the next station to visit.
+ * @param station Next station to visit.
+ * @return Location of the new station.
+ */
+TileIndex Train::GetOrderStationLocation(StationID station)
+{
+	if (station == this->last_station_visited) this->last_station_visited = INVALID_STATION;
+
+	const Station *st = Station::Get(station);
+	if (!(st->facilities & FACIL_TRAIN)) {
+		/* The destination station has no trainstation tiles. */
+		this->IncrementRealOrderIndex();
+		return 0;
+	}
+
+	return st->xy;
+}
+
+/** Goods at the consist have changed, update the graphics, cargo, and acceleration. */
+void Train::MarkDirty()
+{
+	Train *v = this;
+	do {
+		v->UpdateViewport(false, false);
+	} while ((v = v->Next()) != NULL);
+
+	/* need to update acceleration and cached values since the goods on the train changed. */
+	this->CargoChanged();
+	this->UpdateAcceleration();
+}
+
+/**
+ * This function looks at the vehicle and updates its speed (cur_speed
+ * and subspeed) variables. Furthermore, it returns the distance that
+ * the train can drive this tick. #Vehicle::GetAdvanceDistance() determines
+ * the distance to drive before moving a step on the map.
+ * @return distance to drive.
+ */
+int Train::UpdateSpeed()
+{
+	switch (_settings_game.vehicle.train_acceleration_model) {
+		default: NOT_REACHED();
+		case AM_ORIGINAL:
+			return this->DoUpdateSpeed(this->acceleration * (this->GetAccelerationStatus() == AS_BRAKE ? -4 : 2), 0, this->GetCurrentMaxSpeed());
+
+		case AM_REALISTIC:
+			return this->DoUpdateSpeed(this->GetAcceleration(), this->GetAccelerationStatus() == AS_BRAKE ? 0 : 2, this->GetCurrentMaxSpeed());
+	}
+}
+
+/**
+ * Trains enters a station, send out a news item if it is the first train, and start loading.
+ * @param v Train that entered the station.
+ * @param station Station visited.
+ */
+static void TrainEnterStation(Train *v, StationID station)
+{
+	v->last_station_visited = station;
+
+	/* check if a train ever visited this station before */
+	Station *st = Station::Get(station);
+	if (!(st->had_vehicle_of_type & HVOT_TRAIN)) {
+		st->had_vehicle_of_type |= HVOT_TRAIN;
+		SetDParam(0, st->index);
+		AddVehicleNewsItem(
+			STR_NEWS_FIRST_TRAIN_ARRIVAL,
+			v->owner == _local_company ? NT_ARRIVAL_COMPANY : NT_ARRIVAL_OTHER,
+			v->index,
+			st->index
+		);
+		AI::NewEvent(v->owner, new ScriptEventStationFirstVehicle(st->index, v->index));
+		Game::NewEvent(new ScriptEventStationFirstVehicle(st->index, v->index));
+	}
+
+	v->force_proceed = TFP_NONE;
+	SetWindowDirty(WC_VEHICLE_VIEW, v->index);
+
+	v->BeginLoading();
+
+	TriggerStationRandomisation(st, v->tile, SRT_TRAIN_ARRIVES);
+	TriggerStationAnimation(st, v->tile, SAT_TRAIN_ARRIVES);
+}
+
+/* Check if the vehicle is compatible with the specified tile */
+static inline bool CheckCompatibleRail(const Train *v, TileIndex tile)
+{
+	return IsTileOwner(tile, v->owner) &&
+			(!v->IsFrontEngine() || HasBit(v->compatible_railtypes, GetRailType(tile)));
+}
+
+/** Data structure for storing engine speed changes of an acceleration type. */
+struct AccelerationSlowdownParams {
+	byte small_turn; ///< Speed change due to a small turn.
+	byte large_turn; ///< Speed change due to a large turn.
+	byte z_up;       ///< Fraction to remove when moving up.
+	byte z_down;     ///< Fraction to add when moving down.
+};
+
+/** Speed update fractions for each acceleration type. */
+static const AccelerationSlowdownParams _accel_slowdown[] = {
+	/* normal accel */
+	{256 / 4, 256 / 2, 256 / 4, 2}, ///< normal
+	{256 / 4, 256 / 2, 256 / 4, 2}, ///< monorail
+	{0,       256 / 2, 256 / 4, 2}, ///< maglev
+};
+
+/**
+ * Modify the speed of the vehicle due to a change in altitude.
+ * @param v %Train to update.
+ * @param old_z Previous height.
+ */
+static inline void AffectSpeedByZChange(Train *v, int old_z)
+{
+	if (old_z == v->z_pos || _settings_game.vehicle.train_acceleration_model != AM_ORIGINAL) return;
+
+	const AccelerationSlowdownParams *asp = &_accel_slowdown[GetRailTypeInfo(v->railtype)->acceleration_type];
+
+	if (old_z < v->z_pos) {
+		v->cur_speed -= (v->cur_speed * asp->z_up >> 8);
+	} else {
+		uint16 spd = v->cur_speed + asp->z_down;
+		if (spd <= v->gcache.cached_max_track_speed) v->cur_speed = spd;
+	}
+}
+
+static bool TrainMovedChangeSignals(TileIndex tile, DiagDirection dir)
+{
+	if (IsTileType(tile, MP_RAILWAY) &&
+			GetRailTileType(tile) == RAIL_TILE_SIGNALS) {
+		TrackdirBits tracks = TrackBitsToTrackdirBits(GetTrackBits(tile)) & DiagdirReachesTrackdirs(dir);
+		Trackdir trackdir = FindFirstTrackdir(tracks);
+		if (UpdateSignalsOnSegment(tile,  TrackdirToExitdir(trackdir), GetTileOwner(tile)) == SIGSEG_PBS && HasSignalOnTrackdir(tile, trackdir)) {
+			/* A PBS block with a non-PBS signal facing us? */
+			if (!IsPbsSignal(GetSignalType(tile, TrackdirToTrack(trackdir)))) return true;
+		}
+	}
+	return false;
+}
+
+/** Tries to reserve track under whole train consist. */
+void Train::ReserveTrackUnderConsist() const
+{
+	for (const Train *u = this; u != NULL; u = u->Next()) {
+		switch (u->track) {
+			case TRACK_BIT_WORMHOLE:
+				TryReserveRailTrack(u->tile, DiagDirToDiagTrack(GetTunnelBridgeDirection(u->tile)));
+				break;
+			case TRACK_BIT_DEPOT:
+				break;
+			default:
+				TryReserveRailTrack(u->tile, TrackBitsToTrack(u->track));
+				break;
+		}
+	}
+}
+
+/**
+ * The train vehicle crashed!
+ * Update its status and other parts around it.
+ * @param flooded Crash was caused by flooding.
+ * @return Number of people killed.
+ */
+uint Train::Crash(bool flooded)
+{
+	uint pass = 0;
+	if (this->IsFrontEngine()) {
+		pass += 2; // driver
+
+		/* Remove the reserved path in front of the train if it is not stuck.
+		 * Also clear all reserved tracks the train is currently on. */
+		if (!HasBit(this->flags, VRF_TRAIN_STUCK)) FreeTrainTrackReservation(this);
+		for (const Train *v = this; v != NULL; v = v->Next()) {
+			ClearPathReservation(v, v->tile, v->GetVehicleTrackdir());
+			if (IsTileType(v->tile, MP_TUNNELBRIDGE)) {
+				/* ClearPathReservation will not free the wormhole exit
+				 * if the train has just entered the wormhole. */
+				SetTunnelBridgeReservation(GetOtherTunnelBridgeEnd(v->tile), false);
+			}
+		}
+
+		/* we may need to update crossing we were approaching,
+		 * but must be updated after the train has been marked crashed */
+		TileIndex crossing = TrainApproachingCrossingTile(this);
+		if (crossing != INVALID_TILE) UpdateLevelCrossing(crossing);
+
+		/* Remove the loading indicators (if any) */
+		HideFillingPercent(&this->fill_percent_te_id);
+	}
+
+	pass += this->GroundVehicleBase::Crash(flooded);
+
+	this->crash_anim_pos = flooded ? 4000 : 1; // max 4440, disappear pretty fast when flooded
+	return pass;
+}
+
+/**
+ * Marks train as crashed and creates an AI event.
+ * Doesn't do anything if the train is crashed already.
+ * @param v first vehicle of chain
+ * @return number of victims (including 2 drivers; zero if train was already crashed)
+ */
+static uint TrainCrashed(Train *v)
+{
+	uint num = 0;
+
+	/* do not crash train twice */
+	if (!(v->vehstatus & VS_CRASHED)) {
+		num = v->Crash();
+		AI::NewEvent(v->owner, new ScriptEventVehicleCrashed(v->index, v->tile, ScriptEventVehicleCrashed::CRASH_TRAIN));
+		Game::NewEvent(new ScriptEventVehicleCrashed(v->index, v->tile, ScriptEventVehicleCrashed::CRASH_TRAIN));
+	}
+
+	/* Try to re-reserve track under already crashed train too.
+	 * Crash() clears the reservation! */
+	v->ReserveTrackUnderConsist();
+
+	return num;
+}
+
+/** Temporary data storage for testing collisions. */
+struct TrainCollideChecker {
+	Train *v; ///< %Vehicle we are testing for collision.
+	uint num; ///< Total number of victims if train collided.
+};
+
+/**
+ * Collision test function.
+ * @param v %Train vehicle to test collision with.
+ * @param data %Train being examined.
+ * @return \c NULL (always continue search)
+ */
+static Vehicle *FindTrainCollideEnum(Vehicle *v, void *data)
+{
+	TrainCollideChecker *tcc = (TrainCollideChecker*)data;
+
+	/* not a train or in depot */
+	if (v->type != VEH_TRAIN || Train::From(v)->track == TRACK_BIT_DEPOT) return NULL;
+
+	/* do not crash into trains of another company. */
+	if (v->owner != tcc->v->owner) return NULL;
+
+	/* get first vehicle now to make most usual checks faster */
+	Train *coll = Train::From(v)->First();
+
+	/* can't collide with own wagons */
+	if (coll == tcc->v) return NULL;
+
+	int x_diff = v->x_pos - tcc->v->x_pos;
+	int y_diff = v->y_pos - tcc->v->y_pos;
+
+	/* Do fast calculation to check whether trains are not in close vicinity
+	 * and quickly reject trains distant enough for any collision.
+	 * Differences are shifted by 7, mapping range [-7 .. 8] into [0 .. 15]
+	 * Differences are then ORed and then we check for any higher bits */
+	uint hash = (y_diff + 7) | (x_diff + 7);
+	if (hash & ~15) return NULL;
+
+	/* Slower check using multiplication */
+	int min_diff = (Train::From(v)->gcache.cached_veh_length + 1) / 2 + (tcc->v->gcache.cached_veh_length + 1) / 2 - 1;
+	if (x_diff * x_diff + y_diff * y_diff > min_diff * min_diff) return NULL;
+
+	/* Happens when there is a train under bridge next to bridge head */
+	if (abs(v->z_pos - tcc->v->z_pos) > 5) return NULL;
+
+	/* crash both trains */
+	tcc->num += TrainCrashed(tcc->v);
+	tcc->num += TrainCrashed(coll);
+
+	return NULL; // continue searching
+}
+
+/**
+ * Checks whether the specified train has a collision with another vehicle. If
+ * so, destroys this vehicle, and the other vehicle if its subtype has TS_Front.
+ * Reports the incident in a flashy news item, modifies station ratings and
+ * plays a sound.
+ * @param v %Train to test.
+ */
+static bool CheckTrainCollision(Train *v)
+{
+	/* can't collide in depot */
+	if (v->track == TRACK_BIT_DEPOT) return false;
+
+	assert(v->track == TRACK_BIT_WORMHOLE || TileVirtXY(v->x_pos, v->y_pos) == v->tile);
+
+	TrainCollideChecker tcc;
+	tcc.v = v;
+	tcc.num = 0;
+
+	/* find colliding vehicles */
+	if (v->track == TRACK_BIT_WORMHOLE) {
+		FindVehicleOnPos(v->tile, &tcc, FindTrainCollideEnum);
+		FindVehicleOnPos(GetOtherTunnelBridgeEnd(v->tile), &tcc, FindTrainCollideEnum);
+	} else {
+		FindVehicleOnPosXY(v->x_pos, v->y_pos, &tcc, FindTrainCollideEnum);
+	}
+
+	/* any dead -> no crash */
+	if (tcc.num == 0) return false;
+
+	SetDParam(0, tcc.num);
+	AddVehicleNewsItem(STR_NEWS_TRAIN_CRASH, NT_ACCIDENT, v->index);
+
+	ModifyStationRatingAround(v->tile, v->owner, -160, 30);
+	if (_settings_client.sound.disaster) SndPlayVehicleFx(SND_13_BIG_CRASH, v);
+	return true;
+}
+
+static Vehicle *CheckTrainAtSignal(Vehicle *v, void *data)
+{
+	if (v->type != VEH_TRAIN || (v->vehstatus & VS_CRASHED)) return NULL;
+
+	Train *t = Train::From(v);
+	DiagDirection exitdir = *(DiagDirection *)data;
+
+	/* not front engine of a train, inside wormhole or depot, crashed */
+	if (!t->IsFrontEngine() || !(t->track & TRACK_BIT_MASK)) return NULL;
+
+	if (t->cur_speed > 5 || TrainExitDir(t->direction, t->track) != exitdir) return NULL;
+
+	return t;
+}
+
+/**
+ * Move a vehicle chain one movement stop forwards.
+ * @param v First vehicle to move.
+ * @param nomove Stop moving this and all following vehicles.
+ * @param reverse Set to false to not execute the vehicle reversing. This does not change any other logic.
+ * @return True if the vehicle could be moved forward, false otherwise.
+ */
+bool TrainController(Train *v, Vehicle *nomove, bool reverse)
+{
+	Train *first = v->First();
+	Train *prev;
+	bool direction_changed = false; // has direction of any part changed?
+
+	/* For every vehicle after and including the given vehicle */
+	for (prev = v->Previous(); v != nomove; prev = v, v = v->Next()) {
+		DiagDirection enterdir = DIAGDIR_BEGIN;
+		bool update_signals_crossing = false; // will we update signals or crossing state?
+
+		GetNewVehiclePosResult gp = GetNewVehiclePos(v);
+		if (v->track != TRACK_BIT_WORMHOLE) {
+			/* Not inside tunnel */
+			if (gp.old_tile == gp.new_tile) {
+				/* Staying in the old tile */
+				if (v->track == TRACK_BIT_DEPOT) {
+					/* Inside depot */
+					gp.x = v->x_pos;
+					gp.y = v->y_pos;
+				} else {
+					/* Not inside depot */
+
+					/* Reverse when we are at the end of the track already, do not move to the new position */
+					if (v->IsFrontEngine() && !TrainCheckIfLineEnds(v, reverse)) return false;
+
+					uint32 r = VehicleEnterTile(v, gp.new_tile, gp.x, gp.y);
+					if (HasBit(r, VETS_CANNOT_ENTER)) {
+						goto invalid_rail;
+					}
+					if (HasBit(r, VETS_ENTERED_STATION)) {
+						/* The new position is the end of the platform */
+						TrainEnterStation(v, r >> VETS_STATION_ID_OFFSET);
+					}
+				}
+			} else {
+				/* A new tile is about to be entered. */
+
+				/* Determine what direction we're entering the new tile from */
+				enterdir = DiagdirBetweenTiles(gp.old_tile, gp.new_tile);
+				assert(IsValidDiagDirection(enterdir));
+
+				/* Get the status of the tracks in the new tile and mask
+				 * away the bits that aren't reachable. */
+				TrackStatus ts = GetTileTrackStatus(gp.new_tile, TRANSPORT_RAIL, 0, ReverseDiagDir(enterdir));
+				TrackdirBits reachable_trackdirs = DiagdirReachesTrackdirs(enterdir);
+
+				TrackdirBits trackdirbits = TrackStatusToTrackdirBits(ts) & reachable_trackdirs;
+				TrackBits red_signals = TrackdirBitsToTrackBits(TrackStatusToRedSignals(ts) & reachable_trackdirs);
+
+				TrackBits bits = TrackdirBitsToTrackBits(trackdirbits);
+				if (_settings_game.pf.forbid_90_deg && prev == NULL) {
+					/* We allow wagons to make 90 deg turns, because forbid_90_deg
+					 * can be switched on halfway a turn */
+					bits &= ~TrackCrossesTracks(FindFirstTrack(v->track));
+				}
+
+				if (bits == TRACK_BIT_NONE) goto invalid_rail;
+
+				/* Check if the new tile constrains tracks that are compatible
+				 * with the current train, if not, bail out. */
+				if (!CheckCompatibleRail(v, gp.new_tile)) goto invalid_rail;
+
+				TrackBits chosen_track;
+				if (prev == NULL) {
+					/* Currently the locomotive is active. Determine which one of the
+					 * available tracks to choose */
+					chosen_track = TrackToTrackBits(ChooseTrainTrack(v, gp.new_tile, enterdir, bits, false, NULL, true));
+					assert(chosen_track & (bits | GetReservedTrackbits(gp.new_tile)));
+
+					if (v->force_proceed != TFP_NONE && IsPlainRailTile(gp.new_tile) && HasSignals(gp.new_tile)) {
+						/* For each signal we find decrease the counter by one.
+						 * We start at two, so the first signal we pass decreases
+						 * this to one, then if we reach the next signal it is
+						 * decreased to zero and we won't pass that new signal. */
+						Trackdir dir = FindFirstTrackdir(trackdirbits);
+						if (GetSignalType(gp.new_tile, TrackdirToTrack(dir)) != SIGTYPE_PBS ||
+								!HasSignalOnTrackdir(gp.new_tile, ReverseTrackdir(dir))) {
+							/* However, we do not want to be stopped by PBS signals
+							 * entered via the back. */
+							v->force_proceed = (v->force_proceed == TFP_SIGNAL) ? TFP_STUCK : TFP_NONE;
+							SetWindowDirty(WC_VEHICLE_VIEW, v->index);
+						}
+					}
+
+					/* Check if it's a red signal and that force proceed is not clicked. */
+					if ((red_signals & chosen_track) && v->force_proceed == TFP_NONE) {
+						/* In front of a red signal */
+						Trackdir i = FindFirstTrackdir(trackdirbits);
+
+						/* Don't handle stuck trains here. */
+						if (HasBit(v->flags, VRF_TRAIN_STUCK)) return false;
+
+						if (!HasSignalOnTrackdir(gp.new_tile, ReverseTrackdir(i))) {
+							v->cur_speed = 0;
+							v->subspeed = 0;
+							v->progress = 255 - 100;
+							if (!_settings_game.pf.reverse_at_signals || ++v->wait_counter < _settings_game.pf.wait_oneway_signal * 20) return false;
+						} else if (HasSignalOnTrackdir(gp.new_tile, i)) {
+							v->cur_speed = 0;
+							v->subspeed = 0;
+							v->progress = 255 - 10;
+							if (!_settings_game.pf.reverse_at_signals || ++v->wait_counter < _settings_game.pf.wait_twoway_signal * 73) {
+								DiagDirection exitdir = TrackdirToExitdir(i);
+								TileIndex o_tile = TileAddByDiagDir(gp.new_tile, exitdir);
+
+								exitdir = ReverseDiagDir(exitdir);
+
+								/* check if a train is waiting on the other side */
+								if (!HasVehicleOnPos(o_tile, &exitdir, &CheckTrainAtSignal)) return false;
+							}
+						}
+
+						/* If we would reverse but are currently in a PBS block and
+						 * reversing of stuck trains is disabled, don't reverse.
+						 * This does not apply if the reason for reversing is a one-way
+						 * signal blocking us, because a train would then be stuck forever. */
+						if (!_settings_game.pf.reverse_at_signals && !HasOnewaySignalBlockingTrackdir(gp.new_tile, i) &&
+								UpdateSignalsOnSegment(v->tile, enterdir, v->owner) == SIGSEG_PBS) {
+							v->wait_counter = 0;
+							return false;
+						}
+						goto reverse_train_direction;
+					} else {
+						TryReserveRailTrack(gp.new_tile, TrackBitsToTrack(chosen_track), false);
+					}
+				} else {
+					/* The wagon is active, simply follow the prev vehicle. */
+					if (prev->tile == gp.new_tile) {
+						/* Choose the same track as prev */
+						if (prev->track == TRACK_BIT_WORMHOLE) {
+							/* Vehicles entering tunnels enter the wormhole earlier than for bridges.
+							 * However, just choose the track into the wormhole. */
+							assert(IsTunnel(prev->tile));
+							chosen_track = bits;
+						} else {
+							chosen_track = prev->track;
+						}
+					} else {
+						/* Choose the track that leads to the tile where prev is.
+						 * This case is active if 'prev' is already on the second next tile, when 'v' just enters the next tile.
+						 * I.e. when the tile between them has only space for a single vehicle like
+						 *  1) horizontal/vertical track tiles and
+						 *  2) some orientations of tunnel entries, where the vehicle is already inside the wormhole at 8/16 from the tile edge.
+						 *     Is also the train just reversing, the wagon inside the tunnel is 'on' the tile of the opposite tunnel entry.
+						 */
+						static const TrackBits _connecting_track[DIAGDIR_END][DIAGDIR_END] = {
+							{TRACK_BIT_X,     TRACK_BIT_LOWER, TRACK_BIT_NONE,  TRACK_BIT_LEFT },
+							{TRACK_BIT_UPPER, TRACK_BIT_Y,     TRACK_BIT_LEFT,  TRACK_BIT_NONE },
+							{TRACK_BIT_NONE,  TRACK_BIT_RIGHT, TRACK_BIT_X,     TRACK_BIT_UPPER},
+							{TRACK_BIT_RIGHT, TRACK_BIT_NONE,  TRACK_BIT_LOWER, TRACK_BIT_Y    }
+						};
+						DiagDirection exitdir = DiagdirBetweenTiles(gp.new_tile, prev->tile);
+						assert(IsValidDiagDirection(exitdir));
+						chosen_track = _connecting_track[enterdir][exitdir];
+					}
+					chosen_track &= bits;
+				}
+
+				/* Make sure chosen track is a valid track */
+				assert(
+						chosen_track == TRACK_BIT_X     || chosen_track == TRACK_BIT_Y ||
+						chosen_track == TRACK_BIT_UPPER || chosen_track == TRACK_BIT_LOWER ||
+						chosen_track == TRACK_BIT_LEFT  || chosen_track == TRACK_BIT_RIGHT);
+
+				/* Update XY to reflect the entrance to the new tile, and select the direction to use */
+				const byte *b = _initial_tile_subcoord[FIND_FIRST_BIT(chosen_track)][enterdir];
+				gp.x = (gp.x & ~0xF) | b[0];
+				gp.y = (gp.y & ~0xF) | b[1];
+				Direction chosen_dir = (Direction)b[2];
+
+				/* Call the landscape function and tell it that the vehicle entered the tile */
+				uint32 r = VehicleEnterTile(v, gp.new_tile, gp.x, gp.y);
+				if (HasBit(r, VETS_CANNOT_ENTER)) {
+					goto invalid_rail;
+				}
+
+				if (!HasBit(r, VETS_ENTERED_WORMHOLE)) {
+					Track track = FindFirstTrack(chosen_track);
+					Trackdir tdir = TrackDirectionToTrackdir(track, chosen_dir);
+					if (v->IsFrontEngine() && HasPbsSignalOnTrackdir(gp.new_tile, tdir)) {
+						SetSignalStateByTrackdir(gp.new_tile, tdir, SIGNAL_STATE_RED);
+						MarkTileDirtyByTile(gp.new_tile);
+					}
+
+					/* Clear any track reservation when the last vehicle leaves the tile */
+					if (v->Next() == NULL) ClearPathReservation(v, v->tile, v->GetVehicleTrackdir());
+
+					v->tile = gp.new_tile;
+
+					if (GetTileRailType(gp.new_tile) != GetTileRailType(gp.old_tile)) {
+						v->First()->ConsistChanged(true);
+					}
+
+					v->track = chosen_track;
+					assert(v->track);
+				}
+
+				/* We need to update signal status, but after the vehicle position hash
+				 * has been updated by UpdateInclination() */
+				update_signals_crossing = true;
+
+				if (chosen_dir != v->direction) {
+					if (prev == NULL && _settings_game.vehicle.train_acceleration_model == AM_ORIGINAL) {
+						const AccelerationSlowdownParams *asp = &_accel_slowdown[GetRailTypeInfo(v->railtype)->acceleration_type];
+						DirDiff diff = DirDifference(v->direction, chosen_dir);
+						v->cur_speed -= (diff == DIRDIFF_45RIGHT || diff == DIRDIFF_45LEFT ? asp->small_turn : asp->large_turn) * v->cur_speed >> 8;
+					}
+					direction_changed = true;
+					v->direction = chosen_dir;
+				}
+
+				if (v->IsFrontEngine()) {
+					v->wait_counter = 0;
+
+					/* If we are approaching a crossing that is reserved, play the sound now. */
+					TileIndex crossing = TrainApproachingCrossingTile(v);
+					if (crossing != INVALID_TILE && HasCrossingReservation(crossing) && _settings_client.sound.new_year) SndPlayTileFx(SND_0E_LEVEL_CROSSING, crossing);
+
+					/* Always try to extend the reservation when entering a tile. */
+					CheckNextTrainTile(v);
+				}
+
+				if (HasBit(r, VETS_ENTERED_STATION)) {
+					/* The new position is the location where we want to stop */
+					TrainEnterStation(v, r >> VETS_STATION_ID_OFFSET);
+				}
+			}
+		} else {
+			if (IsTileType(gp.new_tile, MP_TUNNELBRIDGE) && HasBit(VehicleEnterTile(v, gp.new_tile, gp.x, gp.y), VETS_ENTERED_WORMHOLE)) {
+				/* Perform look-ahead on tunnel exit. */
+				if (v->IsFrontEngine()) {
+					TryReserveRailTrack(gp.new_tile, DiagDirToDiagTrack(GetTunnelBridgeDirection(gp.new_tile)));
+					CheckNextTrainTile(v);
+				}
+				/* Prevent v->UpdateInclination() being called with wrong parameters.
+				 * This could happen if the train was reversed inside the tunnel/bridge. */
+				if (gp.old_tile == gp.new_tile) {
+					gp.old_tile = GetOtherTunnelBridgeEnd(gp.old_tile);
+				}
+			} else {
+				v->x_pos = gp.x;
+				v->y_pos = gp.y;
+				VehicleUpdatePosition(v);
+				if ((v->vehstatus & VS_HIDDEN) == 0) VehicleUpdateViewport(v, true);
+				continue;
+			}
+		}
+
+		/* update image of train, as well as delta XY */
+		v->UpdateDeltaXY(v->direction);
+
+		v->x_pos = gp.x;
+		v->y_pos = gp.y;
+		VehicleUpdatePosition(v);
+
+		/* update the Z position of the vehicle */
+		int old_z = v->UpdateInclination(gp.new_tile != gp.old_tile, false);
+
+		if (prev == NULL) {
+			/* This is the first vehicle in the train */
+			AffectSpeedByZChange(v, old_z);
+		}
+
+		if (update_signals_crossing) {
+			if (v->IsFrontEngine()) {
+				if (TrainMovedChangeSignals(gp.new_tile, enterdir)) {
+					/* We are entering a block with PBS signals right now, but
+					 * not through a PBS signal. This means we don't have a
+					 * reservation right now. As a conventional signal will only
+					 * ever be green if no other train is in the block, getting
+					 * a path should always be possible. If the player built
+					 * such a strange network that it is not possible, the train
+					 * will be marked as stuck and the player has to deal with
+					 * the problem. */
+					if ((!HasReservedTracks(gp.new_tile, v->track) &&
+							!TryReserveRailTrack(gp.new_tile, FindFirstTrack(v->track))) ||
+							!TryPathReserve(v)) {
+						MarkTrainAsStuck(v);
+					}
+				}
+			}
+
+			/* Signals can only change when the first
+			 * (above) or the last vehicle moves. */
+			if (v->Next() == NULL) {
+				TrainMovedChangeSignals(gp.old_tile, ReverseDiagDir(enterdir));
+				if (IsLevelCrossingTile(gp.old_tile)) UpdateLevelCrossing(gp.old_tile);
+			}
+		}
+
+		/* Do not check on every tick to save some computing time. */
+		if (v->IsFrontEngine() && v->tick_counter % _settings_game.pf.path_backoff_interval == 0) CheckNextTrainTile(v);
+	}
+
+	if (direction_changed) first->tcache.cached_max_curve_speed = first->GetCurveSpeedLimit();
+
+	return true;
+
+invalid_rail:
+	/* We've reached end of line?? */
+	if (prev != NULL) error("Disconnecting train");
+
+reverse_train_direction:
+	if (reverse) {
+		v->wait_counter = 0;
+		v->cur_speed = 0;
+		v->subspeed = 0;
+		ReverseTrainDirection(v);
+	}
+
+	return false;
+}
+
+/**
+ * Collect trackbits of all crashed train vehicles on a tile
+ * @param v Vehicle passed from Find/HasVehicleOnPos()
+ * @param data trackdirbits for the result
+ * @return NULL to iterate over all vehicles on the tile.
+ */
+static Vehicle *CollectTrackbitsFromCrashedVehiclesEnum(Vehicle *v, void *data)
+{
+	TrackBits *trackbits = (TrackBits *)data;
+
+	if (v->type == VEH_TRAIN && (v->vehstatus & VS_CRASHED) != 0) {
+		TrackBits train_tbits = Train::From(v)->track;
+		if (train_tbits == TRACK_BIT_WORMHOLE) {
+			/* Vehicle is inside a wormhole, v->track contains no useful value then. */
+			*trackbits |= DiagDirToDiagTrackBits(GetTunnelBridgeDirection(v->tile));
+		} else if (train_tbits != TRACK_BIT_DEPOT) {
+			*trackbits |= train_tbits;
+		}
+	}
+
+	return NULL;
+}
+
+/**
+ * Deletes/Clears the last wagon of a crashed train. It takes the engine of the
+ * train, then goes to the last wagon and deletes that. Each call to this function
+ * will remove the last wagon of a crashed train. If this wagon was on a crossing,
+ * or inside a tunnel/bridge, recalculate the signals as they might need updating
+ * @param v the Vehicle of which last wagon is to be removed
+ */
+static void DeleteLastWagon(Train *v)
+{
+	Train *first = v->First();
+
+	/* Go to the last wagon and delete the link pointing there
+	 * *u is then the one-before-last wagon, and *v the last
+	 * one which will physically be removed */
+	Train *u = v;
+	for (; v->Next() != NULL; v = v->Next()) u = v;
+	u->SetNext(NULL);
+
+	if (first != v) {
+		/* Recalculate cached train properties */
+		first->ConsistChanged(false);
+		/* Update the depot window if the first vehicle is in depot -
+		 * if v == first, then it is updated in PreDestructor() */
+		if (first->track == TRACK_BIT_DEPOT) {
+			SetWindowDirty(WC_VEHICLE_DEPOT, first->tile);
+		}
+	}
+
+	/* 'v' shouldn't be accessed after it has been deleted */
+	TrackBits trackbits = v->track;
+	TileIndex tile = v->tile;
+	Owner owner = v->owner;
+
+	delete v;
+	v = NULL; // make sure nobody will try to read 'v' anymore
+
+	if (trackbits == TRACK_BIT_WORMHOLE) {
+		/* Vehicle is inside a wormhole, v->track contains no useful value then. */
+		trackbits = DiagDirToDiagTrackBits(GetTunnelBridgeDirection(tile));
+	}
+
+	Track track = TrackBitsToTrack(trackbits);
+	if (HasReservedTracks(tile, trackbits)) {
+		UnreserveRailTrack(tile, track);
+
+		/* If there are still crashed vehicles on the tile, give the track reservation to them */
+		TrackBits remaining_trackbits = TRACK_BIT_NONE;
+		FindVehicleOnPos(tile, &remaining_trackbits, CollectTrackbitsFromCrashedVehiclesEnum);
+
+		/* It is important that these two are the first in the loop, as reservation cannot deal with every trackbit combination */
+		assert(TRACK_BEGIN == TRACK_X && TRACK_Y == TRACK_BEGIN + 1);
+		Track t;
+		FOR_EACH_SET_TRACK(t, remaining_trackbits) TryReserveRailTrack(tile, t);
+	}
+
+	/* check if the wagon was on a road/rail-crossing */
+	if (IsLevelCrossingTile(tile)) UpdateLevelCrossing(tile);
+
+	/* Update signals */
+	if (IsTileType(tile, MP_TUNNELBRIDGE) || IsRailDepotTile(tile)) {
+		UpdateSignalsOnSegment(tile, INVALID_DIAGDIR, owner);
+	} else {
+		SetSignalsOnBothDir(tile, track, owner);
+	}
+}
+
+/**
+ * Rotate all vehicles of a (crashed) train chain randomly to animate the crash.
+ * @param v First crashed vehicle.
+ */
+static void ChangeTrainDirRandomly(Train *v)
+{
+	static const DirDiff delta[] = {
+		DIRDIFF_45LEFT, DIRDIFF_SAME, DIRDIFF_SAME, DIRDIFF_45RIGHT
+	};
+
+	do {
+		/* We don't need to twist around vehicles if they're not visible */
+		if (!(v->vehstatus & VS_HIDDEN)) {
+			v->direction = ChangeDir(v->direction, delta[GB(Random(), 0, 2)]);
+			v->UpdateDeltaXY(v->direction);
+			v->cur_image = v->GetImage(v->direction, EIT_ON_MAP);
+			/* Refrain from updating the z position of the vehicle when on
+			 * a bridge, because UpdateInclination() will put the vehicle under
+			 * the bridge in that case */
+			if (v->track != TRACK_BIT_WORMHOLE) {
+				VehicleUpdatePosition(v);
+				v->UpdateInclination(false, false);
+			}
+		}
+	} while ((v = v->Next()) != NULL);
+}
+
+/**
+ * Handle a crashed train.
+ * @param v First train vehicle.
+ * @return %Vehicle chain still exists.
+ */
+static bool HandleCrashedTrain(Train *v)
+{
+	int state = ++v->crash_anim_pos;
+
+	if (state == 4 && !(v->vehstatus & VS_HIDDEN)) {
+		CreateEffectVehicleRel(v, 4, 4, 8, EV_EXPLOSION_LARGE);
+	}
+
+	uint32 r;
+	if (state <= 200 && Chance16R(1, 7, r)) {
+		int index = (r * 10 >> 16);
+
+		Vehicle *u = v;
+		do {
+			if (--index < 0) {
+				r = Random();
+
+				CreateEffectVehicleRel(u,
+					GB(r,  8, 3) + 2,
+					GB(r, 16, 3) + 2,
+					GB(r,  0, 3) + 5,
+					EV_EXPLOSION_SMALL);
+				break;
+			}
+		} while ((u = u->Next()) != NULL);
+	}
+
+	if (state <= 240 && !(v->tick_counter & 3)) ChangeTrainDirRandomly(v);
+
+	if (state >= 4440 && !(v->tick_counter & 0x1F)) {
+		bool ret = v->Next() != NULL;
+		DeleteLastWagon(v);
+		return ret;
+	}
+
+	return true;
+}
+
+/** Maximum speeds for train that is broken down or approaching line end */
+static const uint16 _breakdown_speeds[16] = {
+	225, 210, 195, 180, 165, 150, 135, 120, 105, 90, 75, 60, 45, 30, 15, 15
+};
+
+
+/**
+ * Train is approaching line end, slow down and possibly reverse
+ *
+ * @param v front train engine
+ * @param signal not line end, just a red signal
+ * @param reverse Set to false to not execute the vehicle reversing. This does not change any other logic.
+ * @return true iff we did NOT have to reverse
+ */
+static bool TrainApproachingLineEnd(Train *v, bool signal, bool reverse)
+{
+	/* Calc position within the current tile */
+	uint x = v->x_pos & 0xF;
+	uint y = v->y_pos & 0xF;
+
+	/* for diagonal directions, 'x' will be 0..15 -
+	 * for other directions, it will be 1, 3, 5, ..., 15 */
+	switch (v->direction) {
+		case DIR_N : x = ~x + ~y + 25; break;
+		case DIR_NW: x = y;            // FALL THROUGH
+		case DIR_NE: x = ~x + 16;      break;
+		case DIR_E : x = ~x + y + 9;   break;
+		case DIR_SE: x = y;            break;
+		case DIR_S : x = x + y - 7;    break;
+		case DIR_W : x = ~y + x + 9;   break;
+		default: break;
+	}
+
+	/* Do not reverse when approaching red signal. Make sure the vehicle's front
+	 * does not cross the tile boundary when we do reverse, but as the vehicle's
+	 * location is based on their center, use half a vehicle's length as offset.
+	 * Multiply the half-length by two for straight directions to compensate that
+	 * we only get odd x offsets there. */
+	if (!signal && x + (v->gcache.cached_veh_length + 1) / 2 * (IsDiagonalDirection(v->direction) ? 1 : 2) >= TILE_SIZE) {
+		/* we are too near the tile end, reverse now */
+		v->cur_speed = 0;
+		if (reverse) ReverseTrainDirection(v);
+		return false;
+	}
+
+	/* slow down */
+	v->vehstatus |= VS_TRAIN_SLOWING;
+	uint16 break_speed = _breakdown_speeds[x & 0xF];
+	if (break_speed < v->cur_speed) v->cur_speed = break_speed;
+
+	return true;
+}
+
+
+/**
+ * Determines whether train would like to leave the tile
+ * @param v train to test
+ * @return true iff vehicle is NOT entering or inside a depot or tunnel/bridge
+ */
+static bool TrainCanLeaveTile(const Train *v)
+{
+	/* Exit if inside a tunnel/bridge or a depot */
+	if (v->track == TRACK_BIT_WORMHOLE || v->track == TRACK_BIT_DEPOT) return false;
+
+	TileIndex tile = v->tile;
+
+	/* entering a tunnel/bridge? */
+	if (IsTileType(tile, MP_TUNNELBRIDGE)) {
+		DiagDirection dir = GetTunnelBridgeDirection(tile);
+		if (DiagDirToDir(dir) == v->direction) return false;
+	}
+
+	/* entering a depot? */
+	if (IsRailDepotTile(tile)) {
+		DiagDirection dir = ReverseDiagDir(GetRailDepotDirection(tile));
+		if (DiagDirToDir(dir) == v->direction) return false;
+	}
+
+	return true;
+}
+
+
+/**
+ * Determines whether train is approaching a rail-road crossing
+ *   (thus making it barred)
+ * @param v front engine of train
+ * @return TileIndex of crossing the train is approaching, else INVALID_TILE
+ * @pre v in non-crashed front engine
+ */
+static TileIndex TrainApproachingCrossingTile(const Train *v)
+{
+	assert(v->IsFrontEngine());
+	assert(!(v->vehstatus & VS_CRASHED));
+
+	if (!TrainCanLeaveTile(v)) return INVALID_TILE;
+
+	DiagDirection dir = TrainExitDir(v->direction, v->track);
+	TileIndex tile = v->tile + TileOffsByDiagDir(dir);
+
+	/* not a crossing || wrong axis || unusable rail (wrong type or owner) */
+	if (!IsLevelCrossingTile(tile) || DiagDirToAxis(dir) == GetCrossingRoadAxis(tile) ||
+			!CheckCompatibleRail(v, tile)) {
+		return INVALID_TILE;
+	}
+
+	return tile;
+}
+
+
+/**
+ * Checks for line end. Also, bars crossing at next tile if needed
+ *
+ * @param v vehicle we are checking
+ * @param reverse Set to false to not execute the vehicle reversing. This does not change any other logic.
+ * @return true iff we did NOT have to reverse
+ */
+static bool TrainCheckIfLineEnds(Train *v, bool reverse)
+{
+	/* First, handle broken down train */
+
+	int t = v->breakdown_ctr;
+	if (t > 1) {
+		v->vehstatus |= VS_TRAIN_SLOWING;
+
+		uint16 break_speed = _breakdown_speeds[GB(~t, 4, 4)];
+		if (break_speed < v->cur_speed) v->cur_speed = break_speed;
+	} else {
+		v->vehstatus &= ~VS_TRAIN_SLOWING;
+	}
+
+	if (!TrainCanLeaveTile(v)) return true;
+
+	/* Determine the non-diagonal direction in which we will exit this tile */
+	DiagDirection dir = TrainExitDir(v->direction, v->track);
+	/* Calculate next tile */
+	TileIndex tile = v->tile + TileOffsByDiagDir(dir);
+
+	/* Determine the track status on the next tile */
+	TrackStatus ts = GetTileTrackStatus(tile, TRANSPORT_RAIL, 0, ReverseDiagDir(dir));
+	TrackdirBits reachable_trackdirs = DiagdirReachesTrackdirs(dir);
+
+	TrackdirBits trackdirbits = TrackStatusToTrackdirBits(ts) & reachable_trackdirs;
+	TrackdirBits red_signals = TrackStatusToRedSignals(ts) & reachable_trackdirs;
+
+	/* We are sure the train is not entering a depot, it is detected above */
+
+	/* mask unreachable track bits if we are forbidden to do 90deg turns */
+	TrackBits bits = TrackdirBitsToTrackBits(trackdirbits);
+	if (_settings_game.pf.forbid_90_deg) {
+		bits &= ~TrackCrossesTracks(FindFirstTrack(v->track));
+	}
+
+	/* no suitable trackbits at all || unusable rail (wrong type or owner) */
+	if (bits == TRACK_BIT_NONE || !CheckCompatibleRail(v, tile)) {
+		return TrainApproachingLineEnd(v, false, reverse);
+	}
+
+	/* approaching red signal */
+	if ((trackdirbits & red_signals) != 0) return TrainApproachingLineEnd(v, true, reverse);
+
+	/* approaching a rail/road crossing? then make it red */
+	if (IsLevelCrossingTile(tile)) MaybeBarCrossingWithSound(tile);
+
+	return true;
+}
+
+
+static bool TrainLocoHandler(Train *v, bool mode)
+{
+	/* train has crashed? */
+	if (v->vehstatus & VS_CRASHED) {
+		return mode ? true : HandleCrashedTrain(v); // 'this' can be deleted here
+	}
+
+	if (v->force_proceed != TFP_NONE) {
+		ClrBit(v->flags, VRF_TRAIN_STUCK);
+		SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);
+	}
+
+	/* train is broken down? */
+	if (v->HandleBreakdown()) return true;
+
+	if (HasBit(v->flags, VRF_REVERSING) && v->cur_speed == 0) {
+		ReverseTrainDirection(v);
+	}
+
+	/* exit if train is stopped */
+	if ((v->vehstatus & VS_STOPPED) && v->cur_speed == 0) return true;
+
+	bool valid_order = !v->current_order.IsType(OT_NOTHING) && v->current_order.GetType() != OT_CONDITIONAL;
+	if (ProcessOrders(v) && CheckReverseTrain(v)) {
+		v->wait_counter = 0;
+		v->cur_speed = 0;
+		v->subspeed = 0;
+		ClrBit(v->flags, VRF_LEAVING_STATION);
+		ReverseTrainDirection(v);
+		return true;
+	} else if (HasBit(v->flags, VRF_LEAVING_STATION)) {
+		/* Try to reserve a path when leaving the station as we
+		 * might not be marked as wanting a reservation, e.g.
+		 * when an overlength train gets turned around in a station. */
+		DiagDirection dir = TrainExitDir(v->direction, v->track);
+		if (IsRailDepotTile(v->tile) || IsTileType(v->tile, MP_TUNNELBRIDGE)) dir = INVALID_DIAGDIR;
+
+		if (UpdateSignalsOnSegment(v->tile, dir, v->owner) == SIGSEG_PBS || _settings_game.pf.reserve_paths) {
+			TryPathReserve(v, true, true);
+		}
+		ClrBit(v->flags, VRF_LEAVING_STATION);
+	}
+
+	v->HandleLoading(mode);
+
+	if (v->current_order.IsType(OT_LOADING)) return true;
+
+	if (CheckTrainStayInDepot(v)) return true;
+
+	if (!mode) v->ShowVisualEffect();
+
+	/* We had no order but have an order now, do look ahead. */
+	if (!valid_order && !v->current_order.IsType(OT_NOTHING)) {
+		CheckNextTrainTile(v);
+	}
+
+	/* Handle stuck trains. */
+	if (!mode && HasBit(v->flags, VRF_TRAIN_STUCK)) {
+		++v->wait_counter;
+
+		/* Should we try reversing this tick if still stuck? */
+		bool turn_around = v->wait_counter % (_settings_game.pf.wait_for_pbs_path * DAY_TICKS) == 0 && _settings_game.pf.reverse_at_signals;
+
+		if (!turn_around && v->wait_counter % _settings_game.pf.path_backoff_interval != 0 && v->force_proceed == TFP_NONE) return true;
+		if (!TryPathReserve(v)) {
+			/* Still stuck. */
+			if (turn_around) ReverseTrainDirection(v);
+
+			if (HasBit(v->flags, VRF_TRAIN_STUCK) && v->wait_counter > 2 * _settings_game.pf.wait_for_pbs_path * DAY_TICKS) {
+				/* Show message to player. */
+				if (_settings_client.gui.lost_vehicle_warn && v->owner == _local_company) {
+					SetDParam(0, v->index);
+					AddVehicleAdviceNewsItem(STR_NEWS_TRAIN_IS_STUCK, v->index);
+				}
+				v->wait_counter = 0;
+			}
+			/* Exit if force proceed not pressed, else reset stuck flag anyway. */
+			if (v->force_proceed == TFP_NONE) return true;
+			ClrBit(v->flags, VRF_TRAIN_STUCK);
+			v->wait_counter = 0;
+			SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);
+		}
+	}
+
+	if (v->current_order.IsType(OT_LEAVESTATION)) {
+		v->current_order.Free();
+		SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);
+		return true;
+	}
+
+	int j = v->UpdateSpeed();
+
+	/* we need to invalidate the widget if we are stopping from 'Stopping 0 km/h' to 'Stopped' */
+	if (v->cur_speed == 0 && (v->vehstatus & VS_STOPPED)) {
+		/* If we manually stopped, we're not force-proceeding anymore. */
+		v->force_proceed = TFP_NONE;
+		SetWindowDirty(WC_VEHICLE_VIEW, v->index);
+	}
+
+	int adv_spd = v->GetAdvanceDistance();
+	if (j < adv_spd) {
+		/* if the vehicle has speed 0, update the last_speed field. */
+		if (v->cur_speed == 0) v->SetLastSpeed();
+	} else {
+		TrainCheckIfLineEnds(v);
+		/* Loop until the train has finished moving. */
+		for (;;) {
+			j -= adv_spd;
+			TrainController(v, NULL);
+			/* Don't continue to move if the train crashed. */
+			if (CheckTrainCollision(v)) break;
+			/* Determine distance to next map position */
+			adv_spd = v->GetAdvanceDistance();
+
+			/* No more moving this tick */
+			if (j < adv_spd || v->cur_speed == 0) break;
+
+			OrderType order_type = v->current_order.GetType();
+			/* Do not skip waypoints (incl. 'via' stations) when passing through at full speed. */
+			if ((order_type == OT_GOTO_WAYPOINT || order_type == OT_GOTO_STATION) &&
+						(v->current_order.GetNonStopType() & ONSF_NO_STOP_AT_DESTINATION_STATION) &&
+						IsTileType(v->tile, MP_STATION) &&
+						v->current_order.GetDestination() == GetStationIndex(v->tile)) {
+				ProcessOrders(v);
+			}
+		}
+		v->SetLastSpeed();
+	}
+
+	for (Train *u = v; u != NULL; u = u->Next()) {
+		if ((u->vehstatus & VS_HIDDEN) != 0) continue;
+
+		u->UpdateViewport(false, false);
+	}
+
+	if (v->progress == 0) v->progress = j; // Save unused spd for next time, if TrainController didn't set progress
+
+	return true;
+}
+
+/**
+ * Get running cost for the train consist.
+ * @return Yearly running costs.
+ */
+Money Train::GetRunningCost() const
+{
+	Money cost = 0;
+	const Train *v = this;
+
+	do {
+		const Engine *e = v->GetEngine();
+		if (e->u.rail.running_cost_class == INVALID_PRICE) continue;
+
+		uint cost_factor = GetVehicleProperty(v, PROP_TRAIN_RUNNING_COST_FACTOR, e->u.rail.running_cost);
+		if (cost_factor == 0) continue;
+
+		/* Halve running cost for multiheaded parts */
+		if (v->IsMultiheaded()) cost_factor /= 2;
+
+		cost += GetPrice(e->u.rail.running_cost_class, cost_factor, e->GetGRF());
+	} while ((v = v->GetNextVehicle()) != NULL);
+
+	return cost;
+}
+
+/**
+ * Update train vehicle data for a tick.
+ * @return True if the vehicle still exists, false if it has ceased to exist (front of consists only).
+ */
+bool Train::Tick()
+{
+	this->tick_counter++;
+
+	if (this->IsFrontEngine()) {
+		if (!(this->vehstatus & VS_STOPPED) || this->cur_speed > 0) this->running_ticks++;
+
+		this->current_order_time++;
+
+		if (!TrainLocoHandler(this, false)) return false;
+
+		return TrainLocoHandler(this, true);
+	} else if (this->IsFreeWagon() && (this->vehstatus & VS_CRASHED)) {
+		/* Delete flooded standalone wagon chain */
+		if (++this->crash_anim_pos >= 4400) {
+			delete this;
+			return false;
+		}
+	}
+
+	return true;
+}
+
+/**
+ * Check whether a train needs service, and if so, find a depot or service it.
+ * @return v %Train to check.
+ */
+static void CheckIfTrainNeedsService(Train *v)
+{
+	if (Company::Get(v->owner)->settings.vehicle.servint_trains == 0 || !v->NeedsAutomaticServicing()) return;
+	if (v->IsChainInDepot()) {
+		VehicleServiceInDepot(v);
+		return;
+	}
+
+	uint max_penalty;
+	switch (_settings_game.pf.pathfinder_for_trains) {
+		case VPF_NPF:  max_penalty = _settings_game.pf.npf.maximum_go_to_depot_penalty;  break;
+		case VPF_YAPF: max_penalty = _settings_game.pf.yapf.maximum_go_to_depot_penalty; break;
+		default: NOT_REACHED();
+	}
+
+	FindDepotData tfdd = FindClosestTrainDepot(v, max_penalty);
+	/* Only go to the depot if it is not too far out of our way. */
+	if (tfdd.best_length == UINT_MAX || tfdd.best_length > max_penalty) {
+		if (v->current_order.IsType(OT_GOTO_DEPOT)) {
+			/* If we were already heading for a depot but it has
+			 * suddenly moved farther away, we continue our normal
+			 * schedule? */
+			v->current_order.MakeDummy();
+			SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);
+		}
+		return;
+	}
+
+	DepotID depot = GetDepotIndex(tfdd.tile);
+
+	if (v->current_order.IsType(OT_GOTO_DEPOT) &&
+			v->current_order.GetDestination() != depot &&
+			!Chance16(3, 16)) {
+		return;
+	}
+
+	SetBit(v->gv_flags, GVF_SUPPRESS_IMPLICIT_ORDERS);
+	v->current_order.MakeGoToDepot(depot, ODTFB_SERVICE);
+	v->dest_tile = tfdd.tile;
+	SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);
+}
+
+/** Update day counters of the train vehicle. */
+void Train::OnNewDay()
+{
+	AgeVehicle(this);
+
+	if ((++this->day_counter & 7) == 0) DecreaseVehicleValue(this);
+
+	if (this->IsFrontEngine()) {
+		CheckVehicleBreakdown(this);
+
+		CheckIfTrainNeedsService(this);
+
+		CheckOrders(this);
+
+		/* update destination */
+		if (this->current_order.IsType(OT_GOTO_STATION)) {
+			TileIndex tile = Station::Get(this->current_order.GetDestination())->train_station.tile;
+			if (tile != INVALID_TILE) this->dest_tile = tile;
+		}
+
+		if (this->running_ticks != 0) {
+			/* running costs */
+			CommandCost cost(EXPENSES_TRAIN_RUN, this->GetRunningCost() * this->running_ticks / (DAYS_IN_YEAR  * DAY_TICKS));
+
+			this->profit_this_year -= cost.GetCost();
+			this->running_ticks = 0;
+
+			SubtractMoneyFromCompanyFract(this->owner, cost);
+
+			SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
+			SetWindowClassesDirty(WC_TRAINS_LIST);
+		}
+	}
+}
+
+/**
+ * Get the tracks of the train vehicle.
+ * @return Current tracks of the vehicle.
+ */
+Trackdir Train::GetVehicleTrackdir() const
+{
+	if (this->vehstatus & VS_CRASHED) return INVALID_TRACKDIR;
+
+	if (this->track == TRACK_BIT_DEPOT) {
+		/* We'll assume the train is facing outwards */
+		return DiagDirToDiagTrackdir(GetRailDepotDirection(this->tile)); // Train in depot
+	}
+
+	if (this->track == TRACK_BIT_WORMHOLE) {
+		/* train in tunnel or on bridge, so just use his direction and assume a diagonal track */
+		return DiagDirToDiagTrackdir(DirToDiagDir(this->direction));
+	}
+
+	return TrackDirectionToTrackdir(FindFirstTrack(this->track), this->direction);
+}
diff --git a/src/train_cmd.cpp.rej b/src/train_cmd.cpp.rej
new file mode 100644
index 0000000..ca55b7d
--- /dev/null
+++ b/src/train_cmd.cpp.rej
@@ -0,0 +1,11 @@
+--- src/train_cmd.cpp	(revision 24056)
++++ src/train_cmd.cpp	(working copy)
+@@ -241,7 +243,7 @@
+ 
+ 	if (this->IsFrontEngine()) {
+ 		this->UpdateAcceleration();
+-		SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
++		if ( !HasBit(this->subtype, GVSF_VIRTUAL) ) SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
+ 		InvalidateWindowData(WC_VEHICLE_REFIT, this->index);
+ 	}
+ }
diff --git a/src/train_gui.cpp b/src/train_gui.cpp
index 866eab7..97bd83c 100644
--- a/src/train_gui.cpp
+++ b/src/train_gui.cpp
@@ -18,6 +18,9 @@
 
 #include "table/strings.h"
 
+// MYGUI_NOEND
+#include <stdio.h>
+
 /**
  * Callback for building wagons.
  * @param result The result of the command.
@@ -55,7 +58,8 @@ void CcBuildWagon(const CommandCost &result, TileIndex tile, uint32 p1, uint32 p
  * @param selection Selected vehicle that is dragged.
  * @return The width of the highlight mark.
  */
-static int HighlightDragPosition(int px, int max_width, VehicleID selection)
+// MYGUI_NOEND previously static
+int HighlightDragPosition(int px, int max_width, VehicleID selection)
 {
 	bool rtl = _current_text_dir == TD_RTL;
 
diff --git a/src/train_gui.cpp.orig b/src/train_gui.cpp.orig
new file mode 100644
index 0000000..866eab7
--- /dev/null
+++ b/src/train_gui.cpp.orig
@@ -0,0 +1,450 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file train_gui.cpp GUI for trains. */
+
+#include "stdafx.h"
+#include "window_gui.h"
+#include "command_func.h"
+#include "train.h"
+#include "strings_func.h"
+#include "vehicle_func.h"
+
+#include "table/strings.h"
+
+/**
+ * Callback for building wagons.
+ * @param result The result of the command.
+ * @param tile   The tile the command was executed on.
+ * @param p1 Additional data for the command (for the #CommandProc)
+ * @param p2 Additional data for the command (for the #CommandProc)
+ */
+void CcBuildWagon(const CommandCost &result, TileIndex tile, uint32 p1, uint32 p2)
+{
+	if (result.Failed()) return;
+
+	/* find a locomotive in the depot. */
+	const Vehicle *found = NULL;
+	const Train *t;
+	FOR_ALL_TRAINS(t) {
+		if (t->IsFrontEngine() && t->tile == tile && t->IsStoppedInDepot()) {
+			if (found != NULL) return; // must be exactly one.
+			found = t;
+		}
+	}
+
+	/* if we found a loco, */
+	if (found != NULL) {
+		found = found->Last();
+		/* put the new wagon at the end of the loco. */
+		DoCommandP(0, _new_vehicle_id, found->index, CMD_MOVE_RAIL_VEHICLE);
+		InvalidateWindowClassesData(WC_TRAINS_LIST, 0);
+	}
+}
+
+/**
+ * Highlight the position where a rail vehicle is dragged over by drawing a light gray background.
+ * @param px        The current x position to draw from.
+ * @param max_width The maximum space available to draw.
+ * @param selection Selected vehicle that is dragged.
+ * @return The width of the highlight mark.
+ */
+static int HighlightDragPosition(int px, int max_width, VehicleID selection)
+{
+	bool rtl = _current_text_dir == TD_RTL;
+
+	assert(selection != INVALID_VEHICLE);
+	int dragged_width = WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+	for (Train *t = Train::Get(selection); t != NULL; t = t->HasArticulatedPart() ? t->GetNextArticulatedPart() : NULL) {
+		dragged_width += t->GetDisplayImageWidth(NULL);
+	}
+
+	int drag_hlight_left = rtl ? max(px -dragged_width, 0) : px;
+	int drag_hlight_right = rtl ? px : min(px + dragged_width, max_width);
+	int drag_hlight_width = max(drag_hlight_right - drag_hlight_left, 0);
+
+	if (drag_hlight_width > 0) {
+		GfxFillRect(drag_hlight_left + WD_FRAMERECT_LEFT, WD_FRAMERECT_TOP + 1,
+				drag_hlight_right - WD_FRAMERECT_RIGHT, 13 - WD_FRAMERECT_BOTTOM, _colour_gradient[COLOUR_GREY][7]);
+	}
+
+	return drag_hlight_width;
+}
+
+/**
+ * Draws an image of a whole train
+ * @param v         Front vehicle
+ * @param left      The minimum horizontal position
+ * @param right     The maximum horizontal position
+ * @param y         Vertical position to draw at
+ * @param selection Selected vehicle to draw a frame around
+ * @param skip      Number of pixels to skip at the front (for scrolling)
+ * @param drag_dest The vehicle another one is dragged over, \c INVALID_VEHICLE if none.
+ */
+void DrawTrainImage(const Train *v, int left, int right, int y, VehicleID selection, EngineImageType image_type, int skip, VehicleID drag_dest)
+{
+	bool rtl = _current_text_dir == TD_RTL;
+	Direction dir = rtl ? DIR_E : DIR_W;
+
+	DrawPixelInfo tmp_dpi, *old_dpi;
+	/* Position of highlight box */
+	int highlight_l = 0;
+	int highlight_r = 0;
+	int max_width = right - left + 1;
+
+	if (!FillDrawPixelInfo(&tmp_dpi, left, y, max_width, 14)) return;
+
+	old_dpi = _cur_dpi;
+	_cur_dpi = &tmp_dpi;
+
+	int px = rtl ? max_width + skip : -skip;
+	bool sel_articulated = false;
+	bool dragging = (drag_dest != INVALID_VEHICLE);
+	bool drag_at_end_of_train = (drag_dest == v->index); // Head index is used to mark dragging at end of train.
+	for (; v != NULL && (rtl ? px > 0 : px < max_width); v = v->Next()) {
+		if (dragging && !drag_at_end_of_train && drag_dest == v->index) {
+			/* Highlight the drag-and-drop destination inside the train. */
+			int drag_hlight_width = HighlightDragPosition(px, max_width, selection);
+			px += rtl ? -drag_hlight_width : drag_hlight_width;
+		}
+
+		Point offset;
+		int width = Train::From(v)->GetDisplayImageWidth(&offset);
+
+		if (rtl ? px + width > 0 : px - width < max_width) {
+			PaletteID pal = (v->vehstatus & VS_CRASHED) ? PALETTE_CRASH : GetVehiclePalette(v);
+			DrawSprite(v->GetImage(dir, image_type), pal, px + (rtl ? -offset.x : offset.x), 7 + offset.y);
+		}
+
+		if (!v->IsArticulatedPart()) sel_articulated = false;
+
+		if (v->index == selection) {
+			/* Set the highlight position */
+			highlight_l = rtl ? px - width : px;
+			highlight_r = rtl ? px - 1 : px + width - 1;
+			sel_articulated = true;
+		} else if ((_cursor.vehchain && highlight_r != 0) || sel_articulated) {
+			if (rtl) {
+				highlight_l -= width;
+			} else {
+				highlight_r += width;
+			}
+		}
+
+		px += rtl ? -width : width;
+	}
+
+	if (dragging && drag_at_end_of_train) {
+		/* Highlight the drag-and-drop destination at the end of the train. */
+		HighlightDragPosition(px, max_width, selection);
+	}
+
+	if (highlight_l != highlight_r) {
+		/* Draw the highlight. Now done after drawing all the engines, as
+		 * the next engine after the highlight could overlap it. */
+		DrawFrameRect(highlight_l, 0, highlight_r, 13, COLOUR_WHITE, FR_BORDERONLY);
+	}
+
+	_cur_dpi = old_dpi;
+}
+
+/** Helper struct for the cargo details information */
+struct CargoSummaryItem {
+	CargoID cargo;    ///< The cargo that is carried
+	StringID subtype; ///< STR_EMPTY if none
+	uint capacity;    ///< Amount that can be carried
+	uint amount;      ///< Amount that is carried
+	StationID source; ///< One of the source stations
+
+	/** Used by CargoSummary::Find() and similar functions */
+	inline bool operator != (const CargoSummaryItem &other) const
+	{
+		return this->cargo != other.cargo || this->subtype != other.subtype;
+	}
+};
+
+static const uint TRAIN_DETAILS_MIN_INDENT = 32; ///< Minimum indent level in the train details window
+static const uint TRAIN_DETAILS_MAX_INDENT = 72; ///< Maximum indent level in the train details window; wider than this and we start on a new line
+
+/** Container for the cargo summary information. */
+typedef SmallVector<CargoSummaryItem, 2> CargoSummary;
+/** Reused container of cargo details */
+static CargoSummary _cargo_summary;
+
+/**
+ * Draw the details cargo tab for the given vehicle at the given position
+ *
+ * @param item  Data to draw
+ * @param left  The left most coordinate to draw
+ * @param right The right most coordinate to draw
+ * @param y     The y coordinate
+ */
+static void TrainDetailsCargoTab(const CargoSummaryItem *item, int left, int right, int y)
+{
+	StringID str;
+	if (item->amount > 0) {
+		SetDParam(0, item->cargo);
+		SetDParam(1, item->amount);
+		SetDParam(2, item->source);
+		SetDParam(3, _settings_game.vehicle.freight_trains);
+		str = FreightWagonMult(item->cargo) > 1 ? STR_VEHICLE_DETAILS_CARGO_FROM_MULT : STR_VEHICLE_DETAILS_CARGO_FROM;
+	} else {
+		SetDParam(0, STR_QUANTITY_N_A);
+		str = item->cargo == INVALID_CARGO ? STR_LTBLUE_STRING : STR_VEHICLE_DETAILS_CARGO_EMPTY;
+	}
+
+	DrawString(left, right, y, str);
+}
+
+/**
+ * Draw the details info tab for the given vehicle at the given position
+ *
+ * @param v     current vehicle
+ * @param left  The left most coordinate to draw
+ * @param right The right most coordinate to draw
+ * @param y     The y coordinate
+ */
+static void TrainDetailsInfoTab(const Vehicle *v, int left, int right, int y)
+{
+	if (RailVehInfo(v->engine_type)->railveh_type == RAILVEH_WAGON) {
+		SetDParam(0, v->engine_type);
+		SetDParam(1, v->value);
+		DrawString(left, right, y, STR_VEHICLE_DETAILS_TRAIN_WAGON_VALUE, TC_FROMSTRING, SA_LEFT | SA_STRIP);
+	} else {
+		SetDParam(0, v->engine_type);
+		SetDParam(1, v->build_year);
+		SetDParam(2, v->value);
+		DrawString(left, right, y, STR_VEHICLE_DETAILS_TRAIN_ENGINE_BUILT_AND_VALUE, TC_FROMSTRING, SA_LEFT | SA_STRIP);
+	}
+}
+
+/**
+ * Draw the details capacity tab for the given vehicle at the given position
+ *
+ * @param item  Data to draw
+ * @param left  The left most coordinate to draw
+ * @param right The right most coordinate to draw
+ * @param y     The y coordinate
+ */
+static void TrainDetailsCapacityTab(const CargoSummaryItem *item, int left, int right, int y)
+{
+	StringID str;
+	if (item->cargo != INVALID_CARGO) {
+		SetDParam(0, item->cargo);
+		SetDParam(1, item->capacity);
+		SetDParam(4, item->subtype);
+		SetDParam(5, _settings_game.vehicle.freight_trains);
+		str = FreightWagonMult(item->cargo) > 1 ? STR_VEHICLE_INFO_CAPACITY_MULT : STR_VEHICLE_INFO_CAPACITY;
+	} else {
+		/* Draw subtype only */
+		SetDParam(0, item->subtype);
+		str = STR_VEHICLE_INFO_NO_CAPACITY;
+	}
+	DrawString(left, right, y, str);
+}
+
+/**
+ * Collects the cargo transported
+ * @param v Vehicle to process
+ * @param summary Space for the result
+ */
+static void GetCargoSummaryOfArticulatedVehicle(const Train *v, CargoSummary *summary)
+{
+	summary->Clear();
+	do {
+		if (!v->GetEngine()->CanCarryCargo()) continue;
+
+		CargoSummaryItem new_item;
+		new_item.cargo = v->cargo_cap > 0 ? v->cargo_type : INVALID_CARGO;
+		new_item.subtype = GetCargoSubtypeText(v);
+		if (new_item.cargo == INVALID_CARGO && new_item.subtype == STR_EMPTY) continue;
+
+		CargoSummaryItem *item = summary->Find(new_item);
+		if (item == summary->End()) {
+			item = summary->Append();
+			item->cargo = new_item.cargo;
+			item->subtype = new_item.subtype;
+			item->capacity = 0;
+			item->amount = 0;
+			item->source = INVALID_STATION;
+		}
+
+		item->capacity += v->cargo_cap;
+		item->amount += v->cargo.StoredCount();
+		if (item->source == INVALID_STATION) item->source = v->cargo.Source();
+	} while ((v = v->Next()) != NULL && v->IsArticulatedPart());
+}
+
+/**
+ * Get the length of an articulated vehicle.
+ * @param v the vehicle to get the length of.
+ * @return the length in pixels.
+ */
+static uint GetLengthOfArticulatedVehicle(const Train *v)
+{
+	uint length = 0;
+
+	do {
+		length += v->GetDisplayImageWidth();
+	} while ((v = v->Next()) != NULL && v->IsArticulatedPart());
+
+	return length;
+}
+
+/**
+ * Determines the number of lines in the train details window
+ * @param veh_id Train
+ * @param det_tab Selected details tab
+ * @return Number of line
+ */
+int GetTrainDetailsWndVScroll(VehicleID veh_id, TrainDetailsWindowTabs det_tab)
+{
+	int num = 0;
+
+	if (det_tab == TDW_TAB_TOTALS) { // Total cargo tab
+		CargoArray act_cargo;
+		CargoArray max_cargo;
+		for (const Vehicle *v = Vehicle::Get(veh_id); v != NULL; v = v->Next()) {
+			act_cargo[v->cargo_type] += v->cargo.StoredCount();
+			max_cargo[v->cargo_type] += v->cargo_cap;
+		}
+
+		/* Set scroll-amount separately from counting, as to not compute num double
+		 * for more carriages of the same type
+		 */
+		for (CargoID i = 0; i < NUM_CARGO; i++) {
+			if (max_cargo[i] > 0) num++; // only count carriages that the train has
+		}
+		num++; // needs one more because first line is description string
+	} else {
+		for (const Train *v = Train::Get(veh_id); v != NULL; v = v->GetNextVehicle()) {
+			GetCargoSummaryOfArticulatedVehicle(v, &_cargo_summary);
+			num += max(1u, _cargo_summary.Length());
+
+			uint length = GetLengthOfArticulatedVehicle(v);
+			if (length > TRAIN_DETAILS_MAX_INDENT) num++;
+		}
+	}
+
+	return num;
+}
+
+/**
+ * Draw the details for the given vehicle at the given position
+ *
+ * @param v     current vehicle
+ * @param left  The left most coordinate to draw
+ * @param right The right most coordinate to draw
+ * @param y     The y coordinate
+ * @param vscroll_pos Position of scrollbar
+ * @param vscroll_cap Number of lines currently displayed
+ * @param det_tab Selected details tab
+ */
+void DrawTrainDetails(const Train *v, int left, int right, int y, int vscroll_pos, uint16 vscroll_cap, TrainDetailsWindowTabs det_tab)
+{
+	/* draw the first 3 details tabs */
+	if (det_tab != TDW_TAB_TOTALS) {
+		bool rtl = _current_text_dir == TD_RTL;
+		Direction dir = rtl ? DIR_E : DIR_W;
+		int x = rtl ? right : left;
+		int sprite_y_offset = 4 + (FONT_HEIGHT_NORMAL - 10) / 2;
+		int line_height = WD_MATRIX_TOP + FONT_HEIGHT_NORMAL + WD_MATRIX_BOTTOM;
+		for (; v != NULL && vscroll_pos > -vscroll_cap; v = v->GetNextVehicle()) {
+			GetCargoSummaryOfArticulatedVehicle(v, &_cargo_summary);
+
+			/* Draw sprites */
+			uint dx = 0;
+			int px = x;
+			const Train *u = v;
+			do {
+				Point offset;
+				int width = u->GetDisplayImageWidth(&offset);
+				if (vscroll_pos <= 0 && vscroll_pos > -vscroll_cap) {
+					PaletteID pal = (v->vehstatus & VS_CRASHED) ? PALETTE_CRASH : GetVehiclePalette(v);
+					DrawSprite(u->GetImage(dir, EIT_IN_DETAILS), pal, px + (rtl ? -offset.x : offset.x), y - line_height * vscroll_pos + sprite_y_offset + offset.y);
+				}
+				px += rtl ? -width : width;
+				dx += width;
+				u = u->Next();
+			} while (u != NULL && u->IsArticulatedPart());
+
+			bool separate_sprite_row = (dx > TRAIN_DETAILS_MAX_INDENT);
+			if (separate_sprite_row) {
+				vscroll_pos--;
+				dx = 0;
+			}
+
+			uint num_lines = max(1u, _cargo_summary.Length());
+			for (uint i = 0; i < num_lines; i++) {
+				int sprite_width = max<int>(dx, TRAIN_DETAILS_MIN_INDENT) + 3;
+				int data_left  = left + (rtl ? 0 : sprite_width);
+				int data_right = right - (rtl ? sprite_width : 0);
+				if (vscroll_pos <= 0 && vscroll_pos > -vscroll_cap) {
+					int py = y - line_height * vscroll_pos;
+					if (i > 0 || separate_sprite_row) {
+						if (vscroll_pos != 0) GfxFillRect(left, py - WD_MATRIX_TOP - 1, right, py - WD_MATRIX_TOP, _colour_gradient[COLOUR_GREY][5]);
+					}
+					switch (det_tab) {
+						case TDW_TAB_CARGO:
+							if (i < _cargo_summary.Length()) {
+								TrainDetailsCargoTab(&_cargo_summary[i], data_left, data_right, py);
+							} else {
+								DrawString(data_left, data_right, py, STR_QUANTITY_N_A, TC_LIGHT_BLUE);
+							}
+							break;
+
+						case TDW_TAB_INFO:
+							if (i == 0) TrainDetailsInfoTab(v, data_left, data_right, py);
+							break;
+
+						case TDW_TAB_CAPACITY:
+							if (i < _cargo_summary.Length()) {
+								TrainDetailsCapacityTab(&_cargo_summary[i], data_left, data_right, py);
+							} else {
+								SetDParam(0, STR_EMPTY);
+								DrawString(data_left, data_right, py, STR_VEHICLE_INFO_NO_CAPACITY);
+							}
+							break;
+
+						default: NOT_REACHED();
+					}
+				}
+				vscroll_pos--;
+			}
+		}
+	} else {
+		CargoArray act_cargo;
+		CargoArray max_cargo;
+		Money feeder_share = 0;
+
+		for (const Vehicle *u = v; u != NULL; u = u->Next()) {
+			act_cargo[u->cargo_type] += u->cargo.StoredCount();
+			max_cargo[u->cargo_type] += u->cargo_cap;
+			feeder_share             += u->cargo.FeederShare();
+		}
+
+		/* draw total cargo tab */
+		DrawString(left, right, y, STR_VEHICLE_DETAILS_TRAIN_TOTAL_CAPACITY_TEXT);
+		y += WD_MATRIX_TOP + FONT_HEIGHT_NORMAL + WD_MATRIX_BOTTOM;
+
+		for (CargoID i = 0; i < NUM_CARGO; i++) {
+			if (max_cargo[i] > 0 && --vscroll_pos < 0 && vscroll_pos > -vscroll_cap) {
+				SetDParam(0, i);            // {CARGO} #1
+				SetDParam(1, act_cargo[i]); // {CARGO} #2
+				SetDParam(2, i);            // {SHORTCARGO} #1
+				SetDParam(3, max_cargo[i]); // {SHORTCARGO} #2
+				SetDParam(4, _settings_game.vehicle.freight_trains);
+				DrawString(left, right, y, FreightWagonMult(i) > 1 ? STR_VEHICLE_DETAILS_TRAIN_TOTAL_CAPACITY_MULT : STR_VEHICLE_DETAILS_TRAIN_TOTAL_CAPACITY);
+				y += WD_MATRIX_TOP + FONT_HEIGHT_NORMAL + WD_MATRIX_BOTTOM;
+			}
+		}
+		SetDParam(0, feeder_share);
+		DrawString(left, right, y, STR_VEHICLE_INFO_FEEDER_CARGO_VALUE);
+	}
+}
diff --git a/src/vehicle.cpp b/src/vehicle.cpp
index edbdd01..5d1c93f 100644
--- a/src/vehicle.cpp
+++ b/src/vehicle.cpp
@@ -53,6 +53,9 @@
 
 #include "table/strings.h"
 
+// MYGUI
+#include "aaa_template_vehicle_func.h"
+
 #define GEN_HASH(x, y) ((GB((y), 6 + ZOOM_LVL_SHIFT, 6) << 6) + GB((x), 7 + ZOOM_LVL_SHIFT, 6))
 
 VehicleID _new_vehicle_id;
@@ -607,6 +610,13 @@ void ResetVehicleColourMap()
 typedef SmallMap<Vehicle *, bool, 4> AutoreplaceMap;
 static AutoreplaceMap _vehicles_to_autoreplace;
 
+/**
+ * List of vehicles that are issued for template replacement this tick.
+ * Mapping is {vehicle : leave depot after replacement}
+ */
+typedef SmallMap<Train *, bool, 4> TemplateReplacementMap;
+static TemplateReplacementMap _vehicles_to_templatereplace;
+
 void InitializeVehicles()
 {
 	_vehicles_to_autoreplace.Reset();
@@ -809,14 +819,25 @@ Vehicle::~Vehicle()
  */
 void VehicleEnteredDepotThisTick(Vehicle *v)
 {
-	/* Vehicle should stop in the depot if it was in 'stopping' state */
-	_vehicles_to_autoreplace[v] = !(v->vehstatus & VS_STOPPED);
+	/* Template Replacement Setup stuff */ // MYGUI
+	bool stayInDepot = v->current_order.GetDepotActionType();
+	TemplateReplacement *tr = GetTemplateReplacementByGroupID(v->group_id);
+	if ( tr ) {
+		if ( stayInDepot )	_vehicles_to_templatereplace[(Train*)v] = true;
+		else				_vehicles_to_templatereplace[(Train*)v] = false;
+	}
+	/* Moved the assignment for auto replacement here to prevent auto replacement
+	 * from happening if template replacement is also scheduled */
+	else
+		/* Vehicle should stop in the depot if it was in 'stopping' state */
+		_vehicles_to_autoreplace[v] = !(v->vehstatus & VS_STOPPED);
 
 	/* We ALWAYS set the stopped state. Even when the vehicle does not plan on
 	 * stopping in the depot, so we stop it to ensure that it will not reserve
 	 * the path out of the depot before we might autoreplace it to a different
 	 * engine. The new engine would not own the reserved path we store that we
 	 * stopped the vehicle, so autoreplace can start it again */
+
 	v->vehstatus |= VS_STOPPED;
 }
 
@@ -857,6 +878,7 @@ static void RunVehicleDayProc()
 void CallVehicleTicks()
 {
 	_vehicles_to_autoreplace.Clear();
+	_vehicles_to_templatereplace.Clear();
 
 	RunVehicleDayProc();
 
@@ -901,6 +923,7 @@ void CallVehicleTicks()
 		}
 	}
 
+	/* do Auto Replacement */
 	Backup<CompanyByte> cur_company(_current_company, FILE_LINE);
 	for (AutoreplaceMap::iterator it = _vehicles_to_autoreplace.Begin(); it != _vehicles_to_autoreplace.End(); it++) {
 		v = it->first;
@@ -945,8 +968,28 @@ void CallVehicleTicks()
 		SetDParam(1, error_message);
 		AddVehicleAdviceNewsItem(message, v->index);
 	}
-
 	cur_company.Restore();
+
+	/* do Template Replacement */
+	Backup<CompanyByte> tmpl_cur_company(_current_company, FILE_LINE);
+	for (TemplateReplacementMap::iterator it = _vehicles_to_templatereplace.Begin(); it != _vehicles_to_templatereplace.End(); it++) {
+
+		Train *t = it->first;
+
+		tmpl_cur_company.Change(t->owner);
+
+		bool stayInDepot = it->second;
+
+		it->first->vehstatus |= VS_STOPPED;
+		REPLACEMENT_IN_PROGRESS = true;
+
+		CmdTemplateReplaceVehicle(t, stayInDepot, DC_EXEC);
+		/* Redraw main gui for changed statistics */
+		SetWindowClassesDirty(WC_TEMPLATEGUI_MAIN);
+
+		REPLACEMENT_IN_PROGRESS = false;
+	}
+	tmpl_cur_company.Restore();
 }
 
 /**
@@ -2234,8 +2277,6 @@ void Vehicle::ShowVisualEffect() const
 			this->cur_speed < 2) {
 		return;
 	}
-
-	uint max_speed = this->vcache.cached_max_speed;
 	if (this->type == VEH_TRAIN) {
 		const Train *t = Train::From(this);
 		/* For trains, do not show any smoke when:
@@ -2247,11 +2288,7 @@ void Vehicle::ShowVisualEffect() const
 				t->cur_speed >= t->Train::GetCurrentMaxSpeed())) {
 			return;
 		}
-
-		max_speed = min(max_speed, t->gcache.cached_max_track_speed);
-		max_speed = min(max_speed, this->current_order.max_speed);
 	}
-	if (this->type == VEH_ROAD || this->type == VEH_SHIP) max_speed = min(max_speed, this->current_order.max_speed * 2);
 
 	const Vehicle *v = this;
 
@@ -2297,7 +2334,7 @@ void Vehicle::ShowVisualEffect() const
 				 * third of its maximum speed spectrum. Steam emission finally normalises at very close to vehicle's maximum speed.
 				 * REGULATION:
 				 * - instead of 1, 4 / 2^smoke_amount (max. 2) is used to provide sufficient regulation to steam puffs' amount. */
-				if (GB(v->tick_counter, 0, ((4 >> _settings_game.vehicle.smoke_amount) + ((this->cur_speed * 3) / max_speed))) == 0) {
+				if (GB(v->tick_counter, 0, ((4 >> _settings_game.vehicle.smoke_amount) + ((this->cur_speed * 3) / this->vcache.cached_max_speed))) == 0) {
 					CreateEffectVehicleRel(v, x, y, 10, EV_STEAM_SMOKE);
 					sound = true;
 				}
@@ -2319,8 +2356,8 @@ void Vehicle::ShowVisualEffect() const
 				if (v->type == VEH_TRAIN) {
 					power_weight_effect = (32 >> (Train::From(this)->gcache.cached_power >> 10)) - (32 >> (Train::From(this)->gcache.cached_weight >> 9));
 				}
-				if (this->cur_speed < (max_speed >> (2 >> _settings_game.vehicle.smoke_amount)) &&
-						Chance16((64 - ((this->cur_speed << 5) / max_speed) + power_weight_effect), (512 >> _settings_game.vehicle.smoke_amount))) {
+				if (this->cur_speed < (this->vcache.cached_max_speed >> (2 >> _settings_game.vehicle.smoke_amount)) &&
+						Chance16((64 - ((this->cur_speed << 5) / this->vcache.cached_max_speed) + power_weight_effect), (512 >> _settings_game.vehicle.smoke_amount))) {
 					CreateEffectVehicleRel(v, x, y, 10, EV_DIESEL_SMOKE);
 					sound = true;
 				}
@@ -2335,7 +2372,7 @@ void Vehicle::ShowVisualEffect() const
 				 * REGULATION:
 				 * - in Chance16 the last value is 360 / 2^smoke_amount (max. sparks when 90 = smoke_amount of 2). */
 				if (GB(v->tick_counter, 0, 2) == 0 &&
-						Chance16((6 - ((this->cur_speed << 2) / max_speed)), (360 >> _settings_game.vehicle.smoke_amount))) {
+						Chance16((6 - ((this->cur_speed << 2) / this->vcache.cached_max_speed)), (360 >> _settings_game.vehicle.smoke_amount))) {
 					CreateEffectVehicleRel(v, x, y, 10, EV_ELECTRIC_SPARK);
 					sound = true;
 				}
diff --git a/src/vehicle.cpp.orig b/src/vehicle.cpp.orig
new file mode 100644
index 0000000..edbdd01
--- /dev/null
+++ b/src/vehicle.cpp.orig
@@ -0,0 +1,2605 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file vehicle.cpp Base implementations of all vehicles. */
+
+#include "stdafx.h"
+#include "error.h"
+#include "roadveh.h"
+#include "ship.h"
+#include "spritecache.h"
+#include "timetable.h"
+#include "viewport_func.h"
+#include "news_func.h"
+#include "command_func.h"
+#include "company_func.h"
+#include "train.h"
+#include "aircraft.h"
+#include "newgrf_debug.h"
+#include "newgrf_sound.h"
+#include "newgrf_station.h"
+#include "group_gui.h"
+#include "strings_func.h"
+#include "zoom_func.h"
+#include "date_func.h"
+#include "vehicle_func.h"
+#include "autoreplace_func.h"
+#include "autoreplace_gui.h"
+#include "station_base.h"
+#include "ai/ai.hpp"
+#include "depot_func.h"
+#include "network/network.h"
+#include "core/pool_func.hpp"
+#include "economy_base.h"
+#include "articulated_vehicles.h"
+#include "roadstop_base.h"
+#include "core/random_func.hpp"
+#include "core/backup_type.hpp"
+#include "order_backup.h"
+#include "sound_func.h"
+#include "effectvehicle_func.h"
+#include "effectvehicle_base.h"
+#include "vehiclelist.h"
+#include "bridge_map.h"
+#include "tunnel_map.h"
+#include "depot_map.h"
+#include "gamelog.h"
+
+#include "table/strings.h"
+
+#define GEN_HASH(x, y) ((GB((y), 6 + ZOOM_LVL_SHIFT, 6) << 6) + GB((x), 7 + ZOOM_LVL_SHIFT, 6))
+
+VehicleID _new_vehicle_id;
+uint16 _returned_refit_capacity;      ///< Stores the capacity after a refit operation.
+uint16 _returned_mail_refit_capacity; ///< Stores the mail capacity after a refit operation (Aircraft only).
+
+
+/** The pool with all our precious vehicles. */
+VehiclePool _vehicle_pool("Vehicle");
+INSTANTIATE_POOL_METHODS(Vehicle)
+
+/**
+ * Function to tell if a vehicle needs to be autorenewed
+ * @param *c The vehicle owner
+ * @param use_renew_setting Should the company renew setting be considered?
+ * @return true if the vehicle is old enough for replacement
+ */
+bool Vehicle::NeedsAutorenewing(const Company *c, bool use_renew_setting) const
+{
+	/* We can always generate the Company pointer when we have the vehicle.
+	 * However this takes time and since the Company pointer is often present
+	 * when this function is called then it's faster to pass the pointer as an
+	 * argument rather than finding it again. */
+	assert(c == Company::Get(this->owner));
+
+	if (use_renew_setting && !c->settings.engine_renew) return false;
+	if (this->age - this->max_age < (c->settings.engine_renew_months * 30)) return false;
+
+	/* Only engines need renewing */
+	if (this->type == VEH_TRAIN && !Train::From(this)->IsEngine()) return false;
+
+	return true;
+}
+
+void VehicleServiceInDepot(Vehicle *v)
+{
+	v->date_of_last_service = _date;
+	v->breakdowns_since_last_service = 0;
+	v->reliability = v->GetEngine()->reliability;
+	/* Prevent vehicles from breaking down directly after exiting the depot. */
+	v->breakdown_chance /= 4;
+	SetWindowDirty(WC_VEHICLE_DETAILS, v->index); // ensure that last service date and reliability are updated
+}
+
+/**
+ * Check if the vehicle needs to go to a depot in near future (if a opportunity presents itself) for service or replacement.
+ *
+ * @see NeedsAutomaticServicing()
+ * @return true if the vehicle should go to a depot if a opportunity presents itself.
+ */
+bool Vehicle::NeedsServicing() const
+{
+	/* Stopped or crashed vehicles will not move, as such making unmovable
+	 * vehicles to go for service is lame. */
+	if (this->vehstatus & (VS_STOPPED | VS_CRASHED)) return false;
+
+	/* Are we ready for the next service cycle? */
+	const Company *c = Company::Get(this->owner);
+	if (this->ServiceIntervalIsPercent() ?
+			(this->reliability >= this->GetEngine()->reliability * (100 - this->GetServiceInterval()) / 100) :
+			(this->date_of_last_service + this->GetServiceInterval() >= _date)) {
+		return false;
+	}
+
+	/* If we're servicing anyway, because we have not disabled servicing when
+	 * there are no breakdowns or we are playing with breakdowns, bail out. */
+	if (!_settings_game.order.no_servicing_if_no_breakdowns ||
+			_settings_game.difficulty.vehicle_breakdowns != 0) {
+		return true;
+	}
+
+	/* Test whether there is some pending autoreplace.
+	 * Note: We do this after the service-interval test.
+	 * There are a lot more reasons for autoreplace to fail than we can test here reasonably. */
+	bool pending_replace = false;
+	Money needed_money = c->settings.engine_renew_money;
+	if (needed_money > c->money) return false;
+
+	for (const Vehicle *v = this; v != NULL; v = (v->type == VEH_TRAIN) ? Train::From(v)->GetNextUnit() : NULL) {
+		bool replace_when_old = false;
+		EngineID new_engine = EngineReplacementForCompany(c, v->engine_type, v->group_id, &replace_when_old);
+
+		/* Check engine availability */
+		if (new_engine == INVALID_ENGINE || !HasBit(Engine::Get(new_engine)->company_avail, v->owner)) continue;
+		/* Is the vehicle old if we are not always replacing? */
+		if (replace_when_old && !v->NeedsAutorenewing(c, false)) continue;
+
+		/* Check refittability */
+		uint32 available_cargo_types, union_mask;
+		GetArticulatedRefitMasks(new_engine, true, &union_mask, &available_cargo_types);
+		/* Is there anything to refit? */
+		if (union_mask != 0) {
+			CargoID cargo_type;
+			/* We cannot refit to mixed cargoes in an automated way */
+			if (IsArticulatedVehicleCarryingDifferentCargoes(v, &cargo_type)) continue;
+
+			/* Did the old vehicle carry anything? */
+			if (cargo_type != CT_INVALID) {
+				/* We can't refit the vehicle to carry the cargo we want */
+				if (!HasBit(available_cargo_types, cargo_type)) continue;
+			}
+		}
+
+		/* Check money.
+		 * We want 2*(the price of the new vehicle) without looking at the value of the vehicle we are going to sell. */
+		pending_replace = true;
+		needed_money += 2 * Engine::Get(new_engine)->GetCost();
+		if (needed_money > c->money) return false;
+	}
+
+	return pending_replace;
+}
+
+/**
+ * Checks if the current order should be interrupted for a service-in-depot order.
+ * @see NeedsServicing()
+ * @return true if the current order should be interrupted.
+ */
+bool Vehicle::NeedsAutomaticServicing() const
+{
+	if (this->HasDepotOrder()) return false;
+	if (this->current_order.IsType(OT_LOADING)) return false;
+	if (this->current_order.IsType(OT_GOTO_DEPOT) && this->current_order.GetDepotOrderType() != ODTFB_SERVICE) return false;
+	return NeedsServicing();
+}
+
+uint Vehicle::Crash(bool flooded)
+{
+	assert((this->vehstatus & VS_CRASHED) == 0);
+	assert(this->Previous() == NULL); // IsPrimaryVehicle fails for free-wagon-chains
+
+	uint pass = 0;
+	/* Stop the vehicle. */
+	if (this->IsPrimaryVehicle()) this->vehstatus |= VS_STOPPED;
+	/* crash all wagons, and count passengers */
+	for (Vehicle *v = this; v != NULL; v = v->Next()) {
+		/* We do not transfer reserver cargo back, so TotalCount() instead of StoredCount() */
+		if (IsCargoInClass(v->cargo_type, CC_PASSENGERS)) pass += v->cargo.TotalCount();
+		v->vehstatus |= VS_CRASHED;
+		MarkSingleVehicleDirty(v);
+	}
+
+	/* Dirty some windows */
+	InvalidateWindowClassesData(GetWindowClassForVehicleType(this->type), 0);
+	SetWindowWidgetDirty(WC_VEHICLE_VIEW, this->index, WID_VV_START_STOP);
+	SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
+	SetWindowDirty(WC_VEHICLE_DEPOT, this->tile);
+
+	delete this->cargo_payment;
+	this->cargo_payment = NULL;
+
+	return RandomRange(pass + 1); // Randomise deceased passengers.
+}
+
+
+/**
+ * Displays a "NewGrf Bug" error message for a engine, and pauses the game if not networking.
+ * @param engine The engine that caused the problem
+ * @param part1  Part 1 of the error message, taking the grfname as parameter 1
+ * @param part2  Part 2 of the error message, taking the engine as parameter 2
+ * @param bug_type Flag to check and set in grfconfig
+ * @param critical Shall the "OpenTTD might crash"-message be shown when the player tries to unpause?
+ */
+void ShowNewGrfVehicleError(EngineID engine, StringID part1, StringID part2, GRFBugs bug_type, bool critical)
+{
+	const Engine *e = Engine::Get(engine);
+	GRFConfig *grfconfig = GetGRFConfig(e->GetGRFID());
+
+	if (!HasBit(grfconfig->grf_bugs, bug_type)) {
+		SetBit(grfconfig->grf_bugs, bug_type);
+		SetDParamStr(0, grfconfig->GetName());
+		SetDParam(1, engine);
+		ShowErrorMessage(part1, part2, WL_CRITICAL);
+		if (!_networking) DoCommand(0, critical ? PM_PAUSED_ERROR : PM_PAUSED_NORMAL, 1, DC_EXEC, CMD_PAUSE);
+	}
+
+	/* debug output */
+	char buffer[512];
+
+	SetDParamStr(0, grfconfig->GetName());
+	GetString(buffer, part1, lastof(buffer));
+	DEBUG(grf, 0, "%s", buffer + 3);
+
+	SetDParam(1, engine);
+	GetString(buffer, part2, lastof(buffer));
+	DEBUG(grf, 0, "%s", buffer + 3);
+}
+
+/**
+ * Logs a bug in GRF and shows a warning message if this
+ * is for the first time this happened.
+ * @param u first vehicle of chain
+ */
+void VehicleLengthChanged(const Vehicle *u)
+{
+	/* show a warning once for each engine in whole game and once for each GRF after each game load */
+	const Engine *engine = u->GetEngine();
+	uint32 grfid = engine->grf_prop.grffile->grfid;
+	GRFConfig *grfconfig = GetGRFConfig(grfid);
+	if (GamelogGRFBugReverse(grfid, engine->grf_prop.local_id) || !HasBit(grfconfig->grf_bugs, GBUG_VEH_LENGTH)) {
+		ShowNewGrfVehicleError(u->engine_type, STR_NEWGRF_BROKEN, STR_NEWGRF_BROKEN_VEHICLE_LENGTH, GBUG_VEH_LENGTH, true);
+	}
+}
+
+/**
+ * Vehicle constructor.
+ * @param type Type of the new vehicle.
+ */
+Vehicle::Vehicle(VehicleType type)
+{
+	this->type               = type;
+	this->coord.left         = INVALID_COORD;
+	this->group_id           = DEFAULT_GROUP;
+	this->fill_percent_te_id = INVALID_TE_ID;
+	this->first              = this;
+	this->colourmap          = PAL_NONE;
+	this->cargo_age_counter  = 1;
+}
+
+/**
+ * Get a value for a vehicle's random_bits.
+ * @return A random value from 0 to 255.
+ */
+byte VehicleRandomBits()
+{
+	return GB(Random(), 0, 8);
+}
+
+/* Size of the hash, 6 = 64 x 64, 7 = 128 x 128. Larger sizes will (in theory) reduce hash
+ * lookup times at the expense of memory usage. */
+const int HASH_BITS = 7;
+const int HASH_SIZE = 1 << HASH_BITS;
+const int HASH_MASK = HASH_SIZE - 1;
+const int TOTAL_HASH_SIZE = 1 << (HASH_BITS * 2);
+const int TOTAL_HASH_MASK = TOTAL_HASH_SIZE - 1;
+
+/* Resolution of the hash, 0 = 1*1 tile, 1 = 2*2 tiles, 2 = 4*4 tiles, etc.
+ * Profiling results show that 0 is fastest. */
+const int HASH_RES = 0;
+
+static Vehicle *_vehicle_tile_hash[TOTAL_HASH_SIZE];
+
+static Vehicle *VehicleFromTileHash(int xl, int yl, int xu, int yu, void *data, VehicleFromPosProc *proc, bool find_first)
+{
+	for (int y = yl; ; y = (y + (1 << HASH_BITS)) & (HASH_MASK << HASH_BITS)) {
+		for (int x = xl; ; x = (x + 1) & HASH_MASK) {
+			Vehicle *v = _vehicle_tile_hash[(x + y) & TOTAL_HASH_MASK];
+			for (; v != NULL; v = v->hash_tile_next) {
+				Vehicle *a = proc(v, data);
+				if (find_first && a != NULL) return a;
+			}
+			if (x == xu) break;
+		}
+		if (y == yu) break;
+	}
+
+	return NULL;
+}
+
+
+/**
+ * Helper function for FindVehicleOnPos/HasVehicleOnPos.
+ * @note Do not call this function directly!
+ * @param x    The X location on the map
+ * @param y    The Y location on the map
+ * @param data Arbitrary data passed to proc
+ * @param proc The proc that determines whether a vehicle will be "found".
+ * @param find_first Whether to return on the first found or iterate over
+ *                   all vehicles
+ * @return the best matching or first vehicle (depending on find_first).
+ */
+static Vehicle *VehicleFromPosXY(int x, int y, void *data, VehicleFromPosProc *proc, bool find_first)
+{
+	const int COLL_DIST = 6;
+
+	/* Hash area to scan is from xl,yl to xu,yu */
+	int xl = GB((x - COLL_DIST) / TILE_SIZE, HASH_RES, HASH_BITS);
+	int xu = GB((x + COLL_DIST) / TILE_SIZE, HASH_RES, HASH_BITS);
+	int yl = GB((y - COLL_DIST) / TILE_SIZE, HASH_RES, HASH_BITS) << HASH_BITS;
+	int yu = GB((y + COLL_DIST) / TILE_SIZE, HASH_RES, HASH_BITS) << HASH_BITS;
+
+	return VehicleFromTileHash(xl, yl, xu, yu, data, proc, find_first);
+}
+
+/**
+ * Find a vehicle from a specific location. It will call proc for ALL vehicles
+ * on the tile and YOU must make SURE that the "best one" is stored in the
+ * data value and is ALWAYS the same regardless of the order of the vehicles
+ * where proc was called on!
+ * When you fail to do this properly you create an almost untraceable DESYNC!
+ * @note The return value of proc will be ignored.
+ * @note Use this when you have the intention that all vehicles
+ *       should be iterated over.
+ * @param x    The X location on the map
+ * @param y    The Y location on the map
+ * @param data Arbitrary data passed to proc
+ * @param proc The proc that determines whether a vehicle will be "found".
+ */
+void FindVehicleOnPosXY(int x, int y, void *data, VehicleFromPosProc *proc)
+{
+	VehicleFromPosXY(x, y, data, proc, false);
+}
+
+/**
+ * Checks whether a vehicle in on a specific location. It will call proc for
+ * vehicles until it returns non-NULL.
+ * @note Use FindVehicleOnPosXY when you have the intention that all vehicles
+ *       should be iterated over.
+ * @param x    The X location on the map
+ * @param y    The Y location on the map
+ * @param data Arbitrary data passed to proc
+ * @param proc The proc that determines whether a vehicle will be "found".
+ * @return True if proc returned non-NULL.
+ */
+bool HasVehicleOnPosXY(int x, int y, void *data, VehicleFromPosProc *proc)
+{
+	return VehicleFromPosXY(x, y, data, proc, true) != NULL;
+}
+
+/**
+ * Helper function for FindVehicleOnPos/HasVehicleOnPos.
+ * @note Do not call this function directly!
+ * @param tile The location on the map
+ * @param data Arbitrary data passed to \a proc.
+ * @param proc The proc that determines whether a vehicle will be "found".
+ * @param find_first Whether to return on the first found or iterate over
+ *                   all vehicles
+ * @return the best matching or first vehicle (depending on find_first).
+ */
+static Vehicle *VehicleFromPos(TileIndex tile, void *data, VehicleFromPosProc *proc, bool find_first)
+{
+	int x = GB(TileX(tile), HASH_RES, HASH_BITS);
+	int y = GB(TileY(tile), HASH_RES, HASH_BITS) << HASH_BITS;
+
+	Vehicle *v = _vehicle_tile_hash[(x + y) & TOTAL_HASH_MASK];
+	for (; v != NULL; v = v->hash_tile_next) {
+		if (v->tile != tile) continue;
+
+		Vehicle *a = proc(v, data);
+		if (find_first && a != NULL) return a;
+	}
+
+	return NULL;
+}
+
+/**
+ * Find a vehicle from a specific location. It will call \a proc for ALL vehicles
+ * on the tile and YOU must make SURE that the "best one" is stored in the
+ * data value and is ALWAYS the same regardless of the order of the vehicles
+ * where proc was called on!
+ * When you fail to do this properly you create an almost untraceable DESYNC!
+ * @note The return value of \a proc will be ignored.
+ * @note Use this function when you have the intention that all vehicles
+ *       should be iterated over.
+ * @param tile The location on the map
+ * @param data Arbitrary data passed to \a proc.
+ * @param proc The proc that determines whether a vehicle will be "found".
+ */
+void FindVehicleOnPos(TileIndex tile, void *data, VehicleFromPosProc *proc)
+{
+	VehicleFromPos(tile, data, proc, false);
+}
+
+/**
+ * Checks whether a vehicle is on a specific location. It will call \a proc for
+ * vehicles until it returns non-NULL.
+ * @note Use #FindVehicleOnPos when you have the intention that all vehicles
+ *       should be iterated over.
+ * @param tile The location on the map
+ * @param data Arbitrary data passed to \a proc.
+ * @param proc The \a proc that determines whether a vehicle will be "found".
+ * @return True if proc returned non-NULL.
+ */
+bool HasVehicleOnPos(TileIndex tile, void *data, VehicleFromPosProc *proc)
+{
+	return VehicleFromPos(tile, data, proc, true) != NULL;
+}
+
+/**
+ * Callback that returns 'real' vehicles lower or at height \c *(int*)data .
+ * @param v Vehicle to examine.
+ * @param data Pointer to height data.
+ * @return \a v if conditions are met, else \c NULL.
+ */
+static Vehicle *EnsureNoVehicleProcZ(Vehicle *v, void *data)
+{
+	int z = *(int*)data;
+
+	if (v->type == VEH_DISASTER || (v->type == VEH_AIRCRAFT && v->subtype == AIR_SHADOW)) return NULL;
+	if (v->z_pos > z) return NULL;
+
+	return v;
+}
+
+/**
+ * Ensure there is no vehicle at the ground at the given position.
+ * @param tile Position to examine.
+ * @return Succeeded command (ground is free) or failed command (a vehicle is found).
+ */
+CommandCost EnsureNoVehicleOnGround(TileIndex tile)
+{
+	int z = GetTileMaxPixelZ(tile);
+
+	/* Value v is not safe in MP games, however, it is used to generate a local
+	 * error message only (which may be different for different machines).
+	 * Such a message does not affect MP synchronisation.
+	 */
+	Vehicle *v = VehicleFromPos(tile, &z, &EnsureNoVehicleProcZ, true);
+	if (v != NULL) return_cmd_error(STR_ERROR_TRAIN_IN_THE_WAY + v->type);
+	return CommandCost();
+}
+
+/** Procedure called for every vehicle found in tunnel/bridge in the hash map */
+static Vehicle *GetVehicleTunnelBridgeProc(Vehicle *v, void *data)
+{
+	if (v->type != VEH_TRAIN && v->type != VEH_ROAD && v->type != VEH_SHIP) return NULL;
+	if (v == (const Vehicle *)data) return NULL;
+
+	return v;
+}
+
+/**
+ * Finds vehicle in tunnel / bridge
+ * @param tile first end
+ * @param endtile second end
+ * @param ignore Ignore this vehicle when searching
+ * @return Succeeded command (if tunnel/bridge is free) or failed command (if a vehicle is using the tunnel/bridge).
+ */
+CommandCost TunnelBridgeIsFree(TileIndex tile, TileIndex endtile, const Vehicle *ignore)
+{
+	/* Value v is not safe in MP games, however, it is used to generate a local
+	 * error message only (which may be different for different machines).
+	 * Such a message does not affect MP synchronisation.
+	 */
+	Vehicle *v = VehicleFromPos(tile, const_cast<Vehicle *>(ignore), &GetVehicleTunnelBridgeProc, true);
+	if (v == NULL) v = VehicleFromPos(endtile, const_cast<Vehicle *>(ignore), &GetVehicleTunnelBridgeProc, true);
+
+	if (v != NULL) return_cmd_error(STR_ERROR_TRAIN_IN_THE_WAY + v->type);
+	return CommandCost();
+}
+
+static Vehicle *EnsureNoTrainOnTrackProc(Vehicle *v, void *data)
+{
+	TrackBits rail_bits = *(TrackBits *)data;
+
+	if (v->type != VEH_TRAIN) return NULL;
+
+	Train *t = Train::From(v);
+	if ((t->track != rail_bits) && !TracksOverlap(t->track | rail_bits)) return NULL;
+
+	return v;
+}
+
+/**
+ * Tests if a vehicle interacts with the specified track bits.
+ * All track bits interact except parallel #TRACK_BIT_HORZ or #TRACK_BIT_VERT.
+ *
+ * @param tile The tile.
+ * @param track_bits The track bits.
+ * @return \c true if no train that interacts, is found. \c false if a train is found.
+ */
+CommandCost EnsureNoTrainOnTrackBits(TileIndex tile, TrackBits track_bits)
+{
+	/* Value v is not safe in MP games, however, it is used to generate a local
+	 * error message only (which may be different for different machines).
+	 * Such a message does not affect MP synchronisation.
+	 */
+	Vehicle *v = VehicleFromPos(tile, &track_bits, &EnsureNoTrainOnTrackProc, true);
+	if (v != NULL) return_cmd_error(STR_ERROR_TRAIN_IN_THE_WAY + v->type);
+	return CommandCost();
+}
+
+static void UpdateVehicleTileHash(Vehicle *v, bool remove)
+{
+	Vehicle **old_hash = v->hash_tile_current;
+	Vehicle **new_hash;
+
+	if (remove) {
+		new_hash = NULL;
+	} else {
+		int x = GB(TileX(v->tile), HASH_RES, HASH_BITS);
+		int y = GB(TileY(v->tile), HASH_RES, HASH_BITS) << HASH_BITS;
+		new_hash = &_vehicle_tile_hash[(x + y) & TOTAL_HASH_MASK];
+	}
+
+	if (old_hash == new_hash) return;
+
+	/* Remove from the old position in the hash table */
+	if (old_hash != NULL) {
+		if (v->hash_tile_next != NULL) v->hash_tile_next->hash_tile_prev = v->hash_tile_prev;
+		*v->hash_tile_prev = v->hash_tile_next;
+	}
+
+	/* Insert vehicle at beginning of the new position in the hash table */
+	if (new_hash != NULL) {
+		v->hash_tile_next = *new_hash;
+		if (v->hash_tile_next != NULL) v->hash_tile_next->hash_tile_prev = &v->hash_tile_next;
+		v->hash_tile_prev = new_hash;
+		*new_hash = v;
+	}
+
+	/* Remember current hash position */
+	v->hash_tile_current = new_hash;
+}
+
+static Vehicle *_vehicle_viewport_hash[0x1000];
+
+static void UpdateVehicleViewportHash(Vehicle *v, int x, int y)
+{
+	Vehicle **old_hash, **new_hash;
+	int old_x = v->coord.left;
+	int old_y = v->coord.top;
+
+	new_hash = (x == INVALID_COORD) ? NULL : &_vehicle_viewport_hash[GEN_HASH(x, y)];
+	old_hash = (old_x == INVALID_COORD) ? NULL : &_vehicle_viewport_hash[GEN_HASH(old_x, old_y)];
+
+	if (old_hash == new_hash) return;
+
+	/* remove from hash table? */
+	if (old_hash != NULL) {
+		if (v->hash_viewport_next != NULL) v->hash_viewport_next->hash_viewport_prev = v->hash_viewport_prev;
+		*v->hash_viewport_prev = v->hash_viewport_next;
+	}
+
+	/* insert into hash table? */
+	if (new_hash != NULL) {
+		v->hash_viewport_next = *new_hash;
+		if (v->hash_viewport_next != NULL) v->hash_viewport_next->hash_viewport_prev = &v->hash_viewport_next;
+		v->hash_viewport_prev = new_hash;
+		*new_hash = v;
+	}
+}
+
+void ResetVehicleHash()
+{
+	Vehicle *v;
+	FOR_ALL_VEHICLES(v) { v->hash_tile_current = NULL; }
+	memset(_vehicle_viewport_hash, 0, sizeof(_vehicle_viewport_hash));
+	memset(_vehicle_tile_hash, 0, sizeof(_vehicle_tile_hash));
+}
+
+void ResetVehicleColourMap()
+{
+	Vehicle *v;
+	FOR_ALL_VEHICLES(v) { v->colourmap = PAL_NONE; }
+}
+
+/**
+ * List of vehicles that should check for autoreplace this tick.
+ * Mapping of vehicle -> leave depot immediately after autoreplace.
+ */
+typedef SmallMap<Vehicle *, bool, 4> AutoreplaceMap;
+static AutoreplaceMap _vehicles_to_autoreplace;
+
+void InitializeVehicles()
+{
+	_vehicles_to_autoreplace.Reset();
+	ResetVehicleHash();
+}
+
+uint CountVehiclesInChain(const Vehicle *v)
+{
+	uint count = 0;
+	do count++; while ((v = v->Next()) != NULL);
+	return count;
+}
+
+/**
+ * Check if a vehicle is counted in num_engines in each company struct
+ * @return true if the vehicle is counted in num_engines
+ */
+bool Vehicle::IsEngineCountable() const
+{
+	switch (this->type) {
+		case VEH_AIRCRAFT: return Aircraft::From(this)->IsNormalAircraft(); // don't count plane shadows and helicopter rotors
+		case VEH_TRAIN:
+			return !this->IsArticulatedPart() && // tenders and other articulated parts
+					!Train::From(this)->IsRearDualheaded(); // rear parts of multiheaded engines
+		case VEH_ROAD: return RoadVehicle::From(this)->IsFrontEngine();
+		case VEH_SHIP: return true;
+		default: return false; // Only count company buildable vehicles
+	}
+}
+
+/**
+ * Check whether Vehicle::engine_type has any meaning.
+ * @return true if the vehicle has a useable engine type.
+ */
+bool Vehicle::HasEngineType() const
+{
+	switch (this->type) {
+		case VEH_AIRCRAFT: return Aircraft::From(this)->IsNormalAircraft();
+		case VEH_TRAIN:
+		case VEH_ROAD:
+		case VEH_SHIP: return true;
+		default: return false;
+	}
+}
+
+/**
+ * Retrieves the engine of the vehicle.
+ * @return Engine of the vehicle.
+ * @pre HasEngineType() == true
+ */
+const Engine *Vehicle::GetEngine() const
+{
+	return Engine::Get(this->engine_type);
+}
+
+/**
+ * Retrieve the NewGRF the vehicle is tied to.
+ * This is the GRF providing the Action 3 for the engine type.
+ * @return NewGRF associated to the vehicle.
+ */
+const GRFFile *Vehicle::GetGRF() const
+{
+	return this->GetEngine()->GetGRF();
+}
+
+/**
+ * Retrieve the GRF ID of the NewGRF the vehicle is tied to.
+ * This is the GRF providing the Action 3 for the engine type.
+ * @return GRF ID of the associated NewGRF.
+ */
+uint32 Vehicle::GetGRFID() const
+{
+	return this->GetEngine()->GetGRFID();
+}
+
+/**
+ * Handle the pathfinding result, especially the lost status.
+ * If the vehicle is now lost and wasn't previously fire an
+ * event to the AIs and a news message to the user. If the
+ * vehicle is not lost anymore remove the news message.
+ * @param path_found Whether the vehicle has a path to its destination.
+ */
+void Vehicle::HandlePathfindingResult(bool path_found)
+{
+	if (path_found) {
+		/* Route found, is the vehicle marked with "lost" flag? */
+		if (!HasBit(this->vehicle_flags, VF_PATHFINDER_LOST)) return;
+
+		/* Clear the flag as the PF's problem was solved. */
+		ClrBit(this->vehicle_flags, VF_PATHFINDER_LOST);
+		/* Delete the news item. */
+		DeleteVehicleNews(this->index, STR_NEWS_VEHICLE_IS_LOST);
+		return;
+	}
+
+	/* Were we already lost? */
+	if (HasBit(this->vehicle_flags, VF_PATHFINDER_LOST)) return;
+
+	/* It is first time the problem occurred, set the "lost" flag. */
+	SetBit(this->vehicle_flags, VF_PATHFINDER_LOST);
+	/* Notify user about the event. */
+	AI::NewEvent(this->owner, new ScriptEventVehicleLost(this->index));
+	if (_settings_client.gui.lost_vehicle_warn && this->owner == _local_company) {
+		SetDParam(0, this->index);
+		AddVehicleAdviceNewsItem(STR_NEWS_VEHICLE_IS_LOST, this->index);
+	}
+}
+
+/** Destroy all stuff that (still) needs the virtual functions to work properly */
+void Vehicle::PreDestructor()
+{
+	if (CleaningPool()) return;
+
+	if (Station::IsValidID(this->last_station_visited)) {
+		Station *st = Station::Get(this->last_station_visited);
+		st->loading_vehicles.remove(this);
+
+		HideFillingPercent(&this->fill_percent_te_id);
+		this->CancelReservation(st);
+		delete this->cargo_payment;
+	}
+
+	if (this->IsEngineCountable()) {
+		GroupStatistics::CountEngine(this, -1);
+		if (this->IsPrimaryVehicle()) GroupStatistics::CountVehicle(this, -1);
+		GroupStatistics::UpdateAutoreplace(this->owner);
+
+		if (this->owner == _local_company) InvalidateAutoreplaceWindow(this->engine_type, this->group_id);
+		DeleteGroupHighlightOfVehicle(this);
+	}
+
+	if (this->type == VEH_AIRCRAFT && this->IsPrimaryVehicle()) {
+		Aircraft *a = Aircraft::From(this);
+		Station *st = GetTargetAirportIfValid(a);
+		if (st != NULL) {
+			const AirportFTA *layout = st->airport.GetFTA()->layout;
+			CLRBITS(st->airport.flags, layout[a->previous_pos].block | layout[a->pos].block);
+		}
+	}
+
+
+	if (this->type == VEH_ROAD && this->IsPrimaryVehicle()) {
+		RoadVehicle *v = RoadVehicle::From(this);
+		if (!(v->vehstatus & VS_CRASHED) && IsInsideMM(v->state, RVSB_IN_DT_ROAD_STOP, RVSB_IN_DT_ROAD_STOP_END)) {
+			/* Leave the drive through roadstop, when you have not already left it. */
+			RoadStop::GetByTile(v->tile, GetRoadStopType(v->tile))->Leave(v);
+		}
+	}
+
+	if (this->Previous() == NULL) {
+		InvalidateWindowData(WC_VEHICLE_DEPOT, this->tile);
+	}
+
+	if (this->IsPrimaryVehicle()) {
+		DeleteWindowById(WC_VEHICLE_VIEW, this->index);
+		DeleteWindowById(WC_VEHICLE_ORDERS, this->index);
+		DeleteWindowById(WC_VEHICLE_REFIT, this->index);
+		DeleteWindowById(WC_VEHICLE_DETAILS, this->index);
+		DeleteWindowById(WC_VEHICLE_TIMETABLE, this->index);
+		SetWindowDirty(WC_COMPANY, this->owner);
+		OrderBackup::ClearVehicle(this);
+	}
+	InvalidateWindowClassesData(GetWindowClassForVehicleType(this->type), 0);
+
+	this->cargo.Truncate();
+	DeleteVehicleOrders(this);
+	DeleteDepotHighlightOfVehicle(this);
+
+	extern void StopGlobalFollowVehicle(const Vehicle *v);
+	StopGlobalFollowVehicle(this);
+
+	ReleaseDisastersTargetingVehicle(this->index);
+}
+
+Vehicle::~Vehicle()
+{
+	if (CleaningPool()) {
+		this->cargo.OnCleanPool();
+		return;
+	}
+
+	/* sometimes, eg. for disaster vehicles, when company bankrupts, when removing crashed/flooded vehicles,
+	 * it may happen that vehicle chain is deleted when visible */
+	if (!(this->vehstatus & VS_HIDDEN)) MarkSingleVehicleDirty(this);
+
+	Vehicle *v = this->Next();
+	this->SetNext(NULL);
+
+	delete v;
+
+	UpdateVehicleTileHash(this, true);
+	UpdateVehicleViewportHash(this, INVALID_COORD, 0);
+	DeleteVehicleNews(this->index, INVALID_STRING_ID);
+	DeleteNewGRFInspectWindow(GetGrfSpecFeature(this->type), this->index);
+}
+
+/**
+ * Adds a vehicle to the list of vehicles that visited a depot this tick
+ * @param *v vehicle to add
+ */
+void VehicleEnteredDepotThisTick(Vehicle *v)
+{
+	/* Vehicle should stop in the depot if it was in 'stopping' state */
+	_vehicles_to_autoreplace[v] = !(v->vehstatus & VS_STOPPED);
+
+	/* We ALWAYS set the stopped state. Even when the vehicle does not plan on
+	 * stopping in the depot, so we stop it to ensure that it will not reserve
+	 * the path out of the depot before we might autoreplace it to a different
+	 * engine. The new engine would not own the reserved path we store that we
+	 * stopped the vehicle, so autoreplace can start it again */
+	v->vehstatus |= VS_STOPPED;
+}
+
+/**
+ * Increases the day counter for all vehicles and calls 1-day and 32-day handlers.
+ * Each tick, it processes vehicles with "index % DAY_TICKS == _date_fract",
+ * so each day, all vehicles are processes in DAY_TICKS steps.
+ */
+static void RunVehicleDayProc()
+{
+	if (_game_mode != GM_NORMAL) return;
+
+	/* Run the day_proc for every DAY_TICKS vehicle starting at _date_fract. */
+	for (size_t i = _date_fract; i < Vehicle::GetPoolSize(); i += DAY_TICKS) {
+		Vehicle *v = Vehicle::Get(i);
+		if (v == NULL) continue;
+
+		/* Call the 32-day callback if needed */
+		if ((v->day_counter & 0x1F) == 0 && v->HasEngineType()) {
+			uint16 callback = GetVehicleCallback(CBID_VEHICLE_32DAY_CALLBACK, 0, 0, v->engine_type, v);
+			if (callback != CALLBACK_FAILED) {
+				if (HasBit(callback, 0)) {
+					/* After a vehicle trigger, the graphics and properties of the vehicle could change. */
+					TriggerVehicle(v, VEHICLE_TRIGGER_CALLBACK_32); // Trigger vehicle trigger 10
+					v->MarkDirty();
+				}
+				if (HasBit(callback, 1)) v->colourmap = PAL_NONE;
+
+				if (callback & ~3) ErrorUnknownCallbackResult(v->GetGRFID(), CBID_VEHICLE_32DAY_CALLBACK, callback);
+			}
+		}
+
+		/* This is called once per day for each vehicle, but not in the first tick of the day */
+		v->OnNewDay();
+	}
+}
+
+void CallVehicleTicks()
+{
+	_vehicles_to_autoreplace.Clear();
+
+	RunVehicleDayProc();
+
+	Station *st;
+	FOR_ALL_STATIONS(st) LoadUnloadStation(st);
+
+	Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		/* Vehicle could be deleted in this tick */
+		if (!v->Tick()) {
+			assert(Vehicle::Get(vehicle_index) == NULL);
+			continue;
+		}
+
+		assert(Vehicle::Get(vehicle_index) == v);
+
+		switch (v->type) {
+			default: break;
+
+			case VEH_TRAIN:
+			case VEH_ROAD:
+			case VEH_AIRCRAFT:
+			case VEH_SHIP:
+				if (v->vcache.cached_cargo_age_period != 0) {
+					v->cargo_age_counter = min(v->cargo_age_counter, v->vcache.cached_cargo_age_period);
+					if (--v->cargo_age_counter == 0) {
+						v->cargo.AgeCargo();
+						v->cargo_age_counter = v->vcache.cached_cargo_age_period;
+					}
+				}
+
+				if (v->type == VEH_TRAIN && Train::From(v)->IsWagon()) continue;
+				if (v->type == VEH_AIRCRAFT && v->subtype != AIR_HELICOPTER) continue;
+				if (v->type == VEH_ROAD && !RoadVehicle::From(v)->IsFrontEngine()) continue;
+
+				v->motion_counter += v->cur_speed;
+				/* Play a running sound if the motion counter passes 256 (Do we not skip sounds?) */
+				if (GB(v->motion_counter, 0, 8) < v->cur_speed) PlayVehicleSound(v, VSE_RUNNING);
+
+				/* Play an alternating running sound every 16 ticks */
+				if (GB(v->tick_counter, 0, 4) == 0) PlayVehicleSound(v, v->cur_speed > 0 ? VSE_RUNNING_16 : VSE_STOPPED_16);
+		}
+	}
+
+	Backup<CompanyByte> cur_company(_current_company, FILE_LINE);
+	for (AutoreplaceMap::iterator it = _vehicles_to_autoreplace.Begin(); it != _vehicles_to_autoreplace.End(); it++) {
+		v = it->first;
+		/* Autoreplace needs the current company set as the vehicle owner */
+		cur_company.Change(v->owner);
+
+		/* Start vehicle if we stopped them in VehicleEnteredDepotThisTick()
+		 * We need to stop them between VehicleEnteredDepotThisTick() and here or we risk that
+		 * they are already leaving the depot again before being replaced. */
+		if (it->second) v->vehstatus &= ~VS_STOPPED;
+
+		/* Store the position of the effect as the vehicle pointer will become invalid later */
+		int x = v->x_pos;
+		int y = v->y_pos;
+		int z = v->z_pos;
+
+		const Company *c = Company::Get(_current_company);
+		SubtractMoneyFromCompany(CommandCost(EXPENSES_NEW_VEHICLES, (Money)c->settings.engine_renew_money));
+		CommandCost res = DoCommand(0, v->index, 0, DC_EXEC, CMD_AUTOREPLACE_VEHICLE);
+		SubtractMoneyFromCompany(CommandCost(EXPENSES_NEW_VEHICLES, -(Money)c->settings.engine_renew_money));
+
+		if (!IsLocalCompany()) continue;
+
+		if (res.Succeeded()) {
+			ShowCostOrIncomeAnimation(x, y, z, res.GetCost());
+			continue;
+		}
+
+		StringID error_message = res.GetErrorMessage();
+		if (error_message == STR_ERROR_AUTOREPLACE_NOTHING_TO_DO || error_message == INVALID_STRING_ID) continue;
+
+		if (error_message == STR_ERROR_NOT_ENOUGH_CASH_REQUIRES_CURRENCY) error_message = STR_ERROR_AUTOREPLACE_MONEY_LIMIT;
+
+		StringID message;
+		if (error_message == STR_ERROR_TRAIN_TOO_LONG_AFTER_REPLACEMENT) {
+			message = error_message;
+		} else {
+			message = STR_NEWS_VEHICLE_AUTORENEW_FAILED;
+		}
+
+		SetDParam(0, v->index);
+		SetDParam(1, error_message);
+		AddVehicleAdviceNewsItem(message, v->index);
+	}
+
+	cur_company.Restore();
+}
+
+/**
+ * Add vehicle sprite for drawing to the screen.
+ * @param v Vehicle to draw.
+ */
+static void DoDrawVehicle(const Vehicle *v)
+{
+	SpriteID image = v->cur_image;
+	PaletteID pal = PAL_NONE;
+
+	if (v->vehstatus & VS_DEFPAL) pal = (v->vehstatus & VS_CRASHED) ? PALETTE_CRASH : GetVehiclePalette(v);
+
+	/* Check whether the vehicle shall be transparent due to the game state */
+	bool shadowed = (v->vehstatus & VS_SHADOW) != 0;
+
+	if (v->type == VEH_EFFECT) {
+		/* Check whether the vehicle shall be transparent/invisible due to GUI settings.
+		 * However, transparent smoke and bubbles look weird, so always hide them. */
+		TransparencyOption to = EffectVehicle::From(v)->GetTransparencyOption();
+		if (to != TO_INVALID && (IsTransparencySet(to) || IsInvisibilitySet(to))) return;
+	}
+
+	AddSortableSpriteToDraw(image, pal, v->x_pos + v->x_offs, v->y_pos + v->y_offs,
+		v->x_extent, v->y_extent, v->z_extent, v->z_pos, shadowed, v->x_bb_offs, v->y_bb_offs);
+}
+
+/**
+ * Add the vehicle sprites that should be drawn at a part of the screen.
+ * @param dpi Rectangle being drawn.
+ */
+void ViewportAddVehicles(DrawPixelInfo *dpi)
+{
+	/* The bounding rectangle */
+	const int l = dpi->left;
+	const int r = dpi->left + dpi->width;
+	const int t = dpi->top;
+	const int b = dpi->top + dpi->height;
+
+	/* The hash area to scan */
+	int xl, xu, yl, yu;
+
+	if (dpi->width + (70 * ZOOM_LVL_BASE) < (1 << (7 + 6 + ZOOM_LVL_SHIFT))) {
+		xl = GB(l - (70 * ZOOM_LVL_BASE), 7 + ZOOM_LVL_SHIFT, 6);
+		xu = GB(r,                        7 + ZOOM_LVL_SHIFT, 6);
+	} else {
+		/* scan whole hash row */
+		xl = 0;
+		xu = 0x3F;
+	}
+
+	if (dpi->height + (70 * ZOOM_LVL_BASE) < (1 << (6 + 6 + ZOOM_LVL_SHIFT))) {
+		yl = GB(t - (70 * ZOOM_LVL_BASE), 6 + ZOOM_LVL_SHIFT, 6) << 6;
+		yu = GB(b,                        6 + ZOOM_LVL_SHIFT, 6) << 6;
+	} else {
+		/* scan whole column */
+		yl = 0;
+		yu = 0x3F << 6;
+	}
+
+	for (int y = yl;; y = (y + (1 << 6)) & (0x3F << 6)) {
+		for (int x = xl;; x = (x + 1) & 0x3F) {
+			const Vehicle *v = _vehicle_viewport_hash[x + y]; // already masked & 0xFFF
+
+			while (v != NULL) {
+				if (!(v->vehstatus & VS_HIDDEN) &&
+						l <= v->coord.right &&
+						t <= v->coord.bottom &&
+						r >= v->coord.left &&
+						b >= v->coord.top) {
+					DoDrawVehicle(v);
+				}
+				v = v->hash_viewport_next;
+			}
+
+			if (x == xu) break;
+		}
+
+		if (y == yu) break;
+	}
+}
+
+/**
+ * Find the vehicle close to the clicked coordinates.
+ * @param vp Viewport clicked in.
+ * @param x  X coordinate in the viewport.
+ * @param y  Y coordinate in the viewport.
+ * @return Closest vehicle, or \c NULL if none found.
+ */
+Vehicle *CheckClickOnVehicle(const ViewPort *vp, int x, int y)
+{
+	Vehicle *found = NULL, *v;
+	uint dist, best_dist = UINT_MAX;
+
+	if ((uint)(x -= vp->left) >= (uint)vp->width || (uint)(y -= vp->top) >= (uint)vp->height) return NULL;
+
+	x = ScaleByZoom(x, vp->zoom) + vp->virtual_left;
+	y = ScaleByZoom(y, vp->zoom) + vp->virtual_top;
+
+	FOR_ALL_VEHICLES(v) {
+		if ((v->vehstatus & (VS_HIDDEN | VS_UNCLICKABLE)) == 0 &&
+				x >= v->coord.left && x <= v->coord.right &&
+				y >= v->coord.top && y <= v->coord.bottom) {
+
+			dist = max(
+				abs(((v->coord.left + v->coord.right) >> 1) - x),
+				abs(((v->coord.top + v->coord.bottom) >> 1) - y)
+			);
+
+			if (dist < best_dist) {
+				found = v;
+				best_dist = dist;
+			}
+		}
+	}
+
+	return found;
+}
+
+/**
+ * Decrease the value of a vehicle.
+ * @param v %Vehicle to devaluate.
+ */
+void DecreaseVehicleValue(Vehicle *v)
+{
+	v->value -= v->value >> 8;
+	SetWindowDirty(WC_VEHICLE_DETAILS, v->index);
+}
+
+static const byte _breakdown_chance[64] = {
+	  3,   3,   3,   3,   3,   3,   3,   3,
+	  4,   4,   5,   5,   6,   6,   7,   7,
+	  8,   8,   9,   9,  10,  10,  11,  11,
+	 12,  13,  13,  13,  13,  14,  15,  16,
+	 17,  19,  21,  25,  28,  31,  34,  37,
+	 40,  44,  48,  52,  56,  60,  64,  68,
+	 72,  80,  90, 100, 110, 120, 130, 140,
+	150, 170, 190, 210, 230, 250, 250, 250,
+};
+
+void CheckVehicleBreakdown(Vehicle *v)
+{
+	int rel, rel_old;
+
+	/* decrease reliability */
+	v->reliability = rel = max((rel_old = v->reliability) - v->reliability_spd_dec, 0);
+	if ((rel_old >> 8) != (rel >> 8)) SetWindowDirty(WC_VEHICLE_DETAILS, v->index);
+
+	if (v->breakdown_ctr != 0 || (v->vehstatus & VS_STOPPED) ||
+			_settings_game.difficulty.vehicle_breakdowns < 1 ||
+			v->cur_speed < 5 || _game_mode == GM_MENU) {
+		return;
+	}
+
+	uint32 r = Random();
+
+	/* increase chance of failure */
+	int chance = v->breakdown_chance + 1;
+	if (Chance16I(1, 25, r)) chance += 25;
+	v->breakdown_chance = min(255, chance);
+
+	/* calculate reliability value to use in comparison */
+	rel = v->reliability;
+	if (v->type == VEH_SHIP) rel += 0x6666;
+
+	/* reduced breakdowns? */
+	if (_settings_game.difficulty.vehicle_breakdowns == 1) rel += 0x6666;
+
+	/* check if to break down */
+	if (_breakdown_chance[(uint)min(rel, 0xffff) >> 10] <= v->breakdown_chance) {
+		v->breakdown_ctr    = GB(r, 16, 6) + 0x3F;
+		v->breakdown_delay  = GB(r, 24, 7) + 0x80;
+		v->breakdown_chance = 0;
+	}
+}
+
+/**
+ * Handle all of the aspects of a vehicle breakdown
+ * This includes adding smoke and sounds, and ending the breakdown when appropriate.
+ * @return true iff the vehicle is stopped because of a breakdown
+ * @note This function always returns false for aircraft, since these never stop for breakdowns
+ */
+bool Vehicle::HandleBreakdown()
+{
+	/* Possible states for Vehicle::breakdown_ctr
+	 * 0  - vehicle is running normally
+	 * 1  - vehicle is currently broken down
+	 * 2  - vehicle is going to break down now
+	 * >2 - vehicle is counting down to the actual breakdown event */
+	switch (this->breakdown_ctr) {
+		case 0:
+			return false;
+
+		case 2:
+			this->breakdown_ctr = 1;
+
+			if (this->breakdowns_since_last_service != 255) {
+				this->breakdowns_since_last_service++;
+			}
+
+			if (this->type == VEH_AIRCRAFT) {
+				/* Aircraft just need this flag, the rest is handled elsewhere */
+				this->vehstatus |= VS_AIRCRAFT_BROKEN;
+			} else {
+				this->cur_speed = 0;
+
+				if (!PlayVehicleSound(this, VSE_BREAKDOWN)) {
+					SndPlayVehicleFx((_settings_game.game_creation.landscape != LT_TOYLAND) ?
+						(this->type == VEH_TRAIN ? SND_10_TRAIN_BREAKDOWN : SND_0F_VEHICLE_BREAKDOWN) :
+						(this->type == VEH_TRAIN ? SND_3A_COMEDY_BREAKDOWN_2 : SND_35_COMEDY_BREAKDOWN), this);
+				}
+
+				if (!(this->vehstatus & VS_HIDDEN) && !HasBit(EngInfo(this->engine_type)->misc_flags, EF_NO_BREAKDOWN_SMOKE)) {
+					EffectVehicle *u = CreateEffectVehicleRel(this, 4, 4, 5, EV_BREAKDOWN_SMOKE);
+					if (u != NULL) u->animation_state = this->breakdown_delay * 2;
+				}
+			}
+
+			this->MarkDirty(); // Update graphics after speed is zeroed
+			SetWindowDirty(WC_VEHICLE_VIEW, this->index);
+			SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
+
+			/* FALL THROUGH */
+		case 1:
+			/* Aircraft breakdowns end only when arriving at the airport */
+			if (this->type == VEH_AIRCRAFT) return false;
+
+			/* For trains this function is called twice per tick, so decrease v->breakdown_delay at half the rate */
+			if ((this->tick_counter & (this->type == VEH_TRAIN ? 3 : 1)) == 0) {
+				if (--this->breakdown_delay == 0) {
+					this->breakdown_ctr = 0;
+					this->MarkDirty();
+					SetWindowDirty(WC_VEHICLE_VIEW, this->index);
+				}
+			}
+			return true;
+
+		default:
+			if (!this->current_order.IsType(OT_LOADING)) this->breakdown_ctr--;
+			return false;
+	}
+}
+
+/**
+ * Update age of a vehicle.
+ * @param v Vehicle to update.
+ */
+void AgeVehicle(Vehicle *v)
+{
+	if (v->age < MAX_DAY) {
+		v->age++;
+		if (v->IsPrimaryVehicle() && v->age == VEHICLE_PROFIT_MIN_AGE + 1) GroupStatistics::VehicleReachedProfitAge(v);
+	}
+
+	if (!v->IsPrimaryVehicle() && (v->type != VEH_TRAIN || !Train::From(v)->IsEngine())) return;
+
+	int age = v->age - v->max_age;
+	if (age == DAYS_IN_LEAP_YEAR * 0 || age == DAYS_IN_LEAP_YEAR * 1 ||
+			age == DAYS_IN_LEAP_YEAR * 2 || age == DAYS_IN_LEAP_YEAR * 3 || age == DAYS_IN_LEAP_YEAR * 4) {
+		v->reliability_spd_dec <<= 1;
+	}
+
+	SetWindowDirty(WC_VEHICLE_DETAILS, v->index);
+
+	/* Don't warn about non-primary or not ours vehicles or vehicles that are crashed */
+	if (v->Previous() != NULL || v->owner != _local_company || (v->vehstatus & VS_CRASHED) != 0) return;
+
+	/* Don't warn if a renew is active */
+	if (Company::Get(v->owner)->settings.engine_renew && v->GetEngine()->company_avail != 0) return;
+
+	StringID str;
+	if (age == -DAYS_IN_LEAP_YEAR) {
+		str = STR_NEWS_VEHICLE_IS_GETTING_OLD;
+	} else if (age == 0) {
+		str = STR_NEWS_VEHICLE_IS_GETTING_VERY_OLD;
+	} else if (age > 0 && (age % DAYS_IN_LEAP_YEAR) == 0) {
+		str = STR_NEWS_VEHICLE_IS_GETTING_VERY_OLD_AND;
+	} else {
+		return;
+	}
+
+	SetDParam(0, v->index);
+	AddVehicleAdviceNewsItem(str, v->index);
+}
+
+/**
+ * Calculates how full a vehicle is.
+ * @param front The front vehicle of the consist to check.
+ * @param colour The string to show depending on if we are unloading or loading
+ * @return A percentage of how full the Vehicle is.
+ */
+uint8 CalcPercentVehicleFilled(const Vehicle *front, StringID *colour)
+{
+	int count = 0;
+	int max = 0;
+	int cars = 0;
+	int unloading = 0;
+	bool loading = false;
+
+	bool is_loading = front->current_order.IsType(OT_LOADING);
+
+	/* The station may be NULL when the (colour) string does not need to be set. */
+	const Station *st = Station::GetIfValid(front->last_station_visited);
+	assert(colour == NULL || (st != NULL && is_loading));
+
+	bool order_no_load = is_loading && (front->current_order.GetLoadType() & OLFB_NO_LOAD);
+	bool order_full_load = is_loading && (front->current_order.GetLoadType() & OLFB_FULL_LOAD);
+
+	/* Count up max and used */
+	for (const Vehicle *v = front; v != NULL; v = v->Next()) {
+		count += v->cargo.StoredCount();
+		max += v->cargo_cap;
+		if (v->cargo_cap != 0 && colour != NULL) {
+			unloading += HasBit(v->vehicle_flags, VF_CARGO_UNLOADING) ? 1 : 0;
+			loading |= !order_no_load &&
+					(order_full_load || st->goods[v->cargo_type].HasRating()) &&
+					!HasBit(v->vehicle_flags, VF_LOADING_FINISHED) && !HasBit(v->vehicle_flags, VF_STOP_LOADING);
+			cars++;
+		}
+	}
+
+	if (colour != NULL) {
+		if (unloading == 0 && loading) {
+			*colour = STR_PERCENT_UP;
+		} else if (unloading == 0 && !loading) {
+			*colour = STR_PERCENT_NONE;
+		} else if (cars == unloading || !loading) {
+			*colour = STR_PERCENT_DOWN;
+		} else {
+			*colour = STR_PERCENT_UP_DOWN;
+		}
+	}
+
+	/* Train without capacity */
+	if (max == 0) return 100;
+
+	/* Return the percentage */
+	return (count * 100) / max;
+}
+
+/**
+ * Vehicle entirely entered the depot, update its status, orders, vehicle windows, service it, etc.
+ * @param v Vehicle that entered a depot.
+ */
+void VehicleEnterDepot(Vehicle *v)
+{
+	/* Always work with the front of the vehicle */
+	assert(v == v->First());
+
+	switch (v->type) {
+		case VEH_TRAIN: {
+			Train *t = Train::From(v);
+			SetWindowClassesDirty(WC_TRAINS_LIST);
+			/* Clear path reservation */
+			SetDepotReservation(t->tile, false);
+			if (_settings_client.gui.show_track_reservation) MarkTileDirtyByTile(t->tile);
+
+			UpdateSignalsOnSegment(t->tile, INVALID_DIAGDIR, t->owner);
+			t->wait_counter = 0;
+			t->force_proceed = TFP_NONE;
+			ClrBit(t->flags, VRF_TOGGLE_REVERSE);
+			t->ConsistChanged(true);
+			break;
+		}
+
+		case VEH_ROAD:
+			SetWindowClassesDirty(WC_ROADVEH_LIST);
+			break;
+
+		case VEH_SHIP: {
+			SetWindowClassesDirty(WC_SHIPS_LIST);
+			Ship *ship = Ship::From(v);
+			ship->state = TRACK_BIT_DEPOT;
+			ship->UpdateCache();
+			ship->UpdateViewport(true, true);
+			SetWindowDirty(WC_VEHICLE_DEPOT, v->tile);
+			break;
+		}
+
+		case VEH_AIRCRAFT:
+			SetWindowClassesDirty(WC_AIRCRAFT_LIST);
+			HandleAircraftEnterHangar(Aircraft::From(v));
+			break;
+		default: NOT_REACHED();
+	}
+	SetWindowDirty(WC_VEHICLE_VIEW, v->index);
+
+	if (v->type != VEH_TRAIN) {
+		/* Trains update the vehicle list when the first unit enters the depot and calls VehicleEnterDepot() when the last unit enters.
+		 * We only increase the number of vehicles when the first one enters, so we will not need to search for more vehicles in the depot */
+		InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
+	}
+	SetWindowDirty(WC_VEHICLE_DEPOT, v->tile);
+
+	v->vehstatus |= VS_HIDDEN;
+	v->cur_speed = 0;
+
+	VehicleServiceInDepot(v);
+
+	/* After a vehicle trigger, the graphics and properties of the vehicle could change. */
+	TriggerVehicle(v, VEHICLE_TRIGGER_DEPOT);
+	v->MarkDirty();
+
+	if (v->current_order.IsType(OT_GOTO_DEPOT)) {
+		SetWindowDirty(WC_VEHICLE_VIEW, v->index);
+
+		const Order *real_order = v->GetOrder(v->cur_real_order_index);
+		Order t = v->current_order;
+		v->current_order.MakeDummy();
+
+		/* Test whether we are heading for this depot. If not, do nothing.
+		 * Note: The target depot for nearest-/manual-depot-orders is only updated on junctions, but we want to accept every depot. */
+		if ((t.GetDepotOrderType() & ODTFB_PART_OF_ORDERS) &&
+				real_order != NULL && !(real_order->GetDepotActionType() & ODATFB_NEAREST_DEPOT) &&
+				(v->type == VEH_AIRCRAFT ? t.GetDestination() != GetStationIndex(v->tile) : v->dest_tile != v->tile)) {
+			/* We are heading for another depot, keep driving. */
+			return;
+		}
+
+		if (t.IsRefit()) {
+			Backup<CompanyByte> cur_company(_current_company, v->owner, FILE_LINE);
+			CommandCost cost = DoCommand(v->tile, v->index, t.GetRefitCargo() | 0xFF << 8, DC_EXEC, GetCmdRefitVeh(v));
+			cur_company.Restore();
+
+			if (cost.Failed()) {
+				_vehicles_to_autoreplace[v] = false;
+				if (v->owner == _local_company) {
+					/* Notify the user that we stopped the vehicle */
+					SetDParam(0, v->index);
+					AddVehicleAdviceNewsItem(STR_NEWS_ORDER_REFIT_FAILED, v->index);
+				}
+			} else if (cost.GetCost() != 0) {
+				v->profit_this_year -= cost.GetCost() << 8;
+				if (v->owner == _local_company) {
+					ShowCostOrIncomeAnimation(v->x_pos, v->y_pos, v->z_pos, cost.GetCost());
+				}
+			}
+		}
+
+		if (t.GetDepotOrderType() & ODTFB_PART_OF_ORDERS) {
+			/* Part of orders */
+			v->DeleteUnreachedImplicitOrders();
+			UpdateVehicleTimetable(v, true);
+			v->IncrementImplicitOrderIndex();
+		}
+		if (t.GetDepotActionType() & ODATFB_HALT) {
+			/* Vehicles are always stopped on entering depots. Do not restart this one. */
+			_vehicles_to_autoreplace[v] = false;
+			if (v->owner == _local_company) {
+				SetDParam(0, v->index);
+				AddVehicleAdviceNewsItem(STR_NEWS_TRAIN_IS_WAITING + v->type, v->index);
+			}
+			AI::NewEvent(v->owner, new ScriptEventVehicleWaitingInDepot(v->index));
+		}
+	}
+}
+
+
+/**
+ * Update the position of the vehicle. This will update the hash that tells
+ *  which vehicles are on a tile.
+ * @param v The vehicle to update.
+ */
+void VehicleUpdatePosition(Vehicle *v)
+{
+	UpdateVehicleTileHash(v, false);
+}
+
+/**
+ * Update the vehicle on the viewport, updating the right hash and setting the
+ *  new coordinates.
+ * @param v The vehicle to update.
+ * @param dirty Mark the (new and old) coordinates of the vehicle as dirty.
+ */
+void VehicleUpdateViewport(Vehicle *v, bool dirty)
+{
+	int img = v->cur_image;
+	Point pt = RemapCoords(v->x_pos + v->x_offs, v->y_pos + v->y_offs, v->z_pos);
+	const Sprite *spr = GetSprite(img, ST_NORMAL);
+
+	pt.x += spr->x_offs;
+	pt.y += spr->y_offs;
+
+	UpdateVehicleViewportHash(v, pt.x, pt.y);
+
+	Rect old_coord = v->coord;
+	v->coord.left   = pt.x;
+	v->coord.top    = pt.y;
+	v->coord.right  = pt.x + spr->width + 2 * ZOOM_LVL_BASE;
+	v->coord.bottom = pt.y + spr->height + 2 * ZOOM_LVL_BASE;
+
+	if (dirty) {
+		if (old_coord.left == INVALID_COORD) {
+			MarkSingleVehicleDirty(v);
+		} else {
+			MarkAllViewportsDirty(
+				min(old_coord.left,   v->coord.left),
+				min(old_coord.top,    v->coord.top),
+				max(old_coord.right,  v->coord.right) + 1 * ZOOM_LVL_BASE,
+				max(old_coord.bottom, v->coord.bottom) + 1 * ZOOM_LVL_BASE
+			);
+		}
+	}
+}
+
+/**
+ * Update the position of the vehicle, and update the viewport.
+ * @param v The vehicle to update.
+ */
+void VehicleUpdatePositionAndViewport(Vehicle *v)
+{
+	VehicleUpdatePosition(v);
+	VehicleUpdateViewport(v, true);
+}
+
+/**
+ * Marks viewports dirty where the vehicle's image is.
+ * @param v vehicle to mark dirty
+ */
+void MarkSingleVehicleDirty(const Vehicle *v)
+{
+	MarkAllViewportsDirty(v->coord.left, v->coord.top, v->coord.right + 1 * ZOOM_LVL_BASE, v->coord.bottom + 1 * ZOOM_LVL_BASE);
+}
+
+/**
+ * Get position information of a vehicle when moving one pixel in the direction it is facing
+ * @param v Vehicle to move
+ * @return Position information after the move
+ */
+GetNewVehiclePosResult GetNewVehiclePos(const Vehicle *v)
+{
+	static const int8 _delta_coord[16] = {
+		-1,-1,-1, 0, 1, 1, 1, 0, /* x */
+		-1, 0, 1, 1, 1, 0,-1,-1, /* y */
+	};
+
+	int x = v->x_pos + _delta_coord[v->direction];
+	int y = v->y_pos + _delta_coord[v->direction + 8];
+
+	GetNewVehiclePosResult gp;
+	gp.x = x;
+	gp.y = y;
+	gp.old_tile = v->tile;
+	gp.new_tile = TileVirtXY(x, y);
+	return gp;
+}
+
+static const Direction _new_direction_table[] = {
+	DIR_N,  DIR_NW, DIR_W,
+	DIR_NE, DIR_SE, DIR_SW,
+	DIR_E,  DIR_SE, DIR_S
+};
+
+Direction GetDirectionTowards(const Vehicle *v, int x, int y)
+{
+	int i = 0;
+
+	if (y >= v->y_pos) {
+		if (y != v->y_pos) i += 3;
+		i += 3;
+	}
+
+	if (x >= v->x_pos) {
+		if (x != v->x_pos) i++;
+		i++;
+	}
+
+	Direction dir = v->direction;
+
+	DirDiff dirdiff = DirDifference(_new_direction_table[i], dir);
+	if (dirdiff == DIRDIFF_SAME) return dir;
+	return ChangeDir(dir, dirdiff > DIRDIFF_REVERSE ? DIRDIFF_45LEFT : DIRDIFF_45RIGHT);
+}
+
+/**
+ * Call the tile callback function for a vehicle entering a tile
+ * @param v    Vehicle entering the tile
+ * @param tile Tile entered
+ * @param x    X position
+ * @param y    Y position
+ * @return Some meta-data over the to be entered tile.
+ * @see VehicleEnterTileStatus to see what the bits in the return value mean.
+ */
+VehicleEnterTileStatus VehicleEnterTile(Vehicle *v, TileIndex tile, int x, int y)
+{
+	return _tile_type_procs[GetTileType(tile)]->vehicle_enter_tile_proc(v, tile, x, y);
+}
+
+/**
+ * Initializes the structure. Vehicle unit numbers are supposed not to change after
+ * struct initialization, except after each call to this->NextID() the returned value
+ * is assigned to a vehicle.
+ * @param type type of vehicle
+ * @param owner owner of vehicles
+ */
+FreeUnitIDGenerator::FreeUnitIDGenerator(VehicleType type, CompanyID owner) : cache(NULL), maxid(0), curid(0)
+{
+	/* Find maximum */
+	const Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		if (v->type == type && v->owner == owner) {
+			this->maxid = max<UnitID>(this->maxid, v->unitnumber);
+		}
+	}
+
+	if (this->maxid == 0) return;
+
+	/* Reserving 'maxid + 2' because we need:
+	 * - space for the last item (with v->unitnumber == maxid)
+	 * - one free slot working as loop terminator in FreeUnitIDGenerator::NextID() */
+	this->cache = CallocT<bool>(this->maxid + 2);
+
+	/* Fill the cache */
+	FOR_ALL_VEHICLES(v) {
+		if (v->type == type && v->owner == owner) {
+			this->cache[v->unitnumber] = true;
+		}
+	}
+}
+
+/** Returns next free UnitID. Supposes the last returned value was assigned to a vehicle. */
+UnitID FreeUnitIDGenerator::NextID()
+{
+	if (this->maxid <= this->curid) return ++this->curid;
+
+	while (this->cache[++this->curid]) { } // it will stop, we reserved more space than needed
+
+	return this->curid;
+}
+
+/**
+ * Get an unused unit number for a vehicle (if allowed).
+ * @param type Type of vehicle
+ * @return A unused unit number for the given type of vehicle if it is allowed to build one, else \c UINT16_MAX.
+ */
+UnitID GetFreeUnitNumber(VehicleType type)
+{
+	/* Check whether it is allowed to build another vehicle. */
+	uint max_veh;
+	switch (type) {
+		case VEH_TRAIN:    max_veh = _settings_game.vehicle.max_trains;   break;
+		case VEH_ROAD:     max_veh = _settings_game.vehicle.max_roadveh;  break;
+		case VEH_SHIP:     max_veh = _settings_game.vehicle.max_ships;    break;
+		case VEH_AIRCRAFT: max_veh = _settings_game.vehicle.max_aircraft; break;
+		default: NOT_REACHED();
+	}
+
+	const Company *c = Company::Get(_current_company);
+	if (c->group_all[type].num_vehicle >= max_veh) return UINT16_MAX; // Currently already at the limit, no room to make a new one.
+
+	FreeUnitIDGenerator gen(type, _current_company);
+
+	return gen.NextID();
+}
+
+
+/**
+ * Check whether we can build infrastructure for the given
+ * vehicle type. This to disable building stations etc. when
+ * you are not allowed/able to have the vehicle type yet.
+ * @param type the vehicle type to check this for
+ * @return true if there is any reason why you may build
+ *         the infrastructure for the given vehicle type
+ */
+bool CanBuildVehicleInfrastructure(VehicleType type)
+{
+	assert(IsCompanyBuildableVehicleType(type));
+
+	if (!Company::IsValidID(_local_company)) return false;
+	if (!_settings_client.gui.disable_unsuitable_building) return true;
+
+	UnitID max;
+	switch (type) {
+		case VEH_TRAIN:    max = _settings_game.vehicle.max_trains; break;
+		case VEH_ROAD:     max = _settings_game.vehicle.max_roadveh; break;
+		case VEH_SHIP:     max = _settings_game.vehicle.max_ships; break;
+		case VEH_AIRCRAFT: max = _settings_game.vehicle.max_aircraft; break;
+		default: NOT_REACHED();
+	}
+
+	/* We can build vehicle infrastructure when we may build the vehicle type */
+	if (max > 0) {
+		/* Can we actually build the vehicle type? */
+		const Engine *e;
+		FOR_ALL_ENGINES_OF_TYPE(e, type) {
+			if (HasBit(e->company_avail, _local_company)) return true;
+		}
+		return false;
+	}
+
+	/* We should be able to build infrastructure when we have the actual vehicle type */
+	const Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		if (v->owner == _local_company && v->type == type) return true;
+	}
+
+	return false;
+}
+
+
+/**
+ * Determines the #LiveryScheme for a vehicle.
+ * @param engine_type Engine of the vehicle.
+ * @param parent_engine_type Engine of the front vehicle, #INVALID_ENGINE if vehicle is at front itself.
+ * @param v the vehicle, \c NULL if in purchase list etc.
+ * @return livery scheme to use.
+ */
+LiveryScheme GetEngineLiveryScheme(EngineID engine_type, EngineID parent_engine_type, const Vehicle *v)
+{
+	CargoID cargo_type = v == NULL ? (CargoID)CT_INVALID : v->cargo_type;
+	const Engine *e = Engine::Get(engine_type);
+	switch (e->type) {
+		default: NOT_REACHED();
+		case VEH_TRAIN:
+			if (v != NULL && parent_engine_type != INVALID_ENGINE && (UsesWagonOverride(v) || (v->IsArticulatedPart() && e->u.rail.railveh_type != RAILVEH_WAGON))) {
+				/* Wagonoverrides use the colour scheme of the front engine.
+				 * Articulated parts use the colour scheme of the first part. (Not supported for articulated wagons) */
+				engine_type = parent_engine_type;
+				e = Engine::Get(engine_type);
+				/* Note: Luckily cargo_type is not needed for engines */
+			}
+
+			if (cargo_type == CT_INVALID) cargo_type = e->GetDefaultCargoType();
+			if (cargo_type == CT_INVALID) cargo_type = CT_GOODS; // The vehicle does not carry anything, let's pick some freight cargo
+			if (e->u.rail.railveh_type == RAILVEH_WAGON) {
+				if (!CargoSpec::Get(cargo_type)->is_freight) {
+					if (parent_engine_type == INVALID_ENGINE) {
+						return LS_PASSENGER_WAGON_STEAM;
+					} else {
+						switch (RailVehInfo(parent_engine_type)->engclass) {
+							default: NOT_REACHED();
+							case EC_STEAM:    return LS_PASSENGER_WAGON_STEAM;
+							case EC_DIESEL:   return LS_PASSENGER_WAGON_DIESEL;
+							case EC_ELECTRIC: return LS_PASSENGER_WAGON_ELECTRIC;
+							case EC_MONORAIL: return LS_PASSENGER_WAGON_MONORAIL;
+							case EC_MAGLEV:   return LS_PASSENGER_WAGON_MAGLEV;
+						}
+					}
+				} else {
+					return LS_FREIGHT_WAGON;
+				}
+			} else {
+				bool is_mu = HasBit(e->info.misc_flags, EF_RAIL_IS_MU);
+
+				switch (e->u.rail.engclass) {
+					default: NOT_REACHED();
+					case EC_STEAM:    return LS_STEAM;
+					case EC_DIESEL:   return is_mu ? LS_DMU : LS_DIESEL;
+					case EC_ELECTRIC: return is_mu ? LS_EMU : LS_ELECTRIC;
+					case EC_MONORAIL: return LS_MONORAIL;
+					case EC_MAGLEV:   return LS_MAGLEV;
+				}
+			}
+
+		case VEH_ROAD:
+			/* Always use the livery of the front */
+			if (v != NULL && parent_engine_type != INVALID_ENGINE) {
+				engine_type = parent_engine_type;
+				e = Engine::Get(engine_type);
+				cargo_type = v->First()->cargo_type;
+			}
+			if (cargo_type == CT_INVALID) cargo_type = e->GetDefaultCargoType();
+			if (cargo_type == CT_INVALID) cargo_type = CT_GOODS; // The vehicle does not carry anything, let's pick some freight cargo
+
+			/* Important: Use Tram Flag of front part. Luckily engine_type refers to the front part here. */
+			if (HasBit(e->info.misc_flags, EF_ROAD_TRAM)) {
+				/* Tram */
+				return IsCargoInClass(cargo_type, CC_PASSENGERS) ? LS_PASSENGER_TRAM : LS_FREIGHT_TRAM;
+			} else {
+				/* Bus or truck */
+				return IsCargoInClass(cargo_type, CC_PASSENGERS) ? LS_BUS : LS_TRUCK;
+			}
+
+		case VEH_SHIP:
+			if (cargo_type == CT_INVALID) cargo_type = e->GetDefaultCargoType();
+			if (cargo_type == CT_INVALID) cargo_type = CT_GOODS; // The vehicle does not carry anything, let's pick some freight cargo
+			return IsCargoInClass(cargo_type, CC_PASSENGERS) ? LS_PASSENGER_SHIP : LS_FREIGHT_SHIP;
+
+		case VEH_AIRCRAFT:
+			switch (e->u.air.subtype) {
+				case AIR_HELI: return LS_HELICOPTER;
+				case AIR_CTOL: return LS_SMALL_PLANE;
+				case AIR_CTOL | AIR_FAST: return LS_LARGE_PLANE;
+				default: NOT_REACHED();
+			}
+	}
+}
+
+/**
+ * Determines the livery for a vehicle.
+ * @param engine_type EngineID of the vehicle
+ * @param company Owner of the vehicle
+ * @param parent_engine_type EngineID of the front vehicle. INVALID_VEHICLE if vehicle is at front itself.
+ * @param v the vehicle. NULL if in purchase list etc.
+ * @param livery_setting The livery settings to use for acquiring the livery information.
+ * @return livery to use
+ */
+const Livery *GetEngineLivery(EngineID engine_type, CompanyID company, EngineID parent_engine_type, const Vehicle *v, byte livery_setting)
+{
+	const Company *c = Company::Get(company);
+	LiveryScheme scheme = LS_DEFAULT;
+
+	/* The default livery is always available for use, but its in_use flag determines
+	 * whether any _other_ liveries are in use. */
+	if (c->livery[LS_DEFAULT].in_use && (livery_setting == LIT_ALL || (livery_setting == LIT_COMPANY && company == _local_company))) {
+		/* Determine the livery scheme to use */
+		scheme = GetEngineLiveryScheme(engine_type, parent_engine_type, v);
+
+		/* Switch back to the default scheme if the resolved scheme is not in use */
+		if (!c->livery[scheme].in_use) scheme = LS_DEFAULT;
+	}
+
+	return &c->livery[scheme];
+}
+
+
+static PaletteID GetEngineColourMap(EngineID engine_type, CompanyID company, EngineID parent_engine_type, const Vehicle *v)
+{
+	PaletteID map = (v != NULL) ? v->colourmap : PAL_NONE;
+
+	/* Return cached value if any */
+	if (map != PAL_NONE) return map;
+
+	const Engine *e = Engine::Get(engine_type);
+
+	/* Check if we should use the colour map callback */
+	if (HasBit(e->info.callback_mask, CBM_VEHICLE_COLOUR_REMAP)) {
+		uint16 callback = GetVehicleCallback(CBID_VEHICLE_COLOUR_MAPPING, 0, 0, engine_type, v);
+		/* Failure means "use the default two-colour" */
+		if (callback != CALLBACK_FAILED) {
+			assert_compile(PAL_NONE == 0); // Returning 0x4000 (resp. 0xC000) coincidences with default value (PAL_NONE)
+			map = GB(callback, 0, 14);
+			/* If bit 14 is set, then the company colours are applied to the
+			 * map else it's returned as-is. */
+			if (!HasBit(callback, 14)) {
+				/* Update cache */
+				if (v != NULL) const_cast<Vehicle *>(v)->colourmap = map;
+				return map;
+			}
+		}
+	}
+
+	bool twocc = HasBit(e->info.misc_flags, EF_USES_2CC);
+
+	if (map == PAL_NONE) map = twocc ? (PaletteID)SPR_2CCMAP_BASE : (PaletteID)PALETTE_RECOLOUR_START;
+
+	/* Spectator has news shown too, but has invalid company ID - as well as dedicated server */
+	if (!Company::IsValidID(company)) return map;
+
+	const Livery *livery = GetEngineLivery(engine_type, company, parent_engine_type, v, _settings_client.gui.liveries);
+
+	map += livery->colour1;
+	if (twocc) map += livery->colour2 * 16;
+
+	/* Update cache */
+	if (v != NULL) const_cast<Vehicle *>(v)->colourmap = map;
+	return map;
+}
+
+/**
+ * Get the colour map for an engine. This used for unbuilt engines in the user interface.
+ * @param engine_type ID of engine
+ * @param company ID of company
+ * @return A ready-to-use palette modifier
+ */
+PaletteID GetEnginePalette(EngineID engine_type, CompanyID company)
+{
+	return GetEngineColourMap(engine_type, company, INVALID_ENGINE, NULL);
+}
+
+/**
+ * Get the colour map for a vehicle.
+ * @param v Vehicle to get colour map for
+ * @return A ready-to-use palette modifier
+ */
+PaletteID GetVehiclePalette(const Vehicle *v)
+{
+	if (v->IsGroundVehicle()) {
+		return GetEngineColourMap(v->engine_type, v->owner, v->GetGroundVehicleCache()->first_engine, v);
+	}
+
+	return GetEngineColourMap(v->engine_type, v->owner, INVALID_ENGINE, v);
+}
+
+/**
+ * Delete all implicit orders which were not reached.
+ */
+void Vehicle::DeleteUnreachedImplicitOrders()
+{
+	if (this->IsGroundVehicle()) {
+		uint16 &gv_flags = this->GetGroundVehicleFlags();
+		if (HasBit(gv_flags, GVF_SUPPRESS_IMPLICIT_ORDERS)) {
+			/* Do not delete orders, only skip them */
+			ClrBit(gv_flags, GVF_SUPPRESS_IMPLICIT_ORDERS);
+			this->cur_implicit_order_index = this->cur_real_order_index;
+			InvalidateVehicleOrder(this, 0);
+			return;
+		}
+	}
+
+	const Order *order = this->GetOrder(this->cur_implicit_order_index);
+	while (order != NULL) {
+		if (this->cur_implicit_order_index == this->cur_real_order_index) break;
+
+		if (order->IsType(OT_IMPLICIT)) {
+			DeleteOrder(this, this->cur_implicit_order_index);
+			/* DeleteOrder does various magic with order_indices, so resync 'order' with 'cur_implicit_order_index' */
+			order = this->GetOrder(this->cur_implicit_order_index);
+		} else {
+			/* Skip non-implicit orders, e.g. service-orders */
+			order = order->next;
+			this->cur_implicit_order_index++;
+		}
+
+		/* Wrap around */
+		if (order == NULL) {
+			order = this->GetOrder(0);
+			this->cur_implicit_order_index = 0;
+		}
+	}
+}
+
+/**
+ * Prepare everything to begin the loading when arriving at a station.
+ * @pre IsTileType(this->tile, MP_STATION) || this->type == VEH_SHIP.
+ */
+void Vehicle::BeginLoading()
+{
+	assert(IsTileType(this->tile, MP_STATION) || this->type == VEH_SHIP);
+
+	if (this->current_order.IsType(OT_GOTO_STATION) &&
+			this->current_order.GetDestination() == this->last_station_visited) {
+		this->DeleteUnreachedImplicitOrders();
+
+		/* Now both order indices point to the destination station, and we can start loading */
+		this->current_order.MakeLoading(true);
+		UpdateVehicleTimetable(this, true);
+
+		/* Furthermore add the Non Stop flag to mark that this station
+		 * is the actual destination of the vehicle, which is (for example)
+		 * necessary to be known for HandleTrainLoading to determine
+		 * whether the train is lost or not; not marking a train lost
+		 * that arrives at random stations is bad. */
+		this->current_order.SetNonStopType(ONSF_NO_STOP_AT_ANY_STATION);
+
+	} else {
+		/* We weren't scheduled to stop here. Insert an implicit order
+		 * to show that we are stopping here, but only do that if the order
+		 * list isn't empty.
+		 * While only groundvehicles have implicit orders, e.g. aircraft might still enter
+		 * the 'wrong' terminal when skipping orders etc. */
+		Order *in_list = this->GetOrder(this->cur_implicit_order_index);
+		if (this->IsGroundVehicle() && in_list != NULL &&
+				(!in_list->IsType(OT_IMPLICIT) ||
+				in_list->GetDestination() != this->last_station_visited)) {
+			bool suppress_implicit_orders = HasBit(this->GetGroundVehicleFlags(), GVF_SUPPRESS_IMPLICIT_ORDERS);
+			/* Do not create consecutive duplicates of implicit orders */
+			Order *prev_order = this->cur_implicit_order_index > 0 ? this->GetOrder(this->cur_implicit_order_index - 1) : (this->GetNumOrders() > 1 ? this->GetLastOrder() : NULL);
+			if (prev_order == NULL ||
+					(!prev_order->IsType(OT_IMPLICIT) && !prev_order->IsType(OT_GOTO_STATION)) ||
+					prev_order->GetDestination() != this->last_station_visited) {
+
+				/* Prefer deleting implicit orders instead of inserting new ones,
+				 * so test whether the right order follows later */
+				int target_index = this->cur_implicit_order_index;
+				bool found = false;
+				while (target_index != this->cur_real_order_index) {
+					const Order *order = this->GetOrder(target_index);
+					if (order->IsType(OT_IMPLICIT) && order->GetDestination() == this->last_station_visited) {
+						found = true;
+						break;
+					}
+					target_index++;
+					if (target_index >= this->orders.list->GetNumOrders()) target_index = 0;
+					assert(target_index != this->cur_implicit_order_index); // infinite loop?
+				}
+
+				if (found) {
+					if (suppress_implicit_orders) {
+						/* Skip to the found order */
+						this->cur_implicit_order_index = target_index;
+						InvalidateVehicleOrder(this, 0);
+					} else {
+						/* Delete all implicit orders up to the station we just reached */
+						const Order *order = this->GetOrder(this->cur_implicit_order_index);
+						while (!order->IsType(OT_IMPLICIT) || order->GetDestination() != this->last_station_visited) {
+							if (order->IsType(OT_IMPLICIT)) {
+								DeleteOrder(this, this->cur_implicit_order_index);
+								/* DeleteOrder does various magic with order_indices, so resync 'order' with 'cur_implicit_order_index' */
+								order = this->GetOrder(this->cur_implicit_order_index);
+							} else {
+								/* Skip non-implicit orders, e.g. service-orders */
+								order = order->next;
+								this->cur_implicit_order_index++;
+							}
+
+							/* Wrap around */
+							if (order == NULL) {
+								order = this->GetOrder(0);
+								this->cur_implicit_order_index = 0;
+							}
+							assert(order != NULL);
+						}
+					}
+				} else if (!suppress_implicit_orders && this->orders.list->GetNumOrders() < MAX_VEH_ORDER_ID && Order::CanAllocateItem()) {
+					/* Insert new implicit order */
+					Order *implicit_order = new Order();
+					implicit_order->MakeImplicit(this->last_station_visited);
+					InsertOrder(this, implicit_order, this->cur_implicit_order_index);
+					if (this->cur_implicit_order_index > 0) --this->cur_implicit_order_index;
+
+					/* InsertOrder disabled creation of implicit orders for all vehicles with the same implicit order.
+					 * Reenable it for this vehicle */
+					uint16 &gv_flags = this->GetGroundVehicleFlags();
+					ClrBit(gv_flags, GVF_SUPPRESS_IMPLICIT_ORDERS);
+				}
+			}
+		}
+		this->current_order.MakeLoading(false);
+	}
+
+	Station::Get(this->last_station_visited)->loading_vehicles.push_back(this);
+
+	PrepareUnload(this);
+
+	SetWindowDirty(GetWindowClassForVehicleType(this->type), this->owner);
+	SetWindowWidgetDirty(WC_VEHICLE_VIEW, this->index, WID_VV_START_STOP);
+	SetWindowDirty(WC_VEHICLE_DETAILS, this->index);
+	SetWindowDirty(WC_STATION_VIEW, this->last_station_visited);
+
+	Station::Get(this->last_station_visited)->MarkTilesDirty(true);
+	this->cur_speed = 0;
+	this->MarkDirty();
+}
+
+/**
+ * Return all reserved cargo packets to the station.
+ * @param st the station where the reserved packets should go.
+ */
+void Vehicle::CancelReservation(Station *st)
+{
+	for (Vehicle *v = this; v != NULL; v = v->next) {
+		VehicleCargoList &cargo = v->cargo;
+		if (cargo.ActionCount(VehicleCargoList::MTA_LOAD) > 0) {
+			DEBUG(misc, 1, "cancelling cargo reservation");
+			cargo.Return(UINT_MAX, &st->goods[v->cargo_type].cargo);
+			cargo.KeepAll();
+		}
+	}
+}
+
+/**
+ * Perform all actions when leaving a station.
+ * @pre this->current_order.IsType(OT_LOADING)
+ */
+void Vehicle::LeaveStation()
+{
+	assert(this->current_order.IsType(OT_LOADING));
+
+	delete this->cargo_payment;
+
+	/* Only update the timetable if the vehicle was supposed to stop here. */
+	if (this->current_order.GetNonStopType() != ONSF_STOP_EVERYWHERE) UpdateVehicleTimetable(this, false);
+
+	this->current_order.MakeLeaveStation();
+	Station *st = Station::Get(this->last_station_visited);
+	this->CancelReservation(st);
+	st->loading_vehicles.remove(this);
+
+	HideFillingPercent(&this->fill_percent_te_id);
+
+	if (this->type == VEH_TRAIN && !(this->vehstatus & VS_CRASHED)) {
+		/* Trigger station animation (trains only) */
+		if (IsTileType(this->tile, MP_STATION)) {
+			TriggerStationRandomisation(st, this->tile, SRT_TRAIN_DEPARTS);
+			TriggerStationAnimation(st, this->tile, SAT_TRAIN_DEPARTS);
+		}
+
+		SetBit(Train::From(this)->flags, VRF_LEAVING_STATION);
+	}
+}
+
+
+/**
+ * Handle the loading of the vehicle; when not it skips through dummy
+ * orders and does nothing in all other cases.
+ * @param mode is the non-first call for this vehicle in this tick?
+ */
+void Vehicle::HandleLoading(bool mode)
+{
+	switch (this->current_order.GetType()) {
+		case OT_LOADING: {
+			uint wait_time = max(this->current_order.wait_time - this->lateness_counter, 0);
+
+			/* Not the first call for this tick, or still loading */
+			if (mode || !HasBit(this->vehicle_flags, VF_LOADING_FINISHED) || this->current_order_time < wait_time) return;
+
+			this->PlayLeaveStationSound();
+
+			this->LeaveStation();
+
+			/* Only advance to next order if we just loaded at the current one */
+			const Order *order = this->GetOrder(this->cur_implicit_order_index);
+			if (order == NULL ||
+					(!order->IsType(OT_IMPLICIT) && !order->IsType(OT_GOTO_STATION)) ||
+					order->GetDestination() != this->last_station_visited) {
+				return;
+			}
+			break;
+		}
+
+		case OT_DUMMY: break;
+
+		default: return;
+	}
+
+	this->IncrementImplicitOrderIndex();
+}
+
+/**
+ * Send this vehicle to the depot using the given command(s).
+ * @param flags   the command flags (like execute and such).
+ * @param command the command to execute.
+ * @return the cost of the depot action.
+ */
+CommandCost Vehicle::SendToDepot(DoCommandFlag flags, DepotCommand command)
+{
+	CommandCost ret = CheckOwnership(this->owner);
+	if (ret.Failed()) return ret;
+
+	if (this->vehstatus & VS_CRASHED) return CMD_ERROR;
+	if (this->IsStoppedInDepot()) return CMD_ERROR;
+
+	if (this->current_order.IsType(OT_GOTO_DEPOT)) {
+		bool halt_in_depot = (this->current_order.GetDepotActionType() & ODATFB_HALT) != 0;
+		if (!!(command & DEPOT_SERVICE) == halt_in_depot) {
+			/* We called with a different DEPOT_SERVICE setting.
+			 * Now we change the setting to apply the new one and let the vehicle head for the same depot.
+			 * Note: the if is (true for requesting service == true for ordered to stop in depot)          */
+			if (flags & DC_EXEC) {
+				this->current_order.SetDepotOrderType(ODTF_MANUAL);
+				this->current_order.SetDepotActionType(halt_in_depot ? ODATF_SERVICE_ONLY : ODATFB_HALT);
+				SetWindowWidgetDirty(WC_VEHICLE_VIEW, this->index, WID_VV_START_STOP);
+			}
+			return CommandCost();
+		}
+
+		if (command & DEPOT_DONT_CANCEL) return CMD_ERROR; // Requested no cancelation of depot orders
+		if (flags & DC_EXEC) {
+			/* If the orders to 'goto depot' are in the orders list (forced servicing),
+			 * then skip to the next order; effectively cancelling this forced service */
+			if (this->current_order.GetDepotOrderType() & ODTFB_PART_OF_ORDERS) this->IncrementRealOrderIndex();
+
+			if (this->IsGroundVehicle()) {
+				uint16 &gv_flags = this->GetGroundVehicleFlags();
+				SetBit(gv_flags, GVF_SUPPRESS_IMPLICIT_ORDERS);
+			}
+
+			this->current_order.MakeDummy();
+			SetWindowWidgetDirty(WC_VEHICLE_VIEW, this->index, WID_VV_START_STOP);
+		}
+		return CommandCost();
+	}
+
+	TileIndex location;
+	DestinationID destination;
+	bool reverse;
+	static const StringID no_depot[] = {STR_ERROR_UNABLE_TO_FIND_ROUTE_TO, STR_ERROR_UNABLE_TO_FIND_LOCAL_DEPOT, STR_ERROR_UNABLE_TO_FIND_LOCAL_DEPOT, STR_ERROR_CAN_T_SEND_AIRCRAFT_TO_HANGAR};
+	if (!this->FindClosestDepot(&location, &destination, &reverse)) return_cmd_error(no_depot[this->type]);
+
+	if (flags & DC_EXEC) {
+		if (this->current_order.IsType(OT_LOADING)) this->LeaveStation();
+
+		if (this->IsGroundVehicle()) {
+			uint16 &gv_flags = this->GetGroundVehicleFlags();
+			SetBit(gv_flags, GVF_SUPPRESS_IMPLICIT_ORDERS);
+		}
+
+		this->dest_tile = location;
+		this->current_order.MakeGoToDepot(destination, ODTF_MANUAL);
+		if (!(command & DEPOT_SERVICE)) this->current_order.SetDepotActionType(ODATFB_HALT);
+		SetWindowWidgetDirty(WC_VEHICLE_VIEW, this->index, WID_VV_START_STOP);
+
+		/* If there is no depot in front, reverse automatically (trains only) */
+		if (this->type == VEH_TRAIN && reverse) DoCommand(this->tile, this->index, 0, DC_EXEC, CMD_REVERSE_TRAIN_DIRECTION);
+
+		if (this->type == VEH_AIRCRAFT) {
+			Aircraft *a = Aircraft::From(this);
+			if (a->state == FLYING && a->targetairport != destination) {
+				/* The aircraft is now heading for a different hangar than the next in the orders */
+				extern void AircraftNextAirportPos_and_Order(Aircraft *a);
+				AircraftNextAirportPos_and_Order(a);
+			}
+		}
+	}
+
+	return CommandCost();
+
+}
+
+/**
+ * Update the cached visual effect.
+ * @param allow_power_change true if the wagon-is-powered-state may change.
+ */
+void Vehicle::UpdateVisualEffect(bool allow_power_change)
+{
+	bool powered_before = HasBit(this->vcache.cached_vis_effect, VE_DISABLE_WAGON_POWER);
+	const Engine *e = this->GetEngine();
+
+	/* Evaluate properties */
+	byte visual_effect;
+	switch (e->type) {
+		case VEH_TRAIN: visual_effect = e->u.rail.visual_effect; break;
+		case VEH_ROAD:  visual_effect = e->u.road.visual_effect; break;
+		case VEH_SHIP:  visual_effect = e->u.ship.visual_effect; break;
+		default:        visual_effect = 1 << VE_DISABLE_EFFECT;  break;
+	}
+
+	/* Check powered wagon / visual effect callback */
+	if (HasBit(e->info.callback_mask, CBM_VEHICLE_VISUAL_EFFECT)) {
+		uint16 callback = GetVehicleCallback(CBID_VEHICLE_VISUAL_EFFECT, 0, 0, this->engine_type, this);
+
+		if (callback != CALLBACK_FAILED) {
+			if (callback >= 0x100 && e->GetGRF()->grf_version >= 8) ErrorUnknownCallbackResult(e->GetGRFID(), CBID_VEHICLE_VISUAL_EFFECT, callback);
+
+			callback = GB(callback, 0, 8);
+			/* Avoid accidentally setting 'visual_effect' to the default value
+			 * Since bit 6 (disable effects) is set anyways, we can safely erase some bits. */
+			if (callback == VE_DEFAULT) {
+				assert(HasBit(callback, VE_DISABLE_EFFECT));
+				SB(callback, VE_TYPE_START, VE_TYPE_COUNT, 0);
+			}
+			visual_effect = callback;
+		}
+	}
+
+	/* Apply default values */
+	if (visual_effect == VE_DEFAULT ||
+			(!HasBit(visual_effect, VE_DISABLE_EFFECT) && GB(visual_effect, VE_TYPE_START, VE_TYPE_COUNT) == VE_TYPE_DEFAULT)) {
+		/* Only train engines have default effects.
+		 * Note: This is independent of whether the engine is a front engine or articulated part or whatever. */
+		if (e->type != VEH_TRAIN || e->u.rail.railveh_type == RAILVEH_WAGON || !IsInsideMM(e->u.rail.engclass, EC_STEAM, EC_MONORAIL)) {
+			if (visual_effect == VE_DEFAULT) {
+				visual_effect = 1 << VE_DISABLE_EFFECT;
+			} else {
+				SetBit(visual_effect, VE_DISABLE_EFFECT);
+			}
+		} else {
+			if (visual_effect == VE_DEFAULT) {
+				/* Also set the offset */
+				visual_effect = (VE_OFFSET_CENTRE - (e->u.rail.engclass == EC_STEAM ? 4 : 0)) << VE_OFFSET_START;
+			}
+			SB(visual_effect, VE_TYPE_START, VE_TYPE_COUNT, e->u.rail.engclass - EC_STEAM + VE_TYPE_STEAM);
+		}
+	}
+
+	this->vcache.cached_vis_effect = visual_effect;
+
+	if (!allow_power_change && powered_before != HasBit(this->vcache.cached_vis_effect, VE_DISABLE_WAGON_POWER)) {
+		ToggleBit(this->vcache.cached_vis_effect, VE_DISABLE_WAGON_POWER);
+		ShowNewGrfVehicleError(this->engine_type, STR_NEWGRF_BROKEN, STR_NEWGRF_BROKEN_POWERED_WAGON, GBUG_VEH_POWERED_WAGON, false);
+	}
+}
+
+static const int8 _vehicle_smoke_pos[8] = {
+	1, 1, 1, 0, -1, -1, -1, 0
+};
+
+/**
+ * Draw visual effects (smoke and/or sparks) for a vehicle chain.
+ * @pre this->IsPrimaryVehicle()
+ */
+void Vehicle::ShowVisualEffect() const
+{
+	assert(this->IsPrimaryVehicle());
+	bool sound = false;
+
+	/* Do not show any smoke when:
+	 * - vehicle smoke is disabled by the player
+	 * - the vehicle is slowing down or stopped (by the player)
+	 * - the vehicle is moving very slowly
+	 */
+	if (_settings_game.vehicle.smoke_amount == 0 ||
+			this->vehstatus & (VS_TRAIN_SLOWING | VS_STOPPED) ||
+			this->cur_speed < 2) {
+		return;
+	}
+
+	uint max_speed = this->vcache.cached_max_speed;
+	if (this->type == VEH_TRAIN) {
+		const Train *t = Train::From(this);
+		/* For trains, do not show any smoke when:
+		 * - the train is reversing
+		 * - is entering a station with an order to stop there and its speed is equal to maximum station entering speed
+		 */
+		if (HasBit(t->flags, VRF_REVERSING) ||
+				(IsRailStationTile(t->tile) && t->IsFrontEngine() && t->current_order.ShouldStopAtStation(t, GetStationIndex(t->tile)) &&
+				t->cur_speed >= t->Train::GetCurrentMaxSpeed())) {
+			return;
+		}
+
+		max_speed = min(max_speed, t->gcache.cached_max_track_speed);
+		max_speed = min(max_speed, this->current_order.max_speed);
+	}
+	if (this->type == VEH_ROAD || this->type == VEH_SHIP) max_speed = min(max_speed, this->current_order.max_speed * 2);
+
+	const Vehicle *v = this;
+
+	do {
+		int effect_offset = GB(v->vcache.cached_vis_effect, VE_OFFSET_START, VE_OFFSET_COUNT) - VE_OFFSET_CENTRE;
+		byte effect_type = GB(v->vcache.cached_vis_effect, VE_TYPE_START, VE_TYPE_COUNT);
+		bool disable_effect = HasBit(v->vcache.cached_vis_effect, VE_DISABLE_EFFECT);
+
+		/* Show no smoke when:
+		 * - Smoke has been disabled for this vehicle
+		 * - The vehicle is not visible
+		 * - The vehicle is under a bridge
+		 * - The vehicle is on a depot tile
+		 * - The vehicle is on a tunnel tile
+		 * - The vehicle is a train engine that is currently unpowered */
+		if (disable_effect ||
+				v->vehstatus & VS_HIDDEN ||
+				(MayHaveBridgeAbove(v->tile) && IsBridgeAbove(v->tile)) ||
+				IsDepotTile(v->tile) ||
+				IsTunnelTile(v->tile) ||
+				(v->type == VEH_TRAIN &&
+				!HasPowerOnRail(Train::From(v)->railtype, GetTileRailType(v->tile)))) {
+			continue;
+		}
+
+		/* The effect offset is relative to a point 4 units behind the vehicle's
+		 * front (which is the center of an 8/8 vehicle). Shorter vehicles need a
+		 * correction factor. */
+		if (v->type == VEH_TRAIN) effect_offset += (VEHICLE_LENGTH - Train::From(v)->gcache.cached_veh_length) / 2;
+
+		int x = _vehicle_smoke_pos[v->direction] * effect_offset;
+		int y = _vehicle_smoke_pos[(v->direction + 2) % 8] * effect_offset;
+
+		if (v->type == VEH_TRAIN && HasBit(Train::From(v)->flags, VRF_REVERSE_DIRECTION)) {
+			x = -x;
+			y = -y;
+		}
+
+		switch (effect_type) {
+			case VE_TYPE_STEAM:
+				/* Steam smoke - amount is gradually falling until vehicle reaches its maximum speed, after that it's normal.
+				 * Details: while vehicle's current speed is gradually increasing, steam plumes' density decreases by one third each
+				 * third of its maximum speed spectrum. Steam emission finally normalises at very close to vehicle's maximum speed.
+				 * REGULATION:
+				 * - instead of 1, 4 / 2^smoke_amount (max. 2) is used to provide sufficient regulation to steam puffs' amount. */
+				if (GB(v->tick_counter, 0, ((4 >> _settings_game.vehicle.smoke_amount) + ((this->cur_speed * 3) / max_speed))) == 0) {
+					CreateEffectVehicleRel(v, x, y, 10, EV_STEAM_SMOKE);
+					sound = true;
+				}
+				break;
+
+			case VE_TYPE_DIESEL: {
+				/* Diesel smoke - thicker when vehicle is starting, gradually subsiding till it reaches its maximum speed
+				 * when smoke emission stops.
+				 * Details: Vehicle's (max.) speed spectrum is divided into 32 parts. When max. speed is reached, chance for smoke
+				 * emission erodes by 32 (1/4). For trains, power and weight come in handy too to either increase smoke emission in
+				 * 6 steps (1000HP each) if the power is low or decrease smoke emission in 6 steps (512 tonnes each) if the train
+				 * isn't overweight. Power and weight contributions are expressed in a way that neither extreme power, nor
+				 * extreme weight can ruin the balance (e.g. FreightWagonMultiplier) in the formula. When the vehicle reaches
+				 * maximum speed no diesel_smoke is emitted.
+				 * REGULATION:
+				 * - up to which speed a diesel vehicle is emitting smoke (with reduced/small setting only until 1/2 of max_speed),
+				 * - in Chance16 - the last value is 512 / 2^smoke_amount (max. smoke when 128 = smoke_amount of 2). */
+				int power_weight_effect = 0;
+				if (v->type == VEH_TRAIN) {
+					power_weight_effect = (32 >> (Train::From(this)->gcache.cached_power >> 10)) - (32 >> (Train::From(this)->gcache.cached_weight >> 9));
+				}
+				if (this->cur_speed < (max_speed >> (2 >> _settings_game.vehicle.smoke_amount)) &&
+						Chance16((64 - ((this->cur_speed << 5) / max_speed) + power_weight_effect), (512 >> _settings_game.vehicle.smoke_amount))) {
+					CreateEffectVehicleRel(v, x, y, 10, EV_DIESEL_SMOKE);
+					sound = true;
+				}
+				break;
+			}
+
+			case VE_TYPE_ELECTRIC:
+				/* Electric train's spark - more often occurs when train is departing (more load)
+				 * Details: Electric locomotives are usually at least twice as powerful as their diesel counterparts, so spark
+				 * emissions are kept simple. Only when starting, creating huge force are sparks more likely to happen, but when
+				 * reaching its max. speed, quarter by quarter of it, chance decreases until the usual 2,22% at train's top speed.
+				 * REGULATION:
+				 * - in Chance16 the last value is 360 / 2^smoke_amount (max. sparks when 90 = smoke_amount of 2). */
+				if (GB(v->tick_counter, 0, 2) == 0 &&
+						Chance16((6 - ((this->cur_speed << 2) / max_speed)), (360 >> _settings_game.vehicle.smoke_amount))) {
+					CreateEffectVehicleRel(v, x, y, 10, EV_ELECTRIC_SPARK);
+					sound = true;
+				}
+				break;
+
+			default:
+				break;
+		}
+	} while ((v = v->Next()) != NULL);
+
+	if (sound) PlayVehicleSound(this, VSE_VISUAL_EFFECT);
+}
+
+/**
+ * Set the next vehicle of this vehicle.
+ * @param next the next vehicle. NULL removes the next vehicle.
+ */
+void Vehicle::SetNext(Vehicle *next)
+{
+	assert(this != next);
+
+	if (this->next != NULL) {
+		/* We had an old next vehicle. Update the first and previous pointers */
+		for (Vehicle *v = this->next; v != NULL; v = v->Next()) {
+			v->first = this->next;
+		}
+		this->next->previous = NULL;
+	}
+
+	this->next = next;
+
+	if (this->next != NULL) {
+		/* A new next vehicle. Update the first and previous pointers */
+		if (this->next->previous != NULL) this->next->previous->next = NULL;
+		this->next->previous = this;
+		for (Vehicle *v = this->next; v != NULL; v = v->Next()) {
+			v->first = this->first;
+		}
+	}
+}
+
+/**
+ * Adds this vehicle to a shared vehicle chain.
+ * @param shared_chain a vehicle of the chain with shared vehicles.
+ * @pre !this->IsOrderListShared()
+ */
+void Vehicle::AddToShared(Vehicle *shared_chain)
+{
+	assert(this->previous_shared == NULL && this->next_shared == NULL);
+
+	if (shared_chain->orders.list == NULL) {
+		assert(shared_chain->previous_shared == NULL);
+		assert(shared_chain->next_shared == NULL);
+		this->orders.list = shared_chain->orders.list = new OrderList(NULL, shared_chain);
+	}
+
+	this->next_shared     = shared_chain->next_shared;
+	this->previous_shared = shared_chain;
+
+	shared_chain->next_shared = this;
+
+	if (this->next_shared != NULL) this->next_shared->previous_shared = this;
+
+	shared_chain->orders.list->AddVehicle(this);
+}
+
+/**
+ * Removes the vehicle from the shared order list.
+ */
+void Vehicle::RemoveFromShared()
+{
+	/* Remember if we were first and the old window number before RemoveVehicle()
+	 * as this changes first if needed. */
+	bool were_first = (this->FirstShared() == this);
+	VehicleListIdentifier vli(VL_SHARED_ORDERS, this->type, this->owner, this->FirstShared()->index);
+
+	this->orders.list->RemoveVehicle(this);
+
+	if (!were_first) {
+		/* We are not the first shared one, so only relink our previous one. */
+		this->previous_shared->next_shared = this->NextShared();
+	}
+
+	if (this->next_shared != NULL) this->next_shared->previous_shared = this->previous_shared;
+
+
+	if (this->orders.list->GetNumVehicles() == 1) {
+		/* When there is only one vehicle, remove the shared order list window. */
+		DeleteWindowById(GetWindowClassForVehicleType(this->type), vli.Pack());
+		InvalidateVehicleOrder(this->FirstShared(), 0);
+	} else if (were_first) {
+		/* If we were the first one, update to the new first one.
+		 * Note: FirstShared() is already the new first */
+		InvalidateWindowData(GetWindowClassForVehicleType(this->type), vli.Pack(), this->FirstShared()->index | (1U << 31));
+	}
+
+	this->next_shared     = NULL;
+	this->previous_shared = NULL;
+}
+
+void VehiclesYearlyLoop()
+{
+	Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		if (v->IsPrimaryVehicle()) {
+			/* show warning if vehicle is not generating enough income last 2 years (corresponds to a red icon in the vehicle list) */
+			Money profit = v->GetDisplayProfitThisYear();
+			if (v->age >= 730 && profit < 0) {
+				if (_settings_client.gui.vehicle_income_warn && v->owner == _local_company) {
+					SetDParam(0, v->index);
+					SetDParam(1, profit);
+					AddVehicleAdviceNewsItem(STR_NEWS_VEHICLE_IS_UNPROFITABLE, v->index);
+				}
+				AI::NewEvent(v->owner, new ScriptEventVehicleUnprofitable(v->index));
+			}
+
+			v->profit_last_year = v->profit_this_year;
+			v->profit_this_year = 0;
+			SetWindowDirty(WC_VEHICLE_DETAILS, v->index);
+		}
+	}
+	GroupStatistics::UpdateProfits();
+	SetWindowClassesDirty(WC_TRAINS_LIST);
+	SetWindowClassesDirty(WC_SHIPS_LIST);
+	SetWindowClassesDirty(WC_ROADVEH_LIST);
+	SetWindowClassesDirty(WC_AIRCRAFT_LIST);
+}
+
+
+/**
+ * Can this station be used by the given engine type?
+ * @param engine_type the type of vehicles to test
+ * @param st the station to test for
+ * @return true if and only if the vehicle of the type can use this station.
+ * @note For road vehicles the Vehicle is needed to determine whether it can
+ *       use the station. This function will return true for road vehicles
+ *       when at least one of the facilities is available.
+ */
+bool CanVehicleUseStation(EngineID engine_type, const Station *st)
+{
+	const Engine *e = Engine::GetIfValid(engine_type);
+	assert(e != NULL);
+
+	switch (e->type) {
+		case VEH_TRAIN:
+			return (st->facilities & FACIL_TRAIN) != 0;
+
+		case VEH_ROAD:
+			/* For road vehicles we need the vehicle to know whether it can actually
+			 * use the station, but if it doesn't have facilities for RVs it is
+			 * certainly not possible that the station can be used. */
+			return (st->facilities & (FACIL_BUS_STOP | FACIL_TRUCK_STOP)) != 0;
+
+		case VEH_SHIP:
+			return (st->facilities & FACIL_DOCK) != 0;
+
+		case VEH_AIRCRAFT:
+			return (st->facilities & FACIL_AIRPORT) != 0 &&
+					(st->airport.GetFTA()->flags & (e->u.air.subtype & AIR_CTOL ? AirportFTAClass::AIRPLANES : AirportFTAClass::HELICOPTERS)) != 0;
+
+		default:
+			return false;
+	}
+}
+
+/**
+ * Can this station be used by the given vehicle?
+ * @param v the vehicle to test
+ * @param st the station to test for
+ * @return true if and only if the vehicle can use this station.
+ */
+bool CanVehicleUseStation(const Vehicle *v, const Station *st)
+{
+	if (v->type == VEH_ROAD) return st->GetPrimaryRoadStop(RoadVehicle::From(v)) != NULL;
+
+	return CanVehicleUseStation(v->engine_type, st);
+}
+
+/**
+ * Access the ground vehicle cache of the vehicle.
+ * @pre The vehicle is a #GroundVehicle.
+ * @return #GroundVehicleCache of the vehicle.
+ */
+GroundVehicleCache *Vehicle::GetGroundVehicleCache()
+{
+	assert(this->IsGroundVehicle());
+	if (this->type == VEH_TRAIN) {
+		return &Train::From(this)->gcache;
+	} else {
+		return &RoadVehicle::From(this)->gcache;
+	}
+}
+
+/**
+ * Access the ground vehicle cache of the vehicle.
+ * @pre The vehicle is a #GroundVehicle.
+ * @return #GroundVehicleCache of the vehicle.
+ */
+const GroundVehicleCache *Vehicle::GetGroundVehicleCache() const
+{
+	assert(this->IsGroundVehicle());
+	if (this->type == VEH_TRAIN) {
+		return &Train::From(this)->gcache;
+	} else {
+		return &RoadVehicle::From(this)->gcache;
+	}
+}
+
+/**
+ * Access the ground vehicle flags of the vehicle.
+ * @pre The vehicle is a #GroundVehicle.
+ * @return #GroundVehicleFlags of the vehicle.
+ */
+uint16 &Vehicle::GetGroundVehicleFlags()
+{
+	assert(this->IsGroundVehicle());
+	if (this->type == VEH_TRAIN) {
+		return Train::From(this)->gv_flags;
+	} else {
+		return RoadVehicle::From(this)->gv_flags;
+	}
+}
+
+/**
+ * Access the ground vehicle flags of the vehicle.
+ * @pre The vehicle is a #GroundVehicle.
+ * @return #GroundVehicleFlags of the vehicle.
+ */
+const uint16 &Vehicle::GetGroundVehicleFlags() const
+{
+	assert(this->IsGroundVehicle());
+	if (this->type == VEH_TRAIN) {
+		return Train::From(this)->gv_flags;
+	} else {
+		return RoadVehicle::From(this)->gv_flags;
+	}
+}
+
+/**
+ * Calculates the set of vehicles that will be affected by a given selection.
+ * @param set [inout] Set of affected vehicles.
+ * @param v First vehicle of the selection.
+ * @param num_vehicles Number of vehicles in the selection (not counting articulated parts).
+ * @pre \a set must be empty.
+ * @post \a set will contain the vehicles that will be refitted.
+ */
+void GetVehicleSet(VehicleSet &set, Vehicle *v, uint8 num_vehicles)
+{
+	if (v->type == VEH_TRAIN) {
+		Train *u = Train::From(v);
+		/* Only include whole vehicles, so start with the first articulated part */
+		u = u->GetFirstEnginePart();
+
+		/* Include num_vehicles vehicles, not counting articulated parts */
+		for (; u != NULL && num_vehicles > 0; num_vehicles--) {
+			do {
+				/* Include current vehicle in the selection. */
+				set.Include(u->index);
+
+				/* If the vehicle is multiheaded, add the other part too. */
+				if (u->IsMultiheaded()) set.Include(u->other_multiheaded_part->index);
+
+				u = u->Next();
+			} while (u != NULL && u->IsArticulatedPart());
+		}
+	}
+}
diff --git a/src/vehicle_base.h b/src/vehicle_base.h
index 7b40d48..9c45c3a 100644
--- a/src/vehicle_base.h
+++ b/src/vehicle_base.h
@@ -23,6 +23,8 @@
 #include "group_type.h"
 #include "base_consist.h"
 
+CommandCost CmdRefitVehicle(TileIndex, DoCommandFlag, uint32, uint32, const char*);
+
 /** Vehicle status bits in #Vehicle::vehstatus. */
 enum VehStatus {
 	VS_HIDDEN          = 0x01, ///< Vehicle is not visible.
@@ -92,6 +94,7 @@ enum VisualEffect {
  * This is defined here instead of at #GroundVehicle because some common function require access to these flags.
  * Do not access it directly unless you have to. Use the subtype access functions.
  */
+// MYGUI appended virtual subtype
 enum GroundVehicleSubtypeFlags {
 	GVSF_FRONT            = 0, ///< Leading engine of a consist.
 	GVSF_ARTICULATED_PART = 1, ///< Articulated part of an engine.
@@ -99,6 +102,7 @@ enum GroundVehicleSubtypeFlags {
 	GVSF_ENGINE           = 3, ///< Engine that can be front engine, but might be placed behind another engine (not used for road vehicles).
 	GVSF_FREE_WAGON       = 4, ///< First in a wagon chain (in depot) (not used for road vehicles).
 	GVSF_MULTIHEADED      = 5, ///< Engine is multiheaded (not used for road vehicles).
+	GVSF_VIRTUAL		  = 6, ///< Used for virtual trains during template design, needed to skip checks for tile or depot status
 };
 
 /** Cached often queried values common to all vehicles. */
@@ -477,6 +481,7 @@ public:
 	Money GetDisplayProfitLastYear() const { return (this->profit_last_year >> 8); }
 
 	void SetNext(Vehicle *next);
+	inline void SetFirst(Vehicle *f) { this->first=f; }
 
 	/**
 	 * Get the next vehicle of this vehicle.
diff --git a/src/vehicle_base.h.orig b/src/vehicle_base.h.orig
new file mode 100644
index 0000000..7b40d48
--- /dev/null
+++ b/src/vehicle_base.h.orig
@@ -0,0 +1,1078 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file  vehicle_base.h Base class for all vehicles. */
+
+#ifndef VEHICLE_BASE_H
+#define VEHICLE_BASE_H
+
+#include "track_type.h"
+#include "command_type.h"
+#include "order_base.h"
+#include "cargopacket.h"
+#include "texteff.hpp"
+#include "engine_type.h"
+#include "order_func.h"
+#include "transport_type.h"
+#include "group_type.h"
+#include "base_consist.h"
+
+/** Vehicle status bits in #Vehicle::vehstatus. */
+enum VehStatus {
+	VS_HIDDEN          = 0x01, ///< Vehicle is not visible.
+	VS_STOPPED         = 0x02, ///< Vehicle is stopped by the player.
+	VS_UNCLICKABLE     = 0x04, ///< Vehicle is not clickable by the user (shadow vehicles).
+	VS_DEFPAL          = 0x08, ///< Use default vehicle palette. @see DoDrawVehicle
+	VS_TRAIN_SLOWING   = 0x10, ///< Train is slowing down.
+	VS_SHADOW          = 0x20, ///< Vehicle is a shadow vehicle.
+	VS_AIRCRAFT_BROKEN = 0x40, ///< Aircraft is broken down.
+	VS_CRASHED         = 0x80, ///< Vehicle is crashed.
+};
+
+/** Bit numbers in #Vehicle::vehicle_flags. */
+enum VehicleFlags {
+	VF_LOADING_FINISHED,        ///< Vehicle has finished loading.
+	VF_CARGO_UNLOADING,         ///< Vehicle is unloading cargo.
+	VF_BUILT_AS_PROTOTYPE,      ///< Vehicle is a prototype (accepted as exclusive preview).
+	VF_TIMETABLE_STARTED,       ///< Whether the vehicle has started running on the timetable yet.
+	VF_AUTOFILL_TIMETABLE,      ///< Whether the vehicle should fill in the timetable automatically.
+	VF_AUTOFILL_PRES_WAIT_TIME, ///< Whether non-destructive auto-fill should preserve waiting times
+	VF_STOP_LOADING,            ///< Don't load anymore during the next load cycle.
+	VF_PATHFINDER_LOST,         ///< Vehicle's pathfinder is lost.
+	VF_SERVINT_IS_CUSTOM,       ///< Service interval is custom.
+	VF_SERVINT_IS_PERCENT,      ///< Service interval is percent.
+};
+
+/** Bit numbers used to indicate which of the #NewGRFCache values are valid. */
+enum NewGRFCacheValidValues {
+	NCVV_POSITION_CONSIST_LENGTH   = 0, ///< This bit will be set if the NewGRF var 40 currently stored is valid.
+	NCVV_POSITION_SAME_ID_LENGTH   = 1, ///< This bit will be set if the NewGRF var 41 currently stored is valid.
+	NCVV_CONSIST_CARGO_INFORMATION = 2, ///< This bit will be set if the NewGRF var 42 currently stored is valid.
+	NCVV_COMPANY_INFORMATION       = 3, ///< This bit will be set if the NewGRF var 43 currently stored is valid.
+	NCVV_END,                           ///< End of the bits.
+};
+
+/** Cached often queried (NewGRF) values */
+struct NewGRFCache {
+	/* Values calculated when they are requested for the first time after invalidating the NewGRF cache. */
+	uint32 position_consist_length;   ///< Cache for NewGRF var 40.
+	uint32 position_same_id_length;   ///< Cache for NewGRF var 41.
+	uint32 consist_cargo_information; ///< Cache for NewGRF var 42. (Note: The cargotype is untranslated in the cache because the accessing GRF is yet unknown.)
+	uint32 company_information;       ///< Cache for NewGRF var 43.
+	uint8  cache_valid;               ///< Bitset that indicates which cache values are valid.
+};
+
+/** Meaning of the various bits of the visual effect. */
+enum VisualEffect {
+	VE_OFFSET_START        = 0, ///< First bit that contains the offset (0 = front, 8 = centre, 15 = rear)
+	VE_OFFSET_COUNT        = 4, ///< Number of bits used for the offset
+	VE_OFFSET_CENTRE       = 8, ///< Value of offset corresponding to a position above the centre of the vehicle
+
+	VE_TYPE_START          = 4, ///< First bit used for the type of effect
+	VE_TYPE_COUNT          = 2, ///< Number of bits used for the effect type
+	VE_TYPE_DEFAULT        = 0, ///< Use default from engine class
+	VE_TYPE_STEAM          = 1, ///< Steam plumes
+	VE_TYPE_DIESEL         = 2, ///< Diesel fumes
+	VE_TYPE_ELECTRIC       = 3, ///< Electric sparks
+
+	VE_DISABLE_EFFECT      = 6, ///< Flag to disable visual effect
+	VE_DISABLE_WAGON_POWER = 7, ///< Flag to disable wagon power
+
+	VE_DEFAULT = 0xFF,          ///< Default value to indicate that visual effect should be based on engine class
+};
+
+/**
+ * Enum to handle ground vehicle subtypes.
+ * This is defined here instead of at #GroundVehicle because some common function require access to these flags.
+ * Do not access it directly unless you have to. Use the subtype access functions.
+ */
+enum GroundVehicleSubtypeFlags {
+	GVSF_FRONT            = 0, ///< Leading engine of a consist.
+	GVSF_ARTICULATED_PART = 1, ///< Articulated part of an engine.
+	GVSF_WAGON            = 2, ///< Wagon (not used for road vehicles).
+	GVSF_ENGINE           = 3, ///< Engine that can be front engine, but might be placed behind another engine (not used for road vehicles).
+	GVSF_FREE_WAGON       = 4, ///< First in a wagon chain (in depot) (not used for road vehicles).
+	GVSF_MULTIHEADED      = 5, ///< Engine is multiheaded (not used for road vehicles).
+};
+
+/** Cached often queried values common to all vehicles. */
+struct VehicleCache {
+	uint16 cached_max_speed;        ///< Maximum speed of the consist (minimum of the max speed of all vehicles in the consist).
+	uint16 cached_cargo_age_period; ///< Number of ticks before carried cargo is aged.
+
+	byte cached_vis_effect;  ///< Visual effect to show (see #VisualEffect)
+};
+
+/** A vehicle pool for a little over 1 million vehicles. */
+typedef Pool<Vehicle, VehicleID, 512, 0xFF000> VehiclePool;
+extern VehiclePool _vehicle_pool;
+
+/* Some declarations of functions, so we can make them friendly */
+struct SaveLoad;
+struct GroundVehicleCache;
+extern const SaveLoad *GetVehicleDescription(VehicleType vt);
+struct LoadgameState;
+extern bool LoadOldVehicle(LoadgameState *ls, int num);
+extern void FixOldVehicles();
+
+struct GRFFile;
+
+/** %Vehicle data structure. */
+struct Vehicle : VehiclePool::PoolItem<&_vehicle_pool>, BaseVehicle, BaseConsist {
+private:
+	Vehicle *next;                      ///< pointer to the next vehicle in the chain
+	Vehicle *previous;                  ///< NOSAVE: pointer to the previous vehicle in the chain
+	Vehicle *first;                     ///< NOSAVE: pointer to the first vehicle in the chain
+
+	Vehicle *next_shared;               ///< pointer to the next vehicle that shares the order
+	Vehicle *previous_shared;           ///< NOSAVE: pointer to the previous vehicle in the shared order chain
+public:
+	friend const SaveLoad *GetVehicleDescription(VehicleType vt); ///< So we can use private/protected variables in the saveload code
+	friend void FixOldVehicles();
+	friend void AfterLoadVehicles(bool part_of_load);             ///< So we can set the #previous and #first pointers while loading
+	friend bool LoadOldVehicle(LoadgameState *ls, int num);       ///< So we can set the proper next pointer while loading
+
+	TileIndex tile;                     ///< Current tile index
+
+	/**
+	 * Heading for this tile.
+	 * For airports and train stations this tile does not necessarily belong to the destination station,
+	 * but it can be used for heuristic purposes to estimate the distance.
+	 */
+	TileIndex dest_tile;
+
+	Money profit_this_year;             ///< Profit this year << 8, low 8 bits are fract
+	Money profit_last_year;             ///< Profit last year << 8, low 8 bits are fract
+	Money value;                        ///< Value of the vehicle
+
+	CargoPayment *cargo_payment;        ///< The cargo payment we're currently in
+
+	Rect coord;                         ///< NOSAVE: Graphical bounding box of the vehicle, i.e. what to redraw on moves.
+
+	Vehicle *hash_viewport_next;        ///< NOSAVE: Next vehicle in the visual location hash.
+	Vehicle **hash_viewport_prev;       ///< NOSAVE: Previous vehicle in the visual location hash.
+
+	Vehicle *hash_tile_next;            ///< NOSAVE: Next vehicle in the tile location hash.
+	Vehicle **hash_tile_prev;           ///< NOSAVE: Previous vehicle in the tile location hash.
+	Vehicle **hash_tile_current;        ///< NOSAVE: Cache of the current hash chain.
+
+	SpriteID colourmap;                 ///< NOSAVE: cached colour mapping
+
+	/* Related to age and service time */
+	Year build_year;                    ///< Year the vehicle has been built.
+	Date age;                           ///< Age in days
+	Date max_age;                       ///< Maximum age
+	Date date_of_last_service;          ///< Last date the vehicle had a service at a depot.
+	uint16 reliability;                 ///< Reliability.
+	uint16 reliability_spd_dec;         ///< Reliability decrease speed.
+	byte breakdown_ctr;                 ///< Counter for managing breakdown events. @see Vehicle::HandleBreakdown
+	byte breakdown_delay;               ///< Counter for managing breakdown length.
+	byte breakdowns_since_last_service; ///< Counter for the amount of breakdowns.
+	byte breakdown_chance;              ///< Current chance of breakdowns.
+
+	int32 x_pos;                        ///< x coordinate.
+	int32 y_pos;                        ///< y coordinate.
+	int32 z_pos;                        ///< z coordinate.
+	DirectionByte direction;            ///< facing
+
+	OwnerByte owner;                    ///< Which company owns the vehicle?
+	/**
+	 * currently displayed sprite index
+	 * 0xfd == custom sprite, 0xfe == custom second head sprite
+	 * 0xff == reserved for another custom sprite
+	 */
+	byte spritenum;
+	SpriteID cur_image;                 ///< sprite number for this vehicle
+	byte x_extent;                      ///< x-extent of vehicle bounding box
+	byte y_extent;                      ///< y-extent of vehicle bounding box
+	byte z_extent;                      ///< z-extent of vehicle bounding box
+	int8 x_bb_offs;                     ///< x offset of vehicle bounding box
+	int8 y_bb_offs;                     ///< y offset of vehicle bounding box
+	int8 x_offs;                        ///< x offset for vehicle sprite
+	int8 y_offs;                        ///< y offset for vehicle sprite
+	EngineID engine_type;               ///< The type of engine used for this vehicle.
+
+	TextEffectID fill_percent_te_id;    ///< a text-effect id to a loading indicator object
+	UnitID unitnumber;                  ///< unit number, for display purposes only
+
+	uint16 cur_speed;                   ///< current speed
+	byte subspeed;                      ///< fractional speed
+	byte acceleration;                  ///< used by train & aircraft
+	uint32 motion_counter;              ///< counter to occasionally play a vehicle sound.
+	byte progress;                      ///< The percentage (if divided by 256) this vehicle already crossed the tile unit.
+
+	byte random_bits;                   ///< Bits used for determining which randomized variational spritegroups to use when drawing.
+	byte waiting_triggers;              ///< Triggers to be yet matched before rerandomizing the random bits.
+
+	StationID last_station_visited;     ///< The last station we stopped at.
+
+	CargoID cargo_type;                 ///< type of cargo this vehicle is carrying
+	byte cargo_subtype;                 ///< Used for livery refits (NewGRF variations)
+	uint16 cargo_cap;                   ///< total capacity
+	VehicleCargoList cargo;             ///< The cargo this vehicle is carrying
+	uint16 cargo_age_counter;           ///< Ticks till cargo is aged next.
+
+	byte day_counter;                   ///< Increased by one for each day
+	byte tick_counter;                  ///< Increased by one for each tick
+	byte running_ticks;                 ///< Number of ticks this vehicle was not stopped this day
+
+	byte vehstatus;                     ///< Status
+	Order current_order;                ///< The current order (+ status, like: loading)
+
+	union {
+		OrderList *list;            ///< Pointer to the order list for this vehicle
+		Order     *old;             ///< Only used during conversion of old save games
+	} orders;                           ///< The orders currently assigned to the vehicle.
+
+	uint16 load_unload_ticks;           ///< Ticks to wait before starting next cycle.
+	GroupID group_id;                   ///< Index of group Pool array
+	byte subtype;                       ///< subtype (Filled with values from #EffectVehicles/#TrainSubTypes/#AircraftSubTypes)
+
+	NewGRFCache grf_cache;              ///< Cache of often used calculated NewGRF values
+	VehicleCache vcache;                ///< Cache of often used vehicle values.
+
+	Vehicle(VehicleType type = VEH_INVALID);
+
+	void PreDestructor();
+	/** We want to 'destruct' the right class. */
+	virtual ~Vehicle();
+
+	void BeginLoading();
+	void CancelReservation(Station *st);
+	void LeaveStation();
+
+	GroundVehicleCache *GetGroundVehicleCache();
+	const GroundVehicleCache *GetGroundVehicleCache() const;
+
+	uint16 &GetGroundVehicleFlags();
+	const uint16 &GetGroundVehicleFlags() const;
+
+	void DeleteUnreachedImplicitOrders();
+
+	void HandleLoading(bool mode = false);
+
+	/**
+	 * Marks the vehicles to be redrawn and updates cached variables
+	 *
+	 * This method marks the area of the vehicle on the screen as dirty.
+	 * It can be use to repaint the vehicle.
+	 *
+	 * @ingroup dirty
+	 */
+	virtual void MarkDirty() {}
+
+	/**
+	 * Updates the x and y offsets and the size of the sprite used
+	 * for this vehicle.
+	 * @param direction the direction the vehicle is facing
+	 */
+	virtual void UpdateDeltaXY(Direction direction) {}
+
+	/**
+	 * Determines the effective direction-specific vehicle movement speed.
+	 *
+	 * This method belongs to the old vehicle movement method:
+	 * A vehicle moves a step every 256 progress units.
+	 * The vehicle speed is scaled by 3/4 when moving in X or Y direction due to the longer distance.
+	 *
+	 * However, this method is slightly wrong in corners, as the leftover progress is not scaled correctly
+	 * when changing movement direction. #GetAdvanceSpeed() and #GetAdvanceDistance() are better wrt. this.
+	 *
+	 * @param speed Direction-independent unscaled speed.
+	 * @return speed scaled by movement direction. 256 units are required for each movement step.
+	 */
+	inline uint GetOldAdvanceSpeed(uint speed)
+	{
+		return (this->direction & 1) ? speed : speed * 3 / 4;
+	}
+
+	/**
+	 * Determines the effective vehicle movement speed.
+	 *
+	 * Together with #GetAdvanceDistance() this function is a replacement for #GetOldAdvanceSpeed().
+	 *
+	 * A vehicle progresses independent of it's movement direction.
+	 * However different amounts of "progress" are needed for moving a step in a specific direction.
+	 * That way the leftover progress does not need any adaption when changing movement direction.
+	 *
+	 * @param speed Direction-independent unscaled speed.
+	 * @return speed, scaled to match #GetAdvanceDistance().
+	 */
+	static inline uint GetAdvanceSpeed(uint speed)
+	{
+		return speed * 3 / 4;
+	}
+
+	/**
+	 * Determines the vehicle "progress" needed for moving a step.
+	 *
+	 * Together with #GetAdvanceSpeed() this function is a replacement for #GetOldAdvanceSpeed().
+	 *
+	 * @return distance to drive for a movement step on the map.
+	 */
+	inline uint GetAdvanceDistance()
+	{
+		return (this->direction & 1) ? 192 : 256;
+	}
+
+	/**
+	 * Sets the expense type associated to this vehicle type
+	 * @param income whether this is income or (running) expenses of the vehicle
+	 */
+	virtual ExpensesType GetExpenseType(bool income) const { return EXPENSES_OTHER; }
+
+	/**
+	 * Play the sound associated with leaving the station
+	 */
+	virtual void PlayLeaveStationSound() const {}
+
+	/**
+	 * Whether this is the primary vehicle in the chain.
+	 */
+	virtual bool IsPrimaryVehicle() const { return false; }
+
+	const Engine *GetEngine() const;
+
+	/**
+	 * Gets the sprite to show for the given direction
+	 * @param direction the direction the vehicle is facing
+	 * @return the sprite for the given vehicle in the given direction
+	 */
+	virtual SpriteID GetImage(Direction direction, EngineImageType image_type) const { return 0; }
+
+	const GRFFile *GetGRF() const;
+	uint32 GetGRFID() const;
+
+	/**
+	 * Invalidates cached NewGRF variables
+	 * @see InvalidateNewGRFCacheOfChain
+	 */
+	inline void InvalidateNewGRFCache()
+	{
+		this->grf_cache.cache_valid = 0;
+	}
+
+	/**
+	 * Invalidates cached NewGRF variables of all vehicles in the chain (after the current vehicle)
+	 * @see InvalidateNewGRFCache
+	 */
+	inline void InvalidateNewGRFCacheOfChain()
+	{
+		for (Vehicle *u = this; u != NULL; u = u->Next()) {
+			u->InvalidateNewGRFCache();
+		}
+	}
+
+	/**
+	 * Check if the vehicle is a ground vehicle.
+	 * @return True iff the vehicle is a train or a road vehicle.
+	 */
+	inline bool IsGroundVehicle() const
+	{
+		return this->type == VEH_TRAIN || this->type == VEH_ROAD;
+	}
+
+	/**
+	 * Gets the speed in km-ish/h that can be sent into SetDParam for string processing.
+	 * @return the vehicle's speed
+	 */
+	virtual int GetDisplaySpeed() const { return 0; }
+
+	/**
+	 * Gets the maximum speed in km-ish/h that can be sent into SetDParam for string processing.
+	 * @return the vehicle's maximum speed
+	 */
+	virtual int GetDisplayMaxSpeed() const { return 0; }
+
+	/**
+	 * Calculates the maximum speed of the vehicle under its current conditions.
+	 * @return Current maximum speed in native units.
+	 */
+	virtual int GetCurrentMaxSpeed() const { return 0; }
+
+	/**
+	 * Gets the running cost of a vehicle
+	 * @return the vehicle's running cost
+	 */
+	virtual Money GetRunningCost() const { return 0; }
+
+	/**
+	 * Check whether the vehicle is in the depot.
+	 * @return true if and only if the vehicle is in the depot.
+	 */
+	virtual bool IsInDepot() const { return false; }
+
+	/**
+	 * Check whether the whole vehicle chain is in the depot.
+	 * @return true if and only if the whole chain is in the depot.
+	 */
+	virtual bool IsChainInDepot() const { return this->IsInDepot(); }
+
+	/**
+	 * Check whether the vehicle is in the depot *and* stopped.
+	 * @return true if and only if the vehicle is in the depot and stopped.
+	 */
+	bool IsStoppedInDepot() const
+	{
+		assert(this == this->First());
+		/* Free wagons have no VS_STOPPED state */
+		if (this->IsPrimaryVehicle() && !(this->vehstatus & VS_STOPPED)) return false;
+		return this->IsChainInDepot();
+	}
+
+	/**
+	 * Calls the tick handler of the vehicle
+	 * @return is this vehicle still valid?
+	 */
+	virtual bool Tick() { return true; };
+
+	/**
+	 * Calls the new day handler of the vehicle
+	 */
+	virtual void OnNewDay() {};
+
+	/**
+	 * Crash the (whole) vehicle chain.
+	 * @param flooded whether the cause of the crash is flooding or not.
+	 * @return the number of lost souls.
+	 */
+	virtual uint Crash(bool flooded = false);
+
+	/**
+	 * Returns the Trackdir on which the vehicle is currently located.
+	 * Works for trains and ships.
+	 * Currently works only sortof for road vehicles, since they have a fuzzy
+	 * concept of being "on" a trackdir. Dunno really what it returns for a road
+	 * vehicle that is halfway a tile, never really understood that part. For road
+	 * vehicles that are at the beginning or end of the tile, should just return
+	 * the diagonal trackdir on which they are driving. I _think_.
+	 * For other vehicles types, or vehicles with no clear trackdir (such as those
+	 * in depots), returns 0xFF.
+	 * @return the trackdir of the vehicle
+	 */
+	virtual Trackdir GetVehicleTrackdir() const { return INVALID_TRACKDIR; }
+
+	/**
+	 * Gets the running cost of a vehicle  that can be sent into SetDParam for string processing.
+	 * @return the vehicle's running cost
+	 */
+	Money GetDisplayRunningCost() const { return (this->GetRunningCost() >> 8); }
+
+	/**
+	 * Gets the profit vehicle had this year. It can be sent into SetDParam for string processing.
+	 * @return the vehicle's profit this year
+	 */
+	Money GetDisplayProfitThisYear() const { return (this->profit_this_year >> 8); }
+
+	/**
+	 * Gets the profit vehicle had last year. It can be sent into SetDParam for string processing.
+	 * @return the vehicle's profit last year
+	 */
+	Money GetDisplayProfitLastYear() const { return (this->profit_last_year >> 8); }
+
+	void SetNext(Vehicle *next);
+
+	/**
+	 * Get the next vehicle of this vehicle.
+	 * @note articulated parts are also counted as vehicles.
+	 * @return the next vehicle or NULL when there isn't a next vehicle.
+	 */
+	inline Vehicle *Next() const { return this->next; }
+
+	/**
+	 * Get the previous vehicle of this vehicle.
+	 * @note articulated parts are also counted as vehicles.
+	 * @return the previous vehicle or NULL when there isn't a previous vehicle.
+	 */
+	inline Vehicle *Previous() const { return this->previous; }
+
+	/**
+	 * Get the first vehicle of this vehicle chain.
+	 * @return the first vehicle of the chain.
+	 */
+	inline Vehicle *First() const { return this->first; }
+
+	/**
+	 * Get the last vehicle of this vehicle chain.
+	 * @return the last vehicle of the chain.
+	 */
+	inline Vehicle *Last()
+	{
+		Vehicle *v = this;
+		while (v->Next() != NULL) v = v->Next();
+		return v;
+	}
+
+	/**
+	 * Get the last vehicle of this vehicle chain.
+	 * @return the last vehicle of the chain.
+	 */
+	inline const Vehicle *Last() const
+	{
+		const Vehicle *v = this;
+		while (v->Next() != NULL) v = v->Next();
+		return v;
+	}
+
+	/**
+	 * Get the vehicle at offset \a n of this vehicle chain.
+	 * @param n Offset from the current vehicle.
+	 * @return The new vehicle or NULL if the offset is out-of-bounds.
+	 */
+	inline Vehicle *Move(int n)
+	{
+		Vehicle *v = this;
+		if (n < 0) {
+			for (int i = 0; i != n && v != NULL; i--) v = v->Previous();
+		} else {
+			for (int i = 0; i != n && v != NULL; i++) v = v->Next();
+		}
+		return v;
+	}
+
+	/**
+	 * Get the vehicle at offset \a n of this vehicle chain.
+	 * @param n Offset from the current vehicle.
+	 * @return The new vehicle or NULL if the offset is out-of-bounds.
+	 */
+	inline const Vehicle *Move(int n) const
+	{
+		const Vehicle *v = this;
+		if (n < 0) {
+			for (int i = 0; i != n && v != NULL; i--) v = v->Previous();
+		} else {
+			for (int i = 0; i != n && v != NULL; i++) v = v->Next();
+		}
+		return v;
+	}
+
+	/**
+	 * Get the first order of the vehicles order list.
+	 * @return first order of order list.
+	 */
+	inline Order *GetFirstOrder() const { return (this->orders.list == NULL) ? NULL : this->orders.list->GetFirstOrder(); }
+
+	void AddToShared(Vehicle *shared_chain);
+	void RemoveFromShared();
+
+	/**
+	 * Get the next vehicle of the shared vehicle chain.
+	 * @return the next shared vehicle or NULL when there isn't a next vehicle.
+	 */
+	inline Vehicle *NextShared() const { return this->next_shared; }
+
+	/**
+	 * Get the previous vehicle of the shared vehicle chain
+	 * @return the previous shared vehicle or NULL when there isn't a previous vehicle.
+	 */
+	inline Vehicle *PreviousShared() const { return this->previous_shared; }
+
+	/**
+	 * Get the first vehicle of this vehicle chain.
+	 * @return the first vehicle of the chain.
+	 */
+	inline Vehicle *FirstShared() const { return (this->orders.list == NULL) ? this->First() : this->orders.list->GetFirstSharedVehicle(); }
+
+	/**
+	 * Check if we share our orders with another vehicle.
+	 * @return true if there are other vehicles sharing the same order
+	 */
+	inline bool IsOrderListShared() const { return this->orders.list != NULL && this->orders.list->IsShared(); }
+
+	/**
+	 * Get the number of orders this vehicle has.
+	 * @return the number of orders this vehicle has.
+	 */
+	inline VehicleOrderID GetNumOrders() const { return (this->orders.list == NULL) ? 0 : this->orders.list->GetNumOrders(); }
+
+	/**
+	 * Get the number of manually added orders this vehicle has.
+	 * @return the number of manually added orders this vehicle has.
+	 */
+	inline VehicleOrderID GetNumManualOrders() const { return (this->orders.list == NULL) ? 0 : this->orders.list->GetNumManualOrders(); }
+
+	/**
+	 * Copy certain configurations and statistics of a vehicle after successful autoreplace/renew
+	 * The function shall copy everything that cannot be copied by a command (like orders / group etc),
+	 * and that shall not be resetted for the new vehicle.
+	 * @param src The old vehicle
+	 */
+	inline void CopyVehicleConfigAndStatistics(const Vehicle *src)
+	{
+		this->CopyConsistPropertiesFrom(src);
+
+		this->unitnumber = src->unitnumber;
+
+		this->current_order = src->current_order;
+		this->dest_tile  = src->dest_tile;
+
+		this->profit_this_year = src->profit_this_year;
+		this->profit_last_year = src->profit_last_year;
+	}
+
+
+	bool HandleBreakdown();
+
+	bool NeedsAutorenewing(const Company *c, bool use_renew_setting = true) const;
+
+	bool NeedsServicing() const;
+	bool NeedsAutomaticServicing() const;
+
+	/**
+	 * Determine the location for the station where the vehicle goes to next.
+	 * Things done for example are allocating slots in a road stop or exact
+	 * location of the platform is determined for ships.
+	 * @param station the station to make the next location of the vehicle.
+	 * @return the location (tile) to aim for.
+	 */
+	virtual TileIndex GetOrderStationLocation(StationID station) { return INVALID_TILE; }
+
+	/**
+	 * Find the closest depot for this vehicle and tell us the location,
+	 * DestinationID and whether we should reverse.
+	 * @param location    where do we go to?
+	 * @param destination what hangar do we go to?
+	 * @param reverse     should the vehicle be reversed?
+	 * @return true if a depot could be found.
+	 */
+	virtual bool FindClosestDepot(TileIndex *location, DestinationID *destination, bool *reverse) { return false; }
+
+	CommandCost SendToDepot(DoCommandFlag flags, DepotCommand command);
+
+	void UpdateVisualEffect(bool allow_power_change = true);
+	void ShowVisualEffect() const;
+
+	inline uint16 GetServiceInterval() const { return this->service_interval; }
+
+	inline void SetServiceInterval(uint16 interval) { this->service_interval = interval; }
+
+	inline bool ServiceIntervalIsCustom() const { return HasBit(this->vehicle_flags, VF_SERVINT_IS_CUSTOM); }
+
+	inline bool ServiceIntervalIsPercent() const { return HasBit(this->vehicle_flags, VF_SERVINT_IS_PERCENT); }
+
+	inline void SetServiceIntervalIsCustom(bool on) { SB(this->vehicle_flags, VF_SERVINT_IS_CUSTOM, 1, on); }
+
+	inline void SetServiceIntervalIsPercent(bool on) { SB(this->vehicle_flags, VF_SERVINT_IS_PERCENT, 1, on); }
+
+private:
+	/**
+	 * Advance cur_real_order_index to the next real order.
+	 * cur_implicit_order_index is not touched.
+	 */
+	void SkipToNextRealOrderIndex()
+	{
+		if (this->GetNumManualOrders() > 0) {
+			/* Advance to next real order */
+			do {
+				this->cur_real_order_index++;
+				if (this->cur_real_order_index >= this->GetNumOrders()) this->cur_real_order_index = 0;
+			} while (this->GetOrder(this->cur_real_order_index)->IsType(OT_IMPLICIT));
+		} else {
+			this->cur_real_order_index = 0;
+		}
+	}
+
+public:
+	/**
+	 * Increments cur_implicit_order_index, keeps care of the wrap-around and invalidates the GUI.
+	 * cur_real_order_index is incremented as well, if needed.
+	 * Note: current_order is not invalidated.
+	 */
+	void IncrementImplicitOrderIndex()
+	{
+		if (this->cur_implicit_order_index == this->cur_real_order_index) {
+			/* Increment real order index as well */
+			this->SkipToNextRealOrderIndex();
+		}
+
+		assert(this->cur_real_order_index == 0 || this->cur_real_order_index < this->GetNumOrders());
+
+		/* Advance to next implicit order */
+		do {
+			this->cur_implicit_order_index++;
+			if (this->cur_implicit_order_index >= this->GetNumOrders()) this->cur_implicit_order_index = 0;
+		} while (this->cur_implicit_order_index != this->cur_real_order_index && !this->GetOrder(this->cur_implicit_order_index)->IsType(OT_IMPLICIT));
+
+		InvalidateVehicleOrder(this, 0);
+	}
+
+	/**
+	 * Advanced cur_real_order_index to the next real order, keeps care of the wrap-around and invalidates the GUI.
+	 * cur_implicit_order_index is incremented as well, if it was equal to cur_real_order_index, i.e. cur_real_order_index is skipped
+	 * but not any implicit orders.
+	 * Note: current_order is not invalidated.
+	 */
+	void IncrementRealOrderIndex()
+	{
+		if (this->cur_implicit_order_index == this->cur_real_order_index) {
+			/* Increment both real and implicit order */
+			this->IncrementImplicitOrderIndex();
+		} else {
+			/* Increment real order only */
+			this->SkipToNextRealOrderIndex();
+			InvalidateVehicleOrder(this, 0);
+		}
+	}
+
+	/**
+	 * Skip implicit orders until cur_real_order_index is a non-implicit order.
+	 */
+	void UpdateRealOrderIndex()
+	{
+		/* Make sure the index is valid */
+		if (this->cur_real_order_index >= this->GetNumOrders()) this->cur_real_order_index = 0;
+
+		if (this->GetNumManualOrders() > 0) {
+			/* Advance to next real order */
+			while (this->GetOrder(this->cur_real_order_index)->IsType(OT_IMPLICIT)) {
+				this->cur_real_order_index++;
+				if (this->cur_real_order_index >= this->GetNumOrders()) this->cur_real_order_index = 0;
+			}
+		} else {
+			this->cur_real_order_index = 0;
+		}
+	}
+
+	/**
+	 * Returns order 'index' of a vehicle or NULL when it doesn't exists
+	 * @param index the order to fetch
+	 * @return the found (or not) order
+	 */
+	inline Order *GetOrder(int index) const
+	{
+		return (this->orders.list == NULL) ? NULL : this->orders.list->GetOrderAt(index);
+	}
+
+	/**
+	 * Returns the last order of a vehicle, or NULL if it doesn't exists
+	 * @return last order of a vehicle, if available
+	 */
+	inline Order *GetLastOrder() const
+	{
+		return (this->orders.list == NULL) ? NULL : this->orders.list->GetLastOrder();
+	}
+
+	bool IsEngineCountable() const;
+	bool HasEngineType() const;
+	bool HasDepotOrder() const;
+	void HandlePathfindingResult(bool path_found);
+
+	/**
+	 * Check if the vehicle is a front engine.
+	 * @return Returns true if the vehicle is a front engine.
+	 */
+	inline bool IsFrontEngine() const
+	{
+		return this->IsGroundVehicle() && HasBit(this->subtype, GVSF_FRONT);
+	}
+
+	/**
+	 * Check if the vehicle is an articulated part of an engine.
+	 * @return Returns true if the vehicle is an articulated part.
+	 */
+	inline bool IsArticulatedPart() const
+	{
+		return this->IsGroundVehicle() && HasBit(this->subtype, GVSF_ARTICULATED_PART);
+	}
+
+	/**
+	 * Check if an engine has an articulated part.
+	 * @return True if the engine has an articulated part.
+	 */
+	inline bool HasArticulatedPart() const
+	{
+		return this->Next() != NULL && this->Next()->IsArticulatedPart();
+	}
+
+	/**
+	 * Get the next part of an articulated engine.
+	 * @return Next part of the articulated engine.
+	 * @pre The vehicle is an articulated engine.
+	 */
+	inline Vehicle *GetNextArticulatedPart() const
+	{
+		assert(this->HasArticulatedPart());
+		return this->Next();
+	}
+
+	/**
+	 * Get the first part of an articulated engine.
+	 * @return First part of the engine.
+	 */
+	inline Vehicle *GetFirstEnginePart()
+	{
+		Vehicle *v = this;
+		while (v->IsArticulatedPart()) v = v->Previous();
+		return v;
+	}
+
+	/**
+	 * Get the first part of an articulated engine.
+	 * @return First part of the engine.
+	 */
+	inline const Vehicle *GetFirstEnginePart() const
+	{
+		const Vehicle *v = this;
+		while (v->IsArticulatedPart()) v = v->Previous();
+		return v;
+	}
+
+	/**
+	 * Get the last part of an articulated engine.
+	 * @return Last part of the engine.
+	 */
+	inline Vehicle *GetLastEnginePart()
+	{
+		Vehicle *v = this;
+		while (v->HasArticulatedPart()) v = v->GetNextArticulatedPart();
+		return v;
+	}
+
+	/**
+	 * Get the next real (non-articulated part) vehicle in the consist.
+	 * @return Next vehicle in the consist.
+	 */
+	inline Vehicle *GetNextVehicle() const
+	{
+		const Vehicle *v = this;
+		while (v->HasArticulatedPart()) v = v->GetNextArticulatedPart();
+
+		/* v now contains the last articulated part in the engine */
+		return v->Next();
+	}
+
+	/**
+	 * Get the previous real (non-articulated part) vehicle in the consist.
+	 * @return Previous vehicle in the consist.
+	 */
+	inline Vehicle *GetPrevVehicle() const
+	{
+		Vehicle *v = this->Previous();
+		while (v != NULL && v->IsArticulatedPart()) v = v->Previous();
+
+		return v;
+	}
+};
+
+/**
+ * Iterate over all vehicles from a given point.
+ * @param var   The variable used to iterate over.
+ * @param start The vehicle to start the iteration at.
+ */
+#define FOR_ALL_VEHICLES_FROM(var, start) FOR_ALL_ITEMS_FROM(Vehicle, vehicle_index, var, start)
+
+/**
+ * Iterate over all vehicles.
+ * @param var The variable used to iterate over.
+ */
+#define FOR_ALL_VEHICLES(var) FOR_ALL_VEHICLES_FROM(var, 0)
+
+/**
+ * Class defining several overloaded accessors so we don't
+ * have to cast vehicle types that often
+ */
+template <class T, VehicleType Type>
+struct SpecializedVehicle : public Vehicle {
+	static const VehicleType EXPECTED_TYPE = Type; ///< Specialized type
+
+	typedef SpecializedVehicle<T, Type> SpecializedVehicleBase; ///< Our type
+
+	/**
+	 * Set vehicle type correctly
+	 */
+	inline SpecializedVehicle<T, Type>() : Vehicle(Type) { }
+
+	/**
+	 * Get the first vehicle in the chain
+	 * @return first vehicle in the chain
+	 */
+	inline T *First() const { return (T *)this->Vehicle::First(); }
+
+	/**
+	 * Get the last vehicle in the chain
+	 * @return last vehicle in the chain
+	 */
+	inline T *Last() { return (T *)this->Vehicle::Last(); }
+
+	/**
+	 * Get the last vehicle in the chain
+	 * @return last vehicle in the chain
+	 */
+	inline const T *Last() const { return (const T *)this->Vehicle::Last(); }
+
+	/**
+	 * Get next vehicle in the chain
+	 * @return next vehicle in the chain
+	 */
+	inline T *Next() const { return (T *)this->Vehicle::Next(); }
+
+	/**
+	 * Get previous vehicle in the chain
+	 * @return previous vehicle in the chain
+	 */
+	inline T *Previous() const { return (T *)this->Vehicle::Previous(); }
+
+	/**
+	 * Get the next part of an articulated engine.
+	 * @return Next part of the articulated engine.
+	 * @pre The vehicle is an articulated engine.
+	 */
+	inline T *GetNextArticulatedPart() { return (T *)this->Vehicle::GetNextArticulatedPart(); }
+
+	/**
+	 * Get the next part of an articulated engine.
+	 * @return Next part of the articulated engine.
+	 * @pre The vehicle is an articulated engine.
+	 */
+	inline T *GetNextArticulatedPart() const { return (T *)this->Vehicle::GetNextArticulatedPart(); }
+
+	/**
+	 * Get the first part of an articulated engine.
+	 * @return First part of the engine.
+	 */
+	inline T *GetFirstEnginePart() { return (T *)this->Vehicle::GetFirstEnginePart(); }
+
+	/**
+	 * Get the first part of an articulated engine.
+	 * @return First part of the engine.
+	 */
+	inline const T *GetFirstEnginePart() const { return (const T *)this->Vehicle::GetFirstEnginePart(); }
+
+	/**
+	 * Get the last part of an articulated engine.
+	 * @return Last part of the engine.
+	 */
+	inline T *GetLastEnginePart() { return (T *)this->Vehicle::GetLastEnginePart(); }
+
+	/**
+	 * Get the next real (non-articulated part) vehicle in the consist.
+	 * @return Next vehicle in the consist.
+	 */
+	inline T *GetNextVehicle() const { return (T *)this->Vehicle::GetNextVehicle(); }
+
+	/**
+	 * Get the previous real (non-articulated part) vehicle in the consist.
+	 * @return Previous vehicle in the consist.
+	 */
+	inline T *GetPrevVehicle() const { return (T *)this->Vehicle::GetPrevVehicle(); }
+
+	/**
+	 * Tests whether given index is a valid index for vehicle of this type
+	 * @param index tested index
+	 * @return is this index valid index of T?
+	 */
+	static inline bool IsValidID(size_t index)
+	{
+		return Vehicle::IsValidID(index) && Vehicle::Get(index)->type == Type;
+	}
+
+	/**
+	 * Gets vehicle with given index
+	 * @return pointer to vehicle with given index casted to T *
+	 */
+	static inline T *Get(size_t index)
+	{
+		return (T *)Vehicle::Get(index);
+	}
+
+	/**
+	 * Returns vehicle if the index is a valid index for this vehicle type
+	 * @return pointer to vehicle with given index if it's a vehicle of this type
+	 */
+	static inline T *GetIfValid(size_t index)
+	{
+		return IsValidID(index) ? Get(index) : NULL;
+	}
+
+	/**
+	 * Converts a Vehicle to SpecializedVehicle with type checking.
+	 * @param v Vehicle pointer
+	 * @return pointer to SpecializedVehicle
+	 */
+	static inline T *From(Vehicle *v)
+	{
+		assert(v->type == Type);
+		return (T *)v;
+	}
+
+	/**
+	 * Converts a const Vehicle to const SpecializedVehicle with type checking.
+	 * @param v Vehicle pointer
+	 * @return pointer to SpecializedVehicle
+	 */
+	static inline const T *From(const Vehicle *v)
+	{
+		assert(v->type == Type);
+		return (const T *)v;
+	}
+
+	/**
+	 * Update vehicle sprite- and position caches
+	 * @param force_update Force updating the vehicle on the viewport.
+	 * @param update_delta Also update the delta?
+	 */
+	inline void UpdateViewport(bool force_update, bool update_delta)
+	{
+		extern void VehicleUpdateViewport(Vehicle *v, bool dirty);
+
+		/* Explicitly choose method to call to prevent vtable dereference -
+		 * it gives ~3% runtime improvements in games with many vehicles */
+		if (update_delta) ((T *)this)->T::UpdateDeltaXY(this->direction);
+		SpriteID old_image = this->cur_image;
+		this->cur_image = ((T *)this)->T::GetImage(this->direction, EIT_ON_MAP);
+		if (force_update || this->cur_image != old_image) VehicleUpdateViewport(this, true);
+	}
+};
+
+/**
+ * Iterate over all vehicles of a particular type.
+ * @param name The type of vehicle to iterate over.
+ * @param var  The variable used to iterate over.
+ */
+#define FOR_ALL_VEHICLES_OF_TYPE(name, var) FOR_ALL_ITEMS_FROM(name, vehicle_index, var, 0) if (var->type == name::EXPECTED_TYPE)
+
+/**
+ * Disasters, like submarines, skyrangers and their shadows, belong to this class.
+ */
+struct DisasterVehicle FINAL : public SpecializedVehicle<DisasterVehicle, VEH_DISASTER> {
+	SpriteID image_override;            ///< Override for the default disaster vehicle sprite.
+	VehicleID big_ufo_destroyer_target; ///< The big UFO that this destroyer is supposed to bomb.
+
+	/** We don't want GCC to zero our struct! It already is zeroed and has an index! */
+	DisasterVehicle() : SpecializedVehicleBase() {}
+	/** We want to 'destruct' the right class. */
+	virtual ~DisasterVehicle() {}
+
+	void UpdateDeltaXY(Direction direction);
+	bool Tick();
+};
+
+/**
+ * Iterate over disaster vehicles.
+ * @param var The variable used to iterate over.
+ */
+#define FOR_ALL_DISASTERVEHICLES(var) FOR_ALL_VEHICLES_OF_TYPE(DisasterVehicle, var)
+
+/** Generates sequence of free UnitID numbers */
+struct FreeUnitIDGenerator {
+	bool *cache;  ///< array of occupied unit id numbers
+	UnitID maxid; ///< maximum ID at the moment of constructor call
+	UnitID curid; ///< last ID returned; 0 if none
+
+	FreeUnitIDGenerator(VehicleType type, CompanyID owner);
+	UnitID NextID();
+
+	/** Releases allocated memory */
+	~FreeUnitIDGenerator() { free(this->cache); }
+};
+
+/** Sentinel for an invalid coordinate. */
+static const int32 INVALID_COORD = 0x7fffffff;
+
+#endif /* VEHICLE_BASE_H */
diff --git a/src/vehicle_cmd.cpp b/src/vehicle_cmd.cpp
index 7cdb4eb..12394af 100644
--- a/src/vehicle_cmd.cpp
+++ b/src/vehicle_cmd.cpp
@@ -429,6 +429,7 @@ static CommandCost RefitVehicle(Vehicle *v, bool only_this, uint8 num_vehicles,
  * @param p2 various bitstuffed elements
  * - p2 = (bit 0-4)   - New cargo type to refit to.
  * - p2 = (bit 6)     - Automatic refitting.
+ * - p2 = (bit 5)	  - Is a virtual train (used by template replacement to allow refitting without stopped-in-depot checks)
  * - p2 = (bit 7)     - Refit only this vehicle. Used only for cloning vehicles.
  * - p2 = (bit 8-15)  - New cargo subtype to refit to. 0xFF means to try keeping the same subtype according to GetBestFittingSubType().
  * - p2 = (bit 16-23) - Number of vehicles to refit (not counting articulated parts). Zero means all vehicles.
@@ -451,12 +452,15 @@ CommandCost CmdRefitVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint
 	if (ret.Failed()) return ret;
 
 	bool auto_refit = HasBit(p2, 6);
+	bool is_virtual_train = HasBit(p2, 5);
 
 	/* Don't allow shadows and such to be refitted. */
 	if (v != front && (v->type == VEH_SHIP || v->type == VEH_AIRCRAFT)) return CMD_ERROR;
 	/* Allow auto-refitting only during loading and normal refitting only in a depot. */
-	if ((!auto_refit || !front->current_order.IsType(OT_LOADING)) && !front->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAIN_MUST_BE_STOPPED_INSIDE_DEPOT + front->type);
-	if (front->vehstatus & VS_CRASHED) return_cmd_error(STR_ERROR_VEHICLE_IS_DESTROYED);
+	if ( ! is_virtual_train ) {
+		if ((!auto_refit || !front->current_order.IsType(OT_LOADING)) && !front->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAIN_MUST_BE_STOPPED_INSIDE_DEPOT + front->type);
+		if (front->vehstatus & VS_CRASHED) return_cmd_error(STR_ERROR_VEHICLE_IS_DESTROYED);
+	}
 
 	/* Check cargo */
 	CargoID new_cid = GB(p2, 0, 5);
@@ -496,7 +500,11 @@ CommandCost CmdRefitVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint
 		}
 
 		InvalidateWindowData(WC_VEHICLE_DETAILS, front->index);
-		SetWindowDirty(WC_VEHICLE_DEPOT, front->tile);
+		/* virtual vehicles get their cargo changed by the TemplateCreateWindow, so set this dirty instead of a depot window */
+		//if ( HasBit(v->subtype, GVSF_VIRTUAL) ) SetWindowDirty(WC_CREATE_TEMPLATE, -1); // MYGUI
+		if ( HasBit(v->subtype, GVSF_VIRTUAL) ) SetWindowClassesDirty(WC_CREATE_TEMPLATE);
+		else SetWindowDirty(WC_VEHICLE_DEPOT, front->tile);
+
 		InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 0);
 	} else {
 		/* Always invalidate the cache; querycost might have filled it. */
diff --git a/src/vehicle_cmd.cpp.orig b/src/vehicle_cmd.cpp.orig
new file mode 100644
index 0000000..7cdb4eb
--- /dev/null
+++ b/src/vehicle_cmd.cpp.orig
@@ -0,0 +1,1088 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file vehicle_cmd.cpp Commands for vehicles. */
+
+#include "stdafx.h"
+#include "roadveh.h"
+#include "news_func.h"
+#include "airport.h"
+#include "cmd_helper.h"
+#include "command_func.h"
+#include "company_func.h"
+#include "train.h"
+#include "aircraft.h"
+#include "newgrf_text.h"
+#include "vehicle_func.h"
+#include "string_func.h"
+#include "depot_map.h"
+#include "vehiclelist.h"
+#include "engine_func.h"
+#include "articulated_vehicles.h"
+#include "autoreplace_gui.h"
+#include "group.h"
+#include "order_backup.h"
+#include "ship.h"
+#include "newgrf.h"
+#include "company_base.h"
+
+#include "table/strings.h"
+
+/* Tables used in vehicle.h to find the right command for a certain vehicle type */
+const uint32 _veh_build_proc_table[] = {
+	CMD_BUILD_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_BUY_TRAIN),
+	CMD_BUILD_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_BUY_ROAD_VEHICLE),
+	CMD_BUILD_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_BUY_SHIP),
+	CMD_BUILD_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_BUY_AIRCRAFT),
+};
+
+const uint32 _veh_sell_proc_table[] = {
+	CMD_SELL_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_SELL_TRAIN),
+	CMD_SELL_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_SELL_ROAD_VEHICLE),
+	CMD_SELL_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_SELL_SHIP),
+	CMD_SELL_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_SELL_AIRCRAFT),
+};
+
+const uint32 _veh_refit_proc_table[] = {
+	CMD_REFIT_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_REFIT_TRAIN),
+	CMD_REFIT_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_REFIT_ROAD_VEHICLE),
+	CMD_REFIT_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_REFIT_SHIP),
+	CMD_REFIT_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_REFIT_AIRCRAFT),
+};
+
+const uint32 _send_to_depot_proc_table[] = {
+	CMD_SEND_VEHICLE_TO_DEPOT | CMD_MSG(STR_ERROR_CAN_T_SEND_TRAIN_TO_DEPOT),
+	CMD_SEND_VEHICLE_TO_DEPOT | CMD_MSG(STR_ERROR_CAN_T_SEND_ROAD_VEHICLE_TO_DEPOT),
+	CMD_SEND_VEHICLE_TO_DEPOT | CMD_MSG(STR_ERROR_CAN_T_SEND_SHIP_TO_DEPOT),
+	CMD_SEND_VEHICLE_TO_DEPOT | CMD_MSG(STR_ERROR_CAN_T_SEND_AIRCRAFT_TO_HANGAR),
+};
+
+
+CommandCost CmdBuildRailVehicle(TileIndex tile, DoCommandFlag flags, const Engine *e, uint16 data, Vehicle **v);
+CommandCost CmdBuildRoadVehicle(TileIndex tile, DoCommandFlag flags, const Engine *e, uint16 data, Vehicle **v);
+CommandCost CmdBuildShip       (TileIndex tile, DoCommandFlag flags, const Engine *e, uint16 data, Vehicle **v);
+CommandCost CmdBuildAircraft   (TileIndex tile, DoCommandFlag flags, const Engine *e, uint16 data, Vehicle **v);
+
+/**
+ * Build a vehicle.
+ * @param tile tile of depot where the vehicle is built
+ * @param flags for command
+ * @param p1 various bitstuffed data
+ *  bits  0-15: vehicle type being built.
+ *  bits 16-31: vehicle type specific bits passed on to the vehicle build functions.
+ * @param p2 User
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdBuildVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	/* Elementary check for valid location. */
+	if (!IsDepotTile(tile) || !IsTileOwner(tile, _current_company)) return CMD_ERROR;
+
+	VehicleType type;
+	switch (GetTileType(tile)) {
+		case MP_RAILWAY: type = VEH_TRAIN;    break;
+		case MP_ROAD:    type = VEH_ROAD;     break;
+		case MP_WATER:   type = VEH_SHIP;     break;
+		case MP_STATION: type = VEH_AIRCRAFT; break;
+		default: NOT_REACHED(); // Safe due to IsDepotTile()
+	}
+
+	/* Validate the engine type. */
+	EngineID eid = GB(p1, 0, 16);
+	if (!IsEngineBuildable(eid, type, _current_company)) return_cmd_error(STR_ERROR_RAIL_VEHICLE_NOT_AVAILABLE + type);
+
+	const Engine *e = Engine::Get(eid);
+	CommandCost value(EXPENSES_NEW_VEHICLES, e->GetCost());
+
+	/* Engines without valid cargo should not be available */
+	if (e->GetDefaultCargoType() == CT_INVALID) return CMD_ERROR;
+
+	/* Check whether the number of vehicles we need to build can be built according to pool space. */
+	uint num_vehicles;
+	switch (type) {
+		case VEH_TRAIN:    num_vehicles = (e->u.rail.railveh_type == RAILVEH_MULTIHEAD ? 2 : 1) + CountArticulatedParts(eid, false); break;
+		case VEH_ROAD:     num_vehicles = 1 + CountArticulatedParts(eid, false); break;
+		case VEH_SHIP:     num_vehicles = 1; break;
+		case VEH_AIRCRAFT: num_vehicles = e->u.air.subtype & AIR_CTOL ? 2 : 3; break;
+		default: NOT_REACHED(); // Safe due to IsDepotTile()
+	}
+	if (!Vehicle::CanAllocateItem(num_vehicles)) return_cmd_error(STR_ERROR_TOO_MANY_VEHICLES_IN_GAME);
+
+	/* Check whether we can allocate a unit number. Autoreplace does not allocate
+	 * an unit number as it will (always) reuse the one of the replaced vehicle
+	 * and (train) wagons don't have an unit number in any scenario. */
+	UnitID unit_num = (flags & DC_AUTOREPLACE || (type == VEH_TRAIN && e->u.rail.railveh_type == RAILVEH_WAGON)) ? 0 : GetFreeUnitNumber(type);
+	if (unit_num == UINT16_MAX) return_cmd_error(STR_ERROR_TOO_MANY_VEHICLES_IN_GAME);
+
+	Vehicle *v;
+	switch (type) {
+		case VEH_TRAIN:    value.AddCost(CmdBuildRailVehicle(tile, flags, e, GB(p1, 16, 16), &v)); break;
+		case VEH_ROAD:     value.AddCost(CmdBuildRoadVehicle(tile, flags, e, GB(p1, 16, 16), &v)); break;
+		case VEH_SHIP:     value.AddCost(CmdBuildShip       (tile, flags, e, GB(p1, 16, 16), &v)); break;
+		case VEH_AIRCRAFT: value.AddCost(CmdBuildAircraft   (tile, flags, e, GB(p1, 16, 16), &v)); break;
+		default: NOT_REACHED(); // Safe due to IsDepotTile()
+	}
+
+	if (value.Succeeded() && flags & DC_EXEC) {
+		v->unitnumber = unit_num;
+		v->value      = value.GetCost();
+
+		InvalidateWindowData(WC_VEHICLE_DEPOT, v->tile);
+		InvalidateWindowClassesData(GetWindowClassForVehicleType(type), 0);
+		SetWindowDirty(WC_COMPANY, _current_company);
+		if (IsLocalCompany()) {
+			InvalidateAutoreplaceWindow(v->engine_type, v->group_id); // updates the auto replace window (must be called before incrementing num_engines)
+		}
+
+		GroupStatistics::CountEngine(v, 1);
+		GroupStatistics::UpdateAutoreplace(_current_company);
+
+		if (v->IsPrimaryVehicle()) {
+			GroupStatistics::CountVehicle(v, 1);
+			OrderBackup::Restore(v, p2);
+		}
+	}
+
+	return value;
+}
+
+CommandCost CmdSellRailWagon(DoCommandFlag flags, Vehicle *v, uint16 data, uint32 user);
+
+/**
+ * Sell a vehicle.
+ * @param tile unused.
+ * @param flags for command.
+ * @param p1 various bitstuffed data.
+ *  bits  0-19: vehicle ID being sold.
+ *  bits 20-30: vehicle type specific bits passed on to the vehicle build functions.
+ *  bit     31: make a backup of the vehicle's order (if an engine).
+ * @param p2 User.
+ * @param text unused.
+ * @return the cost of this operation or an error.
+ */
+CommandCost CmdSellVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	Vehicle *v = Vehicle::GetIfValid(GB(p1, 0, 20));
+	if (v == NULL) return CMD_ERROR;
+
+	Vehicle *front = v->First();
+
+	CommandCost ret = CheckOwnership(front->owner);
+	if (ret.Failed()) return ret;
+
+	if (front->vehstatus & VS_CRASHED) return_cmd_error(STR_ERROR_VEHICLE_IS_DESTROYED);
+
+	if (!front->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAIN_MUST_BE_STOPPED_INSIDE_DEPOT + front->type);
+
+	/* Can we actually make the order backup, i.e. are there enough orders? */
+	if (p1 & MAKE_ORDER_BACKUP_FLAG &&
+			front->orders.list != NULL &&
+			!front->orders.list->IsShared() &&
+			!Order::CanAllocateItem(front->orders.list->GetNumOrders())) {
+		/* Only happens in exceptional cases when there aren't enough orders anyhow.
+		 * Thus it should be safe to just drop the orders in that case. */
+		p1 &= ~MAKE_ORDER_BACKUP_FLAG;
+	}
+
+	if (v->type == VEH_TRAIN) {
+		ret = CmdSellRailWagon(flags, v, GB(p1, 20, 12), p2);
+	} else {
+		ret = CommandCost(EXPENSES_NEW_VEHICLES, -front->value);
+
+		if (flags & DC_EXEC) {
+			if (front->IsPrimaryVehicle() && p1 & MAKE_ORDER_BACKUP_FLAG) OrderBackup::Backup(front, p2);
+			delete front;
+		}
+	}
+
+	return ret;
+}
+
+/**
+ * Helper to run the refit cost callback.
+ * @param v The vehicle we are refitting, can be NULL.
+ * @param engine_type Which engine to refit
+ * @param new_cid Cargo type we are refitting to.
+ * @param new_subtype New cargo subtype.
+ * @param [out] auto_refit_allowed The refit is allowed as an auto-refit.
+ * @return Price for refitting
+ */
+static int GetRefitCostFactor(const Vehicle *v, EngineID engine_type, CargoID new_cid, byte new_subtype, bool *auto_refit_allowed)
+{
+	/* Prepare callback param with info about the new cargo type. */
+	const Engine *e = Engine::Get(engine_type);
+
+	/* Is this vehicle a NewGRF vehicle? */
+	if (e->GetGRF() != NULL) {
+		const CargoSpec *cs = CargoSpec::Get(new_cid);
+		uint32 param1 = (cs->classes << 16) | (new_subtype << 8) | e->GetGRF()->cargo_map[new_cid];
+
+		uint16 cb_res = GetVehicleCallback(CBID_VEHICLE_REFIT_COST, param1, 0, engine_type, v);
+		if (cb_res != CALLBACK_FAILED) {
+			*auto_refit_allowed = HasBit(cb_res, 14);
+			int factor = GB(cb_res, 0, 14);
+			if (factor >= 0x2000) factor -= 0x4000; // Treat as signed integer.
+			return factor;
+		}
+	}
+
+	*auto_refit_allowed = e->info.refit_cost == 0;
+	return (v == NULL || v->cargo_type != new_cid) ? e->info.refit_cost : 0;
+}
+
+/**
+ * Learn the price of refitting a certain engine
+ * @param v The vehicle we are refitting, can be NULL.
+ * @param engine_type Which engine to refit
+ * @param new_cid Cargo type we are refitting to.
+ * @param new_subtype New cargo subtype.
+ * @param [out] auto_refit_allowed The refit is allowed as an auto-refit.
+ * @return Price for refitting
+ */
+static CommandCost GetRefitCost(const Vehicle *v, EngineID engine_type, CargoID new_cid, byte new_subtype, bool *auto_refit_allowed)
+{
+	ExpensesType expense_type;
+	const Engine *e = Engine::Get(engine_type);
+	Price base_price;
+	int cost_factor = GetRefitCostFactor(v, engine_type, new_cid, new_subtype, auto_refit_allowed);
+	switch (e->type) {
+		case VEH_SHIP:
+			base_price = PR_BUILD_VEHICLE_SHIP;
+			expense_type = EXPENSES_SHIP_RUN;
+			break;
+
+		case VEH_ROAD:
+			base_price = PR_BUILD_VEHICLE_ROAD;
+			expense_type = EXPENSES_ROADVEH_RUN;
+			break;
+
+		case VEH_AIRCRAFT:
+			base_price = PR_BUILD_VEHICLE_AIRCRAFT;
+			expense_type = EXPENSES_AIRCRAFT_RUN;
+			break;
+
+		case VEH_TRAIN:
+			base_price = (e->u.rail.railveh_type == RAILVEH_WAGON) ? PR_BUILD_VEHICLE_WAGON : PR_BUILD_VEHICLE_TRAIN;
+			cost_factor <<= 1;
+			expense_type = EXPENSES_TRAIN_RUN;
+			break;
+
+		default: NOT_REACHED();
+	}
+	if (cost_factor < 0) {
+		return CommandCost(expense_type, -GetPrice(base_price, -cost_factor, e->GetGRF(), -10));
+	} else {
+		return CommandCost(expense_type, GetPrice(base_price, cost_factor, e->GetGRF(), -10));
+	}
+}
+
+/** Helper structure for RefitVehicle() */
+struct RefitResult {
+	Vehicle *v;         ///< Vehicle to refit
+	uint capacity;      ///< New capacity of vehicle
+	uint mail_capacity; ///< New mail capacity of aircraft
+	byte subtype;       ///< cargo subtype to refit to
+};
+
+/**
+ * Refits a vehicle (chain).
+ * This is the vehicle-type independent part of the CmdRefitXXX functions.
+ * @param v            The vehicle to refit.
+ * @param only_this    Whether to only refit this vehicle, or to check the rest of them.
+ * @param num_vehicles Number of vehicles to refit (not counting articulated parts). Zero means the whole chain.
+ * @param new_cid      Cargotype to refit to
+ * @param new_subtype  Cargo subtype to refit to. 0xFF means to try keeping the same subtype according to GetBestFittingSubType().
+ * @param flags        Command flags
+ * @param auto_refit   Refitting is done as automatic refitting outside a depot.
+ * @return Refit cost.
+ */
+static CommandCost RefitVehicle(Vehicle *v, bool only_this, uint8 num_vehicles, CargoID new_cid, byte new_subtype, DoCommandFlag flags, bool auto_refit)
+{
+	CommandCost cost(v->GetExpenseType(false));
+	uint total_capacity = 0;
+	uint total_mail_capacity = 0;
+	num_vehicles = num_vehicles == 0 ? UINT8_MAX : num_vehicles;
+
+	VehicleSet vehicles_to_refit;
+	if (!only_this) {
+		GetVehicleSet(vehicles_to_refit, v, num_vehicles);
+		/* In this case, we need to check the whole chain. */
+		v = v->First();
+	}
+
+	static SmallVector<RefitResult, 16> refit_result;
+	refit_result.Clear();
+
+	v->InvalidateNewGRFCacheOfChain();
+	byte actual_subtype = new_subtype;
+	for (; v != NULL; v = (only_this ? NULL : v->Next())) {
+		/* Reset actual_subtype for every new vehicle */
+		if (!v->IsArticulatedPart()) actual_subtype = new_subtype;
+
+		if (v->type == VEH_TRAIN && !vehicles_to_refit.Contains(v->index) && !only_this) continue;
+
+		const Engine *e = v->GetEngine();
+		if (!e->CanCarryCargo()) continue;
+
+		/* If the vehicle is not refittable, or does not allow automatic refitting,
+		 * count its capacity nevertheless if the cargo matches */
+		bool refittable = HasBit(e->info.refit_mask, new_cid) && (!auto_refit || HasBit(e->info.misc_flags, EF_AUTO_REFIT));
+		if (!refittable && v->cargo_type != new_cid) continue;
+
+		/* Determine best fitting subtype if requested */
+		if (actual_subtype == 0xFF) {
+			actual_subtype = GetBestFittingSubType(v, v, new_cid);
+		}
+
+		/* Back up the vehicle's cargo type */
+		CargoID temp_cid = v->cargo_type;
+		byte temp_subtype = v->cargo_subtype;
+		if (refittable) {
+			v->cargo_type = new_cid;
+			v->cargo_subtype = actual_subtype;
+		}
+
+		uint16 mail_capacity = 0;
+		uint amount = e->DetermineCapacity(v, &mail_capacity);
+		total_capacity += amount;
+		/* mail_capacity will always be zero if the vehicle is not an aircraft. */
+		total_mail_capacity += mail_capacity;
+
+		if (!refittable) continue;
+
+		/* Restore the original cargo type */
+		v->cargo_type = temp_cid;
+		v->cargo_subtype = temp_subtype;
+
+		bool auto_refit_allowed;
+		CommandCost refit_cost = GetRefitCost(v, v->engine_type, new_cid, actual_subtype, &auto_refit_allowed);
+		if (auto_refit && !auto_refit_allowed) {
+			/* Sorry, auto-refitting not allowed, subtract the cargo amount again from the total. */
+			total_capacity -= amount;
+			total_mail_capacity -= mail_capacity;
+
+			if (v->cargo_type == new_cid) {
+				/* Add the old capacity nevertheless, if the cargo matches */
+				total_capacity += v->cargo_cap;
+				if (v->type == VEH_AIRCRAFT) total_mail_capacity += v->Next()->cargo_cap;
+			}
+			continue;
+		}
+		cost.AddCost(refit_cost);
+
+		/* Record the refitting.
+		 * Do not execute the refitting immediately, so DetermineCapacity and GetRefitCost do the same in test and exec run.
+		 * (weird NewGRFs)
+		 * Note:
+		 *  - If the capacity of vehicles depends on other vehicles in the chain, the actual capacity is
+		 *    set after RefitVehicle() via ConsistChanged() and friends. The estimation via _returned_refit_capacity will be wrong.
+		 *  - We have to call the refit cost callback with the pre-refit configuration of the chain because we want refit and
+		 *    autorefit to behave the same, and we need its result for auto_refit_allowed.
+		 */
+		RefitResult *result = refit_result.Append();
+		result->v = v;
+		result->capacity = amount;
+		result->mail_capacity = mail_capacity;
+		result->subtype = actual_subtype;
+	}
+
+	if (flags & DC_EXEC) {
+		/* Store the result */
+		for (RefitResult *result = refit_result.Begin(); result != refit_result.End(); result++) {
+			Vehicle *u = result->v;
+			if (u->cargo_type != new_cid) {
+				u->cargo.Truncate(u->cargo_cap);
+			} else if (u->cargo_cap > result->capacity) {
+				u->cargo.Truncate(u->cargo_cap - result->capacity);
+			}
+			u->cargo_type = new_cid;
+			u->cargo_cap = result->capacity;
+			u->cargo_subtype = result->subtype;
+			if (u->type == VEH_AIRCRAFT) {
+				Vehicle *w = u->Next();
+				if (w->cargo_cap > result->mail_capacity) {
+					w->cargo.Truncate(w->cargo_cap - result->mail_capacity);
+				}
+				w->cargo_cap = result->mail_capacity;
+			}
+		}
+	}
+
+	refit_result.Clear();
+	_returned_refit_capacity = total_capacity;
+	_returned_mail_refit_capacity = total_mail_capacity;
+	return cost;
+}
+
+/**
+ * Refits a vehicle to the specified cargo type.
+ * @param tile unused
+ * @param flags type of operation
+ * @param p1 vehicle ID to refit
+ * @param p2 various bitstuffed elements
+ * - p2 = (bit 0-4)   - New cargo type to refit to.
+ * - p2 = (bit 6)     - Automatic refitting.
+ * - p2 = (bit 7)     - Refit only this vehicle. Used only for cloning vehicles.
+ * - p2 = (bit 8-15)  - New cargo subtype to refit to. 0xFF means to try keeping the same subtype according to GetBestFittingSubType().
+ * - p2 = (bit 16-23) - Number of vehicles to refit (not counting articulated parts). Zero means all vehicles.
+ *                      Only used if "refit only this vehicle" is false.
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdRefitVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	Vehicle *v = Vehicle::GetIfValid(p1);
+	if (v == NULL) return CMD_ERROR;
+
+	/* Don't allow disasters and sparks and such to be refitted.
+	 * We cannot check for IsPrimaryVehicle as autoreplace also refits in free wagon chains. */
+	if (!IsCompanyBuildableVehicleType(v->type)) return CMD_ERROR;
+
+	Vehicle *front = v->First();
+
+	CommandCost ret = CheckOwnership(front->owner);
+	if (ret.Failed()) return ret;
+
+	bool auto_refit = HasBit(p2, 6);
+
+	/* Don't allow shadows and such to be refitted. */
+	if (v != front && (v->type == VEH_SHIP || v->type == VEH_AIRCRAFT)) return CMD_ERROR;
+	/* Allow auto-refitting only during loading and normal refitting only in a depot. */
+	if ((!auto_refit || !front->current_order.IsType(OT_LOADING)) && !front->IsStoppedInDepot()) return_cmd_error(STR_ERROR_TRAIN_MUST_BE_STOPPED_INSIDE_DEPOT + front->type);
+	if (front->vehstatus & VS_CRASHED) return_cmd_error(STR_ERROR_VEHICLE_IS_DESTROYED);
+
+	/* Check cargo */
+	CargoID new_cid = GB(p2, 0, 5);
+	byte new_subtype = GB(p2, 8, 8);
+	if (new_cid >= NUM_CARGO) return CMD_ERROR;
+
+	/* For ships and aircrafts there is always only one. */
+	bool only_this = HasBit(p2, 7) || front->type == VEH_SHIP || front->type == VEH_AIRCRAFT;
+	uint8 num_vehicles = GB(p2, 16, 8);
+
+	CommandCost cost = RefitVehicle(v, only_this, num_vehicles, new_cid, new_subtype, flags, auto_refit);
+
+	if (flags & DC_EXEC) {
+		/* Update the cached variables */
+		switch (v->type) {
+			case VEH_TRAIN:
+				Train::From(front)->ConsistChanged(auto_refit);
+				break;
+			case VEH_ROAD:
+				RoadVehUpdateCache(RoadVehicle::From(front), auto_refit);
+				if (_settings_game.vehicle.roadveh_acceleration_model != AM_ORIGINAL) RoadVehicle::From(front)->CargoChanged();
+				break;
+
+			case VEH_SHIP:
+				v->InvalidateNewGRFCacheOfChain();
+				v->colourmap = PAL_NONE; // invalidate vehicle colour map
+				Ship::From(v)->UpdateCache();
+				break;
+
+			case VEH_AIRCRAFT:
+				v->InvalidateNewGRFCacheOfChain();
+				v->colourmap = PAL_NONE; // invalidate vehicle colour map
+				UpdateAircraftCache(Aircraft::From(v), true);
+				break;
+
+			default: NOT_REACHED();
+		}
+
+		InvalidateWindowData(WC_VEHICLE_DETAILS, front->index);
+		SetWindowDirty(WC_VEHICLE_DEPOT, front->tile);
+		InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 0);
+	} else {
+		/* Always invalidate the cache; querycost might have filled it. */
+		v->InvalidateNewGRFCacheOfChain();
+	}
+
+	return cost;
+}
+
+/**
+ * Start/Stop a vehicle
+ * @param tile unused
+ * @param flags type of operation
+ * @param p1 vehicle to start/stop, don't forget to change CcStartStopVehicle if you modify this!
+ * @param p2 bit 0: Shall the start/stop newgrf callback be evaluated (only valid with DC_AUTOREPLACE for network safety)
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdStartStopVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	/* Disable the effect of p2 bit 0, when DC_AUTOREPLACE is not set */
+	if ((flags & DC_AUTOREPLACE) == 0) SetBit(p2, 0);
+
+	Vehicle *v = Vehicle::GetIfValid(p1);
+	if (v == NULL || !v->IsPrimaryVehicle()) return CMD_ERROR;
+
+	CommandCost ret = CheckOwnership(v->owner);
+	if (ret.Failed()) return ret;
+
+	if (v->vehstatus & VS_CRASHED) return_cmd_error(STR_ERROR_VEHICLE_IS_DESTROYED);
+
+	switch (v->type) {
+		case VEH_TRAIN:
+			if ((v->vehstatus & VS_STOPPED) && Train::From(v)->gcache.cached_power == 0) return_cmd_error(STR_ERROR_TRAIN_START_NO_POWER);
+			break;
+
+		case VEH_SHIP:
+		case VEH_ROAD:
+			break;
+
+		case VEH_AIRCRAFT: {
+			Aircraft *a = Aircraft::From(v);
+			/* cannot stop airplane when in flight, or when taking off / landing */
+			if (!(v->vehstatus & VS_CRASHED) && a->state >= STARTTAKEOFF && a->state < TERM7) return_cmd_error(STR_ERROR_AIRCRAFT_IS_IN_FLIGHT);
+			break;
+		}
+
+		default: return CMD_ERROR;
+	}
+
+	if (HasBit(p2, 0)) {
+		/* Check if this vehicle can be started/stopped. Failure means 'allow'. */
+		uint16 callback = GetVehicleCallback(CBID_VEHICLE_START_STOP_CHECK, 0, 0, v->engine_type, v);
+		StringID error = STR_NULL;
+		if (callback != CALLBACK_FAILED) {
+			if (v->GetGRF()->grf_version < 8) {
+				/* 8 bit result 0xFF means 'allow' */
+				if (callback < 0x400 && GB(callback, 0, 8) != 0xFF) error = GetGRFStringID(v->GetGRFID(), 0xD000 + callback);
+			} else {
+				if (callback < 0x400) {
+					error = GetGRFStringID(v->GetGRFID(), 0xD000 + callback);
+				} else {
+					switch (callback) {
+						case 0x400: // allow
+							break;
+
+						default: // unknown reason -> disallow
+							error = STR_ERROR_INCOMPATIBLE_RAIL_TYPES;
+							break;
+					}
+				}
+			}
+		}
+		if (error != STR_NULL) return_cmd_error(error);
+	}
+
+	if (flags & DC_EXEC) {
+		if (v->IsStoppedInDepot() && (flags & DC_AUTOREPLACE) == 0) DeleteVehicleNews(p1, STR_NEWS_TRAIN_IS_WAITING + v->type);
+
+		v->vehstatus ^= VS_STOPPED;
+		if (v->type != VEH_TRAIN) v->cur_speed = 0; // trains can stop 'slowly'
+		v->MarkDirty();
+		SetWindowWidgetDirty(WC_VEHICLE_VIEW, v->index, WID_VV_START_STOP);
+		SetWindowDirty(WC_VEHICLE_DEPOT, v->tile);
+		SetWindowClassesDirty(GetWindowClassForVehicleType(v->type));
+	}
+	return CommandCost();
+}
+
+/**
+ * Starts or stops a lot of vehicles
+ * @param tile Tile of the depot where the vehicles are started/stopped (only used for depots)
+ * @param flags type of operation
+ * @param p1 bitmask
+ *   - bit 0 set = start vehicles, unset = stop vehicles
+ *   - bit 1 if set, then it's a vehicle list window, not a depot and Tile is ignored in this case
+ * @param p2 packed VehicleListIdentifier
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdMassStartStopVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	VehicleList list;
+	bool do_start = HasBit(p1, 0);
+	bool vehicle_list_window = HasBit(p1, 1);
+
+	VehicleListIdentifier vli;
+	if (!vli.Unpack(p2)) return CMD_ERROR;
+	if (!IsCompanyBuildableVehicleType(vli.vtype)) return CMD_ERROR;
+
+	if (vehicle_list_window) {
+		if (!GenerateVehicleSortList(&list, vli)) return CMD_ERROR;
+	} else {
+		/* Get the list of vehicles in the depot */
+		BuildDepotVehicleList(vli.vtype, tile, &list, NULL);
+	}
+
+	for (uint i = 0; i < list.Length(); i++) {
+		const Vehicle *v = list[i];
+
+		if (!!(v->vehstatus & VS_STOPPED) != do_start) continue;
+
+		if (!vehicle_list_window && !v->IsChainInDepot()) continue;
+
+		/* Just try and don't care if some vehicle's can't be stopped. */
+		DoCommand(tile, v->index, 0, flags, CMD_START_STOP_VEHICLE);
+	}
+
+	return CommandCost();
+}
+
+/**
+ * Sells all vehicles in a depot
+ * @param tile Tile of the depot where the depot is
+ * @param flags type of operation
+ * @param p1 Vehicle type
+ * @param p2 unused
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdDepotSellAllVehicles(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	VehicleList list;
+
+	CommandCost cost(EXPENSES_NEW_VEHICLES);
+	VehicleType vehicle_type = Extract<VehicleType, 0, 3>(p1);
+
+	if (!IsCompanyBuildableVehicleType(vehicle_type)) return CMD_ERROR;
+
+	uint sell_command = GetCmdSellVeh(vehicle_type);
+
+	/* Get the list of vehicles in the depot */
+	BuildDepotVehicleList(vehicle_type, tile, &list, &list);
+
+	CommandCost last_error = CMD_ERROR;
+	bool had_success = false;
+	for (uint i = 0; i < list.Length(); i++) {
+		CommandCost ret = DoCommand(tile, list[i]->index | (1 << 20), 0, flags, sell_command);
+		if (ret.Succeeded()) {
+			cost.AddCost(ret);
+			had_success = true;
+		} else {
+			last_error = ret;
+		}
+	}
+
+	return had_success ? cost : last_error;
+}
+
+/**
+ * Autoreplace all vehicles in the depot
+ * @param tile Tile of the depot where the vehicles are
+ * @param flags type of operation
+ * @param p1 Type of vehicle
+ * @param p2 unused
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdDepotMassAutoReplace(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	VehicleList list;
+	CommandCost cost = CommandCost(EXPENSES_NEW_VEHICLES);
+	VehicleType vehicle_type = Extract<VehicleType, 0, 3>(p1);
+
+	if (!IsCompanyBuildableVehicleType(vehicle_type)) return CMD_ERROR;
+	if (!IsDepotTile(tile) || !IsTileOwner(tile, _current_company)) return CMD_ERROR;
+
+	/* Get the list of vehicles in the depot */
+	BuildDepotVehicleList(vehicle_type, tile, &list, &list, true);
+
+	for (uint i = 0; i < list.Length(); i++) {
+		const Vehicle *v = list[i];
+
+		/* Ensure that the vehicle completely in the depot */
+		if (!v->IsChainInDepot()) continue;
+
+		CommandCost ret = DoCommand(0, v->index, 0, flags, CMD_AUTOREPLACE_VEHICLE);
+
+		if (ret.Succeeded()) cost.AddCost(ret);
+	}
+	return cost;
+}
+
+/**
+ * Test if a name is unique among vehicle names.
+ * @param name Name to test.
+ * @return True ifffffff the name is unique.
+ */
+static bool IsUniqueVehicleName(const char *name)
+{
+	const Vehicle *v;
+
+	FOR_ALL_VEHICLES(v) {
+		if (v->name != NULL && strcmp(v->name, name) == 0) return false;
+	}
+
+	return true;
+}
+
+/**
+ * Clone the custom name of a vehicle, adding or incrementing a number.
+ * @param src Source vehicle, with a custom name.
+ * @param dst Destination vehicle.
+ */
+static void CloneVehicleName(const Vehicle *src, Vehicle *dst)
+{
+	char buf[256];
+
+	/* Find the position of the first digit in the last group of digits. */
+	size_t number_position;
+	for (number_position = strlen(src->name); number_position > 0; number_position--) {
+		/* The design of UTF-8 lets this work simply without having to check
+		 * for UTF-8 sequences. */
+		if (src->name[number_position - 1] < '0' || src->name[number_position - 1] > '9') break;
+	}
+
+	/* Format buffer and determine starting number. */
+	int num;
+	byte padding = 0;
+	if (number_position == strlen(src->name)) {
+		/* No digit at the end, so start at number 2. */
+		strecpy(buf, src->name, lastof(buf));
+		strecat(buf, " ", lastof(buf));
+		number_position = strlen(buf);
+		num = 2;
+	} else {
+		/* Found digits, parse them and start at the next number. */
+		strecpy(buf, src->name, lastof(buf));
+		buf[number_position] = '\0';
+		char *endptr;
+		num = strtol(&src->name[number_position], &endptr, 10) + 1;
+		padding = endptr - &src->name[number_position];
+	}
+
+	/* Check if this name is already taken. */
+	for (int max_iterations = 1000; max_iterations > 0; max_iterations--, num++) {
+		/* Attach the number to the temporary name. */
+		seprintf(&buf[number_position], lastof(buf), "%0*d", padding, num);
+
+		/* Check the name is unique. */
+		if (IsUniqueVehicleName(buf)) {
+			dst->name = strdup(buf);
+			break;
+		}
+	}
+
+	/* All done. If we didn't find a name, it'll just use its default. */
+}
+
+/**
+ * Clone a vehicle. If it is a train, it will clone all the cars too
+ * @param tile tile of the depot where the cloned vehicle is build
+ * @param flags type of operation
+ * @param p1 the original vehicle's index
+ * @param p2 1 = shared orders, else copied orders
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdCloneVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	CommandCost total_cost(EXPENSES_NEW_VEHICLES);
+
+	Vehicle *v = Vehicle::GetIfValid(p1);
+	if (v == NULL || !v->IsPrimaryVehicle()) return CMD_ERROR;
+	Vehicle *v_front = v;
+	Vehicle *w = NULL;
+	Vehicle *w_front = NULL;
+	Vehicle *w_rear = NULL;
+
+	/*
+	 * v_front is the front engine in the original vehicle
+	 * v is the car/vehicle of the original vehicle that is currently being copied
+	 * w_front is the front engine of the cloned vehicle
+	 * w is the car/vehicle currently being cloned
+	 * w_rear is the rear end of the cloned train. It's used to add more cars and is only used by trains
+	 */
+
+	CommandCost ret = CheckOwnership(v->owner);
+	if (ret.Failed()) return ret;
+
+	if (v->type == VEH_TRAIN && (!v->IsFrontEngine() || Train::From(v)->crash_anim_pos >= 4400)) return CMD_ERROR;
+
+	/* check that we can allocate enough vehicles */
+	if (!(flags & DC_EXEC)) {
+		int veh_counter = 0;
+		do {
+			veh_counter++;
+		} while ((v = v->Next()) != NULL);
+
+		if (!Vehicle::CanAllocateItem(veh_counter)) {
+			return_cmd_error(STR_ERROR_TOO_MANY_VEHICLES_IN_GAME);
+		}
+	}
+
+	v = v_front;
+
+	do {
+		if (v->type == VEH_TRAIN && Train::From(v)->IsRearDualheaded()) {
+			/* we build the rear ends of multiheaded trains with the front ones */
+			continue;
+		}
+
+		/* In case we're building a multi headed vehicle and the maximum number of
+		 * vehicles is almost reached (e.g. max trains - 1) not all vehicles would
+		 * be cloned. When the non-primary engines were build they were seen as
+		 * 'new' vehicles whereas they would immediately be joined with a primary
+		 * engine. This caused the vehicle to be not build as 'the limit' had been
+		 * reached, resulting in partially build vehicles and such. */
+		DoCommandFlag build_flags = flags;
+		if ((flags & DC_EXEC) && !v->IsPrimaryVehicle()) build_flags |= DC_AUTOREPLACE;
+
+		CommandCost cost = DoCommand(tile, v->engine_type | (1 << 16), 0, build_flags, GetCmdBuildVeh(v));
+
+		if (cost.Failed()) {
+			/* Can't build a part, then sell the stuff we already made; clear up the mess */
+			if (w_front != NULL) DoCommand(w_front->tile, w_front->index | (1 << 20), 0, flags, GetCmdSellVeh(w_front));
+			return cost;
+		}
+
+		total_cost.AddCost(cost);
+
+		if (flags & DC_EXEC) {
+			w = Vehicle::Get(_new_vehicle_id);
+
+			if (v->type == VEH_TRAIN && HasBit(Train::From(v)->flags, VRF_REVERSE_DIRECTION)) {
+				SetBit(Train::From(w)->flags, VRF_REVERSE_DIRECTION);
+			}
+
+			if (v->type == VEH_TRAIN && !v->IsFrontEngine()) {
+				/* this s a train car
+				 * add this unit to the end of the train */
+				CommandCost result = DoCommand(0, w->index | 1 << 20, w_rear->index, flags, CMD_MOVE_RAIL_VEHICLE);
+				if (result.Failed()) {
+					/* The train can't be joined to make the same consist as the original.
+					 * Sell what we already made (clean up) and return an error.           */
+					DoCommand(w_front->tile, w_front->index | 1 << 20, 0, flags, GetCmdSellVeh(w_front));
+					DoCommand(w_front->tile, w->index       | 1 << 20, 0, flags, GetCmdSellVeh(w));
+					return result; // return error and the message returned from CMD_MOVE_RAIL_VEHICLE
+				}
+			} else {
+				/* this is a front engine or not a train. */
+				w_front = w;
+				w->service_interval = v->service_interval;
+				w->SetServiceIntervalIsCustom(v->ServiceIntervalIsCustom());
+				w->SetServiceIntervalIsPercent(v->ServiceIntervalIsPercent());
+			}
+			w_rear = w; // trains needs to know the last car in the train, so they can add more in next loop
+		}
+	} while (v->type == VEH_TRAIN && (v = v->GetNextVehicle()) != NULL);
+
+	if ((flags & DC_EXEC) && v_front->type == VEH_TRAIN) {
+		/* for trains this needs to be the front engine due to the callback function */
+		_new_vehicle_id = w_front->index;
+	}
+
+	if (flags & DC_EXEC) {
+		/* Cloned vehicles belong to the same group */
+		DoCommand(0, v_front->group_id, w_front->index, flags, CMD_ADD_VEHICLE_GROUP);
+	}
+
+
+	/* Take care of refitting. */
+	w = w_front;
+	v = v_front;
+
+	/* Both building and refitting are influenced by newgrf callbacks, which
+	 * makes it impossible to accurately estimate the cloning costs. In
+	 * particular, it is possible for engines of the same type to be built with
+	 * different numbers of articulated parts, so when refitting we have to
+	 * loop over real vehicles first, and then the articulated parts of those
+	 * vehicles in a different loop. */
+	do {
+		do {
+			if (flags & DC_EXEC) {
+				assert(w != NULL);
+
+				/* Find out what's the best sub type */
+				byte subtype = GetBestFittingSubType(v, w, v->cargo_type);
+				if (w->cargo_type != v->cargo_type || w->cargo_subtype != subtype) {
+					CommandCost cost = DoCommand(0, w->index, v->cargo_type | 1U << 7 | (subtype << 8), flags, GetCmdRefitVeh(v));
+					if (cost.Succeeded()) total_cost.AddCost(cost);
+				}
+
+				if (w->IsGroundVehicle() && w->HasArticulatedPart()) {
+					w = w->GetNextArticulatedPart();
+				} else {
+					break;
+				}
+			} else {
+				const Engine *e = v->GetEngine();
+				CargoID initial_cargo = (e->CanCarryCargo() ? e->GetDefaultCargoType() : (CargoID)CT_INVALID);
+
+				if (v->cargo_type != initial_cargo && initial_cargo != CT_INVALID) {
+					bool dummy;
+					total_cost.AddCost(GetRefitCost(NULL, v->engine_type, v->cargo_type, v->cargo_subtype, &dummy));
+				}
+			}
+
+			if (v->IsGroundVehicle() && v->HasArticulatedPart()) {
+				v = v->GetNextArticulatedPart();
+			} else {
+				break;
+			}
+		} while (v != NULL);
+
+		if ((flags & DC_EXEC) && v->type == VEH_TRAIN) w = w->GetNextVehicle();
+	} while (v->type == VEH_TRAIN && (v = v->GetNextVehicle()) != NULL);
+
+	if (flags & DC_EXEC) {
+		/*
+		 * Set the orders of the vehicle. Cannot do it earlier as we need
+		 * the vehicle refitted before doing this, otherwise the moved
+		 * cargo types might not match (passenger vs non-passenger)
+		 */
+		DoCommand(0, w_front->index | (p2 & 1 ? CO_SHARE : CO_COPY) << 30, v_front->index, flags, CMD_CLONE_ORDER);
+
+		/* Now clone the vehicle's name, if it has one. */
+		if (v_front->name != NULL) CloneVehicleName(v_front, w_front);
+	}
+
+	/* Since we can't estimate the cost of cloning a vehicle accurately we must
+	 * check whether the company has enough money manually. */
+	if (!CheckCompanyHasMoney(total_cost)) {
+		if (flags & DC_EXEC) {
+			/* The vehicle has already been bought, so now it must be sold again. */
+			DoCommand(w_front->tile, w_front->index | 1 << 20, 0, flags, GetCmdSellVeh(w_front));
+		}
+		return total_cost;
+	}
+
+	return total_cost;
+}
+
+/**
+ * Send all vehicles of type to depots
+ * @param flags   the flags used for DoCommand()
+ * @param service should the vehicles only get service in the depots
+ * @param vli     identifier of the vehicle list
+ * @return 0 for success and CMD_ERROR if no vehicle is able to go to depot
+ */
+static CommandCost SendAllVehiclesToDepot(DoCommandFlag flags, bool service, const VehicleListIdentifier &vli)
+{
+	VehicleList list;
+
+	if (!GenerateVehicleSortList(&list, vli)) return CMD_ERROR;
+
+	/* Send all the vehicles to a depot */
+	bool had_success = false;
+	for (uint i = 0; i < list.Length(); i++) {
+		const Vehicle *v = list[i];
+		CommandCost ret = DoCommand(v->tile, v->index | (service ? DEPOT_SERVICE : 0U) | DEPOT_DONT_CANCEL, 0, flags, GetCmdSendToDepot(vli.vtype));
+
+		if (ret.Succeeded()) {
+			had_success = true;
+
+			/* Return 0 if DC_EXEC is not set this is a valid goto depot command)
+			 * In this case we know that at least one vehicle can be sent to a depot
+			 * and we will issue the command. We can now safely quit the loop, knowing
+			 * it will succeed at least once. With DC_EXEC we really need to send them to the depot */
+			if (!(flags & DC_EXEC)) break;
+		}
+	}
+
+	return had_success ? CommandCost() : CMD_ERROR;
+}
+
+/**
+ * Send a vehicle to the depot.
+ * @param tile unused
+ * @param flags for command type
+ * @param p1 bitmask
+ * - p1 0-20: bitvehicle ID to send to the depot
+ * - p1 bits 25-8  - DEPOT_ flags (see vehicle_type.h)
+ * @param p2 packed VehicleListIdentifier.
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdSendVehicleToDepot(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	if (p1 & DEPOT_MASS_SEND) {
+		/* Mass goto depot requested */
+		VehicleListIdentifier vli;
+		if (!vli.Unpack(p2)) return CMD_ERROR;
+		return SendAllVehiclesToDepot(flags, (p1 & DEPOT_SERVICE) != 0, vli);
+	}
+
+	Vehicle *v = Vehicle::GetIfValid(GB(p1, 0, 20));
+	if (v == NULL) return CMD_ERROR;
+	if (!v->IsPrimaryVehicle()) return CMD_ERROR;
+
+	return v->SendToDepot(flags, (DepotCommand)(p1 & DEPOT_COMMAND_MASK));
+}
+
+/**
+ * Give a custom name to your vehicle
+ * @param tile unused
+ * @param flags type of operation
+ * @param p1 vehicle ID to name
+ * @param p2 unused
+ * @param text the new name or an empty string when resetting to the default
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdRenameVehicle(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	Vehicle *v = Vehicle::GetIfValid(p1);
+	if (v == NULL || !v->IsPrimaryVehicle()) return CMD_ERROR;
+
+	CommandCost ret = CheckOwnership(v->owner);
+	if (ret.Failed()) return ret;
+
+	bool reset = StrEmpty(text);
+
+	if (!reset) {
+		if (Utf8StringLength(text) >= MAX_LENGTH_VEHICLE_NAME_CHARS) return CMD_ERROR;
+		if (!(flags & DC_AUTOREPLACE) && !IsUniqueVehicleName(text)) return_cmd_error(STR_ERROR_NAME_MUST_BE_UNIQUE);
+	}
+
+	if (flags & DC_EXEC) {
+		free(v->name);
+		v->name = reset ? NULL : strdup(text);
+		InvalidateWindowClassesData(GetWindowClassForVehicleType(v->type), 1);
+		MarkWholeScreenDirty();
+	}
+
+	return CommandCost();
+}
+
+
+/**
+ * Change the service interval of a vehicle
+ * @param tile unused
+ * @param flags type of operation
+ * @param p1 vehicle ID that is being service-interval-changed
+ * @param p2 bitmask
+ * - p2 = (bit  0-15) - new service interval
+ * - p2 = (bit 16)    - service interval is custom flag
+ * - p2 = (bit 17)    - service interval is percentage flag
+ * @param text unused
+ * @return the cost of this operation or an error
+ */
+CommandCost CmdChangeServiceInt(TileIndex tile, DoCommandFlag flags, uint32 p1, uint32 p2, const char *text)
+{
+	Vehicle *v = Vehicle::GetIfValid(p1);
+	if (v == NULL || !v->IsPrimaryVehicle()) return CMD_ERROR;
+
+	CommandCost ret = CheckOwnership(v->owner);
+	if (ret.Failed()) return ret;
+
+	const Company *company = Company::Get(v->owner);
+	bool iscustom  = HasBit(p2, 16);
+	bool ispercent = iscustom ? HasBit(p2, 17) : company->settings.vehicle.servint_ispercent;
+
+	uint16 serv_int;
+	if (iscustom) {
+		serv_int = GB(p2, 0, 16);
+		if (serv_int != GetServiceIntervalClamped(serv_int, ispercent)) return CMD_ERROR;
+	} else {
+		serv_int = CompanyServiceInterval(company, v->type);
+	}
+
+	if (flags & DC_EXEC) {
+		v->SetServiceInterval(serv_int);
+		v->SetServiceIntervalIsCustom(iscustom);
+		v->SetServiceIntervalIsPercent(ispercent);
+		SetWindowDirty(WC_VEHICLE_DETAILS, v->index);
+	}
+
+	return CommandCost();
+}
diff --git a/src/vehicle_gui.cpp b/src/vehicle_gui.cpp
index d04217d..2abe531 100644
--- a/src/vehicle_gui.cpp
+++ b/src/vehicle_gui.cpp
@@ -39,7 +39,6 @@
 #include "tilehighlight_func.h"
 #include "zoom_func.h"
 
-
 Sorting _sorting;
 
 static GUIVehicleList::SortFunction VehicleNumberSorter;
@@ -156,6 +155,7 @@ DropDownList *BaseVehicleListWindow::BuildActionDropdownList(bool show_autorepla
 {
 	DropDownList *list = new DropDownList();
 
+	list->push_back(new DropDownListStringItem(STR_TMPL_TEMPLATE_REPLACEMENT, ADI_TEMPLATE_REPLACE, false));		// MYGUI_NOEND
 	if (show_autoreplace) list->push_back(new DropDownListStringItem(STR_VEHICLE_LIST_REPLACE_VEHICLES, ADI_REPLACE, false));
 	list->push_back(new DropDownListStringItem(STR_VEHICLE_LIST_SEND_FOR_SERVICING, ADI_SERVICE, false));
 	list->push_back(new DropDownListStringItem(this->vehicle_depot_name[this->vli.vtype], ADI_DEPOT, false));
@@ -388,6 +388,7 @@ struct RefitWindow : public Window {
 	VehicleID selected_vehicle;  ///< First vehicle in the current selection.
 	uint8 num_vehicles;          ///< Number of selected vehicles.
 	bool auto_refit;             ///< Select cargo for auto-refitting.
+	bool is_virtual_train;
 
 	/**
 	 * Collects all (cargo, subcargo) refit options of a vehicle chain.
@@ -574,6 +575,7 @@ struct RefitWindow : public Window {
 		this->sel[0] = -1;
 		this->sel[1] = 0;
 		this->auto_refit = auto_refit;
+		this->is_virtual_train = is_virtual;
 		this->order = order;
 		this->CreateNestedTree(desc);
 
@@ -930,9 +932,9 @@ struct RefitWindow : public Window {
 
 					if (this->order == INVALID_VEH_ORDER_ID) {
 						bool delete_window = this->selected_vehicle == v->index && this->num_vehicles == UINT8_MAX;
-						if (DoCommandP(v->tile, this->selected_vehicle, this->cargo->cargo | this->cargo->subtype << 8 | this->num_vehicles << 16, GetCmdRefitVeh(v)) && delete_window) delete this;
+						if (DoCommandP(v->tile, this->selected_vehicle, this->cargo->cargo | this->cargo->subtype << 8 | this->num_vehicles << 16 | this->is_virtual_train << 5, GetCmdRefitVeh(v)) && delete_window) delete this;
 					} else {
-						if (DoCommandP(v->tile, v->index, this->cargo->cargo | this->order << 16, CMD_ORDER_REFIT)) delete this;
+						if (DoCommandP(v->tile, v->index, this->cargo->cargo | this->cargo->subtype << 8 | this->order << 16 | this->is_virtual_train << 5, CMD_ORDER_REFIT)) delete this;
 					}
 				}
 				break;
@@ -1013,10 +1015,10 @@ static const WindowDesc _vehicle_refit_desc(
  * @param parent the parent window of the refit window
  * @param auto_refit Choose cargo for auto-refitting
  */
-void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit)
+void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit, bool is_virtual_train)
 {
 	DeleteWindowById(WC_VEHICLE_REFIT, v->index);
-	RefitWindow *w = new RefitWindow(&_vehicle_refit_desc, v, order, auto_refit);
+	RefitWindow *w = new RefitWindow(&_vehicle_refit_desc, v, order, auto_refit, is_virtual_train);
 	w->parent = parent;
 }
 
diff --git a/src/vehicle_gui.cpp.orig b/src/vehicle_gui.cpp.orig
new file mode 100644
index 0000000..d04217d
--- /dev/null
+++ b/src/vehicle_gui.cpp.orig
@@ -0,0 +1,2817 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file vehicle_gui.cpp The base GUI for all vehicles. */
+
+#include "stdafx.h"
+#include "debug.h"
+#include "company_func.h"
+#include "gui.h"
+#include "textbuf_gui.h"
+#include "command_func.h"
+#include "vehicle_gui_base.h"
+#include "viewport_func.h"
+#include "newgrf_text.h"
+#include "newgrf_debug.h"
+#include "roadveh.h"
+#include "train.h"
+#include "aircraft.h"
+#include "depot_map.h"
+#include "group_gui.h"
+#include "strings_func.h"
+#include "vehicle_func.h"
+#include "autoreplace_gui.h"
+#include "string_func.h"
+#include "widgets/dropdown_func.h"
+#include "timetable.h"
+#include "articulated_vehicles.h"
+#include "spritecache.h"
+#include "core/geometry_func.hpp"
+#include "company_base.h"
+#include "engine_func.h"
+#include "station_base.h"
+#include "tilehighlight_func.h"
+#include "zoom_func.h"
+
+
+Sorting _sorting;
+
+static GUIVehicleList::SortFunction VehicleNumberSorter;
+static GUIVehicleList::SortFunction VehicleNameSorter;
+static GUIVehicleList::SortFunction VehicleAgeSorter;
+static GUIVehicleList::SortFunction VehicleProfitThisYearSorter;
+static GUIVehicleList::SortFunction VehicleProfitLastYearSorter;
+static GUIVehicleList::SortFunction VehicleCargoSorter;
+static GUIVehicleList::SortFunction VehicleReliabilitySorter;
+static GUIVehicleList::SortFunction VehicleMaxSpeedSorter;
+static GUIVehicleList::SortFunction VehicleModelSorter;
+static GUIVehicleList::SortFunction VehicleValueSorter;
+static GUIVehicleList::SortFunction VehicleLengthSorter;
+static GUIVehicleList::SortFunction VehicleTimeToLiveSorter;
+static GUIVehicleList::SortFunction VehicleTimetableDelaySorter;
+
+GUIVehicleList::SortFunction * const BaseVehicleListWindow::vehicle_sorter_funcs[] = {
+	&VehicleNumberSorter,
+	&VehicleNameSorter,
+	&VehicleAgeSorter,
+	&VehicleProfitThisYearSorter,
+	&VehicleProfitLastYearSorter,
+	&VehicleCargoSorter,
+	&VehicleReliabilitySorter,
+	&VehicleMaxSpeedSorter,
+	&VehicleModelSorter,
+	&VehicleValueSorter,
+	&VehicleLengthSorter,
+	&VehicleTimeToLiveSorter,
+	&VehicleTimetableDelaySorter,
+};
+
+const StringID BaseVehicleListWindow::vehicle_sorter_names[] = {
+	STR_SORT_BY_NUMBER,
+	STR_SORT_BY_NAME,
+	STR_SORT_BY_AGE,
+	STR_SORT_BY_PROFIT_THIS_YEAR,
+	STR_SORT_BY_PROFIT_LAST_YEAR,
+	STR_SORT_BY_TOTAL_CAPACITY_PER_CARGOTYPE,
+	STR_SORT_BY_RELIABILITY,
+	STR_SORT_BY_MAX_SPEED,
+	STR_SORT_BY_MODEL,
+	STR_SORT_BY_VALUE,
+	STR_SORT_BY_LENGTH,
+	STR_SORT_BY_LIFE_TIME,
+	STR_SORT_BY_TIMETABLE_DELAY,
+	INVALID_STRING_ID
+};
+
+const StringID BaseVehicleListWindow::vehicle_depot_name[] = {
+	STR_VEHICLE_LIST_SEND_TRAIN_TO_DEPOT,
+	STR_VEHICLE_LIST_SEND_ROAD_VEHICLE_TO_DEPOT,
+	STR_VEHICLE_LIST_SEND_SHIP_TO_DEPOT,
+	STR_VEHICLE_LIST_SEND_AIRCRAFT_TO_HANGAR
+};
+
+void BaseVehicleListWindow::BuildVehicleList()
+{
+	if (!this->vehicles.NeedRebuild()) return;
+
+	DEBUG(misc, 3, "Building vehicle list type %d for company %d given index %d", this->vli.type, this->vli.company, this->vli.index);
+
+	GenerateVehicleSortList(&this->vehicles, this->vli);
+
+	uint unitnumber = 0;
+	for (const Vehicle **v = this->vehicles.Begin(); v != this->vehicles.End(); v++) {
+		unitnumber = max<uint>(unitnumber, (*v)->unitnumber);
+	}
+
+	/* Because 111 is much less wide than e.g. 999 we use the
+	 * wider numbers to determine the width instead of just
+	 * the random number that it seems to be. */
+	if (unitnumber >= 1000) {
+		this->unitnumber_digits = 4;
+	} else if (unitnumber >= 100) {
+		this->unitnumber_digits = 3;
+	} else {
+		this->unitnumber_digits = 2;
+	}
+
+	this->vehicles.RebuildDone();
+	this->vscroll->SetCount(this->vehicles.Length());
+}
+
+/**
+ * Compute the size for the Action dropdown.
+ * @param show_autoreplace If true include the autoreplace item.
+ * @param show_group If true include group-related stuff.
+ * @return Required size.
+ */
+Dimension BaseVehicleListWindow::GetActionDropdownSize(bool show_autoreplace, bool show_group)
+{
+	Dimension d = {0, 0};
+
+	if (show_autoreplace) d = maxdim(d, GetStringBoundingBox(STR_VEHICLE_LIST_REPLACE_VEHICLES));
+	d = maxdim(d, GetStringBoundingBox(STR_VEHICLE_LIST_SEND_FOR_SERVICING));
+	d = maxdim(d, GetStringBoundingBox(this->vehicle_depot_name[this->vli.vtype]));
+
+	if (show_group) {
+		d = maxdim(d, GetStringBoundingBox(STR_GROUP_ADD_SHARED_VEHICLE));
+		d = maxdim(d, GetStringBoundingBox(STR_GROUP_REMOVE_ALL_VEHICLES));
+	}
+
+	return d;
+}
+
+/**
+ * Display the Action dropdown window.
+ * @param show_autoreplace If true include the autoreplace item.
+ * @param show_group If true include group-related stuff.
+ * @return Itemlist for dropdown
+ */
+DropDownList *BaseVehicleListWindow::BuildActionDropdownList(bool show_autoreplace, bool show_group)
+{
+	DropDownList *list = new DropDownList();
+
+	if (show_autoreplace) list->push_back(new DropDownListStringItem(STR_VEHICLE_LIST_REPLACE_VEHICLES, ADI_REPLACE, false));
+	list->push_back(new DropDownListStringItem(STR_VEHICLE_LIST_SEND_FOR_SERVICING, ADI_SERVICE, false));
+	list->push_back(new DropDownListStringItem(this->vehicle_depot_name[this->vli.vtype], ADI_DEPOT, false));
+
+	if (show_group) {
+		list->push_back(new DropDownListStringItem(STR_GROUP_ADD_SHARED_VEHICLE, ADI_ADD_SHARED, false));
+		list->push_back(new DropDownListStringItem(STR_GROUP_REMOVE_ALL_VEHICLES, ADI_REMOVE_ALL, false));
+	}
+
+	return list;
+}
+
+/* cached values for VehicleNameSorter to spare many GetString() calls */
+static const Vehicle *_last_vehicle[2] = { NULL, NULL };
+
+void BaseVehicleListWindow::SortVehicleList()
+{
+	if (this->vehicles.Sort()) return;
+
+	/* invalidate cached values for name sorter - vehicle names could change */
+	_last_vehicle[0] = _last_vehicle[1] = NULL;
+}
+
+void DepotSortList(VehicleList *list)
+{
+	if (list->Length() < 2) return;
+	QSortT(list->Begin(), list->Length(), &VehicleNumberSorter);
+}
+
+/** draw the vehicle profit button in the vehicle list window. */
+static void DrawVehicleProfitButton(const Vehicle *v, int x, int y)
+{
+	SpriteID spr;
+
+	/* draw profit-based coloured icons */
+	if (v->age <= VEHICLE_PROFIT_MIN_AGE) {
+		spr = SPR_PROFIT_NA;
+	} else if (v->GetDisplayProfitLastYear() < 0) {
+		spr = SPR_PROFIT_NEGATIVE;
+	} else if (v->GetDisplayProfitLastYear() < VEHICLE_PROFIT_THRESHOLD) {
+		spr = SPR_PROFIT_SOME;
+	} else {
+		spr = SPR_PROFIT_LOT;
+	}
+	DrawSprite(spr, PAL_NONE, x, y);
+}
+
+/** Maximum number of refit cycles we try, to prevent infinite loops. And we store only a byte anyway */
+static const uint MAX_REFIT_CYCLE = 256;
+
+/**
+ * Get the best fitting subtype when 'cloning'/'replacing' \a v_from with \a v_for.
+ * All articulated parts of both vehicles are tested to find a possibly shared subtype.
+ * For \a v_for only vehicle refittable to \a dest_cargo_type are considered.
+ * @param v_from the vehicle to match the subtype from
+ * @param v_for  the vehicle to get the subtype for
+ * @param dest_cargo_type Destination cargo type.
+ * @return the best sub type
+ */
+byte GetBestFittingSubType(Vehicle *v_from, Vehicle *v_for, CargoID dest_cargo_type)
+{
+	v_from = v_from->GetFirstEnginePart();
+	v_for = v_for->GetFirstEnginePart();
+
+	/* Create a list of subtypes used by the various parts of v_for */
+	static SmallVector<StringID, 4> subtypes;
+	subtypes.Clear();
+	for (; v_from != NULL; v_from = v_from->HasArticulatedPart() ? v_from->GetNextArticulatedPart() : NULL) {
+		const Engine *e_from = v_from->GetEngine();
+		if (!e_from->CanCarryCargo() || !HasBit(e_from->info.callback_mask, CBM_VEHICLE_CARGO_SUFFIX)) continue;
+		subtypes.Include(GetCargoSubtypeText(v_from));
+	}
+
+	byte ret_refit_cyc = 0;
+	bool success = false;
+	if (subtypes.Length() > 0) {
+		/* Check whether any articulated part is refittable to 'dest_cargo_type' with a subtype listed in 'subtypes' */
+		for (Vehicle *v = v_for; v != NULL; v = v->HasArticulatedPart() ? v->GetNextArticulatedPart() : NULL) {
+			const Engine *e = v->GetEngine();
+			if (!e->CanCarryCargo() || !HasBit(e->info.callback_mask, CBM_VEHICLE_CARGO_SUFFIX)) continue;
+			if (!HasBit(e->info.refit_mask, dest_cargo_type) && v->cargo_type != dest_cargo_type) continue;
+
+			CargoID old_cargo_type = v->cargo_type;
+			byte old_cargo_subtype = v->cargo_subtype;
+
+			/* Set the 'destination' cargo */
+			v->cargo_type = dest_cargo_type;
+
+			/* Cycle through the refits */
+			for (uint refit_cyc = 0; refit_cyc < MAX_REFIT_CYCLE; refit_cyc++) {
+				v->cargo_subtype = refit_cyc;
+
+				/* Make sure we don't pick up anything cached. */
+				v->First()->InvalidateNewGRFCache();
+				v->InvalidateNewGRFCache();
+
+				StringID subtype = GetCargoSubtypeText(v);
+				if (subtype == STR_EMPTY) break;
+
+				if (!subtypes.Contains(subtype)) continue;
+
+				/* We found something matching. */
+				ret_refit_cyc = refit_cyc;
+				success = true;
+				break;
+			}
+
+			/* Reset the vehicle's cargo type */
+			v->cargo_type    = old_cargo_type;
+			v->cargo_subtype = old_cargo_subtype;
+
+			/* Make sure we don't taint the vehicle. */
+			v->First()->InvalidateNewGRFCache();
+			v->InvalidateNewGRFCache();
+
+			if (success) break;
+		}
+	}
+
+	return ret_refit_cyc;
+}
+
+/** Option to refit a vehicle chain */
+struct RefitOption {
+	CargoID cargo;    ///< Cargo to refit to
+	byte subtype;     ///< Subcargo to use
+	StringID string;  ///< GRF-local String to display for the cargo
+
+	/**
+	 * Inequality operator for #RefitOption.
+	 * @param other Compare to this #RefitOption.
+	 * @return True if both #RefitOption are different.
+	 */
+	inline bool operator != (const RefitOption &other) const
+	{
+		return other.cargo != this->cargo || other.string != this->string;
+	}
+
+	/**
+	 * Equality operator for #RefitOption.
+	 * @param other Compare to this #RefitOption.
+	 * @return True if both #RefitOption are equal.
+	 */
+	inline bool operator == (const RefitOption &other) const
+	{
+		return other.cargo == this->cargo && other.string == this->string;
+	}
+};
+
+typedef SmallVector<RefitOption, 32> SubtypeList; ///< List of refit subtypes associated to a cargo.
+
+/**
+ * Draw the list of available refit options for a consist and highlight the selected refit option (if any).
+ * @param list  List of subtype options for each (sorted) cargo.
+ * @param sel   Selected refit cargo-type in the window
+ * @param pos   Position of the selected item in caller widow
+ * @param rows  Number of rows(capacity) in caller window
+ * @param delta Step height in caller window
+ * @param r     Rectangle of the matrix widget.
+ */
+static void DrawVehicleRefitWindow(const SubtypeList list[NUM_CARGO], const int sel[2], uint pos, uint rows, uint delta, const Rect &r)
+{
+	uint y = r.top + WD_MATRIX_TOP;
+	uint current = 0;
+
+	bool rtl = _current_text_dir == TD_RTL;
+	uint iconwidth = max(GetSpriteSize(SPR_CIRCLE_FOLDED).width, GetSpriteSize(SPR_CIRCLE_UNFOLDED).width);
+	uint iconheight = GetSpriteSize(SPR_CIRCLE_FOLDED).height;
+	int linecolour = _colour_gradient[COLOUR_ORANGE][4];
+
+	int iconleft   = rtl ? r.right - WD_MATRIX_RIGHT - iconwidth     : r.left + WD_MATRIX_LEFT;
+	int iconcenter = rtl ? r.right - WD_MATRIX_RIGHT - iconwidth / 2 : r.left + WD_MATRIX_LEFT + iconwidth / 2;
+	int iconinner  = rtl ? r.right - WD_MATRIX_RIGHT - iconwidth     : r.left + WD_MATRIX_LEFT + iconwidth;
+
+	int textleft   = r.left  + WD_MATRIX_LEFT  + (rtl ? 0 : iconwidth + 4);
+	int textright  = r.right - WD_MATRIX_RIGHT - (rtl ? iconwidth + 4 : 0);
+
+	/* Draw the list of subtypes for each cargo, and find the selected refit option (by its position). */
+	for (uint i = 0; current < pos + rows && i < NUM_CARGO; i++) {
+		for (uint j = 0; current < pos + rows && j < list[i].Length(); j++) {
+			const RefitOption &refit = list[i][j];
+
+			/* Hide subtypes if sel[0] does not match */
+			if (sel[0] != (int)i && refit.subtype != 0xFF) continue;
+
+			/* Refit options with a position smaller than pos don't have to be drawn. */
+			if (current < pos) {
+				current++;
+				continue;
+			}
+
+			if (list[i].Length() > 1) {
+				if (refit.subtype != 0xFF) {
+					/* Draw tree lines */
+					int ycenter = y + FONT_HEIGHT_NORMAL / 2;
+					GfxDrawLine(iconcenter, y - WD_MATRIX_TOP, iconcenter, j == list[i].Length() - 1 ? ycenter : y - WD_MATRIX_TOP + delta - 1, linecolour);
+					GfxDrawLine(iconcenter, ycenter, iconinner, ycenter, linecolour);
+				} else {
+					/* Draw expand/collapse icon */
+					DrawSprite(sel[0] == (int)i ? SPR_CIRCLE_UNFOLDED : SPR_CIRCLE_FOLDED, PAL_NONE, iconleft, y + (FONT_HEIGHT_NORMAL - iconheight) / 2);
+				}
+			}
+
+			TextColour colour = (sel[0] == (int)i && (uint)sel[1] == j) ? TC_WHITE : TC_BLACK;
+			/* Get the cargo name. */
+			SetDParam(0, CargoSpec::Get(refit.cargo)->name);
+			SetDParam(1, refit.string);
+			DrawString(textleft, textright, y, STR_JUST_STRING_STRING, colour);
+
+			y += delta;
+			current++;
+		}
+	}
+}
+
+/** Refit cargo window. */
+struct RefitWindow : public Window {
+	int sel[2];                  ///< Index in refit options, sel[0] == -1 if nothing is selected.
+	RefitOption *cargo;          ///< Refit option selected by #sel.
+	SubtypeList list[NUM_CARGO]; ///< List of refit subtypes available for each sorted cargo.
+	VehicleOrderID order;        ///< If not #INVALID_VEH_ORDER_ID, selection is part of a refit order (rather than execute directly).
+	uint information_width;      ///< Width required for correctly displaying all cargoes in the information panel.
+	Scrollbar *vscroll;          ///< The main scrollbar.
+	Scrollbar *hscroll;          ///< Only used for long vehicles.
+	int vehicle_width;           ///< Width of the vehicle being drawn.
+	int sprite_left;             ///< Left position of the vehicle sprite.
+	int sprite_right;            ///< Right position of the vehicle sprite.
+	uint vehicle_margin;         ///< Margin to use while selecting vehicles when the vehicle image is centered.
+	int click_x;                 ///< Position of the first click while dragging.
+	VehicleID selected_vehicle;  ///< First vehicle in the current selection.
+	uint8 num_vehicles;          ///< Number of selected vehicles.
+	bool auto_refit;             ///< Select cargo for auto-refitting.
+
+	/**
+	 * Collects all (cargo, subcargo) refit options of a vehicle chain.
+	 */
+	void BuildRefitList()
+	{
+		for (uint i = 0; i < NUM_CARGO; i++) this->list[i].Clear();
+		Vehicle *v = Vehicle::Get(this->window_number);
+
+		/* Check only the selected vehicles. */
+		VehicleSet vehicles_to_refit;
+		GetVehicleSet(vehicles_to_refit, Vehicle::Get(this->selected_vehicle), this->num_vehicles);
+
+		do {
+			if (v->type == VEH_TRAIN && !vehicles_to_refit.Contains(v->index)) continue;
+			const Engine *e = v->GetEngine();
+			uint32 cmask = e->info.refit_mask;
+			byte callback_mask = e->info.callback_mask;
+
+			/* Skip this engine if it does not carry anything */
+			if (!e->CanCarryCargo()) continue;
+			/* Skip this engine if we build the list for auto-refitting and engine doesn't allow it. */
+			if (this->auto_refit && !HasBit(e->info.misc_flags, EF_AUTO_REFIT)) continue;
+
+			/* Loop through all cargoes in the refit mask */
+			int current_index = 0;
+			const CargoSpec *cs;
+			FOR_ALL_SORTED_CARGOSPECS(cs) {
+				CargoID cid = cs->Index();
+				/* Skip cargo type if it's not listed */
+				if (!HasBit(cmask, cid)) {
+					current_index++;
+					continue;
+				}
+
+				bool first_vehicle = this->list[current_index].Length() == 0;
+				if (first_vehicle) {
+					/* Keeping the current subtype is always an option. It also serves as the option in case of no subtypes */
+					RefitOption *option = this->list[current_index].Append();
+					option->cargo   = cid;
+					option->subtype = 0xFF;
+					option->string  = STR_EMPTY;
+				}
+
+				/* Check the vehicle's callback mask for cargo suffixes.
+				 * This is not supported for ordered refits, since subtypes only have a meaning
+				 * for a specific vehicle at a specific point in time, which conflicts with shared orders,
+				 * autoreplace, autorenew, clone, order restoration, ... */
+				if (this->order == INVALID_VEH_ORDER_ID && HasBit(callback_mask, CBM_VEHICLE_CARGO_SUFFIX)) {
+					/* Make a note of the original cargo type. It has to be
+					 * changed to test the cargo & subtype... */
+					CargoID temp_cargo = v->cargo_type;
+					byte temp_subtype  = v->cargo_subtype;
+
+					v->cargo_type = cid;
+
+					for (uint refit_cyc = 0; refit_cyc < MAX_REFIT_CYCLE; refit_cyc++) {
+						v->cargo_subtype = refit_cyc;
+
+						/* Make sure we don't pick up anything cached. */
+						v->First()->InvalidateNewGRFCache();
+						v->InvalidateNewGRFCache();
+
+						StringID subtype = GetCargoSubtypeText(v);
+
+						if (first_vehicle) {
+							/* Append new subtype (don't add duplicates though) */
+							if (subtype == STR_EMPTY) break;
+
+							RefitOption option;
+							option.cargo   = cid;
+							option.subtype = refit_cyc;
+							option.string  = subtype;
+							this->list[current_index].Include(option);
+						} else {
+							/* Intersect the subtypes of earlier vehicles with the subtypes of this vehicle */
+							if (subtype == STR_EMPTY) {
+								/* No more subtypes for this vehicle, delete all subtypes >= refit_cyc */
+								SubtypeList &l = this->list[current_index];
+								/* 0xFF item is in front, other subtypes are sorted. So just truncate the list in the right spot */
+								for (uint i = 1; i < l.Length(); i++) {
+									if (l[i].subtype >= refit_cyc) {
+										l.Resize(i);
+										break;
+									}
+								}
+								break;
+							} else {
+								/* Check whether the subtype matches with the subtype of earlier vehicles. */
+								uint pos = 1;
+								SubtypeList &l = this->list[current_index];
+								while (pos < l.Length() && l[pos].subtype != refit_cyc) pos++;
+								if (pos < l.Length() && l[pos].string != subtype) {
+									/* String mismatch, remove item keeping the order */
+									l.ErasePreservingOrder(pos);
+								}
+							}
+						}
+					}
+
+					/* Reset the vehicle's cargo type */
+					v->cargo_type    = temp_cargo;
+					v->cargo_subtype = temp_subtype;
+
+					/* And make sure we haven't tainted the cache */
+					v->First()->InvalidateNewGRFCache();
+					v->InvalidateNewGRFCache();
+				}
+				current_index++;
+			}
+		} while (v->IsGroundVehicle() && (v = v->Next()) != NULL);
+	}
+
+	/**
+	 * Refresh scrollbar after selection changed
+	 */
+	void RefreshScrollbar()
+	{
+		uint scroll_row = 0;
+		uint row = 0;
+
+		for (uint i = 0; i < NUM_CARGO; i++) {
+			for (uint j = 0; j < this->list[i].Length(); j++) {
+				const RefitOption &refit = this->list[i][j];
+
+				/* Hide subtypes if sel[0] does not match */
+				if (this->sel[0] != (int)i && refit.subtype != 0xFF) continue;
+
+				if (this->sel[0] == (int)i && (uint)this->sel[1] == j) scroll_row = row;
+
+				row++;
+			}
+		}
+
+		this->vscroll->SetCount(row);
+		this->vscroll->ScrollTowards(scroll_row);
+	}
+
+	/**
+	 * Select a row.
+	 * @param click_row Clicked row
+	 */
+	void SetSelection(uint click_row)
+	{
+		uint row = 0;
+
+		for (uint i = 0; i < NUM_CARGO; i++) {
+			for (uint j = 0; j < this->list[i].Length(); j++) {
+				const RefitOption &refit = this->list[i][j];
+
+				/* Hide subtypes if sel[0] does not match */
+				if (this->sel[0] != (int)i && refit.subtype != 0xFF) continue;
+
+				if (row == click_row) {
+					this->sel[0] = i;
+					this->sel[1] = j;
+					return;
+				}
+
+				row++;
+			}
+		}
+
+		this->sel[0] = -1;
+		this->sel[1] = 0;
+	}
+
+	/**
+	 * Gets the #RefitOption placed in the selected index.
+	 * @return Pointer to the #RefitOption currently in use.
+	 */
+	RefitOption *GetRefitOption()
+	{
+		if (this->sel[0] < 0) return NULL;
+
+		SubtypeList &l = this->list[this->sel[0]];
+		if ((uint)this->sel[1] >= l.Length()) return NULL;
+
+		return &l[this->sel[1]];
+	}
+
+	RefitWindow(const WindowDesc *desc, const Vehicle *v, VehicleOrderID order, bool auto_refit) : Window()
+	{
+		this->sel[0] = -1;
+		this->sel[1] = 0;
+		this->auto_refit = auto_refit;
+		this->order = order;
+		this->CreateNestedTree(desc);
+
+		this->vscroll = this->GetScrollbar(WID_VR_SCROLLBAR);
+		this->hscroll = (v->IsGroundVehicle() ? this->GetScrollbar(WID_VR_HSCROLLBAR) : NULL);
+		this->GetWidget<NWidgetCore>(WID_VR_SELECT_HEADER)->tool_tip = STR_REFIT_TRAIN_LIST_TOOLTIP + v->type;
+		this->GetWidget<NWidgetCore>(WID_VR_MATRIX)->tool_tip        = STR_REFIT_TRAIN_LIST_TOOLTIP + v->type;
+		NWidgetCore *nwi = this->GetWidget<NWidgetCore>(WID_VR_REFIT);
+		nwi->widget_data = STR_REFIT_TRAIN_REFIT_BUTTON + v->type;
+		nwi->tool_tip    = STR_REFIT_TRAIN_REFIT_TOOLTIP + v->type;
+		this->GetWidget<NWidgetStacked>(WID_VR_SHOW_HSCROLLBAR)->SetDisplayedPlane(v->IsGroundVehicle() ? 0 : SZSP_HORIZONTAL);
+		this->GetWidget<NWidgetCore>(WID_VR_VEHICLE_PANEL_DISPLAY)->tool_tip = (v->type == VEH_TRAIN) ? STR_REFIT_SELECT_VEHICLES_TOOLTIP : STR_NULL;
+
+		this->FinishInitNested(desc, v->index);
+		this->owner = v->owner;
+
+		this->SetWidgetDisabledState(WID_VR_REFIT, this->sel[0] < 0);
+	}
+
+	virtual void OnInit()
+	{
+		if (this->cargo != NULL) {
+			/* Store the RefitOption currently in use. */
+			RefitOption current_refit_option = *(this->cargo);
+
+			/* Rebuild the refit list */
+			this->BuildRefitList();
+			this->sel[0] = -1;
+			this->sel[1] = 0;
+			this->cargo = NULL;
+			for (uint i = 0; this->cargo == NULL && i < NUM_CARGO; i++) {
+				for (uint j = 0; j < list[i].Length(); j++) {
+					if (list[i][j] == current_refit_option) {
+						this->sel[0] = i;
+						this->sel[1] = j;
+						this->cargo = &list[i][j];
+						break;
+					}
+				}
+			}
+
+			this->SetWidgetDisabledState(WID_VR_REFIT, this->sel[0] < 0);
+			this->RefreshScrollbar();
+		} else {
+			/* Rebuild the refit list */
+			this->OnInvalidateData(VIWD_CONSIST_CHANGED);
+		}
+	}
+
+	virtual void OnPaint()
+	{
+		/* Determine amount of items for scroller. */
+		if (this->hscroll != NULL) this->hscroll->SetCount(this->vehicle_width);
+
+		/* Calculate sprite position. */
+		NWidgetCore *vehicle_panel_display = this->GetWidget<NWidgetCore>(WID_VR_VEHICLE_PANEL_DISPLAY);
+		int sprite_width = max(0, ((int)vehicle_panel_display->current_x - this->vehicle_width) / 2);
+		this->sprite_left = vehicle_panel_display->pos_x;
+		this->sprite_right = vehicle_panel_display->pos_x + vehicle_panel_display->current_x - 1;
+		if (_current_text_dir == TD_RTL) {
+			this->sprite_right -= sprite_width;
+			this->vehicle_margin = vehicle_panel_display->current_x - sprite_right;
+		} else {
+			this->sprite_left += sprite_width;
+			this->vehicle_margin = sprite_left;
+		}
+
+		this->DrawWidgets();
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case WID_VR_MATRIX:
+				resize->height = WD_MATRIX_TOP + FONT_HEIGHT_NORMAL + WD_MATRIX_BOTTOM;
+				size->height = resize->height * 8;
+				break;
+
+			case WID_VR_VEHICLE_PANEL_DISPLAY:
+				size->height = GetVehicleHeight(Vehicle::Get(this->window_number)->type);
+				break;
+
+			case WID_VR_INFO:
+				size->width = WD_FRAMERECT_LEFT + this->information_width + WD_FRAMERECT_RIGHT;
+				break;
+		}
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		if (widget == WID_VR_CAPTION) SetDParam(0, Vehicle::Get(this->window_number)->index);
+	}
+
+	/**
+	 * Gets the #StringID to use for displaying capacity.
+	 * @param Cargo and cargo subtype to check for capacity.
+	 * @return INVALID_STRING_ID if there is no capacity. StringID to use in any other case.
+	 * @post String parameters have been set.
+	 */
+	StringID GetCapacityString(RefitOption *option) const
+	{
+		assert(_current_company == _local_company);
+		Vehicle *v = Vehicle::Get(this->window_number);
+		CommandCost cost = DoCommand(v->tile, this->selected_vehicle, option->cargo | (int)this->auto_refit << 6 | option->subtype << 8 |
+				this->num_vehicles << 16, DC_QUERY_COST, GetCmdRefitVeh(v->type));
+
+		if (cost.Failed()) return INVALID_STRING_ID;
+
+		SetDParam(0, option->cargo);
+		SetDParam(1, _returned_refit_capacity);
+
+		Money money = cost.GetCost();
+		if (_returned_mail_refit_capacity > 0) {
+			SetDParam(2, CT_MAIL);
+			SetDParam(3, _returned_mail_refit_capacity);
+			if (money <= 0) {
+				SetDParam(4, -money);
+				return STR_REFIT_NEW_CAPACITY_INCOME_FROM_AIRCRAFT_REFIT;
+			} else {
+				SetDParam(4, money);
+				return STR_REFIT_NEW_CAPACITY_COST_OF_AIRCRAFT_REFIT;
+			}
+		} else {
+			if (money <= 0) {
+				SetDParam(2, -money);
+				return STR_REFIT_NEW_CAPACITY_INCOME_FROM_REFIT;
+			} else {
+				SetDParam(2, money);
+				return STR_REFIT_NEW_CAPACITY_COST_OF_REFIT;
+			}
+		}
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch (widget) {
+			case WID_VR_VEHICLE_PANEL_DISPLAY: {
+				Vehicle *v = Vehicle::Get(this->window_number);
+				DrawVehicleImage(v, this->sprite_left + WD_FRAMERECT_LEFT, this->sprite_right - WD_FRAMERECT_RIGHT,
+					r.top + WD_FRAMERECT_TOP, INVALID_VEHICLE, EIT_IN_DETAILS, this->hscroll != NULL ? this->hscroll->GetPosition() : 0);
+
+				/* Highlight selected vehicles. */
+				if (this->order != INVALID_VEH_ORDER_ID) break;
+				int x = 0;
+				switch (v->type) {
+					case VEH_TRAIN: {
+						VehicleSet vehicles_to_refit;
+						GetVehicleSet(vehicles_to_refit, Vehicle::Get(this->selected_vehicle), this->num_vehicles);
+
+						int left = INT32_MIN;
+						int width = 0;
+
+						for (Train *u = Train::From(v); u != NULL; u = u->Next()) {
+							/* Start checking. */
+							if (vehicles_to_refit.Contains(u->index) && left == INT32_MIN) {
+								left = x - this->hscroll->GetPosition() + r.left + this->vehicle_margin;
+								width = 0;
+							}
+
+							/* Draw a selection. */
+							if ((!vehicles_to_refit.Contains(u->index) || u->Next() == NULL) && left != INT32_MIN) {
+								if (u->Next() == NULL && vehicles_to_refit.Contains(u->index)) {
+									int current_width = u->GetDisplayImageWidth();
+									width += current_width;
+									x += current_width;
+								}
+
+								int right = Clamp(left + width, 0, r.right);
+								left = max(0, left);
+
+								if (_current_text_dir == TD_RTL) {
+									right = this->GetWidget<NWidgetCore>(WID_VR_VEHICLE_PANEL_DISPLAY)->current_x - left;
+									left = right - width;
+								}
+
+								if (left != right) {
+									DrawFrameRect(left, r.top + WD_FRAMERECT_TOP, right, r.top + WD_FRAMERECT_TOP + 13, COLOUR_WHITE, FR_BORDERONLY);
+								}
+
+								left = INT32_MIN;
+							}
+
+							int current_width = u->GetDisplayImageWidth();
+							width += current_width;
+							x += current_width;
+						}
+						break;
+					}
+
+					default: break;
+				}
+				break;
+			}
+
+			case WID_VR_MATRIX:
+				DrawVehicleRefitWindow(this->list, this->sel, this->vscroll->GetPosition(), this->vscroll->GetCapacity(), this->resize.step_height, r);
+				break;
+
+			case WID_VR_INFO:
+				if (this->cargo != NULL) {
+					StringID string = this->GetCapacityString(this->cargo);
+					if (string != INVALID_STRING_ID) {
+						DrawStringMultiLine(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT,
+								r.top + WD_FRAMERECT_TOP, r.bottom - WD_FRAMERECT_BOTTOM, string);
+					}
+				}
+				break;
+		}
+	}
+
+	/**
+	 * Some data on this window has become invalid.
+	 * @param data Information about the changed data.
+	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+	 */
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		switch (data) {
+			case VIWD_AUTOREPLACE: // Autoreplace replaced the vehicle; selected_vehicle became invalid.
+			case VIWD_CONSIST_CHANGED: { // The consist has changed; rebuild the entire list.
+				/* Clear the selection. */
+				Vehicle *v = Vehicle::Get(this->window_number);
+				this->selected_vehicle = v->index;
+				this->num_vehicles = UINT8_MAX;
+				/* FALL THROUGH */
+			}
+
+			case 2: { // The vehicle selection has changed; rebuild the entire list.
+				if (!gui_scope) break;
+				this->BuildRefitList();
+
+				/* The vehicle width has changed too. */
+				this->vehicle_width = GetVehicleWidth(Vehicle::Get(this->window_number), EIT_IN_DETAILS);
+				uint max_width = 0;
+
+				/* Check the width of all cargo information strings. */
+				for (uint i = 0; i < NUM_CARGO; i++) {
+					for (uint j = 0; j < this->list[i].Length(); j++) {
+						StringID string = this->GetCapacityString(&list[i][j]);
+						if (string != INVALID_STRING_ID) {
+							Dimension dim = GetStringBoundingBox(string);
+							max_width = max(dim.width, max_width);
+						}
+					}
+				}
+
+				if (this->information_width < max_width) {
+					this->information_width = max_width;
+					this->ReInit();
+				}
+				/* FALL THROUGH */
+			}
+
+			case 1: // A new cargo has been selected.
+				if (!gui_scope) break;
+				this->cargo = GetRefitOption();
+				this->RefreshScrollbar();
+				break;
+		}
+	}
+
+	int GetClickPosition(int click_x)
+	{
+		const NWidgetCore *matrix_widget = this->GetWidget<NWidgetCore>(WID_VR_VEHICLE_PANEL_DISPLAY);
+		if (_current_text_dir == TD_RTL) click_x = matrix_widget->current_x - click_x;
+		click_x -= this->vehicle_margin;
+		if (this->hscroll != NULL) click_x += this->hscroll->GetPosition();
+
+		return click_x;
+	}
+
+	void SetSelectedVehicles(int drag_x)
+	{
+		drag_x = GetClickPosition(drag_x);
+
+		int left_x  = min(this->click_x, drag_x);
+		int right_x = max(this->click_x, drag_x);
+		this->num_vehicles = 0;
+
+		Vehicle *v = Vehicle::Get(this->window_number);
+		/* Find the vehicle part that was clicked. */
+		switch (v->type) {
+			case VEH_TRAIN: {
+				/* Don't select anything if we are not clicking in the vehicle. */
+				if (left_x >= 0) {
+					const Train *u = Train::From(v);
+					bool start_counting = false;
+					for (; u != NULL; u = u->Next()) {
+						int current_width = u->GetDisplayImageWidth();
+						left_x  -= current_width;
+						right_x -= current_width;
+
+						if (left_x < 0 && !start_counting) {
+							this->selected_vehicle = u->index;
+							start_counting = true;
+
+							/* Count the first vehicle, even if articulated part */
+							this->num_vehicles++;
+						} else if (start_counting && !u->IsArticulatedPart()) {
+							/* Do not count articulated parts */
+							this->num_vehicles++;
+						}
+
+						if (right_x < 0) break;
+					}
+				}
+
+				/* If the selection is not correct, clear it. */
+				if (this->num_vehicles != 0) {
+					if (_ctrl_pressed) this->num_vehicles = UINT8_MAX;
+					break;
+				}
+				/* FALL THROUGH */
+			}
+
+			default:
+				/* Clear the selection. */
+				this->selected_vehicle = v->index;
+				this->num_vehicles = UINT8_MAX;
+				break;
+		}
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch (widget) {
+			case WID_VR_VEHICLE_PANEL_DISPLAY: { // Vehicle image.
+				if (this->order != INVALID_VEH_ORDER_ID) break;
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(WID_VR_VEHICLE_PANEL_DISPLAY);
+				this->click_x = GetClickPosition(pt.x - nwi->pos_x);
+				this->SetSelectedVehicles(pt.x - nwi->pos_x);
+				this->SetWidgetDirty(WID_VR_VEHICLE_PANEL_DISPLAY);
+				if (!_ctrl_pressed) {
+					SetObjectToPlaceWnd(SPR_CURSOR_MOUSE, PAL_NONE, HT_DRAG, this);
+				} else {
+					/* The vehicle selection has changed. */
+					this->InvalidateData(2);
+				}
+				break;
+			}
+
+			case WID_VR_MATRIX: { // listbox
+				this->SetSelection(this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_VR_MATRIX));
+				this->SetWidgetDisabledState(WID_VR_REFIT, this->sel[0] < 0);
+				this->InvalidateData(1);
+
+				if (click_count == 1) break;
+				/* FALL THROUGH */
+			}
+
+			case WID_VR_REFIT: // refit button
+				if (this->cargo != NULL) {
+					const Vehicle *v = Vehicle::Get(this->window_number);
+
+					if (this->order == INVALID_VEH_ORDER_ID) {
+						bool delete_window = this->selected_vehicle == v->index && this->num_vehicles == UINT8_MAX;
+						if (DoCommandP(v->tile, this->selected_vehicle, this->cargo->cargo | this->cargo->subtype << 8 | this->num_vehicles << 16, GetCmdRefitVeh(v)) && delete_window) delete this;
+					} else {
+						if (DoCommandP(v->tile, v->index, this->cargo->cargo | this->order << 16, CMD_ORDER_REFIT)) delete this;
+					}
+				}
+				break;
+		}
+	}
+
+	virtual void OnMouseDrag(Point pt, int widget)
+	{
+		switch (widget) {
+			case WID_VR_VEHICLE_PANEL_DISPLAY: { // Vehicle image.
+				if (this->order != INVALID_VEH_ORDER_ID) break;
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(WID_VR_VEHICLE_PANEL_DISPLAY);
+				this->SetSelectedVehicles(pt.x - nwi->pos_x);
+				this->SetWidgetDirty(WID_VR_VEHICLE_PANEL_DISPLAY);
+				break;
+			}
+		}
+	}
+
+	virtual void OnDragDrop(Point pt, int widget)
+	{
+		switch (widget) {
+			case WID_VR_VEHICLE_PANEL_DISPLAY: { // Vehicle image.
+				if (this->order != INVALID_VEH_ORDER_ID) break;
+				NWidgetBase *nwi = this->GetWidget<NWidgetBase>(WID_VR_VEHICLE_PANEL_DISPLAY);
+				this->SetSelectedVehicles(pt.x - nwi->pos_x);
+				this->InvalidateData(2);
+				break;
+			}
+		}
+	}
+
+	virtual void OnResize()
+	{
+		this->vehicle_width = GetVehicleWidth(Vehicle::Get(this->window_number), EIT_IN_DETAILS);
+		this->vscroll->SetCapacityFromWidget(this, WID_VR_MATRIX);
+		if (this->hscroll != NULL) this->hscroll->SetCapacityFromWidget(this, WID_VR_VEHICLE_PANEL_DISPLAY);
+		this->GetWidget<NWidgetCore>(WID_VR_MATRIX)->widget_data = (this->vscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+};
+
+static const NWidgetPart _nested_vehicle_refit_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_VR_CAPTION), SetDataTip(STR_REFIT_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+	EndContainer(),
+	/* Vehicle display + scrollbar. */
+	NWidget(NWID_VERTICAL),
+		NWidget(WWT_PANEL, COLOUR_GREY, WID_VR_VEHICLE_PANEL_DISPLAY), SetMinimalSize(228, 14), SetResize(1, 0), SetScrollbar(WID_VR_HSCROLLBAR), EndContainer(),
+		NWidget(NWID_SELECTION, INVALID_COLOUR, WID_VR_SHOW_HSCROLLBAR),
+			NWidget(NWID_HSCROLLBAR, COLOUR_GREY, WID_VR_HSCROLLBAR),
+		EndContainer(),
+	EndContainer(),
+	NWidget(WWT_TEXTBTN, COLOUR_GREY, WID_VR_SELECT_HEADER), SetDataTip(STR_REFIT_TITLE, STR_NULL), SetResize(1, 0),
+	/* Matrix + scrollbar. */
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, WID_VR_MATRIX), SetMinimalSize(228, 112), SetResize(1, 14), SetFill(1, 1), SetDataTip(0x801, STR_NULL), SetScrollbar(WID_VR_SCROLLBAR),
+		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_VR_SCROLLBAR),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY, WID_VR_INFO), SetMinimalTextLines(2, WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM), SetResize(1, 0), EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VR_REFIT), SetFill(1, 0), SetResize(1, 0),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static const WindowDesc _vehicle_refit_desc(
+	WDP_AUTO, 240, 174,
+	WC_VEHICLE_REFIT, WC_VEHICLE_VIEW,
+	WDF_CONSTRUCTION,
+	_nested_vehicle_refit_widgets, lengthof(_nested_vehicle_refit_widgets)
+);
+
+/**
+ * Show the refit window for a vehicle
+ * @param *v The vehicle to show the refit window for
+ * @param order of the vehicle to assign refit to, or INVALID_VEH_ORDER_ID to refit the vehicle now
+ * @param parent the parent window of the refit window
+ * @param auto_refit Choose cargo for auto-refitting
+ */
+void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit)
+{
+	DeleteWindowById(WC_VEHICLE_REFIT, v->index);
+	RefitWindow *w = new RefitWindow(&_vehicle_refit_desc, v, order, auto_refit);
+	w->parent = parent;
+}
+
+/** Display list of cargo types of the engine, for the purchase information window */
+uint ShowRefitOptionsList(int left, int right, int y, EngineID engine)
+{
+	/* List of cargo types of this engine */
+	uint32 cmask = GetUnionOfArticulatedRefitMasks(engine, false);
+	/* List of cargo types available in this climate */
+	uint32 lmask = _cargo_mask;
+
+	/* Draw nothing if the engine is not refittable */
+	if (HasAtMostOneBit(cmask)) return y;
+
+	if (cmask == lmask) {
+		/* Engine can be refitted to all types in this climate */
+		SetDParam(0, STR_PURCHASE_INFO_ALL_TYPES);
+	} else {
+		/* Check if we are able to refit to more cargo types and unable to. If
+		 * so, invert the cargo types to list those that we can't refit to. */
+		if (CountBits(cmask ^ lmask) < CountBits(cmask) && CountBits(cmask ^ lmask) <= 7) {
+			cmask ^= lmask;
+			SetDParam(0, STR_PURCHASE_INFO_ALL_BUT);
+		} else {
+			SetDParam(0, STR_JUST_CARGO_LIST);
+		}
+		SetDParam(1, cmask);
+	}
+
+	return DrawStringMultiLine(left, right, y, INT32_MAX, STR_PURCHASE_INFO_REFITTABLE_TO);
+}
+
+/** Get the cargo subtype text from NewGRF for the vehicle details window. */
+StringID GetCargoSubtypeText(const Vehicle *v)
+{
+	if (HasBit(EngInfo(v->engine_type)->callback_mask, CBM_VEHICLE_CARGO_SUFFIX)) {
+		uint16 cb = GetVehicleCallback(CBID_VEHICLE_CARGO_SUFFIX, 0, 0, v->engine_type, v);
+		if (cb != CALLBACK_FAILED) {
+			if (cb > 0x400) ErrorUnknownCallbackResult(v->GetGRFID(), CBID_VEHICLE_CARGO_SUFFIX, cb);
+			if (cb >= 0x400 || (v->GetGRF()->grf_version < 8 && cb == 0xFF)) cb = CALLBACK_FAILED;
+		}
+		if (cb != CALLBACK_FAILED) {
+			return GetGRFStringID(v->GetGRFID(), 0xD000 + cb);
+		}
+	}
+	return STR_EMPTY;
+}
+
+/** Sort vehicles by their number */
+static int CDECL VehicleNumberSorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	return (*a)->unitnumber - (*b)->unitnumber;
+}
+
+/** Sort vehicles by their name */
+static int CDECL VehicleNameSorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	static char last_name[2][64];
+
+	if (*a != _last_vehicle[0]) {
+		_last_vehicle[0] = *a;
+		SetDParam(0, (*a)->index);
+		GetString(last_name[0], STR_VEHICLE_NAME, lastof(last_name[0]));
+	}
+
+	if (*b != _last_vehicle[1]) {
+		_last_vehicle[1] = *b;
+		SetDParam(0, (*b)->index);
+		GetString(last_name[1], STR_VEHICLE_NAME, lastof(last_name[1]));
+	}
+
+	int r = strnatcmp(last_name[0], last_name[1]); // Sort by name (natural sorting).
+	return (r != 0) ? r : VehicleNumberSorter(a, b);
+}
+
+/** Sort vehicles by their age */
+static int CDECL VehicleAgeSorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	int r = (*a)->age - (*b)->age;
+	return (r != 0) ? r : VehicleNumberSorter(a, b);
+}
+
+/** Sort vehicles by this year profit */
+static int CDECL VehicleProfitThisYearSorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	int r = ClampToI32((*a)->GetDisplayProfitThisYear() - (*b)->GetDisplayProfitThisYear());
+	return (r != 0) ? r : VehicleNumberSorter(a, b);
+}
+
+/** Sort vehicles by last year profit */
+static int CDECL VehicleProfitLastYearSorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	int r = ClampToI32((*a)->GetDisplayProfitLastYear() - (*b)->GetDisplayProfitLastYear());
+	return (r != 0) ? r : VehicleNumberSorter(a, b);
+}
+
+/** Sort vehicles by their cargo */
+static int CDECL VehicleCargoSorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	const Vehicle *v;
+	CargoArray diff;
+
+	/* Append the cargo of the connected waggons */
+	for (v = *a; v != NULL; v = v->Next()) diff[v->cargo_type] += v->cargo_cap;
+	for (v = *b; v != NULL; v = v->Next()) diff[v->cargo_type] -= v->cargo_cap;
+
+	int r = 0;
+	for (CargoID i = 0; i < NUM_CARGO; i++) {
+		r = diff[i];
+		if (r != 0) break;
+	}
+
+	return (r != 0) ? r : VehicleNumberSorter(a, b);
+}
+
+/** Sort vehicles by their reliability */
+static int CDECL VehicleReliabilitySorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	int r = (*a)->reliability - (*b)->reliability;
+	return (r != 0) ? r : VehicleNumberSorter(a, b);
+}
+
+/** Sort vehicles by their max speed */
+static int CDECL VehicleMaxSpeedSorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	int r = (*a)->vcache.cached_max_speed - (*b)->vcache.cached_max_speed;
+	return (r != 0) ? r : VehicleNumberSorter(a, b);
+}
+
+/** Sort vehicles by model */
+static int CDECL VehicleModelSorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	int r = (*a)->engine_type - (*b)->engine_type;
+	return (r != 0) ? r : VehicleNumberSorter(a, b);
+}
+
+/** Sort vehicles by their value */
+static int CDECL VehicleValueSorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	const Vehicle *u;
+	Money diff = 0;
+
+	for (u = *a; u != NULL; u = u->Next()) diff += u->value;
+	for (u = *b; u != NULL; u = u->Next()) diff -= u->value;
+
+	int r = ClampToI32(diff);
+	return (r != 0) ? r : VehicleNumberSorter(a, b);
+}
+
+/** Sort vehicles by their length */
+static int CDECL VehicleLengthSorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	int r = (*a)->GetGroundVehicleCache()->cached_total_length - (*b)->GetGroundVehicleCache()->cached_total_length;
+	return (r != 0) ? r : VehicleNumberSorter(a, b);
+}
+
+/** Sort vehicles by the time they can still live */
+static int CDECL VehicleTimeToLiveSorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	int r = ClampToI32(((*a)->max_age - (*a)->age) - ((*b)->max_age - (*b)->age));
+	return (r != 0) ? r : VehicleNumberSorter(a, b);
+}
+
+/** Sort vehicles by the timetable delay */
+static int CDECL VehicleTimetableDelaySorter(const Vehicle * const *a, const Vehicle * const *b)
+{
+	int r = (*a)->lateness_counter - (*b)->lateness_counter;
+	return (r != 0) ? r : VehicleNumberSorter(a, b);
+}
+
+void InitializeGUI()
+{
+	MemSetT(&_sorting, 0);
+}
+
+/**
+ * Assign a vehicle window a new vehicle
+ * @param window_class WindowClass to search for
+ * @param from_index the old vehicle ID
+ * @param to_index the new vehicle ID
+ */
+static inline void ChangeVehicleWindow(WindowClass window_class, VehicleID from_index, VehicleID to_index)
+{
+	Window *w = FindWindowById(window_class, from_index);
+	if (w != NULL) {
+		/* Update window_number */
+		w->window_number = to_index;
+		if (w->viewport != NULL) w->viewport->follow_vehicle = to_index;
+
+		/* Update vehicle drag data */
+		if (_thd.window_class == window_class && _thd.window_number == (WindowNumber)from_index) {
+			_thd.window_number = to_index;
+		}
+
+		/* Notify the window. */
+		w->InvalidateData(VIWD_AUTOREPLACE, false);
+	}
+}
+
+/**
+ * Report a change in vehicle IDs (due to autoreplace) to affected vehicle windows.
+ * @param from_index the old vehicle ID
+ * @param to_index the new vehicle ID
+ */
+void ChangeVehicleViewWindow(VehicleID from_index, VehicleID to_index)
+{
+	ChangeVehicleWindow(WC_VEHICLE_VIEW,      from_index, to_index);
+	ChangeVehicleWindow(WC_VEHICLE_ORDERS,    from_index, to_index);
+	ChangeVehicleWindow(WC_VEHICLE_REFIT,     from_index, to_index);
+	ChangeVehicleWindow(WC_VEHICLE_DETAILS,   from_index, to_index);
+	ChangeVehicleWindow(WC_VEHICLE_TIMETABLE, from_index, to_index);
+}
+
+static const NWidgetPart _nested_vehicle_list[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_VL_CAPTION),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VL_SORT_ORDER), SetMinimalSize(81, 12), SetFill(0, 1), SetDataTip(STR_BUTTON_SORT_BY, STR_TOOLTIP_SORT_ORDER),
+		NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_VL_SORT_BY_PULLDOWN), SetMinimalSize(167, 12), SetFill(0, 1), SetDataTip(0x0, STR_TOOLTIP_SORT_CRITERIA),
+		NWidget(WWT_PANEL, COLOUR_GREY), SetMinimalSize(12, 12), SetFill(1, 1), SetResize(1, 0),
+		EndContainer(),
+	EndContainer(),
+
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, WID_VL_LIST), SetMinimalSize(248, 0), SetFill(1, 0), SetResize(1, 1), SetScrollbar(WID_VL_SCROLLBAR),
+		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_VL_SCROLLBAR),
+	EndContainer(),
+
+	NWidget(NWID_HORIZONTAL),
+		NWidget(NWID_SELECTION, INVALID_COLOUR, WID_VL_HIDE_BUTTONS),
+			NWidget(NWID_HORIZONTAL),
+				NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VL_AVAILABLE_VEHICLES), SetMinimalSize(106, 12), SetFill(0, 1),
+								SetDataTip(STR_BLACK_STRING, STR_VEHICLE_LIST_AVAILABLE_ENGINES_TOOLTIP),
+				NWidget(WWT_PANEL, COLOUR_GREY), SetMinimalSize(0, 12), SetResize(1, 0), SetFill(1, 1), EndContainer(),
+				NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_VL_MANAGE_VEHICLES_DROPDOWN), SetMinimalSize(118, 12), SetFill(0, 1),
+								SetDataTip(STR_VEHICLE_LIST_MANAGE_LIST, STR_VEHICLE_LIST_MANAGE_LIST_TOOLTIP),
+				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_VL_STOP_ALL), SetMinimalSize(12, 12), SetFill(0, 1),
+								SetDataTip(SPR_FLAG_VEH_STOPPED, STR_VEHICLE_LIST_MASS_STOP_LIST_TOOLTIP),
+				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_VL_START_ALL), SetMinimalSize(12, 12), SetFill(0, 1),
+								SetDataTip(SPR_FLAG_VEH_RUNNING, STR_VEHICLE_LIST_MASS_START_LIST_TOOLTIP),
+			EndContainer(),
+			/* Widget to be shown for other companies hiding the previous 5 widgets. */
+			NWidget(WWT_PANEL, COLOUR_GREY), SetFill(1, 1), SetResize(1, 0), EndContainer(),
+		EndContainer(),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+static void DrawSmallOrderList(const Vehicle *v, int left, int right, int y, VehicleOrderID start = 0)
+{
+	const Order *order = v->GetOrder(start);
+	if (order == NULL) return;
+
+	int i = 0;
+	VehicleOrderID oid = start;
+
+	do {
+		if (oid == v->cur_real_order_index) DrawString(left, right, y, STR_TINY_RIGHT_ARROW, TC_BLACK);
+
+		if (order->IsType(OT_GOTO_STATION)) {
+			SetDParam(0, order->GetDestination());
+			DrawString(left + 6, right - 6, y, STR_TINY_BLACK_STATION);
+
+			y += FONT_HEIGHT_SMALL;
+			if (++i == 4) break;
+		}
+
+		oid++;
+		order = order->next;
+		if (order == NULL) {
+			order = v->orders.list->GetFirstOrder();
+			oid = 0;
+		}
+	} while (oid != start);
+}
+
+/**
+ * Draws an image of a vehicle chain
+ * @param v         Front vehicle
+ * @param left      The minimum horizontal position
+ * @param right     The maximum horizontal position
+ * @param y         Vertical position to draw at
+ * @param selection Selected vehicle to draw a frame around
+ * @param skip      Number of pixels to skip at the front (for scrolling)
+ */
+void DrawVehicleImage(const Vehicle *v, int left, int right, int y, VehicleID selection, EngineImageType image_type, int skip)
+{
+	switch (v->type) {
+		case VEH_TRAIN:    DrawTrainImage(Train::From(v), left, right, y, selection, image_type, skip); break;
+		case VEH_ROAD:     DrawRoadVehImage(v, left, right, y, selection, image_type, skip);  break;
+		case VEH_SHIP:     DrawShipImage(v, left, right, y, selection, image_type);     break;
+		case VEH_AIRCRAFT: DrawAircraftImage(v, left, right, y, selection, image_type); break;
+		default: NOT_REACHED();
+	}
+}
+
+/**
+ * Get the height of a vehicle in the vehicle list GUIs.
+ * @param type    the vehicle type to look at
+ * @param divisor the resulting height must be dividable by this
+ * @return the height
+ */
+uint GetVehicleListHeight(VehicleType type, uint divisor)
+{
+	/* Name + vehicle + profit */
+	uint base = GetVehicleHeight(type) + 2 * FONT_HEIGHT_SMALL;
+	/* Drawing of the 4 small orders + profit*/
+	if (type >= VEH_SHIP) base = max(base, 5U * FONT_HEIGHT_SMALL);
+
+	if (divisor == 1) return base;
+
+	/* Make sure the height is dividable by divisor */
+	uint rem = base % divisor;
+	return base + (rem == 0 ? 0 : divisor - rem);
+}
+
+/**
+ * Draw all the vehicle list items.
+ * @param selected_vehicle The vehicle that is to be highlighted.
+ * @param line_height      Height of a single item line.
+ * @param r                Rectangle with edge positions of the matrix widget.
+ */
+void BaseVehicleListWindow::DrawVehicleListItems(VehicleID selected_vehicle, int line_height, const Rect &r) const
+{
+	int left = r.left + WD_MATRIX_LEFT;
+	int right = r.right - WD_MATRIX_RIGHT;
+	int width = right - left;
+	bool rtl = _current_text_dir == TD_RTL;
+
+	int text_offset = GetDigitWidth() * this->unitnumber_digits + WD_FRAMERECT_RIGHT;
+	int text_left  = left  + (rtl ?           0 : text_offset);
+	int text_right = right - (rtl ? text_offset :           0);
+
+	bool show_orderlist = this->vli.vtype >= VEH_SHIP;
+	int orderlist_left  = left  + (rtl ? 0 : max(100 + text_offset, width / 2));
+	int orderlist_right = right - (rtl ? max(100 + text_offset, width / 2) : 0);
+
+	int image_left  = (rtl && show_orderlist) ? orderlist_right : text_left;
+	int image_right = (!rtl && show_orderlist) ? orderlist_left : text_right;
+
+	int vehicle_button_x = rtl ? right - GetSpriteSize(SPR_PROFIT_LOT).width : left;
+
+	int y = r.top;
+	uint max = min(this->vscroll->GetPosition() + this->vscroll->GetCapacity(), this->vehicles.Length());
+	for (uint i = this->vscroll->GetPosition(); i < max; ++i) {
+		const Vehicle *v = this->vehicles[i];
+		StringID str;
+
+		SetDParam(0, v->GetDisplayProfitThisYear());
+		SetDParam(1, v->GetDisplayProfitLastYear());
+
+		DrawVehicleImage(v, image_left, image_right, y + FONT_HEIGHT_SMALL - 1, selected_vehicle, EIT_IN_LIST, 0);
+		DrawString(text_left, text_right, y + line_height - FONT_HEIGHT_SMALL - WD_FRAMERECT_BOTTOM - 1, STR_VEHICLE_LIST_PROFIT_THIS_YEAR_LAST_YEAR);
+
+		if (v->name != NULL) {
+			/* The vehicle got a name so we will print it */
+			SetDParam(0, v->index);
+			DrawString(text_left, text_right, y, STR_TINY_BLACK_VEHICLE);
+		} else if (v->group_id != DEFAULT_GROUP) {
+			/* The vehicle has no name, but is member of a group, so print group name */
+			SetDParam(0, v->group_id);
+			DrawString(text_left, text_right, y, STR_TINY_GROUP, TC_BLACK);
+		}
+
+		if (show_orderlist) DrawSmallOrderList(v, orderlist_left, orderlist_right, y, v->cur_real_order_index);
+
+		if (v->IsChainInDepot()) {
+			str = STR_BLUE_COMMA;
+		} else {
+			str = (v->age > v->max_age - DAYS_IN_LEAP_YEAR) ? STR_RED_COMMA : STR_BLACK_COMMA;
+		}
+
+		SetDParam(0, v->unitnumber);
+		DrawString(left, right, y + 2, str);
+
+		DrawVehicleProfitButton(v, vehicle_button_x, y + FONT_HEIGHT_NORMAL + 3);
+
+		y += line_height;
+	}
+}
+
+/**
+ * Window for the (old) vehicle listing.
+ *
+ * bitmask for w->window_number
+ * 0-7 CompanyID (owner)
+ * 8-10 window type (use flags in vehicle_gui.h)
+ * 11-15 vehicle type (using VEH_, but can be compressed to fewer bytes if needed)
+ * 16-31 StationID or OrderID depending on window type (bit 8-10)
+ */
+struct VehicleListWindow : public BaseVehicleListWindow {
+private:
+	/** Enumeration of planes of the button row at the bottom. */
+	enum ButtonPlanes {
+		BP_SHOW_BUTTONS, ///< Show the buttons.
+		BP_HIDE_BUTTONS, ///< Show the empty panel.
+	};
+
+public:
+	VehicleListWindow(const WindowDesc *desc, WindowNumber window_number) : BaseVehicleListWindow(window_number)
+	{
+		/* Set up sorting. Make the window-specific _sorting variable
+		 * point to the correct global _sorting struct so we are freed
+		 * from having conditionals during window operation */
+		switch (this->vli.vtype) {
+			case VEH_TRAIN:    this->sorting = &_sorting.train; break;
+			case VEH_ROAD:     this->sorting = &_sorting.roadveh; break;
+			case VEH_SHIP:     this->sorting = &_sorting.ship; break;
+			case VEH_AIRCRAFT: this->sorting = &_sorting.aircraft; break;
+			default: NOT_REACHED();
+		}
+
+		this->CreateNestedTree(desc);
+
+		this->vscroll = this->GetScrollbar(WID_VL_SCROLLBAR);
+
+		this->vehicles.SetListing(*this->sorting);
+		this->vehicles.ForceRebuild();
+		this->vehicles.NeedResort();
+		this->BuildVehicleList();
+		this->SortVehicleList();
+
+		/* Set up the window widgets */
+		this->GetWidget<NWidgetCore>(WID_VL_LIST)->tool_tip = STR_VEHICLE_LIST_TRAIN_LIST_TOOLTIP + this->vli.vtype;
+
+		if (this->vli.type == VL_SHARED_ORDERS) {
+			this->GetWidget<NWidgetCore>(WID_VL_CAPTION)->widget_data = STR_VEHICLE_LIST_SHARED_ORDERS_LIST_CAPTION;
+		} else {
+			this->GetWidget<NWidgetCore>(WID_VL_CAPTION)->widget_data = STR_VEHICLE_LIST_TRAIN_CAPTION + this->vli.vtype;
+		}
+
+		this->FinishInitNested(desc, window_number);
+		if (this->vli.company != OWNER_NONE) this->owner = this->vli.company;
+
+		if (this->vli.vtype == VEH_TRAIN) ResizeWindow(this, 65, 0);
+	}
+
+	~VehicleListWindow()
+	{
+		*this->sorting = this->vehicles.GetListing();
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case WID_VL_LIST:
+				resize->height = GetVehicleListHeight(this->vli.vtype, 1);
+
+				switch (this->vli.vtype) {
+					case VEH_TRAIN:
+					case VEH_ROAD:
+						size->height = 6 * resize->height;
+						break;
+					case VEH_SHIP:
+					case VEH_AIRCRAFT:
+						size->height = 4 * resize->height;
+						break;
+					default: NOT_REACHED();
+				}
+				break;
+
+			case WID_VL_SORT_ORDER: {
+				Dimension d = GetStringBoundingBox(this->GetWidget<NWidgetCore>(widget)->widget_data);
+				d.width += padding.width + WD_SORTBUTTON_ARROW_WIDTH * 2; // Doubled since the string is centred and it also looks better.
+				d.height += padding.height;
+				*size = maxdim(*size, d);
+				break;
+			}
+
+			case WID_VL_MANAGE_VEHICLES_DROPDOWN: {
+				Dimension d = this->GetActionDropdownSize(this->vli.type == VL_STANDARD, false);
+				d.height += padding.height;
+				d.width  += padding.width;
+				*size = maxdim(*size, d);
+				break;
+			}
+		}
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		switch (widget) {
+			case WID_VL_AVAILABLE_VEHICLES:
+				SetDParam(0, STR_VEHICLE_LIST_AVAILABLE_TRAINS + this->vli.vtype);
+				break;
+
+			case WID_VL_CAPTION: {
+				switch (this->vli.type) {
+					case VL_SHARED_ORDERS: // Shared Orders
+						if (this->vehicles.Length() == 0) {
+							/* We can't open this window without vehicles using this order
+							 * and we should close the window when deleting the order. */
+							NOT_REACHED();
+						}
+						SetDParam(0, this->vscroll->GetCount());
+						break;
+
+					case VL_STANDARD: // Company Name
+						SetDParam(0, STR_COMPANY_NAME);
+						SetDParam(1, this->vli.index);
+						SetDParam(3, this->vscroll->GetCount());
+						break;
+
+					case VL_STATION_LIST: // Station/Waypoint Name
+						SetDParam(0, Station::IsExpected(BaseStation::Get(this->vli.index)) ? STR_STATION_NAME : STR_WAYPOINT_NAME);
+						SetDParam(1, this->vli.index);
+						SetDParam(3, this->vscroll->GetCount());
+						break;
+
+					case VL_DEPOT_LIST:
+						SetDParam(0, STR_DEPOT_CAPTION);
+						SetDParam(1, this->vli.vtype);
+						SetDParam(2, this->vli.index);
+						SetDParam(3, this->vscroll->GetCount());
+						break;
+					default: NOT_REACHED();
+				}
+				break;
+			}
+		}
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		switch (widget) {
+			case WID_VL_SORT_ORDER:
+				/* draw arrow pointing up/down for ascending/descending sorting */
+				this->DrawSortButtonState(widget, this->vehicles.IsDescSortOrder() ? SBS_DOWN : SBS_UP);
+				break;
+
+			case WID_VL_LIST:
+				this->DrawVehicleListItems(INVALID_VEHICLE, this->resize.step_height, r);
+				break;
+		}
+	}
+
+	virtual void OnPaint()
+	{
+		this->BuildVehicleList();
+		this->SortVehicleList();
+
+		if (this->vehicles.Length() == 0 && this->IsWidgetLowered(WID_VL_MANAGE_VEHICLES_DROPDOWN)) {
+			HideDropDownMenu(this);
+		}
+
+		/* Hide the widgets that we will not use in this window
+		 * Some windows contains actions only fit for the owner */
+		int plane_to_show = (this->owner == _local_company) ? BP_SHOW_BUTTONS : BP_HIDE_BUTTONS;
+		NWidgetStacked *nwi = this->GetWidget<NWidgetStacked>(WID_VL_HIDE_BUTTONS);
+		if (plane_to_show != nwi->shown_plane) {
+			nwi->SetDisplayedPlane(plane_to_show);
+			nwi->SetDirty(this);
+		}
+		if (this->owner == _local_company) {
+			this->SetWidgetDisabledState(WID_VL_AVAILABLE_VEHICLES, this->vli.type != VL_STANDARD);
+			this->SetWidgetsDisabledState(this->vehicles.Length() == 0,
+				WID_VL_MANAGE_VEHICLES_DROPDOWN,
+				WID_VL_STOP_ALL,
+				WID_VL_START_ALL,
+				WIDGET_LIST_END);
+		}
+
+		/* Set text of sort by dropdown widget. */
+		this->GetWidget<NWidgetCore>(WID_VL_SORT_BY_PULLDOWN)->widget_data = this->vehicle_sorter_names[this->vehicles.SortType()];
+
+		this->DrawWidgets();
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch (widget) {
+			case WID_VL_SORT_ORDER: // Flip sorting method ascending/descending
+				this->vehicles.ToggleSortOrder();
+				this->SetDirty();
+				break;
+
+			case WID_VL_SORT_BY_PULLDOWN:// Select sorting criteria dropdown menu
+				ShowDropDownMenu(this, this->vehicle_sorter_names, this->vehicles.SortType(), WID_VL_SORT_BY_PULLDOWN, 0,
+						(this->vli.vtype == VEH_TRAIN || this->vli.vtype == VEH_ROAD) ? 0 : (1 << 10));
+				return;
+
+			case WID_VL_LIST: { // Matrix to show vehicles
+				uint id_v = this->vscroll->GetScrolledRowFromWidget(pt.y, this, WID_VL_LIST);
+				if (id_v >= this->vehicles.Length()) return; // click out of list bound
+
+				const Vehicle *v = this->vehicles[id_v];
+				if (!VehicleClicked(v)) ShowVehicleViewWindow(v);
+				break;
+			}
+
+			case WID_VL_AVAILABLE_VEHICLES:
+				ShowBuildVehicleWindow(INVALID_TILE, this->vli.vtype);
+				break;
+
+			case WID_VL_MANAGE_VEHICLES_DROPDOWN: {
+				DropDownList *list = this->BuildActionDropdownList(VehicleListIdentifier(this->window_number).type == VL_STANDARD, false);
+				ShowDropDownList(this, list, 0, WID_VL_MANAGE_VEHICLES_DROPDOWN);
+				break;
+			}
+
+			case WID_VL_STOP_ALL:
+			case WID_VL_START_ALL:
+				DoCommandP(0, (1 << 1) | (widget == WID_VL_START_ALL ? (1 << 0) : 0), this->window_number, CMD_MASS_START_STOP);
+				break;
+		}
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		switch (widget) {
+			case WID_VL_SORT_BY_PULLDOWN:
+				this->vehicles.SetSortType(index);
+				break;
+			case WID_VL_MANAGE_VEHICLES_DROPDOWN:
+				assert(this->vehicles.Length() != 0);
+
+				switch (index) {
+					case ADI_REPLACE: // Replace window
+						ShowReplaceGroupVehicleWindow(ALL_GROUP, this->vli.vtype);
+						break;
+					case ADI_SERVICE: // Send for servicing
+					case ADI_DEPOT: // Send to Depots
+						DoCommandP(0, DEPOT_MASS_SEND | (index == ADI_SERVICE ? DEPOT_SERVICE : (DepotCommand)0), this->window_number, GetCmdSendToDepot(this->vli.vtype));
+						break;
+
+					default: NOT_REACHED();
+				}
+				break;
+			default: NOT_REACHED();
+		}
+		this->SetDirty();
+	}
+
+	virtual void OnTick()
+	{
+		if (_pause_mode != PM_UNPAUSED) return;
+		if (this->vehicles.NeedResort()) {
+			StationID station = (this->vli.type == VL_STATION_LIST) ? this->vli.index : INVALID_STATION;
+
+			DEBUG(misc, 3, "Periodic resort %d list company %d at station %d", this->vli.vtype, this->owner, station);
+			this->SetDirty();
+		}
+	}
+
+	virtual void OnResize()
+	{
+		this->vscroll->SetCapacityFromWidget(this, WID_VL_LIST);
+		this->GetWidget<NWidgetCore>(WID_VL_LIST)->widget_data = (this->vscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+	}
+
+	/**
+	 * Some data on this window has become invalid.
+	 * @param data Information about the changed data.
+	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+	 */
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		if (!gui_scope && HasBit(data, 31) && this->vli.type == VL_SHARED_ORDERS) {
+			/* Needs to be done in command-scope, so everything stays valid */
+			this->vli.index = GB(data, 0, 20);
+			this->window_number = this->vli.Pack();
+			this->vehicles.ForceRebuild();
+			return;
+		}
+
+		if (data == 0) {
+			/* This needs to be done in command-scope to enforce rebuilding before resorting invalid data */
+			this->vehicles.ForceRebuild();
+		} else {
+			this->vehicles.ForceResort();
+		}
+	}
+};
+
+static WindowDesc _vehicle_list_desc(
+	WDP_AUTO, 260, 246,
+	WC_INVALID, WC_NONE,
+	0,
+	_nested_vehicle_list, lengthof(_nested_vehicle_list)
+);
+
+static void ShowVehicleListWindowLocal(CompanyID company, VehicleListType vlt, VehicleType vehicle_type, uint16 unique_number)
+{
+	if (!Company::IsValidID(company) && company != OWNER_NONE) return;
+
+	_vehicle_list_desc.cls = GetWindowClassForVehicleType(vehicle_type);
+	AllocateWindowDescFront<VehicleListWindow>(&_vehicle_list_desc, VehicleListIdentifier(vlt, vehicle_type, company, unique_number).Pack());
+}
+
+void ShowVehicleListWindow(CompanyID company, VehicleType vehicle_type)
+{
+	/* If _settings_client.gui.advanced_vehicle_list > 1, display the Advanced list
+	 * if _settings_client.gui.advanced_vehicle_list == 1, display Advanced list only for local company
+	 * if _ctrl_pressed, do the opposite action (Advanced list x Normal list)
+	 */
+
+	if ((_settings_client.gui.advanced_vehicle_list > (uint)(company != _local_company)) != _ctrl_pressed) {
+		ShowCompanyGroup(company, vehicle_type);
+	} else {
+		ShowVehicleListWindowLocal(company, VL_STANDARD, vehicle_type, company);
+	}
+}
+
+void ShowVehicleListWindow(const Vehicle *v)
+{
+	ShowVehicleListWindowLocal(v->owner, VL_SHARED_ORDERS, v->type, v->FirstShared()->index);
+}
+
+void ShowVehicleListWindow(CompanyID company, VehicleType vehicle_type, StationID station)
+{
+	_vehicle_list_desc.flags &= ~WDF_CONSTRUCTION;
+	ShowVehicleListWindowLocal(company, VL_STATION_LIST, vehicle_type, station);
+}
+
+void ShowVehicleListWindow(CompanyID company, VehicleType vehicle_type, TileIndex depot_tile)
+{
+	uint16 depot_airport_index;
+
+	if (vehicle_type == VEH_AIRCRAFT) {
+		depot_airport_index = GetStationIndex(depot_tile);
+	} else {
+		depot_airport_index = GetDepotIndex(depot_tile);
+	}
+	ShowVehicleListWindowLocal(company, VL_DEPOT_LIST, vehicle_type, depot_airport_index);
+}
+
+
+/* Unified vehicle GUI - Vehicle Details Window */
+
+assert_compile(WID_VD_DETAILS_CARGO_CARRIED    == WID_VD_DETAILS_CARGO_CARRIED + TDW_TAB_CARGO   );
+assert_compile(WID_VD_DETAILS_TRAIN_VEHICLES   == WID_VD_DETAILS_CARGO_CARRIED + TDW_TAB_INFO    );
+assert_compile(WID_VD_DETAILS_CAPACITY_OF_EACH == WID_VD_DETAILS_CARGO_CARRIED + TDW_TAB_CAPACITY);
+assert_compile(WID_VD_DETAILS_TOTAL_CARGO      == WID_VD_DETAILS_CARGO_CARRIED + TDW_TAB_TOTALS  );
+
+/** Vehicle details widgets (other than train). */
+static const NWidgetPart _nested_nontrain_vehicle_details_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_VD_CAPTION), SetDataTip(STR_VEHICLE_DETAILS_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_RENAME_VEHICLE), SetMinimalSize(40, 0), SetMinimalTextLines(1, WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM + 2), SetDataTip(STR_VEHICLE_NAME_BUTTON, STR_NULL /* filled in later */),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY, WID_VD_TOP_DETAILS), SetMinimalSize(405, 42), SetResize(1, 0), EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY, WID_VD_MIDDLE_DETAILS), SetMinimalSize(405, 45), SetResize(1, 0), EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHARROWBTN, COLOUR_GREY, WID_VD_DECREASE_SERVICING_INTERVAL), SetFill(0, 1),
+				SetDataTip(AWV_DECREASE, STR_VEHICLE_DETAILS_DECREASE_SERVICING_INTERVAL_TOOLTIP),
+		NWidget(WWT_PUSHARROWBTN, COLOUR_GREY, WID_VD_INCREASE_SERVICING_INTERVAL), SetFill(0, 1),
+				SetDataTip(AWV_INCREASE, STR_VEHICLE_DETAILS_INCREASE_SERVICING_INTERVAL_TOOLTIP),
+		NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_VD_SERVICE_INTERVAL_DROPDOWN), SetFill(0, 1),
+				SetDataTip(STR_EMPTY, STR_SERVICE_INTERVAL_DROPDOWN_TOOLTIP),
+		NWidget(WWT_PANEL, COLOUR_GREY, WID_VD_SERVICING_INTERVAL), SetFill(1, 1), SetResize(1, 0), EndContainer(),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+/** Train details widgets. */
+static const NWidgetPart _nested_train_vehicle_details_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_VD_CAPTION), SetDataTip(STR_VEHICLE_DETAILS_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_RENAME_VEHICLE), SetMinimalSize(40, 0), SetMinimalTextLines(1, WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM + 2), SetDataTip(STR_VEHICLE_NAME_BUTTON, STR_NULL /* filled in later */),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(WWT_PANEL, COLOUR_GREY, WID_VD_TOP_DETAILS), SetResize(1, 0), SetMinimalSize(405, 42), EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_MATRIX, COLOUR_GREY, WID_VD_MATRIX), SetResize(1, 1), SetMinimalSize(393, 45), SetDataTip(0x701, STR_NULL), SetFill(1, 0), SetScrollbar(WID_VD_SCROLLBAR),
+		NWidget(NWID_VSCROLLBAR, COLOUR_GREY, WID_VD_SCROLLBAR),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHARROWBTN, COLOUR_GREY, WID_VD_DECREASE_SERVICING_INTERVAL), SetFill(0, 1),
+				SetDataTip(AWV_DECREASE, STR_VEHICLE_DETAILS_DECREASE_SERVICING_INTERVAL_TOOLTIP),
+		NWidget(WWT_PUSHARROWBTN, COLOUR_GREY, WID_VD_INCREASE_SERVICING_INTERVAL), SetFill(0, 1),
+				SetDataTip(AWV_INCREASE, STR_VEHICLE_DETAILS_DECREASE_SERVICING_INTERVAL_TOOLTIP),
+		NWidget(WWT_DROPDOWN, COLOUR_GREY, WID_VD_SERVICE_INTERVAL_DROPDOWN), SetFill(0, 1),
+				SetDataTip(STR_EMPTY, STR_SERVICE_INTERVAL_DROPDOWN_TOOLTIP),
+		NWidget(WWT_PANEL, COLOUR_GREY, WID_VD_SERVICING_INTERVAL), SetFill(1, 1), SetResize(1, 0), EndContainer(),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_DETAILS_CARGO_CARRIED), SetMinimalSize(96, 12),
+				SetDataTip(STR_VEHICLE_DETAIL_TAB_CARGO, STR_VEHICLE_DETAILS_TRAIN_CARGO_TOOLTIP), SetFill(1, 0), SetResize(1, 0),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_DETAILS_TRAIN_VEHICLES), SetMinimalSize(99, 12),
+				SetDataTip(STR_VEHICLE_DETAIL_TAB_INFORMATION, STR_VEHICLE_DETAILS_TRAIN_INFORMATION_TOOLTIP), SetFill(1, 0), SetResize(1, 0),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_DETAILS_CAPACITY_OF_EACH), SetMinimalSize(99, 12),
+				SetDataTip(STR_VEHICLE_DETAIL_TAB_CAPACITIES, STR_VEHICLE_DETAILS_TRAIN_CAPACITIES_TOOLTIP), SetFill(1, 0), SetResize(1, 0),
+		NWidget(WWT_PUSHTXTBTN, COLOUR_GREY, WID_VD_DETAILS_TOTAL_CARGO), SetMinimalSize(99, 12),
+				SetDataTip(STR_VEHICLE_DETAIL_TAB_TOTAL_CARGO, STR_VEHICLE_DETAILS_TRAIN_TOTAL_CARGO_TOOLTIP), SetFill(1, 0), SetResize(1, 0),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+
+extern int GetTrainDetailsWndVScroll(VehicleID veh_id, TrainDetailsWindowTabs det_tab);
+extern void DrawTrainDetails(const Train *v, int left, int right, int y, int vscroll_pos, uint16 vscroll_cap, TrainDetailsWindowTabs det_tab);
+extern void DrawRoadVehDetails(const Vehicle *v, int left, int right, int y);
+extern void DrawShipDetails(const Vehicle *v, int left, int right, int y);
+extern void DrawAircraftDetails(const Aircraft *v, int left, int right, int y);
+
+static StringID _service_interval_dropdown[] = {
+	STR_VEHICLE_DETAILS_DEFAULT,
+	STR_VEHICLE_DETAILS_DAYS,
+	STR_VEHICLE_DETAILS_PERCENT,
+	INVALID_STRING_ID,
+};
+
+/** Class for managing the vehicle details window. */
+struct VehicleDetailsWindow : Window {
+	TrainDetailsWindowTabs tab; ///< For train vehicles: which tab is displayed.
+	Scrollbar *vscroll;
+
+	/** Initialize a newly created vehicle details window */
+	VehicleDetailsWindow(const WindowDesc *desc, WindowNumber window_number) : Window()
+	{
+		const Vehicle *v = Vehicle::Get(window_number);
+
+		this->CreateNestedTree(desc);
+		this->vscroll = (v->type == VEH_TRAIN ? this->GetScrollbar(WID_VD_SCROLLBAR) : NULL);
+		this->FinishInitNested(desc, window_number);
+
+		this->GetWidget<NWidgetCore>(WID_VD_RENAME_VEHICLE)->tool_tip = STR_VEHICLE_DETAILS_TRAIN_RENAME + v->type;
+
+		this->owner = v->owner;
+		this->tab = TDW_TAB_CARGO;
+	}
+
+	/**
+	 * Some data on this window has become invalid.
+	 * @param data Information about the changed data.
+	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+	 */
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		if (data == VIWD_AUTOREPLACE) {
+			/* Autoreplace replaced the vehicle.
+			 * Nothing to do for this window. */
+			return;
+		}
+		if (!gui_scope) return;
+		const Vehicle *v = Vehicle::Get(this->window_number);
+		if (v->type == VEH_ROAD) {
+			const NWidgetBase *nwid_info = this->GetWidget<NWidgetBase>(WID_VD_MIDDLE_DETAILS);
+			uint aimed_height = this->GetRoadVehDetailsHeight(v);
+			/* If the number of articulated parts changes, the size of the window must change too. */
+			if (aimed_height != nwid_info->current_y) {
+				this->ReInit();
+			}
+		}
+	}
+
+	/**
+	 * Gets the desired height for the road vehicle details panel.
+	 * @param v Road vehicle being shown.
+	 * @return Desired height in pixels.
+	 */
+	uint GetRoadVehDetailsHeight(const Vehicle *v)
+	{
+		uint desired_height;
+		if (v->HasArticulatedPart()) {
+			/* An articulated RV has its text drawn under the sprite instead of after it, hence 15 pixels extra. */
+			desired_height = WD_FRAMERECT_TOP + 15 + 3 * FONT_HEIGHT_NORMAL + 2 + WD_FRAMERECT_BOTTOM;
+			/* Add space for the cargo amount for each part. */
+			for (const Vehicle *u = v; u != NULL; u = u->Next()) {
+				if (u->cargo_cap != 0) desired_height += FONT_HEIGHT_NORMAL + 1;
+			}
+		} else {
+			desired_height = WD_FRAMERECT_TOP + 4 * FONT_HEIGHT_NORMAL + 3 + WD_FRAMERECT_BOTTOM;
+		}
+		return desired_height;
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		switch (widget) {
+			case WID_VD_TOP_DETAILS: {
+				Dimension dim = { 0, 0 };
+				size->height = WD_FRAMERECT_TOP + 4 * FONT_HEIGHT_NORMAL + WD_FRAMERECT_BOTTOM;
+
+				for (uint i = 0; i < 4; i++) SetDParamMaxValue(i, INT16_MAX);
+				static const StringID info_strings[] = {
+					STR_VEHICLE_INFO_MAX_SPEED,
+					STR_VEHICLE_INFO_WEIGHT_POWER_MAX_SPEED,
+					STR_VEHICLE_INFO_WEIGHT_POWER_MAX_SPEED_MAX_TE,
+					STR_VEHICLE_INFO_PROFIT_THIS_YEAR_LAST_YEAR,
+					STR_VEHICLE_INFO_RELIABILITY_BREAKDOWNS
+				};
+				for (uint i = 0; i < lengthof(info_strings); i++) {
+					dim = maxdim(dim, GetStringBoundingBox(info_strings[i]));
+				}
+				SetDParam(0, STR_VEHICLE_INFO_AGE);
+				dim = maxdim(dim, GetStringBoundingBox(STR_VEHICLE_INFO_AGE_RUNNING_COST_YR));
+				size->width = dim.width + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+				break;
+			}
+
+			case WID_VD_MIDDLE_DETAILS: {
+				const Vehicle *v = Vehicle::Get(this->window_number);
+				switch (v->type) {
+					case VEH_ROAD:
+						size->height = this->GetRoadVehDetailsHeight(v);
+						break;
+
+					case VEH_SHIP:
+						size->height = WD_FRAMERECT_TOP + 4 * FONT_HEIGHT_NORMAL + 3 + WD_FRAMERECT_BOTTOM;
+						break;
+
+					case VEH_AIRCRAFT:
+						size->height = WD_FRAMERECT_TOP + 5 * FONT_HEIGHT_NORMAL + 4 + WD_FRAMERECT_BOTTOM;
+						break;
+
+					default:
+						NOT_REACHED(); // Train uses WID_VD_MATRIX instead.
+				}
+				break;
+			}
+
+			case WID_VD_MATRIX:
+				resize->height = WD_MATRIX_TOP + FONT_HEIGHT_NORMAL + WD_MATRIX_BOTTOM;
+				size->height = 4 * resize->height;
+				break;
+
+			case WID_VD_SERVICE_INTERVAL_DROPDOWN: {
+				StringID *strs = _service_interval_dropdown;
+				while (*strs != INVALID_STRING_ID) {
+					*size = maxdim(*size, GetStringBoundingBox(*strs++));
+				}
+				size->width += padding.width;
+				size->height = FONT_HEIGHT_NORMAL + WD_DROPDOWNTEXT_TOP + WD_DROPDOWNTEXT_BOTTOM;
+				break;
+			}
+
+			case WID_VD_SERVICING_INTERVAL:
+				SetDParamMaxValue(0, MAX_SERVINT_DAYS); // Roughly the maximum interval
+				SetDParamMaxValue(1, MAX_YEAR * DAYS_IN_YEAR); // Roughly the maximum year
+				size->width = max(GetStringBoundingBox(STR_VEHICLE_DETAILS_SERVICING_INTERVAL_PERCENT).width, GetStringBoundingBox(STR_VEHICLE_DETAILS_SERVICING_INTERVAL_DAYS).width) + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+				size->height = WD_FRAMERECT_TOP + FONT_HEIGHT_NORMAL + WD_FRAMERECT_BOTTOM;
+				break;
+		}
+	}
+
+	/** Checks whether service interval is enabled for the vehicle. */
+	static bool IsVehicleServiceIntervalEnabled(const VehicleType vehicle_type, CompanyID company_id)
+	{
+		const VehicleDefaultSettings *vds = &Company::Get(company_id)->settings.vehicle;
+		switch (vehicle_type) {
+			default: NOT_REACHED();
+			case VEH_TRAIN:    return vds->servint_trains   != 0;
+			case VEH_ROAD:     return vds->servint_roadveh  != 0;
+			case VEH_SHIP:     return vds->servint_ships    != 0;
+			case VEH_AIRCRAFT: return vds->servint_aircraft != 0;
+		}
+	}
+
+	/**
+	 * Draw the details for the given vehicle at the position of the Details windows
+	 *
+	 * @param v     current vehicle
+	 * @param left  The left most coordinate to draw
+	 * @param right The right most coordinate to draw
+	 * @param y     The y coordinate
+	 * @param vscroll_pos Position of scrollbar (train only)
+	 * @param vscroll_cap Number of lines currently displayed (train only)
+	 * @param det_tab Selected details tab (train only)
+	 */
+	static void DrawVehicleDetails(const Vehicle *v, int left, int right, int y, int vscroll_pos, uint vscroll_cap, TrainDetailsWindowTabs det_tab)
+	{
+		switch (v->type) {
+			case VEH_TRAIN:    DrawTrainDetails(Train::From(v), left, right, y, vscroll_pos, vscroll_cap, det_tab);  break;
+			case VEH_ROAD:     DrawRoadVehDetails(v, left, right, y);  break;
+			case VEH_SHIP:     DrawShipDetails(v, left, right, y);     break;
+			case VEH_AIRCRAFT: DrawAircraftDetails(Aircraft::From(v), left, right, y); break;
+			default: NOT_REACHED();
+		}
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		if (widget == WID_VD_CAPTION) SetDParam(0, Vehicle::Get(this->window_number)->index);
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		const Vehicle *v = Vehicle::Get(this->window_number);
+
+		switch (widget) {
+			case WID_VD_TOP_DETAILS: {
+				int y = r.top + WD_FRAMERECT_TOP;
+
+				/* Draw running cost */
+				SetDParam(1, v->age / DAYS_IN_LEAP_YEAR);
+				SetDParam(0, (v->age + DAYS_IN_YEAR < v->max_age) ? STR_VEHICLE_INFO_AGE : STR_VEHICLE_INFO_AGE_RED);
+				SetDParam(2, v->max_age / DAYS_IN_LEAP_YEAR);
+				SetDParam(3, v->GetDisplayRunningCost());
+				DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_VEHICLE_INFO_AGE_RUNNING_COST_YR);
+				y += FONT_HEIGHT_NORMAL;
+
+				/* Draw max speed */
+				StringID string;
+				if (v->type == VEH_TRAIN ||
+						(v->type == VEH_ROAD && _settings_game.vehicle.roadveh_acceleration_model != AM_ORIGINAL)) {
+					const GroundVehicleCache *gcache = v->GetGroundVehicleCache();
+					SetDParam(2, v->GetDisplayMaxSpeed());
+					SetDParam(1, gcache->cached_power);
+					SetDParam(0, gcache->cached_weight);
+					SetDParam(3, gcache->cached_max_te / 1000);
+					if (v->type == VEH_TRAIN && (_settings_game.vehicle.train_acceleration_model == AM_ORIGINAL ||
+							GetRailTypeInfo(Train::From(v)->railtype)->acceleration_type == 2)) {
+						string = STR_VEHICLE_INFO_WEIGHT_POWER_MAX_SPEED;
+					} else {
+						string = STR_VEHICLE_INFO_WEIGHT_POWER_MAX_SPEED_MAX_TE;
+					}
+				} else {
+					SetDParam(0, v->GetDisplayMaxSpeed());
+					if (v->type == VEH_AIRCRAFT && Aircraft::From(v)->GetRange() > 0) {
+						SetDParam(1, Aircraft::From(v)->GetRange());
+						string = STR_VEHICLE_INFO_MAX_SPEED_RANGE;
+					} else {
+						string = STR_VEHICLE_INFO_MAX_SPEED;
+					}
+				}
+				DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, string);
+				y += FONT_HEIGHT_NORMAL;
+
+				/* Draw profit */
+				SetDParam(0, v->GetDisplayProfitThisYear());
+				SetDParam(1, v->GetDisplayProfitLastYear());
+				DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_VEHICLE_INFO_PROFIT_THIS_YEAR_LAST_YEAR);
+				y += FONT_HEIGHT_NORMAL;
+
+				/* Draw breakdown & reliability */
+				SetDParam(0, ToPercent16(v->reliability));
+				SetDParam(1, v->breakdowns_since_last_service);
+				DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, y, STR_VEHICLE_INFO_RELIABILITY_BREAKDOWNS);
+				break;
+			}
+
+			case WID_VD_MATRIX:
+				/* For trains only. */
+				DrawVehicleDetails(v, r.left + WD_MATRIX_LEFT, r.right - WD_MATRIX_RIGHT, r.top + WD_MATRIX_TOP, this->vscroll->GetPosition(), this->vscroll->GetCapacity(), this->tab);
+				break;
+
+			case WID_VD_MIDDLE_DETAILS: {
+				/* For other vehicles, at the place of the matrix. */
+				bool rtl = _current_text_dir == TD_RTL;
+				uint sprite_width = max<uint>(UnScaleByZoom(GetSprite(v->GetImage(rtl ? DIR_E : DIR_W, EIT_IN_DETAILS), ST_NORMAL)->width, ZOOM_LVL_GUI), 70U) + WD_FRAMERECT_LEFT + WD_FRAMERECT_RIGHT;
+
+				uint text_left  = r.left  + (rtl ? 0 : sprite_width);
+				uint text_right = r.right - (rtl ? sprite_width : 0);
+
+				/* Articulated road vehicles use a complete line. */
+				if (v->type == VEH_ROAD && v->HasArticulatedPart()) {
+					DrawVehicleImage(v, r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, INVALID_VEHICLE, EIT_IN_DETAILS, 0);
+				} else {
+					uint sprite_left  = rtl ? text_right : r.left;
+					uint sprite_right = rtl ? r.right : text_left;
+
+					DrawVehicleImage(v, sprite_left + WD_FRAMERECT_LEFT, sprite_right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, INVALID_VEHICLE, EIT_IN_DETAILS, 0);
+				}
+				DrawVehicleDetails(v, text_left + WD_FRAMERECT_LEFT, text_right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, 0, 0, this->tab);
+				break;
+			}
+
+			case WID_VD_SERVICING_INTERVAL:
+				/* Draw service interval text */
+				SetDParam(0, v->GetServiceInterval());
+				SetDParam(1, v->date_of_last_service);
+				DrawString(r.left + WD_FRAMERECT_LEFT, r.right - WD_FRAMERECT_RIGHT, r.top + (r.bottom - r.top + 1 - FONT_HEIGHT_NORMAL) / 2,
+						v->ServiceIntervalIsPercent() ? STR_VEHICLE_DETAILS_SERVICING_INTERVAL_PERCENT : STR_VEHICLE_DETAILS_SERVICING_INTERVAL_DAYS);
+				break;
+		}
+	}
+
+	/** Repaint vehicle details window. */
+	virtual void OnPaint()
+	{
+		const Vehicle *v = Vehicle::Get(this->window_number);
+
+		this->SetWidgetDisabledState(WID_VD_RENAME_VEHICLE, v->owner != _local_company);
+
+		if (v->type == VEH_TRAIN) {
+			this->DisableWidget(this->tab + WID_VD_DETAILS_CARGO_CARRIED);
+			this->vscroll->SetCount(GetTrainDetailsWndVScroll(v->index, this->tab));
+		}
+
+		/* Disable service-scroller when interval is set to disabled */
+		this->SetWidgetsDisabledState(!IsVehicleServiceIntervalEnabled(v->type, v->owner),
+			WID_VD_INCREASE_SERVICING_INTERVAL,
+			WID_VD_DECREASE_SERVICING_INTERVAL,
+			WIDGET_LIST_END);
+
+		StringID str = v->ServiceIntervalIsCustom() ?
+			(v->ServiceIntervalIsPercent() ? STR_VEHICLE_DETAILS_PERCENT : STR_VEHICLE_DETAILS_DAYS) :
+			STR_VEHICLE_DETAILS_DEFAULT;
+		this->GetWidget<NWidgetCore>(WID_VD_SERVICE_INTERVAL_DROPDOWN)->widget_data = str;
+
+		this->DrawWidgets();
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		switch (widget) {
+			case WID_VD_RENAME_VEHICLE: { // rename
+				const Vehicle *v = Vehicle::Get(this->window_number);
+				SetDParam(0, v->index);
+				ShowQueryString(STR_VEHICLE_NAME, STR_QUERY_RENAME_TRAIN_CAPTION + v->type,
+						MAX_LENGTH_VEHICLE_NAME_CHARS, this, CS_ALPHANUMERAL, QSF_ENABLE_DEFAULT | QSF_LEN_IN_CHARS);
+				break;
+			}
+
+			case WID_VD_INCREASE_SERVICING_INTERVAL:   // increase int
+			case WID_VD_DECREASE_SERVICING_INTERVAL: { // decrease int
+				int mod = _ctrl_pressed ? 5 : 10;
+				const Vehicle *v = Vehicle::Get(this->window_number);
+
+				mod = (widget == WID_VD_DECREASE_SERVICING_INTERVAL) ? -mod : mod;
+				mod = GetServiceIntervalClamped(mod + v->GetServiceInterval(), v->ServiceIntervalIsPercent());
+				if (mod == v->GetServiceInterval()) return;
+
+				DoCommandP(v->tile, v->index, mod | (1 << 16) | (v->ServiceIntervalIsPercent() << 17), CMD_CHANGE_SERVICE_INT | CMD_MSG(STR_ERROR_CAN_T_CHANGE_SERVICING));
+				break;
+			}
+
+			case WID_VD_SERVICE_INTERVAL_DROPDOWN: {
+				const Vehicle *v = Vehicle::Get(this->window_number);
+				ShowDropDownMenu(this, _service_interval_dropdown, v->ServiceIntervalIsCustom() ? (v->ServiceIntervalIsPercent() ? 2 : 1) : 0, widget, 0, 0);
+				break;
+			}
+
+			case WID_VD_DETAILS_CARGO_CARRIED:
+			case WID_VD_DETAILS_TRAIN_VEHICLES:
+			case WID_VD_DETAILS_CAPACITY_OF_EACH:
+			case WID_VD_DETAILS_TOTAL_CARGO:
+				this->SetWidgetsDisabledState(false,
+					WID_VD_DETAILS_CARGO_CARRIED,
+					WID_VD_DETAILS_TRAIN_VEHICLES,
+					WID_VD_DETAILS_CAPACITY_OF_EACH,
+					WID_VD_DETAILS_TOTAL_CARGO,
+					widget,
+					WIDGET_LIST_END);
+
+				this->tab = (TrainDetailsWindowTabs)(widget - WID_VD_DETAILS_CARGO_CARRIED);
+				this->SetDirty();
+				break;
+		}
+	}
+
+	virtual void OnDropdownSelect(int widget, int index)
+	{
+		switch (widget) {
+			case WID_VD_SERVICE_INTERVAL_DROPDOWN: {
+				const Vehicle *v = Vehicle::Get(this->window_number);
+				bool iscustom = index != 0;
+				bool ispercent = iscustom ? (index == 2) : Company::Get(v->owner)->settings.vehicle.servint_ispercent;
+				uint16 interval = GetServiceIntervalClamped(v->GetServiceInterval(), ispercent);
+				DoCommandP(v->tile, v->index, interval | (iscustom << 16) | (ispercent << 17), CMD_CHANGE_SERVICE_INT | CMD_MSG(STR_ERROR_CAN_T_CHANGE_SERVICING));
+				break;
+			}
+		}
+	}
+
+	virtual void OnQueryTextFinished(char *str)
+	{
+		if (str == NULL) return;
+
+		DoCommandP(0, this->window_number, 0, CMD_RENAME_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_RENAME_TRAIN + Vehicle::Get(this->window_number)->type), NULL, str);
+	}
+
+	virtual void OnResize()
+	{
+		NWidgetCore *nwi = this->GetWidget<NWidgetCore>(WID_VD_MATRIX);
+		if (nwi != NULL) {
+			this->vscroll->SetCapacityFromWidget(this, WID_VD_MATRIX);
+			nwi->widget_data = (this->vscroll->GetCapacity() << MAT_ROW_START) + (1 << MAT_COL_START);
+		}
+	}
+};
+
+/** Vehicle details window descriptor. */
+static const WindowDesc _train_vehicle_details_desc(
+	WDP_AUTO, 405, 178,
+	WC_VEHICLE_DETAILS, WC_VEHICLE_VIEW,
+	0,
+	_nested_train_vehicle_details_widgets, lengthof(_nested_train_vehicle_details_widgets)
+);
+
+/** Vehicle details window descriptor for other vehicles than a train. */
+static const WindowDesc _nontrain_vehicle_details_desc(
+	WDP_AUTO, 405, 113,
+	WC_VEHICLE_DETAILS, WC_VEHICLE_VIEW,
+	0,
+	_nested_nontrain_vehicle_details_widgets, lengthof(_nested_nontrain_vehicle_details_widgets)
+);
+
+/** Shows the vehicle details window of the given vehicle. */
+static void ShowVehicleDetailsWindow(const Vehicle *v)
+{
+	DeleteWindowById(WC_VEHICLE_ORDERS, v->index, false);
+	DeleteWindowById(WC_VEHICLE_TIMETABLE, v->index, false);
+	AllocateWindowDescFront<VehicleDetailsWindow>((v->type == VEH_TRAIN) ? &_train_vehicle_details_desc : &_nontrain_vehicle_details_desc, v->index);
+}
+
+
+/* Unified vehicle GUI - Vehicle View Window */
+
+/** Vehicle view widgets. */
+static const NWidgetPart _nested_vehicle_view_widgets[] = {
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_CLOSEBOX, COLOUR_GREY),
+		NWidget(WWT_CAPTION, COLOUR_GREY, WID_VV_CAPTION), SetDataTip(STR_VEHICLE_VIEW_CAPTION, STR_TOOLTIP_WINDOW_TITLE_DRAG_THIS),
+		NWidget(WWT_DEBUGBOX, COLOUR_GREY),
+		NWidget(WWT_SHADEBOX, COLOUR_GREY),
+		NWidget(WWT_STICKYBOX, COLOUR_GREY),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PANEL, COLOUR_GREY),
+			NWidget(WWT_INSET, COLOUR_GREY), SetPadding(2, 2, 2, 2),
+				NWidget(NWID_VIEWPORT, INVALID_COLOUR, WID_VV_VIEWPORT), SetMinimalSize(226, 84), SetResize(1, 1), SetPadding(1, 1, 1, 1),
+			EndContainer(),
+		EndContainer(),
+		NWidget(NWID_VERTICAL),
+			NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_VV_CENTER_MAIN_VIEW), SetMinimalSize(18, 18), SetFill(1, 1), SetDataTip(SPR_CENTRE_VIEW_VEHICLE, 0x0 /* filled later */),
+			NWidget(NWID_SELECTION, INVALID_COLOUR, WID_VV_SELECT_DEPOT_CLONE),
+				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_VV_GOTO_DEPOT), SetMinimalSize(18, 18), SetFill(1, 1), SetDataTip(0x0 /* filled later */, 0x0 /* filled later */),
+				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_VV_CLONE), SetMinimalSize(18, 18), SetFill(1, 1), SetDataTip(0x0 /* filled later */, 0x0 /* filled later */),
+			EndContainer(),
+			/* For trains only, 'ignore signal' button. */
+			NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_VV_FORCE_PROCEED), SetMinimalSize(18, 18), SetFill(1, 1),
+											SetDataTip(SPR_IGNORE_SIGNALS, STR_VEHICLE_VIEW_TRAIN_IGNORE_SIGNAL_TOOLTIP),
+			NWidget(NWID_SELECTION, INVALID_COLOUR, WID_VV_SELECT_REFIT_TURN),
+				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_VV_REFIT), SetMinimalSize(18, 18), SetFill(1, 1), SetDataTip(SPR_REFIT_VEHICLE, 0x0 /* filled later */),
+				NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_VV_TURN_AROUND), SetMinimalSize(18, 18), SetFill(1, 1),
+												SetDataTip(SPR_FORCE_VEHICLE_TURN, STR_VEHICLE_VIEW_ROAD_VEHICLE_REVERSE_TOOLTIP),
+			EndContainer(),
+			NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_VV_SHOW_ORDERS), SetFill(1, 1), SetMinimalSize(18, 18), SetDataTip(SPR_SHOW_ORDERS, 0x0 /* filled later */),
+			NWidget(WWT_PUSHIMGBTN, COLOUR_GREY, WID_VV_SHOW_DETAILS), SetFill(1, 1), SetMinimalSize(18, 18), SetDataTip(SPR_SHOW_VEHICLE_DETAILS, 0x0 /* filled later */),
+			NWidget(WWT_PANEL, COLOUR_GREY), SetFill(1, 1), SetMinimalSize(18, 0), SetResize(0, 1), EndContainer(),
+		EndContainer(),
+	EndContainer(),
+	NWidget(NWID_HORIZONTAL),
+		NWidget(WWT_PUSHBTN, COLOUR_GREY, WID_VV_START_STOP), SetMinimalTextLines(1, WD_FRAMERECT_TOP + WD_FRAMERECT_BOTTOM + 2), SetResize(1, 0), SetFill(1, 0),
+		NWidget(WWT_RESIZEBOX, COLOUR_GREY),
+	EndContainer(),
+};
+
+/** Vehicle view window descriptor for all vehicles but trains. */
+static const WindowDesc _vehicle_view_desc(
+	WDP_AUTO, 250, 116,
+	WC_VEHICLE_VIEW, WC_NONE,
+	0,
+	_nested_vehicle_view_widgets, lengthof(_nested_vehicle_view_widgets)
+);
+
+/**
+ * Vehicle view window descriptor for trains. Only minimum_height and
+ *  default_height are different for train view.
+ */
+static const WindowDesc _train_view_desc(
+	WDP_AUTO, 250, 134,
+	WC_VEHICLE_VIEW, WC_NONE,
+	0,
+	_nested_vehicle_view_widgets, lengthof(_nested_vehicle_view_widgets)
+);
+
+
+/* Just to make sure, nobody has changed the vehicle type constants, as we are
+	 using them for array indexing in a number of places here. */
+assert_compile(VEH_TRAIN == 0);
+assert_compile(VEH_ROAD == 1);
+assert_compile(VEH_SHIP == 2);
+assert_compile(VEH_AIRCRAFT == 3);
+
+/** Zoom levels for vehicle views indexed by vehicle type. */
+static const ZoomLevel _vehicle_view_zoom_levels[] = {
+	ZOOM_LVL_TRAIN,
+	ZOOM_LVL_ROADVEH,
+	ZOOM_LVL_SHIP,
+	ZOOM_LVL_AIRCRAFT,
+};
+
+/* Constants for geometry of vehicle view viewport */
+static const int VV_INITIAL_VIEWPORT_WIDTH = 226;
+static const int VV_INITIAL_VIEWPORT_HEIGHT = 84;
+static const int VV_INITIAL_VIEWPORT_HEIGHT_TRAIN = 102;
+
+/** Command indices for the _vehicle_command_translation_table. */
+enum VehicleCommandTranslation {
+	VCT_CMD_START_STOP = 0,
+	VCT_CMD_CLONE_VEH,
+	VCT_CMD_TURN_AROUND,
+};
+
+/** Command codes for the shared buttons indexed by VehicleCommandTranslation and vehicle type. */
+static const uint32 _vehicle_command_translation_table[][4] = {
+	{ // VCT_CMD_START_STOP
+		CMD_START_STOP_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_STOP_START_TRAIN),
+		CMD_START_STOP_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_STOP_START_ROAD_VEHICLE),
+		CMD_START_STOP_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_STOP_START_SHIP),
+		CMD_START_STOP_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_STOP_START_AIRCRAFT)
+	},
+	{ // VCT_CMD_CLONE_VEH
+		CMD_CLONE_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_BUY_TRAIN),
+		CMD_CLONE_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_BUY_ROAD_VEHICLE),
+		CMD_CLONE_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_BUY_SHIP),
+		CMD_CLONE_VEHICLE | CMD_MSG(STR_ERROR_CAN_T_BUY_AIRCRAFT)
+	},
+	{ // VCT_CMD_TURN_AROUND
+		CMD_REVERSE_TRAIN_DIRECTION | CMD_MSG(STR_ERROR_CAN_T_REVERSE_DIRECTION_TRAIN),
+		CMD_TURN_ROADVEH            | CMD_MSG(STR_ERROR_CAN_T_MAKE_ROAD_VEHICLE_TURN),
+		0xffffffff, // invalid for ships
+		0xffffffff  // invalid for aircrafts
+	},
+};
+
+/**
+ * This is the Callback method after the cloning attempt of a vehicle
+ * @param result the result of the cloning command
+ * @param tile unused
+ * @param p1 vehicle ID
+ * @param p2 unused
+ */
+void CcStartStopVehicle(const CommandCost &result, TileIndex tile, uint32 p1, uint32 p2)
+{
+	if (result.Failed()) return;
+
+	const Vehicle *v = Vehicle::GetIfValid(p1);
+	if (v == NULL || !v->IsPrimaryVehicle() || v->owner != _local_company) return;
+
+	StringID msg = (v->vehstatus & VS_STOPPED) ? STR_VEHICLE_COMMAND_STOPPED : STR_VEHICLE_COMMAND_STARTED;
+	Point pt = RemapCoords(v->x_pos, v->y_pos, v->z_pos);
+	AddTextEffect(msg, pt.x, pt.y, DAY_TICKS, TE_RISING);
+}
+
+/**
+ * Executes #CMD_START_STOP_VEHICLE for given vehicle.
+ * @param v Vehicle to start/stop
+ * @param texteffect Should a texteffect be shown?
+ */
+void StartStopVehicle(const Vehicle *v, bool texteffect)
+{
+	assert(v->IsPrimaryVehicle());
+	DoCommandP(v->tile, v->index, 0, _vehicle_command_translation_table[VCT_CMD_START_STOP][v->type], texteffect ? CcStartStopVehicle : NULL);
+}
+
+/** Checks whether the vehicle may be refitted at the moment.*/
+static bool IsVehicleRefitable(const Vehicle *v)
+{
+	if (!v->IsStoppedInDepot()) return false;
+
+	do {
+		if (IsEngineRefittable(v->engine_type)) return true;
+	} while (v->IsGroundVehicle() && (v = v->Next()) != NULL);
+
+	return false;
+}
+
+/** Window manager class for viewing a vehicle. */
+struct VehicleViewWindow : Window {
+private:
+	/** Display planes available in the vehicle view window. */
+	enum PlaneSelections {
+		SEL_DC_GOTO_DEPOT,  ///< Display 'goto depot' button in #WID_VV_SELECT_DEPOT_CLONE stacked widget.
+		SEL_DC_CLONE,       ///< Display 'clone vehicle' button in #WID_VV_SELECT_DEPOT_CLONE stacked widget.
+
+		SEL_RT_REFIT,       ///< Display 'refit' button in #WID_VV_SELECT_REFIT_TURN stacked widget.
+		SEL_RT_TURN_AROUND, ///< Display 'turn around' button in #WID_VV_SELECT_REFIT_TURN stacked widget.
+
+		SEL_DC_BASEPLANE = SEL_DC_GOTO_DEPOT, ///< First plane of the #WID_VV_SELECT_DEPOT_CLONE stacked widget.
+		SEL_RT_BASEPLANE = SEL_RT_REFIT,      ///< First plane of the #WID_VV_SELECT_REFIT_TURN stacked widget.
+	};
+
+	/**
+	 * Display a plane in the window.
+	 * @param plane Plane to show.
+	 */
+	void SelectPlane(PlaneSelections plane)
+	{
+		switch (plane) {
+			case SEL_DC_GOTO_DEPOT:
+			case SEL_DC_CLONE:
+				this->GetWidget<NWidgetStacked>(WID_VV_SELECT_DEPOT_CLONE)->SetDisplayedPlane(plane - SEL_DC_BASEPLANE);
+				break;
+
+			case SEL_RT_REFIT:
+			case SEL_RT_TURN_AROUND:
+				this->GetWidget<NWidgetStacked>(WID_VV_SELECT_REFIT_TURN)->SetDisplayedPlane(plane - SEL_RT_BASEPLANE);
+				break;
+
+			default:
+				NOT_REACHED();
+		}
+	}
+
+public:
+	VehicleViewWindow(const WindowDesc *desc, WindowNumber window_number) : Window()
+	{
+		this->CreateNestedTree(desc);
+
+		/* Sprites for the 'send to depot' button indexed by vehicle type. */
+		static const SpriteID vehicle_view_goto_depot_sprites[] = {
+			SPR_SEND_TRAIN_TODEPOT,
+			SPR_SEND_ROADVEH_TODEPOT,
+			SPR_SEND_SHIP_TODEPOT,
+			SPR_SEND_AIRCRAFT_TODEPOT,
+		};
+		const Vehicle *v = Vehicle::Get(window_number);
+		this->GetWidget<NWidgetCore>(WID_VV_GOTO_DEPOT)->widget_data = vehicle_view_goto_depot_sprites[v->type];
+
+		/* Sprites for the 'clone vehicle' button indexed by vehicle type. */
+		static const SpriteID vehicle_view_clone_sprites[] = {
+			SPR_CLONE_TRAIN,
+			SPR_CLONE_ROADVEH,
+			SPR_CLONE_SHIP,
+			SPR_CLONE_AIRCRAFT,
+		};
+		this->GetWidget<NWidgetCore>(WID_VV_CLONE)->widget_data = vehicle_view_clone_sprites[v->type];
+
+		switch (v->type) {
+			case VEH_TRAIN:
+				this->GetWidget<NWidgetCore>(WID_VV_TURN_AROUND)->tool_tip = STR_VEHICLE_VIEW_TRAIN_REVERSE_TOOLTIP;
+				break;
+
+			case VEH_ROAD:
+				break;
+
+			case VEH_SHIP:
+			case VEH_AIRCRAFT:
+				this->SelectPlane(SEL_RT_REFIT);
+				break;
+
+			default: NOT_REACHED();
+		}
+		this->FinishInitNested(desc, window_number);
+		this->owner = v->owner;
+		this->GetWidget<NWidgetViewport>(WID_VV_VIEWPORT)->InitializeViewport(this, this->window_number | (1 << 31), _vehicle_view_zoom_levels[v->type]);
+
+		this->GetWidget<NWidgetCore>(WID_VV_START_STOP)->tool_tip       = STR_VEHICLE_VIEW_TRAIN_STATE_START_STOP_TOOLTIP + v->type;
+		this->GetWidget<NWidgetCore>(WID_VV_CENTER_MAIN_VIEW)->tool_tip = STR_VEHICLE_VIEW_TRAIN_LOCATION_TOOLTIP + v->type;
+		this->GetWidget<NWidgetCore>(WID_VV_REFIT)->tool_tip            = STR_VEHICLE_VIEW_TRAIN_REFIT_TOOLTIP + v->type;
+		this->GetWidget<NWidgetCore>(WID_VV_GOTO_DEPOT)->tool_tip       = STR_VEHICLE_VIEW_TRAIN_SEND_TO_DEPOT_TOOLTIP + v->type;
+		this->GetWidget<NWidgetCore>(WID_VV_SHOW_ORDERS)->tool_tip      = STR_VEHICLE_VIEW_TRAIN_ORDERS_TOOLTIP + v->type;
+		this->GetWidget<NWidgetCore>(WID_VV_SHOW_DETAILS)->tool_tip     = STR_VEHICLE_VIEW_TRAIN_SHOW_DETAILS_TOOLTIP + v->type;
+		this->GetWidget<NWidgetCore>(WID_VV_CLONE)->tool_tip            = STR_VEHICLE_VIEW_CLONE_TRAIN_INFO + v->type;
+	}
+
+	~VehicleViewWindow()
+	{
+		DeleteWindowById(WC_VEHICLE_ORDERS, this->window_number, false);
+		DeleteWindowById(WC_VEHICLE_REFIT, this->window_number, false);
+		DeleteWindowById(WC_VEHICLE_DETAILS, this->window_number, false);
+		DeleteWindowById(WC_VEHICLE_TIMETABLE, this->window_number, false);
+	}
+
+	virtual void UpdateWidgetSize(int widget, Dimension *size, const Dimension &padding, Dimension *fill, Dimension *resize)
+	{
+		const Vehicle *v = Vehicle::Get(this->window_number);
+		switch (widget) {
+			case WID_VV_FORCE_PROCEED:
+				if (v->type != VEH_TRAIN) {
+					size->height = 0;
+					size->width = 0;
+				}
+				break;
+
+			case WID_VV_VIEWPORT:
+				size->width = VV_INITIAL_VIEWPORT_WIDTH;
+				size->height = (v->type == VEH_TRAIN) ? VV_INITIAL_VIEWPORT_HEIGHT_TRAIN : VV_INITIAL_VIEWPORT_HEIGHT;
+				break;
+		}
+	}
+
+	virtual void OnPaint()
+	{
+		const Vehicle *v = Vehicle::Get(this->window_number);
+		bool is_localcompany = v->owner == _local_company;
+		bool refitable_and_stopped_in_depot = IsVehicleRefitable(v);
+
+		this->SetWidgetDisabledState(WID_VV_GOTO_DEPOT, !is_localcompany);
+		this->SetWidgetDisabledState(WID_VV_REFIT, !refitable_and_stopped_in_depot || !is_localcompany);
+		this->SetWidgetDisabledState(WID_VV_CLONE, !is_localcompany);
+
+		if (v->type == VEH_TRAIN) {
+			this->SetWidgetLoweredState(WID_VV_FORCE_PROCEED, Train::From(v)->force_proceed == TFP_SIGNAL);
+			this->SetWidgetDisabledState(WID_VV_FORCE_PROCEED, !is_localcompany);
+			this->SetWidgetDisabledState(WID_VV_TURN_AROUND, !is_localcompany);
+		}
+
+		this->DrawWidgets();
+	}
+
+	virtual void SetStringParameters(int widget) const
+	{
+		if (widget != WID_VV_CAPTION) return;
+
+		const Vehicle *v = Vehicle::Get(this->window_number);
+		SetDParam(0, v->index);
+	}
+
+	virtual void DrawWidget(const Rect &r, int widget) const
+	{
+		if (widget != WID_VV_START_STOP) return;
+
+		const Vehicle *v = Vehicle::Get(this->window_number);
+		StringID str;
+		if (v->vehstatus & VS_CRASHED) {
+			str = STR_VEHICLE_STATUS_CRASHED;
+		} else if (v->type != VEH_AIRCRAFT && v->breakdown_ctr == 1) { // check for aircraft necessary?
+			str = STR_VEHICLE_STATUS_BROKEN_DOWN;
+		} else if (v->vehstatus & VS_STOPPED) {
+			if (v->type == VEH_TRAIN) {
+				if (v->cur_speed == 0) {
+					if (Train::From(v)->gcache.cached_power == 0) {
+						str = STR_VEHICLE_STATUS_TRAIN_NO_POWER;
+					} else {
+						str = STR_VEHICLE_STATUS_STOPPED;
+					}
+				} else {
+					SetDParam(0, v->GetDisplaySpeed());
+					str = STR_VEHICLE_STATUS_TRAIN_STOPPING_VEL;
+				}
+			} else { // no train
+				str = STR_VEHICLE_STATUS_STOPPED;
+			}
+		} else if (v->type == VEH_TRAIN && HasBit(Train::From(v)->flags, VRF_TRAIN_STUCK) && !v->current_order.IsType(OT_LOADING)) {
+			str = STR_VEHICLE_STATUS_TRAIN_STUCK;
+		} else if (v->type == VEH_AIRCRAFT && HasBit(Aircraft::From(v)->flags, VAF_DEST_TOO_FAR) && !v->current_order.IsType(OT_LOADING)) {
+			str = STR_VEHICLE_STATUS_AIRCRAFT_TOO_FAR;
+		} else { // vehicle is in a "normal" state, show current order
+			switch (v->current_order.GetType()) {
+				case OT_GOTO_STATION: {
+					SetDParam(0, v->current_order.GetDestination());
+					SetDParam(1, v->GetDisplaySpeed());
+					str = STR_VEHICLE_STATUS_HEADING_FOR_STATION_VEL;
+					break;
+				}
+
+				case OT_GOTO_DEPOT: {
+					SetDParam(0, v->type);
+					SetDParam(1, v->current_order.GetDestination());
+					SetDParam(2, v->GetDisplaySpeed());
+					if (v->current_order.GetDepotActionType() & ODATFB_NEAREST_DEPOT) {
+						/* This case *only* happens when multiple nearest depot orders
+						 * follow each other (including an order list only one order: a
+						 * nearest depot order) and there are no reachable depots.
+						 * It is primarily to guard for the case that there is no
+						 * depot with index 0, which would be used as fallback for
+						 * evaluating the string in the status bar. */
+						str = STR_EMPTY;
+					} else if (v->current_order.GetDepotActionType() & ODATFB_HALT) {
+						str = STR_VEHICLE_STATUS_HEADING_FOR_DEPOT_VEL;
+					} else {
+						str = STR_VEHICLE_STATUS_HEADING_FOR_DEPOT_SERVICE_VEL;
+					}
+					break;
+				}
+
+				case OT_LOADING:
+					str = STR_VEHICLE_STATUS_LOADING_UNLOADING;
+					break;
+
+				case OT_GOTO_WAYPOINT: {
+					assert(v->type == VEH_TRAIN || v->type == VEH_SHIP);
+					SetDParam(0, v->current_order.GetDestination());
+					str = STR_VEHICLE_STATUS_HEADING_FOR_WAYPOINT_VEL;
+					SetDParam(1, v->GetDisplaySpeed());
+					break;
+				}
+
+				case OT_LEAVESTATION:
+					if (v->type != VEH_AIRCRAFT) {
+						str = STR_VEHICLE_STATUS_LEAVING;
+						break;
+					}
+					/* FALL THROUGH, if aircraft. Does this even happen? */
+
+				default:
+					if (v->GetNumManualOrders() == 0) {
+						str = STR_VEHICLE_STATUS_NO_ORDERS_VEL;
+						SetDParam(0, v->GetDisplaySpeed());
+					} else {
+						str = STR_EMPTY;
+					}
+					break;
+			}
+		}
+
+		/* draw the flag plus orders */
+		DrawSprite(v->vehstatus & VS_STOPPED ? SPR_FLAG_VEH_STOPPED : SPR_FLAG_VEH_RUNNING, PAL_NONE, WD_FRAMERECT_LEFT, r.top + WD_FRAMERECT_TOP);
+		DrawString(r.left + WD_FRAMERECT_LEFT + 6, r.right - WD_FRAMERECT_RIGHT, r.top + WD_FRAMERECT_TOP, str, TC_FROMSTRING, SA_HOR_CENTER);
+	}
+
+	virtual void OnClick(Point pt, int widget, int click_count)
+	{
+		const Vehicle *v = Vehicle::Get(this->window_number);
+
+		switch (widget) {
+			case WID_VV_START_STOP: // start stop
+				if (_ctrl_pressed) {
+					/* Scroll to current order destination */
+					TileIndex tile = v->current_order.GetLocation(v);
+					if (tile != INVALID_TILE) ScrollMainWindowToTile(tile);
+				} else {
+					/* Start/Stop */
+					StartStopVehicle(v, false);
+				}
+				break;
+			case WID_VV_CENTER_MAIN_VIEW: {// center main view
+				const Window *mainwindow = FindWindowById(WC_MAIN_WINDOW, 0);
+				/* code to allow the main window to 'follow' the vehicle if the ctrl key is pressed */
+				if (_ctrl_pressed && mainwindow->viewport->zoom <= ZOOM_LVL_OUT_4X) {
+					mainwindow->viewport->follow_vehicle = v->index;
+				} else {
+					ScrollMainWindowTo(v->x_pos, v->y_pos, v->z_pos);
+				}
+				break;
+			}
+
+			case WID_VV_GOTO_DEPOT: // goto hangar
+				DoCommandP(v->tile, v->index | (_ctrl_pressed ? DEPOT_SERVICE : 0U), 0, GetCmdSendToDepot(v));
+				break;
+			case WID_VV_REFIT: // refit
+				ShowVehicleRefitWindow(v, INVALID_VEH_ORDER_ID, this);
+				break;
+			case WID_VV_SHOW_ORDERS: // show orders
+				if (_ctrl_pressed) {
+					ShowTimetableWindow(v);
+				} else {
+					ShowOrdersWindow(v);
+				}
+				break;
+			case WID_VV_SHOW_DETAILS: // show details
+				ShowVehicleDetailsWindow(v);
+				break;
+			case WID_VV_CLONE: // clone vehicle
+				/* Suppress the vehicle GUI when share-cloning.
+				 * There is no point to it except for starting the vehicle.
+				 * For starting the vehicle the player has to open the depot GUI, which is
+				 * most likely already open, but is also visible in the vehicle viewport. */
+				DoCommandP(v->tile, v->index, _ctrl_pressed ? 1 : 0,
+										_vehicle_command_translation_table[VCT_CMD_CLONE_VEH][v->type],
+										_ctrl_pressed ? NULL : CcCloneVehicle);
+				break;
+			case WID_VV_TURN_AROUND: // turn around
+				assert(v->IsGroundVehicle());
+				DoCommandP(v->tile, v->index, 0,
+										_vehicle_command_translation_table[VCT_CMD_TURN_AROUND][v->type]);
+				break;
+			case WID_VV_FORCE_PROCEED: // force proceed
+				assert(v->type == VEH_TRAIN);
+				DoCommandP(v->tile, v->index, 0, CMD_FORCE_TRAIN_PROCEED | CMD_MSG(STR_ERROR_CAN_T_MAKE_TRAIN_PASS_SIGNAL));
+				break;
+		}
+	}
+
+	virtual void OnResize()
+	{
+		if (this->viewport != NULL) {
+			NWidgetViewport *nvp = this->GetWidget<NWidgetViewport>(WID_VV_VIEWPORT);
+			nvp->UpdateViewportCoordinates(this);
+		}
+	}
+
+	virtual void OnTick()
+	{
+		const Vehicle *v = Vehicle::Get(this->window_number);
+		bool veh_stopped = v->IsStoppedInDepot();
+
+		/* Widget WID_VV_GOTO_DEPOT must be hidden if the vehicle is already stopped in depot.
+		 * Widget WID_VV_CLONE_VEH should then be shown, since cloning is allowed only while in depot and stopped.
+		 */
+		PlaneSelections plane = veh_stopped ? SEL_DC_CLONE : SEL_DC_GOTO_DEPOT;
+		NWidgetStacked *nwi = this->GetWidget<NWidgetStacked>(WID_VV_SELECT_DEPOT_CLONE); // Selection widget 'send to depot' / 'clone'.
+		if (nwi->shown_plane + SEL_DC_BASEPLANE != plane) {
+			this->SelectPlane(plane);
+			this->SetWidgetDirty(WID_VV_SELECT_DEPOT_CLONE);
+		}
+		/* The same system applies to widget WID_VV_REFIT_VEH and VVW_WIDGET_TURN_AROUND.*/
+		if (v->IsGroundVehicle()) {
+			PlaneSelections plane = veh_stopped ? SEL_RT_REFIT : SEL_RT_TURN_AROUND;
+			NWidgetStacked *nwi = this->GetWidget<NWidgetStacked>(WID_VV_SELECT_REFIT_TURN);
+			if (nwi->shown_plane + SEL_RT_BASEPLANE != plane) {
+				this->SelectPlane(plane);
+				this->SetWidgetDirty(WID_VV_SELECT_REFIT_TURN);
+			}
+		}
+	}
+
+	/**
+	 * Some data on this window has become invalid.
+	 * @param data Information about the changed data.
+	 * @param gui_scope Whether the call is done from GUI scope. You may not do everything when not in GUI scope. See #InvalidateWindowData() for details.
+	 */
+	virtual void OnInvalidateData(int data = 0, bool gui_scope = true)
+	{
+		if (data == VIWD_AUTOREPLACE) {
+			/* Autoreplace replaced the vehicle.
+			 * Nothing to do for this window. */
+			return;
+		}
+	}
+
+	virtual bool IsNewGRFInspectable() const
+	{
+		return ::IsNewGRFInspectable(GetGrfSpecFeature(Vehicle::Get(this->window_number)->type), this->window_number);
+	}
+
+	virtual void ShowNewGRFInspectWindow() const
+	{
+		::ShowNewGRFInspectWindow(GetGrfSpecFeature(Vehicle::Get(this->window_number)->type), this->window_number);
+	}
+};
+
+
+/** Shows the vehicle view window of the given vehicle. */
+void ShowVehicleViewWindow(const Vehicle *v)
+{
+	AllocateWindowDescFront<VehicleViewWindow>((v->type == VEH_TRAIN) ? &_train_view_desc : &_vehicle_view_desc, v->index);
+}
+
+/**
+ * Dispatch a "vehicle selected" event if any window waits for it.
+ * @param v selected vehicle;
+ * @return did any window accept vehicle selection?
+ */
+bool VehicleClicked(const Vehicle *v)
+{
+	assert(v != NULL);
+	if (!(_thd.place_mode & HT_VEHICLE)) return false;
+
+	v = v->First();
+	if (!v->IsPrimaryVehicle()) return false;
+
+	return _thd.GetCallbackWnd()->OnVehicleSelect(v);
+}
+
+void StopGlobalFollowVehicle(const Vehicle *v)
+{
+	Window *w = FindWindowById(WC_MAIN_WINDOW, 0);
+	if (w != NULL && w->viewport->follow_vehicle == v->index) {
+		ScrollMainWindowTo(v->x_pos, v->y_pos, v->z_pos, true); // lock the main view on the vehicle's last position
+		w->viewport->follow_vehicle = INVALID_VEHICLE;
+	}
+}
+
+
+/**
+ * This is the Callback method after the construction attempt of a primary vehicle
+ * @param result indicates completion (or not) of the operation
+ * @param tile unused
+ * @param p1 unused
+ * @param p2 unused
+ */
+void CcBuildPrimaryVehicle(const CommandCost &result, TileIndex tile, uint32 p1, uint32 p2)
+{
+	if (result.Failed()) return;
+
+	const Vehicle *v = Vehicle::Get(_new_vehicle_id);
+	ShowVehicleViewWindow(v);
+}
+
+/**
+ * Get the width of a vehicle (including all parts of the consist) in pixels.
+ * @param v Vehicle to get the width for.
+ * @return Width of the vehicle.
+ */
+int GetVehicleWidth(Vehicle *v, EngineImageType image_type)
+{
+	int vehicle_width = 0;
+
+	switch (v->type) {
+		case VEH_TRAIN:
+			for (const Train *u = Train::From(v); u != NULL; u = u->Next()) {
+				vehicle_width += u->GetDisplayImageWidth();
+			}
+			break;
+
+		case VEH_ROAD:
+			for (const RoadVehicle *u = RoadVehicle::From(v); u != NULL; u = u->Next()) {
+				vehicle_width += u->GetDisplayImageWidth();
+			}
+			break;
+
+		default:
+			bool rtl = _current_text_dir == TD_RTL;
+			SpriteID sprite = v->GetImage(rtl ? DIR_E : DIR_W, image_type);
+			const Sprite *real_sprite = GetSprite(sprite, ST_NORMAL);
+			vehicle_width = UnScaleByZoom(real_sprite->width, ZOOM_LVL_GUI);
+
+			break;
+	}
+
+	return vehicle_width;
+}
diff --git a/src/vehicle_gui.cpp.rej b/src/vehicle_gui.cpp.rej
new file mode 100644
index 0000000..22db2af
--- /dev/null
+++ b/src/vehicle_gui.cpp.rej
@@ -0,0 +1,33 @@
+--- src/vehicle_gui.cpp	(revision 24056)
++++ src/vehicle_gui.cpp	(working copy)
+@@ -484,10 +485,11 @@
+ 		return NULL;
+ 	}
+ 
+-	RefitWindow(const WindowDesc *desc, const Vehicle *v, VehicleOrderID order, bool auto_refit) : Window()
++	RefitWindow(const WindowDesc *desc, const Vehicle *v, VehicleOrderID order, bool auto_refit, bool is_virtual) : Window()
+ 	{
+ 		this->sel = -1;
+ 		this->auto_refit = auto_refit;
++		this->is_virtual_train = is_virtual;
+ 		this->CreateNestedTree(desc);
+ 
+ 		this->vscroll = this->GetScrollbar(WID_VR_SCROLLBAR);
+@@ -830,14 +832,15 @@
+ 			}
+ 
+ 			case WID_VR_REFIT: // refit button
++
+ 				if (this->cargo != NULL) {
+ 					const Vehicle *v = Vehicle::Get(this->window_number);
+ 
+ 					if (this->order == INVALID_VEH_ORDER_ID) {
+ 						bool delete_window = this->selected_vehicle == v->index && this->num_vehicles == UINT8_MAX;
+-						if (DoCommandP(v->tile, this->selected_vehicle, this->cargo->cargo | this->cargo->subtype << 8 | this->num_vehicles << 16, GetCmdRefitVeh(v)) && delete_window) delete this;
++						if (DoCommandP(v->tile, this->selected_vehicle, this->cargo->cargo | this->cargo->subtype << 8 | this->num_vehicles << 16 | this->is_virtual_train << 5, GetCmdRefitVeh(v)) && delete_window) delete this;
+ 					} else {
+-						if (DoCommandP(v->tile, v->index, this->cargo->cargo | this->cargo->subtype << 8 | this->order << 16, CMD_ORDER_REFIT)) delete this;
++						if (DoCommandP(v->tile, v->index, this->cargo->cargo | this->cargo->subtype << 8 | this->order << 16 | this->is_virtual_train << 5, CMD_ORDER_REFIT)) delete this;
+ 					}
+ 				}
+ 				break;
diff --git a/src/vehicle_gui.h b/src/vehicle_gui.h
index 83e098d..523fe38 100644
--- a/src/vehicle_gui.h
+++ b/src/vehicle_gui.h
@@ -19,7 +19,7 @@
 #include "engine_type.h"
 #include "company_type.h"
 
-void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit = false);
+void ShowVehicleRefitWindow(const Vehicle *v, VehicleOrderID order, Window *parent, bool auto_refit = false, bool is_virtual_train = false);
 
 /** The tabs in the train details window */
 enum TrainDetailsWindowTabs {
diff --git a/src/vehicle_gui_base.h b/src/vehicle_gui_base.h
index e4f6ccc..f4115ec 100644
--- a/src/vehicle_gui_base.h
+++ b/src/vehicle_gui_base.h
@@ -27,6 +27,7 @@ struct BaseVehicleListWindow : public Window {
 	VehicleListIdentifier vli; ///< Identifier of the vehicle list we want to currently show.
 
 	enum ActionDropdownItem {
+		ADI_TEMPLATE_REPLACE,
 		ADI_REPLACE,
 		ADI_SERVICE,
 		ADI_DEPOT,
diff --git a/src/vehiclelist.cpp b/src/vehiclelist.cpp
index b15f055..e70b5c7 100644
--- a/src/vehiclelist.cpp
+++ b/src/vehiclelist.cpp
@@ -143,7 +143,7 @@ bool GenerateVehicleSortList(VehicleList *list, const VehicleListIdentifier &vli
 		case VL_GROUP_LIST:
 			if (vli.index != ALL_GROUP) {
 				FOR_ALL_VEHICLES(v) {
-					if (v->type == vli.vtype && v->IsPrimaryVehicle() &&
+					if (!HasBit(v->subtype, GVSF_VIRTUAL) && v->type == vli.vtype && v->IsPrimaryVehicle() &&	//MYGUI
 							v->owner == vli.company && v->group_id == vli.index) {
 						*list->Append() = v;
 					}
@@ -154,7 +154,7 @@ bool GenerateVehicleSortList(VehicleList *list, const VehicleListIdentifier &vli
 
 		case VL_STANDARD:
 			FOR_ALL_VEHICLES(v) {
-				if (v->type == vli.vtype && v->owner == vli.company && v->IsPrimaryVehicle()) {
+				if (!HasBit(v->subtype, GVSF_VIRTUAL) && v->type == vli.vtype && v->owner == vli.company && v->IsPrimaryVehicle()) { //MYGUI
 					*list->Append() = v;
 				}
 			}
diff --git a/src/vehiclelist.cpp.orig b/src/vehiclelist.cpp.orig
new file mode 100644
index 0000000..b15f055
--- /dev/null
+++ b/src/vehiclelist.cpp.orig
@@ -0,0 +1,183 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file vehiclelist.cpp Lists of vehicles. */
+
+#include "stdafx.h"
+#include "train.h"
+#include "vehiclelist.h"
+
+/**
+ * Pack a VehicleListIdentifier in a single uint32.
+ * @return The packed identifier.
+ */
+uint32 VehicleListIdentifier::Pack()
+{
+	byte c = this->company == OWNER_NONE ? 0xF : (byte)this->company;
+	assert(c             < (1 <<  4));
+	assert(this->type    < (1 <<  3));
+	assert(this->vtype   < (1 <<  2));
+	assert(this->index   < (1 << 20));
+
+	return c << 28 | this->type << 23 | this->vtype << 26 | this->index;
+}
+
+/**
+ * Unpack a VehicleListIdentifier from a single uint32.
+ * @param data The data to unpack.
+ * @return true iff the data was valid (enough).
+ */
+bool VehicleListIdentifier::Unpack(uint32 data)
+{
+	byte c        = GB(data, 28, 4);
+	this->company = c == 0xF ? OWNER_NONE : (CompanyID)c;
+	this->type    = (VehicleListType)GB(data, 23, 3);
+	this->vtype   = (VehicleType)GB(data, 26, 2);
+	this->index   = GB(data, 0, 20);
+
+	return this->type < VLT_END;
+}
+
+/**
+ * Decode a packed vehicle list identifier into a new one.
+ * @param data The data to unpack.
+ */
+VehicleListIdentifier::VehicleListIdentifier(uint32 data)
+{
+	bool ret = this->Unpack(data);
+	assert(ret);
+}
+
+/**
+ * Generate a list of vehicles inside a depot.
+ * @param type    Type of vehicle
+ * @param tile    The tile the depot is located on
+ * @param engines Pointer to list to add vehicles to
+ * @param wagons  Pointer to list to add wagons to (can be NULL)
+ * @param individual_wagons If true add every wagon to \a wagons which is not attached to an engine. If false only add the first wagon of every row.
+ */
+void BuildDepotVehicleList(VehicleType type, TileIndex tile, VehicleList *engines, VehicleList *wagons, bool individual_wagons)
+{
+	engines->Clear();
+	if (wagons != NULL && wagons != engines) wagons->Clear();
+
+	const Vehicle *v;
+	FOR_ALL_VEHICLES(v) {
+		/* General tests for all vehicle types */
+		if (v->type != type) continue;
+		if (v->tile != tile) continue;
+
+		switch (type) {
+			case VEH_TRAIN: {
+				const Train *t = Train::From(v);
+				if (t->IsArticulatedPart() || t->IsRearDualheaded()) continue;
+				if (t->track != TRACK_BIT_DEPOT) continue;
+				if (wagons != NULL && t->First()->IsFreeWagon()) {
+					if (individual_wagons || t->IsFreeWagon()) *wagons->Append() = t;
+					continue;
+				}
+				break;
+			}
+
+			default:
+				if (!v->IsInDepot()) continue;
+				break;
+		}
+
+		if (!v->IsPrimaryVehicle()) continue;
+
+		*engines->Append() = v;
+	}
+
+	/* Ensure the lists are not wasting too much space. If the lists are fresh
+	 * (i.e. built within a command) then this will actually do nothing. */
+	engines->Compact();
+	if (wagons != NULL && wagons != engines) wagons->Compact();
+}
+
+/**
+ * Generate a list of vehicles based on window type.
+ * @param list Pointer to list to add vehicles to
+ * @param vli  The identifier of this vehicle list.
+ * @return false if invalid list is requested
+ */
+bool GenerateVehicleSortList(VehicleList *list, const VehicleListIdentifier &vli)
+{
+	list->Clear();
+
+	const Vehicle *v;
+
+	switch (vli.type) {
+		case VL_STATION_LIST:
+			FOR_ALL_VEHICLES(v) {
+				if (v->type == vli.vtype && v->IsPrimaryVehicle()) {
+					const Order *order;
+
+					FOR_VEHICLE_ORDERS(v, order) {
+						if ((order->IsType(OT_GOTO_STATION) || order->IsType(OT_GOTO_WAYPOINT) || order->IsType(OT_IMPLICIT))
+								&& order->GetDestination() == vli.index) {
+							*list->Append() = v;
+							break;
+						}
+					}
+				}
+			}
+			break;
+
+		case VL_SHARED_ORDERS:
+			/* Add all vehicles from this vehicle's shared order list */
+			v = Vehicle::GetIfValid(vli.index);
+			if (v == NULL || v->type != vli.vtype || !v->IsPrimaryVehicle()) return false;
+
+			for (; v != NULL; v = v->NextShared()) {
+				*list->Append() = v;
+			}
+			break;
+
+		case VL_GROUP_LIST:
+			if (vli.index != ALL_GROUP) {
+				FOR_ALL_VEHICLES(v) {
+					if (v->type == vli.vtype && v->IsPrimaryVehicle() &&
+							v->owner == vli.company && v->group_id == vli.index) {
+						*list->Append() = v;
+					}
+				}
+				break;
+			}
+			/* FALL THROUGH */
+
+		case VL_STANDARD:
+			FOR_ALL_VEHICLES(v) {
+				if (v->type == vli.vtype && v->owner == vli.company && v->IsPrimaryVehicle()) {
+					*list->Append() = v;
+				}
+			}
+			break;
+
+		case VL_DEPOT_LIST:
+			FOR_ALL_VEHICLES(v) {
+				if (v->type == vli.vtype && v->IsPrimaryVehicle()) {
+					const Order *order;
+
+					FOR_VEHICLE_ORDERS(v, order) {
+						if (order->IsType(OT_GOTO_DEPOT) && !(order->GetDepotActionType() & ODATFB_NEAREST_DEPOT) && order->GetDestination() == vli.index) {
+							*list->Append() = v;
+							break;
+						}
+					}
+				}
+			}
+			break;
+
+		default: return false;
+	}
+
+	list->Compact();
+	return true;
+}
diff --git a/src/viewport.cpp b/src/viewport.cpp
index bfcc8d9..66b6856 100644
--- a/src/viewport.cpp
+++ b/src/viewport.cpp
@@ -1976,9 +1976,10 @@ bool HandleViewportClicked(const ViewPort *vp, int x, int y)
 		DEBUG(misc, 2, "Vehicle %d (index %d) at %p", v->unitnumber, v->index, v);
 		if (IsCompanyBuildableVehicleType(v)) {
 			v = v->First();
+			WindowClass wc = _thd.GetCallbackWnd()->window_class;
 			if (_ctrl_pressed && v->owner == _local_company) {
 				StartStopVehicle(v, true);
-			} else {
+			} else if ( wc != WC_CREATE_TEMPLATE && wc != WC_TEMPLATEGUI_MAIN) {
 				ShowVehicleViewWindow(v);
 			}
 		}
diff --git a/src/viewport.cpp.orig b/src/viewport.cpp.orig
new file mode 100644
index 0000000..bfcc8d9
--- /dev/null
+++ b/src/viewport.cpp.orig
@@ -0,0 +1,2968 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/**
+ * @file viewport.cpp Handling of all viewports.
+ *
+ * \verbatim
+ * The in-game coordinate system looks like this *
+ *                                               *
+ *                    ^ Z                        *
+ *                    |                          *
+ *                    |                          *
+ *                    |                          *
+ *                    |                          *
+ *                 /     \                       *
+ *              /           \                    *
+ *           /                 \                 *
+ *        /                       \              *
+ *   X <                             > Y         *
+ * \endverbatim
+ */
+
+#include "stdafx.h"
+#include "landscape.h"
+#include "viewport_func.h"
+#include "station_base.h"
+#include "waypoint_base.h"
+#include "town.h"
+#include "signs_base.h"
+#include "signs_func.h"
+#include "vehicle_base.h"
+#include "vehicle_gui.h"
+#include "blitter/factory.hpp"
+#include "strings_func.h"
+#include "zoom_func.h"
+#include "vehicle_func.h"
+#include "company_func.h"
+#include "waypoint_func.h"
+#include "window_func.h"
+#include "tilehighlight_func.h"
+#include "window_gui.h"
+
+#include "table/strings.h"
+#include "table/palettes.h"
+
+Point _tile_fract_coords;
+
+struct StringSpriteToDraw {
+	StringID string;
+	Colours colour;
+	int32 x;
+	int32 y;
+	uint64 params[2];
+	uint16 width;
+};
+
+struct TileSpriteToDraw {
+	SpriteID image;
+	PaletteID pal;
+	const SubSprite *sub;           ///< only draw a rectangular part of the sprite
+	int32 x;                        ///< screen X coordinate of sprite
+	int32 y;                        ///< screen Y coordinate of sprite
+};
+
+struct ChildScreenSpriteToDraw {
+	SpriteID image;
+	PaletteID pal;
+	const SubSprite *sub;           ///< only draw a rectangular part of the sprite
+	int32 x;
+	int32 y;
+	int next;                       ///< next child to draw (-1 at the end)
+};
+
+/** Parent sprite that should be drawn */
+struct ParentSpriteToDraw {
+	SpriteID image;                 ///< sprite to draw
+	PaletteID pal;                  ///< palette to use
+	const SubSprite *sub;           ///< only draw a rectangular part of the sprite
+
+	int32 x;                        ///< screen X coordinate of sprite
+	int32 y;                        ///< screen Y coordinate of sprite
+
+	int32 left;                     ///< minimal screen X coordinate of sprite (= x + sprite->x_offs), reference point for child sprites
+	int32 top;                      ///< minimal screen Y coordinate of sprite (= y + sprite->y_offs), reference point for child sprites
+
+	int32 xmin;                     ///< minimal world X coordinate of bounding box
+	int32 xmax;                     ///< maximal world X coordinate of bounding box
+	int32 ymin;                     ///< minimal world Y coordinate of bounding box
+	int32 ymax;                     ///< maximal world Y coordinate of bounding box
+	int zmin;                       ///< minimal world Z coordinate of bounding box
+	int zmax;                       ///< maximal world Z coordinate of bounding box
+
+	int first_child;                ///< the first child to draw.
+	bool comparison_done;           ///< Used during sprite sorting: true if sprite has been compared with all other sprites
+};
+
+/** Enumeration of multi-part foundations */
+enum FoundationPart {
+	FOUNDATION_PART_NONE     = 0xFF,  ///< Neither foundation nor groundsprite drawn yet.
+	FOUNDATION_PART_NORMAL   = 0,     ///< First part (normal foundation or no foundation)
+	FOUNDATION_PART_HALFTILE = 1,     ///< Second part (halftile foundation)
+	FOUNDATION_PART_END
+};
+
+/**
+ * Mode of "sprite combining"
+ * @see StartSpriteCombine
+ */
+enum SpriteCombineMode {
+	SPRITE_COMBINE_NONE,     ///< Every #AddSortableSpriteToDraw start its own bounding box
+	SPRITE_COMBINE_PENDING,  ///< %Sprite combining will start with the next unclipped sprite.
+	SPRITE_COMBINE_ACTIVE,   ///< %Sprite combining is active. #AddSortableSpriteToDraw outputs child sprites.
+};
+
+typedef SmallVector<TileSpriteToDraw, 64> TileSpriteToDrawVector;
+typedef SmallVector<StringSpriteToDraw, 4> StringSpriteToDrawVector;
+typedef SmallVector<ParentSpriteToDraw, 64> ParentSpriteToDrawVector;
+typedef SmallVector<ParentSpriteToDraw*, 64> ParentSpriteToSortVector;
+typedef SmallVector<ChildScreenSpriteToDraw, 16> ChildScreenSpriteToDrawVector;
+
+/** Data structure storing rendering information */
+struct ViewportDrawer {
+	DrawPixelInfo dpi;
+
+	StringSpriteToDrawVector string_sprites_to_draw;
+	TileSpriteToDrawVector tile_sprites_to_draw;
+	ParentSpriteToDrawVector parent_sprites_to_draw;
+	ParentSpriteToSortVector parent_sprites_to_sort; ///< Parent sprite pointer array used for sorting
+	ChildScreenSpriteToDrawVector child_screen_sprites_to_draw;
+
+	int *last_child;
+
+	SpriteCombineMode combine_sprites;               ///< Current mode of "sprite combining". @see StartSpriteCombine
+
+	int foundation[FOUNDATION_PART_END];             ///< Foundation sprites (index into parent_sprites_to_draw).
+	FoundationPart foundation_part;                  ///< Currently active foundation for ground sprite drawing.
+	int *last_foundation_child[FOUNDATION_PART_END]; ///< Tail of ChildSprite list of the foundations. (index into child_screen_sprites_to_draw)
+	Point foundation_offset[FOUNDATION_PART_END];    ///< Pixel offset for ground sprites on the foundations.
+};
+
+static void MarkViewportDirty(const ViewPort *vp, int left, int top, int right, int bottom);
+
+static ViewportDrawer _vd;
+
+TileHighlightData _thd;
+static TileInfo *_cur_ti;
+bool _draw_bounding_boxes = false;
+bool _draw_dirty_blocks = false;
+uint _dirty_block_colour = 0;
+
+static Point MapXYZToViewport(const ViewPort *vp, int x, int y, int z)
+{
+	Point p = RemapCoords(x, y, z);
+	p.x -= vp->virtual_width / 2;
+	p.y -= vp->virtual_height / 2;
+	return p;
+}
+
+void DeleteWindowViewport(Window *w)
+{
+	free(w->viewport);
+	w->viewport = NULL;
+}
+
+/**
+ * Initialize viewport of the window for use.
+ * @param w Window to use/display the viewport in
+ * @param x Offset of left edge of viewport with respect to left edge window \a w
+ * @param y Offset of top edge of viewport with respect to top edge window \a w
+ * @param width Width of the viewport
+ * @param height Height of the viewport
+ * @param follow_flags Flags controlling the viewport.
+ *        - If bit 31 is set, the lower 20 bits are the vehicle that the viewport should follow.
+ *        - If bit 31 is clear, it is a #TileIndex.
+ * @param zoom Zoomlevel to display
+ */
+void InitializeWindowViewport(Window *w, int x, int y,
+	int width, int height, uint32 follow_flags, ZoomLevel zoom)
+{
+	assert(w->viewport == NULL);
+
+	ViewportData *vp = CallocT<ViewportData>(1);
+
+	vp->left = x + w->left;
+	vp->top = y + w->top;
+	vp->width = width;
+	vp->height = height;
+
+	vp->zoom = static_cast<ZoomLevel>(Clamp(zoom, _settings_client.gui.zoom_min, _settings_client.gui.zoom_max));
+
+	vp->virtual_width = ScaleByZoom(width, zoom);
+	vp->virtual_height = ScaleByZoom(height, zoom);
+
+	Point pt;
+
+	if (follow_flags & 0x80000000) {
+		const Vehicle *veh;
+
+		vp->follow_vehicle = (VehicleID)(follow_flags & 0xFFFFF);
+		veh = Vehicle::Get(vp->follow_vehicle);
+		pt = MapXYZToViewport(vp, veh->x_pos, veh->y_pos, veh->z_pos);
+	} else {
+		uint x = TileX(follow_flags) * TILE_SIZE;
+		uint y = TileY(follow_flags) * TILE_SIZE;
+
+		vp->follow_vehicle = INVALID_VEHICLE;
+		pt = MapXYZToViewport(vp, x, y, GetSlopePixelZ(x, y));
+	}
+
+	vp->scrollpos_x = pt.x;
+	vp->scrollpos_y = pt.y;
+	vp->dest_scrollpos_x = pt.x;
+	vp->dest_scrollpos_y = pt.y;
+
+	w->viewport = vp;
+	vp->virtual_left = 0;//pt.x;
+	vp->virtual_top = 0;//pt.y;
+}
+
+static Point _vp_move_offs;
+
+static void DoSetViewportPosition(const Window *w, int left, int top, int width, int height)
+{
+	FOR_ALL_WINDOWS_FROM_BACK_FROM(w, w) {
+		if (left + width > w->left &&
+				w->left + w->width > left &&
+				top + height > w->top &&
+				w->top + w->height > top) {
+
+			if (left < w->left) {
+				DoSetViewportPosition(w, left, top, w->left - left, height);
+				DoSetViewportPosition(w, left + (w->left - left), top, width - (w->left - left), height);
+				return;
+			}
+
+			if (left + width > w->left + w->width) {
+				DoSetViewportPosition(w, left, top, (w->left + w->width - left), height);
+				DoSetViewportPosition(w, left + (w->left + w->width - left), top, width - (w->left + w->width - left), height);
+				return;
+			}
+
+			if (top < w->top) {
+				DoSetViewportPosition(w, left, top, width, (w->top - top));
+				DoSetViewportPosition(w, left, top + (w->top - top), width, height - (w->top - top));
+				return;
+			}
+
+			if (top + height > w->top + w->height) {
+				DoSetViewportPosition(w, left, top, width, (w->top + w->height - top));
+				DoSetViewportPosition(w, left, top + (w->top + w->height - top), width, height - (w->top + w->height - top));
+				return;
+			}
+
+			return;
+		}
+	}
+
+	{
+		int xo = _vp_move_offs.x;
+		int yo = _vp_move_offs.y;
+
+		if (abs(xo) >= width || abs(yo) >= height) {
+			/* fully_outside */
+			RedrawScreenRect(left, top, left + width, top + height);
+			return;
+		}
+
+		GfxScroll(left, top, width, height, xo, yo);
+
+		if (xo > 0) {
+			RedrawScreenRect(left, top, xo + left, top + height);
+			left += xo;
+			width -= xo;
+		} else if (xo < 0) {
+			RedrawScreenRect(left + width + xo, top, left + width, top + height);
+			width += xo;
+		}
+
+		if (yo > 0) {
+			RedrawScreenRect(left, top, width + left, top + yo);
+		} else if (yo < 0) {
+			RedrawScreenRect(left, top + height + yo, width + left, top + height);
+		}
+	}
+}
+
+static void SetViewportPosition(Window *w, int x, int y)
+{
+	ViewPort *vp = w->viewport;
+	int old_left = vp->virtual_left;
+	int old_top = vp->virtual_top;
+	int i;
+	int left, top, width, height;
+
+	vp->virtual_left = x;
+	vp->virtual_top = y;
+
+	/* Viewport is bound to its left top corner, so it must be rounded down (UnScaleByZoomLower)
+	 * else glitch described in FS#1412 will happen (offset by 1 pixel with zoom level > NORMAL)
+	 */
+	old_left = UnScaleByZoomLower(old_left, vp->zoom);
+	old_top = UnScaleByZoomLower(old_top, vp->zoom);
+	x = UnScaleByZoomLower(x, vp->zoom);
+	y = UnScaleByZoomLower(y, vp->zoom);
+
+	old_left -= x;
+	old_top -= y;
+
+	if (old_top == 0 && old_left == 0) return;
+
+	_vp_move_offs.x = old_left;
+	_vp_move_offs.y = old_top;
+
+	left = vp->left;
+	top = vp->top;
+	width = vp->width;
+	height = vp->height;
+
+	if (left < 0) {
+		width += left;
+		left = 0;
+	}
+
+	i = left + width - _screen.width;
+	if (i >= 0) width -= i;
+
+	if (width > 0) {
+		if (top < 0) {
+			height += top;
+			top = 0;
+		}
+
+		i = top + height - _screen.height;
+		if (i >= 0) height -= i;
+
+		if (height > 0) DoSetViewportPosition(w->z_front, left, top, width, height);
+	}
+}
+
+/**
+ * Is a xy position inside the viewport of the window?
+ * @param w Window to examine its viewport
+ * @param x X coordinate of the xy position
+ * @param y Y coordinate of the xy position
+ * @return Pointer to the viewport if the xy position is in the viewport of the window,
+ *         otherwise \c NULL is returned.
+ */
+ViewPort *IsPtInWindowViewport(const Window *w, int x, int y)
+{
+	ViewPort *vp = w->viewport;
+
+	if (vp != NULL &&
+			IsInsideMM(x, vp->left, vp->left + vp->width) &&
+			IsInsideMM(y, vp->top, vp->top + vp->height))
+		return vp;
+
+	return NULL;
+}
+
+/**
+ * Translate screen coordinate in a viewport to a tile coordinate
+ * @param vp  Viewport that contains the (\a x, \a y) screen coordinate
+ * @param x   Screen x coordinate
+ * @param y   Screen y coordinate
+ * @return Tile coordinate
+ */
+static Point TranslateXYToTileCoord(const ViewPort *vp, int x, int y)
+{
+	Point pt;
+	int a, b;
+	int z;
+
+	if ( (uint)(x -= vp->left) >= (uint)vp->width ||
+				(uint)(y -= vp->top) >= (uint)vp->height) {
+				Point pt = {-1, -1};
+				return pt;
+	}
+
+	x = (ScaleByZoom(x, vp->zoom) + vp->virtual_left) >> (2 + ZOOM_LVL_SHIFT);
+	y = (ScaleByZoom(y, vp->zoom) + vp->virtual_top) >> (1 + ZOOM_LVL_SHIFT);
+
+	a = y - x;
+	b = y + x;
+
+	/* we need to move variables in to the valid range, as the
+	 * GetTileZoomCenterWindow() function can call here with invalid x and/or y,
+	 * when the user tries to zoom out along the sides of the map */
+	a = Clamp(a, -4 * (int)TILE_SIZE, (int)(MapMaxX() * TILE_SIZE) - 1);
+	b = Clamp(b, -4 * (int)TILE_SIZE, (int)(MapMaxY() * TILE_SIZE) - 1);
+
+	/* (a, b) is the X/Y-world coordinate that belongs to (x,y) if the landscape would be completely flat on height 0.
+	 * Now find the Z-world coordinate by fix point iteration.
+	 * This is a bit tricky because the tile height is non-continuous at foundations.
+	 * The clicked point should be approached from the back, otherwise there are regions that are not clickable.
+	 * (FOUNDATION_HALFTILE_LOWER on SLOPE_STEEP_S hides north halftile completely)
+	 * So give it a z-malus of 4 in the first iterations.
+	 */
+	z = 0;
+
+	int min_coord = _settings_game.construction.freeform_edges ? TILE_SIZE : 0;
+
+	for (int i = 0; i < 5; i++) z = GetSlopePixelZ(Clamp(a + max(z, 4) - 4, min_coord, MapMaxX() * TILE_SIZE - 1), Clamp(b + max(z, 4) - 4, min_coord, MapMaxY() * TILE_SIZE - 1)) / 2;
+	for (int malus = 3; malus > 0; malus--) z = GetSlopePixelZ(Clamp(a + max(z, malus) - malus, min_coord, MapMaxX() * TILE_SIZE - 1), Clamp(b + max(z, malus) - malus, min_coord, MapMaxY() * TILE_SIZE - 1)) / 2;
+	for (int i = 0; i < 5; i++) z = GetSlopePixelZ(Clamp(a + z, min_coord, MapMaxX() * TILE_SIZE - 1), Clamp(b + z, min_coord, MapMaxY() * TILE_SIZE - 1)) / 2;
+
+	pt.x = Clamp(a + z, min_coord, MapMaxX() * TILE_SIZE - 1);
+	pt.y = Clamp(b + z, min_coord, MapMaxY() * TILE_SIZE - 1);
+
+	return pt;
+}
+
+/* When used for zooming, check area below current coordinates (x,y)
+ * and return the tile of the zoomed out/in position (zoom_x, zoom_y)
+ * when you just want the tile, make x = zoom_x and y = zoom_y */
+static Point GetTileFromScreenXY(int x, int y, int zoom_x, int zoom_y)
+{
+	Window *w;
+	ViewPort *vp;
+	Point pt;
+
+	if ( (w = FindWindowFromPt(x, y)) != NULL &&
+			 (vp = IsPtInWindowViewport(w, x, y)) != NULL)
+				return TranslateXYToTileCoord(vp, zoom_x, zoom_y);
+
+	pt.y = pt.x = -1;
+	return pt;
+}
+
+Point GetTileBelowCursor()
+{
+	return GetTileFromScreenXY(_cursor.pos.x, _cursor.pos.y, _cursor.pos.x, _cursor.pos.y);
+}
+
+
+Point GetTileZoomCenterWindow(bool in, Window * w)
+{
+	int x, y;
+	ViewPort *vp = w->viewport;
+
+	if (in) {
+		x = ((_cursor.pos.x - vp->left) >> 1) + (vp->width >> 2);
+		y = ((_cursor.pos.y - vp->top) >> 1) + (vp->height >> 2);
+	} else {
+		x = vp->width - (_cursor.pos.x - vp->left);
+		y = vp->height - (_cursor.pos.y - vp->top);
+	}
+	/* Get the tile below the cursor and center on the zoomed-out center */
+	return GetTileFromScreenXY(_cursor.pos.x, _cursor.pos.y, x + vp->left, y + vp->top);
+}
+
+/**
+ * Update the status of the zoom-buttons according to the zoom-level
+ * of the viewport. This will update their status and invalidate accordingly
+ * @param w Window pointer to the window that has the zoom buttons
+ * @param vp pointer to the viewport whose zoom-level the buttons represent
+ * @param widget_zoom_in widget index for window with zoom-in button
+ * @param widget_zoom_out widget index for window with zoom-out button
+ */
+void HandleZoomMessage(Window *w, const ViewPort *vp, byte widget_zoom_in, byte widget_zoom_out)
+{
+	w->SetWidgetDisabledState(widget_zoom_in, vp->zoom <= _settings_client.gui.zoom_min);
+	w->SetWidgetDirty(widget_zoom_in);
+
+	w->SetWidgetDisabledState(widget_zoom_out, vp->zoom >= _settings_client.gui.zoom_max);
+	w->SetWidgetDirty(widget_zoom_out);
+}
+
+/**
+ * Schedules a tile sprite for drawing.
+ *
+ * @param image the image to draw.
+ * @param pal the provided palette.
+ * @param x position x (world coordinates) of the sprite.
+ * @param y position y (world coordinates) of the sprite.
+ * @param z position z (world coordinates) of the sprite.
+ * @param sub Only draw a part of the sprite.
+ * @param extra_offs_x Pixel X offset for the sprite position.
+ * @param extra_offs_y Pixel Y offset for the sprite position.
+ */
+static void AddTileSpriteToDraw(SpriteID image, PaletteID pal, int32 x, int32 y, int z, const SubSprite *sub = NULL, int extra_offs_x = 0, int extra_offs_y = 0)
+{
+	assert((image & SPRITE_MASK) < MAX_SPRITES);
+
+	TileSpriteToDraw *ts = _vd.tile_sprites_to_draw.Append();
+	ts->image = image;
+	ts->pal = pal;
+	ts->sub = sub;
+	Point pt = RemapCoords(x, y, z);
+	ts->x = pt.x + extra_offs_x;
+	ts->y = pt.y + extra_offs_y;
+}
+
+/**
+ * Adds a child sprite to the active foundation.
+ *
+ * The pixel offset of the sprite relative to the ParentSprite is the sum of the offset passed to OffsetGroundSprite() and extra_offs_?.
+ *
+ * @param image the image to draw.
+ * @param pal the provided palette.
+ * @param sub Only draw a part of the sprite.
+ * @param foundation_part Foundation part.
+ * @param extra_offs_x Pixel X offset for the sprite position.
+ * @param extra_offs_y Pixel Y offset for the sprite position.
+ */
+static void AddChildSpriteToFoundation(SpriteID image, PaletteID pal, const SubSprite *sub, FoundationPart foundation_part, int extra_offs_x, int extra_offs_y)
+{
+	assert(IsInsideMM(foundation_part, 0, FOUNDATION_PART_END));
+	assert(_vd.foundation[foundation_part] != -1);
+	Point offs = _vd.foundation_offset[foundation_part];
+
+	/* Change the active ChildSprite list to the one of the foundation */
+	int *old_child = _vd.last_child;
+	_vd.last_child = _vd.last_foundation_child[foundation_part];
+
+	AddChildSpriteScreen(image, pal, offs.x + extra_offs_x, offs.y + extra_offs_y, false, sub, false);
+
+	/* Switch back to last ChildSprite list */
+	_vd.last_child = old_child;
+}
+
+/**
+ * Draws a ground sprite at a specific world-coordinate relative to the current tile.
+ * If the current tile is drawn on top of a foundation the sprite is added as child sprite to the "foundation"-ParentSprite.
+ *
+ * @param image the image to draw.
+ * @param pal the provided palette.
+ * @param x position x (world coordinates) of the sprite relative to current tile.
+ * @param y position y (world coordinates) of the sprite relative to current tile.
+ * @param z position z (world coordinates) of the sprite relative to current tile.
+ * @param sub Only draw a part of the sprite.
+ * @param extra_offs_x Pixel X offset for the sprite position.
+ * @param extra_offs_y Pixel Y offset for the sprite position.
+ */
+void DrawGroundSpriteAt(SpriteID image, PaletteID pal, int32 x, int32 y, int z, const SubSprite *sub, int extra_offs_x, int extra_offs_y)
+{
+	/* Switch to first foundation part, if no foundation was drawn */
+	if (_vd.foundation_part == FOUNDATION_PART_NONE) _vd.foundation_part = FOUNDATION_PART_NORMAL;
+
+	if (_vd.foundation[_vd.foundation_part] != -1) {
+		Point pt = RemapCoords(x, y, z);
+		AddChildSpriteToFoundation(image, pal, sub, _vd.foundation_part, pt.x + extra_offs_x * ZOOM_LVL_BASE, pt.y + extra_offs_y * ZOOM_LVL_BASE);
+	} else {
+		AddTileSpriteToDraw(image, pal, _cur_ti->x + x, _cur_ti->y + y, _cur_ti->z + z, sub, extra_offs_x * ZOOM_LVL_BASE, extra_offs_y * ZOOM_LVL_BASE);
+	}
+}
+
+/**
+ * Draws a ground sprite for the current tile.
+ * If the current tile is drawn on top of a foundation the sprite is added as child sprite to the "foundation"-ParentSprite.
+ *
+ * @param image the image to draw.
+ * @param pal the provided palette.
+ * @param sub Only draw a part of the sprite.
+ * @param extra_offs_x Pixel X offset for the sprite position.
+ * @param extra_offs_y Pixel Y offset for the sprite position.
+ */
+void DrawGroundSprite(SpriteID image, PaletteID pal, const SubSprite *sub, int extra_offs_x, int extra_offs_y)
+{
+	DrawGroundSpriteAt(image, pal, 0, 0, 0, sub, extra_offs_x, extra_offs_y);
+}
+
+/**
+ * Called when a foundation has been drawn for the current tile.
+ * Successive ground sprites for the current tile will be drawn as child sprites of the "foundation"-ParentSprite, not as TileSprites.
+ *
+ * @param x sprite x-offset (screen coordinates) of ground sprites relative to the "foundation"-ParentSprite.
+ * @param y sprite y-offset (screen coordinates) of ground sprites relative to the "foundation"-ParentSprite.
+ */
+void OffsetGroundSprite(int x, int y)
+{
+	/* Switch to next foundation part */
+	switch (_vd.foundation_part) {
+		case FOUNDATION_PART_NONE:
+			_vd.foundation_part = FOUNDATION_PART_NORMAL;
+			break;
+		case FOUNDATION_PART_NORMAL:
+			_vd.foundation_part = FOUNDATION_PART_HALFTILE;
+			break;
+		default: NOT_REACHED();
+	}
+
+	/* _vd.last_child == NULL if foundation sprite was clipped by the viewport bounds */
+	if (_vd.last_child != NULL) _vd.foundation[_vd.foundation_part] = _vd.parent_sprites_to_draw.Length() - 1;
+
+	_vd.foundation_offset[_vd.foundation_part].x = x * ZOOM_LVL_BASE;
+	_vd.foundation_offset[_vd.foundation_part].y = y * ZOOM_LVL_BASE;
+	_vd.last_foundation_child[_vd.foundation_part] = _vd.last_child;
+}
+
+/**
+ * Adds a child sprite to a parent sprite.
+ * In contrast to "AddChildSpriteScreen()" the sprite position is in world coordinates
+ *
+ * @param image the image to draw.
+ * @param pal the provided palette.
+ * @param x position x of the sprite.
+ * @param y position y of the sprite.
+ * @param z position z of the sprite.
+ * @param sub Only draw a part of the sprite.
+ */
+static void AddCombinedSprite(SpriteID image, PaletteID pal, int x, int y, int z, const SubSprite *sub)
+{
+	Point pt = RemapCoords(x, y, z);
+	const Sprite *spr = GetSprite(image & SPRITE_MASK, ST_NORMAL);
+
+	if (pt.x + spr->x_offs >= _vd.dpi.left + _vd.dpi.width ||
+			pt.x + spr->x_offs + spr->width <= _vd.dpi.left ||
+			pt.y + spr->y_offs >= _vd.dpi.top + _vd.dpi.height ||
+			pt.y + spr->y_offs + spr->height <= _vd.dpi.top)
+		return;
+
+	const ParentSpriteToDraw *pstd = _vd.parent_sprites_to_draw.End() - 1;
+	AddChildSpriteScreen(image, pal, pt.x - pstd->left, pt.y - pstd->top, false, sub, false);
+}
+
+/**
+ * Draw a (transparent) sprite at given coordinates with a given bounding box.
+ * The bounding box extends from (x + bb_offset_x, y + bb_offset_y, z + bb_offset_z) to (x + w - 1, y + h - 1, z + dz - 1), both corners included.
+ * Bounding boxes with bb_offset_x == w or bb_offset_y == h or bb_offset_z == dz are allowed and produce thin slices.
+ *
+ * @note Bounding boxes are normally specified with bb_offset_x = bb_offset_y = bb_offset_z = 0. The extent of the bounding box in negative direction is
+ *       defined by the sprite offset in the grf file.
+ *       However if modifying the sprite offsets is not suitable (e.g. when using existing graphics), the bounding box can be tuned by bb_offset.
+ *
+ * @pre w >= bb_offset_x, h >= bb_offset_y, dz >= bb_offset_z. Else w, h or dz are ignored.
+ *
+ * @param image the image to combine and draw,
+ * @param pal the provided palette,
+ * @param x position X (world) of the sprite,
+ * @param y position Y (world) of the sprite,
+ * @param w bounding box extent towards positive X (world),
+ * @param h bounding box extent towards positive Y (world),
+ * @param dz bounding box extent towards positive Z (world),
+ * @param z position Z (world) of the sprite,
+ * @param transparent if true, switch the palette between the provided palette and the transparent palette,
+ * @param bb_offset_x bounding box extent towards negative X (world),
+ * @param bb_offset_y bounding box extent towards negative Y (world),
+ * @param bb_offset_z bounding box extent towards negative Z (world)
+ * @param sub Only draw a part of the sprite.
+ */
+void AddSortableSpriteToDraw(SpriteID image, PaletteID pal, int x, int y, int w, int h, int dz, int z, bool transparent, int bb_offset_x, int bb_offset_y, int bb_offset_z, const SubSprite *sub)
+{
+	int32 left, right, top, bottom;
+
+	assert((image & SPRITE_MASK) < MAX_SPRITES);
+
+	/* make the sprites transparent with the right palette */
+	if (transparent) {
+		SetBit(image, PALETTE_MODIFIER_TRANSPARENT);
+		pal = PALETTE_TO_TRANSPARENT;
+	}
+
+	if (_vd.combine_sprites == SPRITE_COMBINE_ACTIVE) {
+		AddCombinedSprite(image, pal, x, y, z, sub);
+		return;
+	}
+
+	_vd.last_child = NULL;
+
+	Point pt = RemapCoords(x, y, z);
+	int tmp_left, tmp_top, tmp_x = pt.x, tmp_y = pt.y;
+
+	/* Compute screen extents of sprite */
+	if (image == SPR_EMPTY_BOUNDING_BOX) {
+		left = tmp_left = RemapCoords(x + w          , y + bb_offset_y, z + bb_offset_z).x;
+		right           = RemapCoords(x + bb_offset_x, y + h          , z + bb_offset_z).x + 1;
+		top  = tmp_top  = RemapCoords(x + bb_offset_x, y + bb_offset_y, z + dz         ).y;
+		bottom          = RemapCoords(x + w          , y + h          , z + bb_offset_z).y + 1;
+	} else {
+		const Sprite *spr = GetSprite(image & SPRITE_MASK, ST_NORMAL);
+		left = tmp_left = (pt.x += spr->x_offs);
+		right           = (pt.x +  spr->width );
+		top  = tmp_top  = (pt.y += spr->y_offs);
+		bottom          = (pt.y +  spr->height);
+	}
+
+	if (_draw_bounding_boxes && (image != SPR_EMPTY_BOUNDING_BOX)) {
+		/* Compute maximal extents of sprite and its bounding box */
+		left   = min(left  , RemapCoords(x + w          , y + bb_offset_y, z + bb_offset_z).x);
+		right  = max(right , RemapCoords(x + bb_offset_x, y + h          , z + bb_offset_z).x + 1);
+		top    = min(top   , RemapCoords(x + bb_offset_x, y + bb_offset_y, z + dz         ).y);
+		bottom = max(bottom, RemapCoords(x + w          , y + h          , z + bb_offset_z).y + 1);
+	}
+
+	/* Do not add the sprite to the viewport, if it is outside */
+	if (left   >= _vd.dpi.left + _vd.dpi.width ||
+	    right  <= _vd.dpi.left                 ||
+	    top    >= _vd.dpi.top + _vd.dpi.height ||
+	    bottom <= _vd.dpi.top) {
+		return;
+	}
+
+	ParentSpriteToDraw *ps = _vd.parent_sprites_to_draw.Append();
+	ps->x = tmp_x;
+	ps->y = tmp_y;
+
+	ps->left = tmp_left;
+	ps->top  = tmp_top;
+
+	ps->image = image;
+	ps->pal = pal;
+	ps->sub = sub;
+	ps->xmin = x + bb_offset_x;
+	ps->xmax = x + max(bb_offset_x, w) - 1;
+
+	ps->ymin = y + bb_offset_y;
+	ps->ymax = y + max(bb_offset_y, h) - 1;
+
+	ps->zmin = z + bb_offset_z;
+	ps->zmax = z + max(bb_offset_z, dz) - 1;
+
+	ps->comparison_done = false;
+	ps->first_child = -1;
+
+	_vd.last_child = &ps->first_child;
+
+	if (_vd.combine_sprites == SPRITE_COMBINE_PENDING) _vd.combine_sprites = SPRITE_COMBINE_ACTIVE;
+}
+
+/**
+ * Starts a block of sprites, which are "combined" into a single bounding box.
+ *
+ * Subsequent calls to #AddSortableSpriteToDraw will be drawn into the same bounding box.
+ * That is: The first sprite that is not clipped by the viewport defines the bounding box, and
+ * the following sprites will be child sprites to that one.
+ *
+ * That implies:
+ *  - The drawing order is definite. No other sprites will be sorted between those of the block.
+ *  - You have to provide a valid bounding box for all sprites,
+ *    as you won't know which one is the first non-clipped one.
+ *    Preferable you use the same bounding box for all.
+ *  - You cannot use #AddChildSpriteScreen inside the block, as its result will be indefinite.
+ *
+ * The block is terminated by #EndSpriteCombine.
+ *
+ * You cannot nest "combined" blocks.
+ */
+void StartSpriteCombine()
+{
+	assert(_vd.combine_sprites == SPRITE_COMBINE_NONE);
+	_vd.combine_sprites = SPRITE_COMBINE_PENDING;
+}
+
+/**
+ * Terminates a block of sprites started by #StartSpriteCombine.
+ * Take a look there for details.
+ */
+void EndSpriteCombine()
+{
+	assert(_vd.combine_sprites != SPRITE_COMBINE_NONE);
+	_vd.combine_sprites = SPRITE_COMBINE_NONE;
+}
+
+/**
+ * Check if the parameter "check" is inside the interval between
+ * begin and end, including both begin and end.
+ * @note Whether \c begin or \c end is the biggest does not matter.
+ *       This method will account for that.
+ * @param begin The begin of the interval.
+ * @param end   The end of the interval.
+ * @param check The value to check.
+ */
+static bool IsInRangeInclusive(int begin, int end, int check)
+{
+	if (begin > end) Swap(begin, end);
+	return begin <= check && check <= end;
+}
+
+/**
+ * Checks whether a point is inside the selected a diagonal rectangle given by _thd.size and _thd.pos
+ * @param x The x coordinate of the point to be checked.
+ * @param y The y coordinate of the point to be checked.
+ * @return True if the point is inside the rectangle, else false.
+ */
+bool IsInsideRotatedRectangle(int x, int y)
+{
+	int dist_a = (_thd.size.x + _thd.size.y);      // Rotated coordinate system for selected rectangle.
+	int dist_b = (_thd.size.x - _thd.size.y);      // We don't have to divide by 2. It's all relative!
+	int a = ((x - _thd.pos.x) + (y - _thd.pos.y)); // Rotated coordinate system for the point under scrutiny.
+	int b = ((x - _thd.pos.x) - (y - _thd.pos.y));
+
+	/* Check if a and b are between 0 and dist_a or dist_b respectively. */
+	return IsInRangeInclusive(dist_a, 0, a) && IsInRangeInclusive(dist_b, 0, b);
+}
+
+/**
+ * Add a child sprite to a parent sprite.
+ *
+ * @param image the image to draw.
+ * @param pal the provided palette.
+ * @param x sprite x-offset (screen coordinates) relative to parent sprite.
+ * @param y sprite y-offset (screen coordinates) relative to parent sprite.
+ * @param transparent if true, switch the palette between the provided palette and the transparent palette,
+ * @param sub Only draw a part of the sprite.
+ */
+void AddChildSpriteScreen(SpriteID image, PaletteID pal, int x, int y, bool transparent, const SubSprite *sub, bool scale)
+{
+	assert((image & SPRITE_MASK) < MAX_SPRITES);
+
+	/* If the ParentSprite was clipped by the viewport bounds, do not draw the ChildSprites either */
+	if (_vd.last_child == NULL) return;
+
+	/* make the sprites transparent with the right palette */
+	if (transparent) {
+		SetBit(image, PALETTE_MODIFIER_TRANSPARENT);
+		pal = PALETTE_TO_TRANSPARENT;
+	}
+
+	*_vd.last_child = _vd.child_screen_sprites_to_draw.Length();
+
+	ChildScreenSpriteToDraw *cs = _vd.child_screen_sprites_to_draw.Append();
+	cs->image = image;
+	cs->pal = pal;
+	cs->sub = sub;
+	cs->x = scale ? x * ZOOM_LVL_BASE : x;
+	cs->y = scale ? y * ZOOM_LVL_BASE : y;
+	cs->next = -1;
+
+	/* Append the sprite to the active ChildSprite list.
+	 * If the active ParentSprite is a foundation, update last_foundation_child as well.
+	 * Note: ChildSprites of foundations are NOT sequential in the vector, as selection sprites are added at last. */
+	if (_vd.last_foundation_child[0] == _vd.last_child) _vd.last_foundation_child[0] = &cs->next;
+	if (_vd.last_foundation_child[1] == _vd.last_child) _vd.last_foundation_child[1] = &cs->next;
+	_vd.last_child = &cs->next;
+}
+
+static void AddStringToDraw(int x, int y, StringID string, uint64 params_1, uint64 params_2, Colours colour, uint16 width)
+{
+	assert(width != 0);
+	StringSpriteToDraw *ss = _vd.string_sprites_to_draw.Append();
+	ss->string = string;
+	ss->x = x;
+	ss->y = y;
+	ss->params[0] = params_1;
+	ss->params[1] = params_2;
+	ss->width = width;
+	ss->colour = colour;
+}
+
+
+/**
+ * Draws sprites between ground sprite and everything above.
+ *
+ * The sprite is either drawn as TileSprite or as ChildSprite of the active foundation.
+ *
+ * @param image the image to draw.
+ * @param pal the provided palette.
+ * @param ti TileInfo Tile that is being drawn
+ * @param z_offset Z offset relative to the groundsprite. Only used for the sprite position, not for sprite sorting.
+ * @param foundation_part Foundation part the sprite belongs to.
+ */
+static void DrawSelectionSprite(SpriteID image, PaletteID pal, const TileInfo *ti, int z_offset, FoundationPart foundation_part)
+{
+	/* FIXME: This is not totally valid for some autorail highlights that extend over the edges of the tile. */
+	if (_vd.foundation[foundation_part] == -1) {
+		/* draw on real ground */
+		AddTileSpriteToDraw(image, pal, ti->x, ti->y, ti->z + z_offset);
+	} else {
+		/* draw on top of foundation */
+		AddChildSpriteToFoundation(image, pal, NULL, foundation_part, 0, -z_offset * ZOOM_LVL_BASE);
+	}
+}
+
+/**
+ * Draws a selection rectangle on a tile.
+ *
+ * @param ti TileInfo Tile that is being drawn
+ * @param pal Palette to apply.
+ */
+static void DrawTileSelectionRect(const TileInfo *ti, PaletteID pal)
+{
+	if (!IsValidTile(ti->tile)) return;
+
+	SpriteID sel;
+	if (IsHalftileSlope(ti->tileh)) {
+		Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
+		SpriteID sel2 = SPR_HALFTILE_SELECTION_FLAT + halftile_corner;
+		DrawSelectionSprite(sel2, pal, ti, 7 + TILE_HEIGHT, FOUNDATION_PART_HALFTILE);
+
+		Corner opposite_corner = OppositeCorner(halftile_corner);
+		if (IsSteepSlope(ti->tileh)) {
+			sel = SPR_HALFTILE_SELECTION_DOWN;
+		} else {
+			sel = ((ti->tileh & SlopeWithOneCornerRaised(opposite_corner)) != 0 ? SPR_HALFTILE_SELECTION_UP : SPR_HALFTILE_SELECTION_FLAT);
+		}
+		sel += opposite_corner;
+	} else {
+		sel = SPR_SELECT_TILE + SlopeToSpriteOffset(ti->tileh);
+	}
+	DrawSelectionSprite(sel, pal, ti, 7, FOUNDATION_PART_NORMAL);
+}
+
+static bool IsPartOfAutoLine(int px, int py)
+{
+	px -= _thd.selstart.x;
+	py -= _thd.selstart.y;
+
+	if ((_thd.drawstyle & HT_DRAG_MASK) != HT_LINE) return false;
+
+	switch (_thd.drawstyle & HT_DIR_MASK) {
+		case HT_DIR_X:  return py == 0; // x direction
+		case HT_DIR_Y:  return px == 0; // y direction
+		case HT_DIR_HU: return px == -py || px == -py - 16; // horizontal upper
+		case HT_DIR_HL: return px == -py || px == -py + 16; // horizontal lower
+		case HT_DIR_VL: return px == py || px == py + 16; // vertical left
+		case HT_DIR_VR: return px == py || px == py - 16; // vertical right
+		default:
+			NOT_REACHED();
+	}
+}
+
+/* [direction][side] */
+static const HighLightStyle _autorail_type[6][2] = {
+	{ HT_DIR_X,  HT_DIR_X },
+	{ HT_DIR_Y,  HT_DIR_Y },
+	{ HT_DIR_HU, HT_DIR_HL },
+	{ HT_DIR_HL, HT_DIR_HU },
+	{ HT_DIR_VL, HT_DIR_VR },
+	{ HT_DIR_VR, HT_DIR_VL }
+};
+
+#include "table/autorail.h"
+
+/**
+ * Draws autorail highlights.
+ *
+ * @param *ti TileInfo Tile that is being drawn
+ * @param autorail_type Offset into _AutorailTilehSprite[][]
+ */
+static void DrawAutorailSelection(const TileInfo *ti, uint autorail_type)
+{
+	SpriteID image;
+	PaletteID pal;
+	int offset;
+
+	FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
+	Slope autorail_tileh = RemoveHalftileSlope(ti->tileh);
+	if (IsHalftileSlope(ti->tileh)) {
+		static const uint _lower_rail[4] = { 5U, 2U, 4U, 3U };
+		Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
+		if (autorail_type != _lower_rail[halftile_corner]) {
+			foundation_part = FOUNDATION_PART_HALFTILE;
+			/* Here we draw the highlights of the "three-corners-raised"-slope. That looks ok to me. */
+			autorail_tileh = SlopeWithThreeCornersRaised(OppositeCorner(halftile_corner));
+		}
+	}
+
+	offset = _AutorailTilehSprite[autorail_tileh][autorail_type];
+	if (offset >= 0) {
+		image = SPR_AUTORAIL_BASE + offset;
+		pal = PAL_NONE;
+	} else {
+		image = SPR_AUTORAIL_BASE - offset;
+		pal = PALETTE_SEL_TILE_RED;
+	}
+
+	DrawSelectionSprite(image, _thd.make_square_red ? PALETTE_SEL_TILE_RED : pal, ti, 7, foundation_part);
+}
+
+/**
+ * Checks if the specified tile is selected and if so draws selection using correct selectionstyle.
+ * @param *ti TileInfo Tile that is being drawn
+ */
+static void DrawTileSelection(const TileInfo *ti)
+{
+	/* Draw a red error square? */
+	bool is_redsq = _thd.redsq == ti->tile;
+	if (is_redsq) DrawTileSelectionRect(ti, PALETTE_TILE_RED_PULSATING);
+
+	/* No tile selection active? */
+	if ((_thd.drawstyle & HT_DRAG_MASK) == HT_NONE) return;
+
+	if (_thd.diagonal) { // We're drawing a 45 degrees rotated (diagonal) rectangle
+		if (IsInsideRotatedRectangle((int)ti->x, (int)ti->y)) goto draw_inner;
+		return;
+	}
+
+	/* Inside the inner area? */
+	if (IsInsideBS(ti->x, _thd.pos.x, _thd.size.x) &&
+			IsInsideBS(ti->y, _thd.pos.y, _thd.size.y)) {
+draw_inner:
+		if (_thd.drawstyle & HT_RECT) {
+			if (!is_redsq) DrawTileSelectionRect(ti, _thd.make_square_red ? PALETTE_SEL_TILE_RED : PAL_NONE);
+		} else if (_thd.drawstyle & HT_POINT) {
+			/* Figure out the Z coordinate for the single dot. */
+			int z = 0;
+			FoundationPart foundation_part = FOUNDATION_PART_NORMAL;
+			if (ti->tileh & SLOPE_N) {
+				z += TILE_HEIGHT;
+				if (RemoveHalftileSlope(ti->tileh) == SLOPE_STEEP_N) z += TILE_HEIGHT;
+			}
+			if (IsHalftileSlope(ti->tileh)) {
+				Corner halftile_corner = GetHalftileSlopeCorner(ti->tileh);
+				if ((halftile_corner == CORNER_W) || (halftile_corner == CORNER_E)) z += TILE_HEIGHT;
+				if (halftile_corner != CORNER_S) {
+					foundation_part = FOUNDATION_PART_HALFTILE;
+					if (IsSteepSlope(ti->tileh)) z -= TILE_HEIGHT;
+				}
+			}
+			DrawSelectionSprite(_cur_dpi->zoom <= ZOOM_LVL_DETAIL ? SPR_DOT : SPR_DOT_SMALL, PAL_NONE, ti, z, foundation_part);
+		} else if (_thd.drawstyle & HT_RAIL) {
+			/* autorail highlight piece under cursor */
+			HighLightStyle type = _thd.drawstyle & HT_DIR_MASK;
+			assert(type < HT_DIR_END);
+			DrawAutorailSelection(ti, _autorail_type[type][0]);
+		} else if (IsPartOfAutoLine(ti->x, ti->y)) {
+			/* autorail highlighting long line */
+			HighLightStyle dir = _thd.drawstyle & HT_DIR_MASK;
+			uint side;
+
+			if (dir == HT_DIR_X || dir == HT_DIR_Y) {
+				side = 0;
+			} else {
+				TileIndex start = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
+				side = Delta(Delta(TileX(start), TileX(ti->tile)), Delta(TileY(start), TileY(ti->tile)));
+			}
+
+			DrawAutorailSelection(ti, _autorail_type[dir][side]);
+		}
+		return;
+	}
+
+	/* Check if it's inside the outer area? */
+	if (!is_redsq && _thd.outersize.x > 0 &&
+			IsInsideBS(ti->x, _thd.pos.x + _thd.offs.x, _thd.size.x + _thd.outersize.x) &&
+			IsInsideBS(ti->y, _thd.pos.y + _thd.offs.y, _thd.size.y + _thd.outersize.y)) {
+		/* Draw a blue rect. */
+		DrawTileSelectionRect(ti, PALETTE_SEL_TILE_BLUE);
+		return;
+	}
+}
+
+static void ViewportAddLandscape()
+{
+	int x, y, width, height;
+	TileInfo ti;
+	bool direction;
+
+	_cur_ti = &ti;
+
+	/* Transform into tile coordinates and round to closest full tile */
+	x = ((_vd.dpi.top >> (1 + ZOOM_LVL_SHIFT)) - (_vd.dpi.left >> (2 + ZOOM_LVL_SHIFT))) & ~TILE_UNIT_MASK;
+	y = ((_vd.dpi.top >> (1 + ZOOM_LVL_SHIFT)) + (_vd.dpi.left >> (2 + ZOOM_LVL_SHIFT)) - TILE_SIZE) & ~TILE_UNIT_MASK;
+
+	/* determine size of area */
+	{
+		Point pt = RemapCoords(x, y, 241);
+		width = (_vd.dpi.left + _vd.dpi.width - pt.x + 96 * ZOOM_LVL_BASE - 1) >> (6 + ZOOM_LVL_SHIFT);
+		height = (_vd.dpi.top + _vd.dpi.height - pt.y) >> (5 + ZOOM_LVL_SHIFT) << 1;
+	}
+
+	assert(width > 0);
+	assert(height > 0);
+
+	direction = false;
+
+	do {
+		int width_cur = width;
+		uint x_cur = x;
+		uint y_cur = y;
+
+		do {
+			TileType tt = MP_VOID;
+
+			ti.x = x_cur;
+			ti.y = y_cur;
+
+			ti.z = 0;
+
+			ti.tileh = SLOPE_FLAT;
+			ti.tile = INVALID_TILE;
+
+			if (x_cur < MapMaxX() * TILE_SIZE &&
+					y_cur < MapMaxY() * TILE_SIZE) {
+				TileIndex tile = TileVirtXY(x_cur, y_cur);
+
+				if (!_settings_game.construction.freeform_edges || (TileX(tile) != 0 && TileY(tile) != 0)) {
+					if (x_cur == ((int)MapMaxX() - 1) * TILE_SIZE || y_cur == ((int)MapMaxY() - 1) * TILE_SIZE) {
+						uint maxh = max<uint>(TileHeight(tile), 1);
+						for (uint h = 0; h < maxh; h++) {
+							AddTileSpriteToDraw(SPR_SHADOW_CELL, PAL_NONE, ti.x, ti.y, h * TILE_HEIGHT);
+						}
+					}
+
+					ti.tile = tile;
+					ti.tileh = GetTilePixelSlope(tile, &ti.z);
+					tt = GetTileType(tile);
+				}
+			}
+
+			_vd.foundation_part = FOUNDATION_PART_NONE;
+			_vd.foundation[0] = -1;
+			_vd.foundation[1] = -1;
+			_vd.last_foundation_child[0] = NULL;
+			_vd.last_foundation_child[1] = NULL;
+
+			_tile_type_procs[tt]->draw_tile_proc(&ti);
+
+			if ((x_cur == (int)MapMaxX() * TILE_SIZE && IsInsideMM(y_cur, 0, MapMaxY() * TILE_SIZE + 1)) ||
+					(y_cur == (int)MapMaxY() * TILE_SIZE && IsInsideMM(x_cur, 0, MapMaxX() * TILE_SIZE + 1))) {
+				TileIndex tile = TileVirtXY(x_cur, y_cur);
+				ti.tile = tile;
+				ti.tileh = GetTilePixelSlope(tile, &ti.z);
+				tt = GetTileType(tile);
+			}
+			if (ti.tile != INVALID_TILE) DrawTileSelection(&ti);
+
+			y_cur += 0x10;
+			x_cur -= 0x10;
+		} while (--width_cur);
+
+		if ((direction ^= 1) != 0) {
+			y += 0x10;
+		} else {
+			x += 0x10;
+		}
+	} while (--height);
+}
+
+/**
+ * Add a string to draw in the viewport
+ * @param dpi current viewport area
+ * @param small_from Zoomlevel from when the small font should be used
+ * @param sign sign position and dimension
+ * @param string_normal String for normal and 2x zoom level
+ * @param string_small String for 4x and 8x zoom level
+ * @param string_small_shadow Shadow string for 4x and 8x zoom level; or #STR_NULL if no shadow
+ * @param colour colour of the sign background; or INVALID_COLOUR if transparent
+ */
+void ViewportAddString(const DrawPixelInfo *dpi, ZoomLevel small_from, const ViewportSign *sign, StringID string_normal, StringID string_small, StringID string_small_shadow, uint64 params_1, uint64 params_2, Colours colour)
+{
+	bool small = dpi->zoom >= small_from;
+
+	int left   = dpi->left;
+	int top    = dpi->top;
+	int right  = left + dpi->width;
+	int bottom = top + dpi->height;
+
+	int sign_height     = ScaleByZoom(VPSM_TOP + FONT_HEIGHT_NORMAL + VPSM_BOTTOM, dpi->zoom);
+	int sign_half_width = ScaleByZoom((small ? sign->width_small : sign->width_normal) / 2, dpi->zoom);
+
+	if (bottom < sign->top ||
+			top   > sign->top + sign_height ||
+			right < sign->center - sign_half_width ||
+			left  > sign->center + sign_half_width) {
+		return;
+	}
+
+	if (!small) {
+		AddStringToDraw(sign->center - sign_half_width, sign->top, string_normal, params_1, params_2, colour, sign->width_normal);
+	} else {
+		int shadow_offset = 0;
+		if (string_small_shadow != STR_NULL) {
+			shadow_offset = 4;
+			AddStringToDraw(sign->center - sign_half_width + shadow_offset, sign->top, string_small_shadow, params_1, params_2, INVALID_COLOUR, sign->width_small);
+		}
+		AddStringToDraw(sign->center - sign_half_width, sign->top - shadow_offset, string_small, params_1, params_2,
+				colour, sign->width_small | 0x8000);
+	}
+}
+
+static void ViewportAddTownNames(DrawPixelInfo *dpi)
+{
+	if (!HasBit(_display_opt, DO_SHOW_TOWN_NAMES) || _game_mode == GM_MENU) return;
+
+	const Town *t;
+	FOR_ALL_TOWNS(t) {
+		ViewportAddString(dpi, ZOOM_LVL_OUT_16X, &t->cache.sign,
+				_settings_client.gui.population_in_label ? STR_VIEWPORT_TOWN_POP : STR_VIEWPORT_TOWN,
+				STR_VIEWPORT_TOWN_TINY_WHITE, STR_VIEWPORT_TOWN_TINY_BLACK,
+				t->index, t->cache.population);
+	}
+}
+
+
+static void ViewportAddStationNames(DrawPixelInfo *dpi)
+{
+	if (!(HasBit(_display_opt, DO_SHOW_STATION_NAMES) || HasBit(_display_opt, DO_SHOW_WAYPOINT_NAMES)) || _game_mode == GM_MENU) return;
+
+	const BaseStation *st;
+	FOR_ALL_BASE_STATIONS(st) {
+		/* Check whether the base station is a station or a waypoint */
+		bool is_station = Station::IsExpected(st);
+
+		/* Don't draw if the display options are disabled */
+		if (!HasBit(_display_opt, is_station ? DO_SHOW_STATION_NAMES : DO_SHOW_WAYPOINT_NAMES)) continue;
+
+		/* Don't draw if station is owned by another company and competitor station names are hidden. Stations owned by none are never ignored. */
+		if (!HasBit(_display_opt, DO_SHOW_COMPETITOR_SIGNS) && _local_company != st->owner && st->owner != OWNER_NONE) continue;
+
+		ViewportAddString(dpi, ZOOM_LVL_OUT_16X, &st->sign,
+				is_station ? STR_VIEWPORT_STATION : STR_VIEWPORT_WAYPOINT,
+				(is_station ? STR_VIEWPORT_STATION : STR_VIEWPORT_WAYPOINT) + 1, STR_NULL,
+				st->index, st->facilities, (st->owner == OWNER_NONE || !st->IsInUse()) ? COLOUR_GREY : _company_colours[st->owner]);
+	}
+}
+
+
+static void ViewportAddSigns(DrawPixelInfo *dpi)
+{
+	/* Signs are turned off or are invisible */
+	if (!HasBit(_display_opt, DO_SHOW_SIGNS) || IsInvisibilitySet(TO_SIGNS)) return;
+
+	const Sign *si;
+	FOR_ALL_SIGNS(si) {
+		/* Don't draw if sign is owned by another company and competitor signs should be hidden.
+		 * Note: It is intentional that also signs owned by OWNER_NONE are hidden. Bankrupt
+		 * companies can leave OWNER_NONE signs after them. */
+		if (!HasBit(_display_opt, DO_SHOW_COMPETITOR_SIGNS) && _local_company != si->owner && si->owner != OWNER_DEITY) continue;
+
+		ViewportAddString(dpi, ZOOM_LVL_OUT_16X, &si->sign,
+				STR_WHITE_SIGN,
+				(IsTransparencySet(TO_SIGNS) || si->owner == OWNER_DEITY) ? STR_VIEWPORT_SIGN_SMALL_WHITE : STR_VIEWPORT_SIGN_SMALL_BLACK, STR_NULL,
+				si->index, 0, (si->owner == OWNER_NONE) ? COLOUR_GREY : (si->owner == OWNER_DEITY ? INVALID_COLOUR : _company_colours[si->owner]));
+	}
+}
+
+/**
+ * Update the position of the viewport sign.
+ * @param center the (preferred) center of the viewport sign
+ * @param top    the new top of the sign
+ * @param str    the string to show in the sign
+ */
+void ViewportSign::UpdatePosition(int center, int top, StringID str)
+{
+	if (this->width_normal != 0) this->MarkDirty();
+
+	this->top = top;
+
+	char buffer[DRAW_STRING_BUFFER];
+
+	GetString(buffer, str, lastof(buffer));
+	this->width_normal = VPSM_LEFT + Align(GetStringBoundingBox(buffer).width, 2) + VPSM_RIGHT;
+	this->center = center;
+
+	/* zoomed out version */
+	this->width_small = VPSM_LEFT + Align(GetStringBoundingBox(buffer, FS_SMALL).width, 2) + VPSM_RIGHT;
+
+	this->MarkDirty();
+}
+
+/**
+ * Mark the sign dirty in all viewports.
+ * @param maxzoom Maximum %ZoomLevel at which the text is visible.
+ *
+ * @ingroup dirty
+ */
+void ViewportSign::MarkDirty(ZoomLevel maxzoom) const
+{
+	Rect zoomlevels[ZOOM_LVL_COUNT];
+
+	for (ZoomLevel zoom = ZOOM_LVL_BEGIN; zoom != ZOOM_LVL_END; zoom++) {
+		/* FIXME: This doesn't switch to width_small when appropriate. */
+		zoomlevels[zoom].left   = this->center - ScaleByZoom(this->width_normal / 2 + 1, zoom);
+		zoomlevels[zoom].top    = this->top    - ScaleByZoom(1, zoom);
+		zoomlevels[zoom].right  = this->center + ScaleByZoom(this->width_normal / 2 + 1, zoom);
+		zoomlevels[zoom].bottom = this->top    + ScaleByZoom(VPSM_TOP + FONT_HEIGHT_NORMAL + VPSM_BOTTOM + 1, zoom);
+	}
+
+	Window *w;
+	FOR_ALL_WINDOWS_FROM_BACK(w) {
+		ViewPort *vp = w->viewport;
+		if (vp != NULL && vp->zoom <= maxzoom) {
+			assert(vp->width != 0);
+			Rect &zl = zoomlevels[vp->zoom];
+			MarkViewportDirty(vp, zl.left, zl.top, zl.right, zl.bottom);
+		}
+	}
+}
+
+static void ViewportDrawTileSprites(const TileSpriteToDrawVector *tstdv)
+{
+	const TileSpriteToDraw *tsend = tstdv->End();
+	for (const TileSpriteToDraw *ts = tstdv->Begin(); ts != tsend; ++ts) {
+		DrawSpriteViewport(ts->image, ts->pal, ts->x, ts->y, ts->sub);
+	}
+}
+
+/** Sort parent sprites pointer array */
+static void ViewportSortParentSprites(ParentSpriteToSortVector *psdv)
+{
+	ParentSpriteToDraw **psdvend = psdv->End();
+	ParentSpriteToDraw **psd = psdv->Begin();
+	while (psd != psdvend) {
+		ParentSpriteToDraw *ps = *psd;
+
+		if (ps->comparison_done) {
+			psd++;
+			continue;
+		}
+
+		ps->comparison_done = true;
+
+		for (ParentSpriteToDraw **psd2 = psd + 1; psd2 != psdvend; psd2++) {
+			ParentSpriteToDraw *ps2 = *psd2;
+
+			if (ps2->comparison_done) continue;
+
+			/* Decide which comparator to use, based on whether the bounding
+			 * boxes overlap
+			 */
+			if (ps->xmax >= ps2->xmin && ps->xmin <= ps2->xmax && // overlap in X?
+					ps->ymax >= ps2->ymin && ps->ymin <= ps2->ymax && // overlap in Y?
+					ps->zmax >= ps2->zmin && ps->zmin <= ps2->zmax) { // overlap in Z?
+				/* Use X+Y+Z as the sorting order, so sprites closer to the bottom of
+				 * the screen and with higher Z elevation, are drawn in front.
+				 * Here X,Y,Z are the coordinates of the "center of mass" of the sprite,
+				 * i.e. X=(left+right)/2, etc.
+				 * However, since we only care about order, don't actually divide / 2
+				 */
+				if (ps->xmin + ps->xmax + ps->ymin + ps->ymax + ps->zmin + ps->zmax <=
+						ps2->xmin + ps2->xmax + ps2->ymin + ps2->ymax + ps2->zmin + ps2->zmax) {
+					continue;
+				}
+			} else {
+				/* We only change the order, if it is definite.
+				 * I.e. every single order of X, Y, Z says ps2 is behind ps or they overlap.
+				 * That is: If one partial order says ps behind ps2, do not change the order.
+				 */
+				if (ps->xmax < ps2->xmin ||
+						ps->ymax < ps2->ymin ||
+						ps->zmax < ps2->zmin) {
+					continue;
+				}
+			}
+
+			/* Move ps2 in front of ps */
+			ParentSpriteToDraw *temp = ps2;
+			for (ParentSpriteToDraw **psd3 = psd2; psd3 > psd; psd3--) {
+				*psd3 = *(psd3 - 1);
+			}
+			*psd = temp;
+		}
+	}
+}
+
+static void ViewportDrawParentSprites(const ParentSpriteToSortVector *psd, const ChildScreenSpriteToDrawVector *csstdv)
+{
+	const ParentSpriteToDraw * const *psd_end = psd->End();
+	for (const ParentSpriteToDraw * const *it = psd->Begin(); it != psd_end; it++) {
+		const ParentSpriteToDraw *ps = *it;
+		if (ps->image != SPR_EMPTY_BOUNDING_BOX) DrawSpriteViewport(ps->image, ps->pal, ps->x, ps->y, ps->sub);
+
+		int child_idx = ps->first_child;
+		while (child_idx >= 0) {
+			const ChildScreenSpriteToDraw *cs = csstdv->Get(child_idx);
+			child_idx = cs->next;
+			DrawSpriteViewport(cs->image, cs->pal, ps->left + cs->x, ps->top + cs->y, cs->sub);
+		}
+	}
+}
+
+/**
+ * Draws the bounding boxes of all ParentSprites
+ * @param psd Array of ParentSprites
+ */
+static void ViewportDrawBoundingBoxes(const ParentSpriteToSortVector *psd)
+{
+	const ParentSpriteToDraw * const *psd_end = psd->End();
+	for (const ParentSpriteToDraw * const *it = psd->Begin(); it != psd_end; it++) {
+		const ParentSpriteToDraw *ps = *it;
+		Point pt1 = RemapCoords(ps->xmax + 1, ps->ymax + 1, ps->zmax + 1); // top front corner
+		Point pt2 = RemapCoords(ps->xmin    , ps->ymax + 1, ps->zmax + 1); // top left corner
+		Point pt3 = RemapCoords(ps->xmax + 1, ps->ymin    , ps->zmax + 1); // top right corner
+		Point pt4 = RemapCoords(ps->xmax + 1, ps->ymax + 1, ps->zmin    ); // bottom front corner
+
+		DrawBox(        pt1.x,         pt1.y,
+		        pt2.x - pt1.x, pt2.y - pt1.y,
+		        pt3.x - pt1.x, pt3.y - pt1.y,
+		        pt4.x - pt1.x, pt4.y - pt1.y);
+	}
+}
+
+/**
+ * Draw/colour the blocks that have been redrawn.
+ */
+static void ViewportDrawDirtyBlocks()
+{
+	Blitter *blitter = BlitterFactoryBase::GetCurrentBlitter();
+	const DrawPixelInfo *dpi = _cur_dpi;
+	void *dst;
+	int right =  UnScaleByZoom(dpi->width,  dpi->zoom);
+	int bottom = UnScaleByZoom(dpi->height, dpi->zoom);
+
+	int colour = _string_colourmap[_dirty_block_colour & 0xF];
+
+	dst = dpi->dst_ptr;
+
+	byte bo = UnScaleByZoom(dpi->left + dpi->top, dpi->zoom) & 1;
+	do {
+		for (int i = (bo ^= 1); i < right; i += 2) blitter->SetPixel(dst, i, 0, (uint8)colour);
+		dst = blitter->MoveTo(dst, 0, 1);
+	} while (--bottom > 0);
+}
+
+static void ViewportDrawStrings(DrawPixelInfo *dpi, const StringSpriteToDrawVector *sstdv)
+{
+	DrawPixelInfo dp;
+	ZoomLevel zoom;
+
+	_cur_dpi = &dp;
+	dp = *dpi;
+
+	zoom = dp.zoom;
+	dp.zoom = ZOOM_LVL_NORMAL;
+
+	dp.left   = UnScaleByZoom(dp.left,   zoom);
+	dp.top    = UnScaleByZoom(dp.top,    zoom);
+	dp.width  = UnScaleByZoom(dp.width,  zoom);
+	dp.height = UnScaleByZoom(dp.height, zoom);
+
+	const StringSpriteToDraw *ssend = sstdv->End();
+	for (const StringSpriteToDraw *ss = sstdv->Begin(); ss != ssend; ++ss) {
+		TextColour colour = TC_BLACK;
+		bool small = HasBit(ss->width, 15);
+		int w = GB(ss->width, 0, 15);
+		int x = UnScaleByZoom(ss->x, zoom);
+		int y = UnScaleByZoom(ss->y, zoom);
+		int h = VPSM_TOP + (small ? FONT_HEIGHT_SMALL : FONT_HEIGHT_NORMAL) + VPSM_BOTTOM;
+
+		SetDParam(0, ss->params[0]);
+		SetDParam(1, ss->params[1]);
+
+		if (ss->colour != INVALID_COLOUR) {
+			/* Do not draw signs nor station names if they are set invisible */
+			if (IsInvisibilitySet(TO_SIGNS) && ss->string != STR_WHITE_SIGN) continue;
+
+			/* if we didn't draw a rectangle, or if transperant building is on,
+			 * draw the text in the colour the rectangle would have */
+			if (IsTransparencySet(TO_SIGNS) && ss->string != STR_WHITE_SIGN) {
+				/* Real colours need the TC_IS_PALETTE_COLOUR flag
+				 * otherwise colours from _string_colourmap are assumed. */
+				colour = (TextColour)_colour_gradient[ss->colour][6] | TC_IS_PALETTE_COLOUR;
+			}
+
+			/* Draw the rectangle if 'transparent station signs' is off,
+			 * or if we are drawing a general text sign (STR_WHITE_SIGN) */
+			if (!IsTransparencySet(TO_SIGNS) || ss->string == STR_WHITE_SIGN) {
+				DrawFrameRect(
+					x, y, x + w, y + h, ss->colour,
+					IsTransparencySet(TO_SIGNS) ? FR_TRANSPARENT : FR_NONE
+				);
+			}
+		}
+
+		DrawString(x + VPSM_LEFT, x + w - 1 - VPSM_RIGHT, y + VPSM_TOP, ss->string, colour, SA_HOR_CENTER);
+	}
+}
+
+void ViewportDoDraw(const ViewPort *vp, int left, int top, int right, int bottom)
+{
+	DrawPixelInfo *old_dpi = _cur_dpi;
+	_cur_dpi = &_vd.dpi;
+
+	_vd.dpi.zoom = vp->zoom;
+	int mask = ScaleByZoom(-1, vp->zoom);
+
+	_vd.combine_sprites = SPRITE_COMBINE_NONE;
+
+	_vd.dpi.width = (right - left) & mask;
+	_vd.dpi.height = (bottom - top) & mask;
+	_vd.dpi.left = left & mask;
+	_vd.dpi.top = top & mask;
+	_vd.dpi.pitch = old_dpi->pitch;
+	_vd.last_child = NULL;
+
+	int x = UnScaleByZoom(_vd.dpi.left - (vp->virtual_left & mask), vp->zoom) + vp->left;
+	int y = UnScaleByZoom(_vd.dpi.top - (vp->virtual_top & mask), vp->zoom) + vp->top;
+
+	_vd.dpi.dst_ptr = BlitterFactoryBase::GetCurrentBlitter()->MoveTo(old_dpi->dst_ptr, x - old_dpi->left, y - old_dpi->top);
+
+	ViewportAddLandscape();
+	ViewportAddVehicles(&_vd.dpi);
+
+	ViewportAddTownNames(&_vd.dpi);
+	ViewportAddStationNames(&_vd.dpi);
+	ViewportAddSigns(&_vd.dpi);
+
+	DrawTextEffects(&_vd.dpi);
+
+	if (_vd.tile_sprites_to_draw.Length() != 0) ViewportDrawTileSprites(&_vd.tile_sprites_to_draw);
+
+	ParentSpriteToDraw *psd_end = _vd.parent_sprites_to_draw.End();
+	for (ParentSpriteToDraw *it = _vd.parent_sprites_to_draw.Begin(); it != psd_end; it++) {
+		*_vd.parent_sprites_to_sort.Append() = it;
+	}
+
+	ViewportSortParentSprites(&_vd.parent_sprites_to_sort);
+	ViewportDrawParentSprites(&_vd.parent_sprites_to_sort, &_vd.child_screen_sprites_to_draw);
+
+	if (_draw_bounding_boxes) ViewportDrawBoundingBoxes(&_vd.parent_sprites_to_sort);
+	if (_draw_dirty_blocks) ViewportDrawDirtyBlocks();
+
+	if (_vd.string_sprites_to_draw.Length() != 0) ViewportDrawStrings(&_vd.dpi, &_vd.string_sprites_to_draw);
+
+	_cur_dpi = old_dpi;
+
+	_vd.string_sprites_to_draw.Clear();
+	_vd.tile_sprites_to_draw.Clear();
+	_vd.parent_sprites_to_draw.Clear();
+	_vd.parent_sprites_to_sort.Clear();
+	_vd.child_screen_sprites_to_draw.Clear();
+}
+
+/**
+ * Make sure we don't draw a too big area at a time.
+ * If we do, the sprite memory will overflow.
+ */
+static void ViewportDrawChk(const ViewPort *vp, int left, int top, int right, int bottom)
+{
+	if (ScaleByZoom(bottom - top, vp->zoom) * ScaleByZoom(right - left, vp->zoom) > 180000 * ZOOM_LVL_BASE * ZOOM_LVL_BASE) {
+		if ((bottom - top) > (right - left)) {
+			int t = (top + bottom) >> 1;
+			ViewportDrawChk(vp, left, top, right, t);
+			ViewportDrawChk(vp, left, t, right, bottom);
+		} else {
+			int t = (left + right) >> 1;
+			ViewportDrawChk(vp, left, top, t, bottom);
+			ViewportDrawChk(vp, t, top, right, bottom);
+		}
+	} else {
+		ViewportDoDraw(vp,
+			ScaleByZoom(left - vp->left, vp->zoom) + vp->virtual_left,
+			ScaleByZoom(top - vp->top, vp->zoom) + vp->virtual_top,
+			ScaleByZoom(right - vp->left, vp->zoom) + vp->virtual_left,
+			ScaleByZoom(bottom - vp->top, vp->zoom) + vp->virtual_top
+		);
+	}
+}
+
+static inline void ViewportDraw(const ViewPort *vp, int left, int top, int right, int bottom)
+{
+	if (right <= vp->left || bottom <= vp->top) return;
+
+	if (left >= vp->left + vp->width) return;
+
+	if (left < vp->left) left = vp->left;
+	if (right > vp->left + vp->width) right = vp->left + vp->width;
+
+	if (top >= vp->top + vp->height) return;
+
+	if (top < vp->top) top = vp->top;
+	if (bottom > vp->top + vp->height) bottom = vp->top + vp->height;
+
+	ViewportDrawChk(vp, left, top, right, bottom);
+}
+
+/**
+ * Draw the viewport of this window.
+ */
+void Window::DrawViewport() const
+{
+	DrawPixelInfo *dpi = _cur_dpi;
+
+	dpi->left += this->left;
+	dpi->top += this->top;
+
+	ViewportDraw(this->viewport, dpi->left, dpi->top, dpi->left + dpi->width, dpi->top + dpi->height);
+
+	dpi->left -= this->left;
+	dpi->top -= this->top;
+}
+
+static inline void ClampViewportToMap(const ViewPort *vp, int &x, int &y)
+{
+	/* Centre of the viewport is hot spot */
+	x += vp->virtual_width / 2;
+	y += vp->virtual_height / 2;
+
+	/* Convert viewport coordinates to map coordinates
+	 * Calculation is scaled by 4 to avoid rounding errors */
+	int vx = -x + y * 2;
+	int vy =  x + y * 2;
+
+	/* clamp to size of map */
+	vx = Clamp(vx, 0, MapMaxX() * TILE_SIZE * 4 * ZOOM_LVL_BASE);
+	vy = Clamp(vy, 0, MapMaxY() * TILE_SIZE * 4 * ZOOM_LVL_BASE);
+
+	/* Convert map coordinates to viewport coordinates */
+	x = (-vx + vy) / 2;
+	y = ( vx + vy) / 4;
+
+	/* Remove centering */
+	x -= vp->virtual_width / 2;
+	y -= vp->virtual_height / 2;
+}
+
+/**
+ * Update the viewport position being displayed.
+ * @param w %Window owning the viewport.
+ */
+void UpdateViewportPosition(Window *w)
+{
+	const ViewPort *vp = w->viewport;
+
+	if (w->viewport->follow_vehicle != INVALID_VEHICLE) {
+		const Vehicle *veh = Vehicle::Get(w->viewport->follow_vehicle);
+		Point pt = MapXYZToViewport(vp, veh->x_pos, veh->y_pos, veh->z_pos);
+
+		w->viewport->scrollpos_x = pt.x;
+		w->viewport->scrollpos_y = pt.y;
+		SetViewportPosition(w, pt.x, pt.y);
+	} else {
+		/* Ensure the destination location is within the map */
+		ClampViewportToMap(vp, w->viewport->dest_scrollpos_x, w->viewport->dest_scrollpos_y);
+
+		int delta_x = w->viewport->dest_scrollpos_x - w->viewport->scrollpos_x;
+		int delta_y = w->viewport->dest_scrollpos_y - w->viewport->scrollpos_y;
+
+		if (delta_x != 0 || delta_y != 0) {
+			if (_settings_client.gui.smooth_scroll) {
+				int max_scroll = ScaleByMapSize1D(512 * ZOOM_LVL_BASE);
+				/* Not at our desired position yet... */
+				w->viewport->scrollpos_x += Clamp(delta_x / 4, -max_scroll, max_scroll);
+				w->viewport->scrollpos_y += Clamp(delta_y / 4, -max_scroll, max_scroll);
+			} else {
+				w->viewport->scrollpos_x = w->viewport->dest_scrollpos_x;
+				w->viewport->scrollpos_y = w->viewport->dest_scrollpos_y;
+			}
+		}
+
+		ClampViewportToMap(vp, w->viewport->scrollpos_x, w->viewport->scrollpos_y);
+
+		SetViewportPosition(w, w->viewport->scrollpos_x, w->viewport->scrollpos_y);
+	}
+}
+
+/**
+ * Marks a viewport as dirty for repaint if it displays (a part of) the area the needs to be repainted.
+ * @param vp     The viewport to mark as dirty
+ * @param left   Left edge of area to repaint
+ * @param top    Top edge of area to repaint
+ * @param right  Right edge of area to repaint
+ * @param bottom Bottom edge of area to repaint
+ * @ingroup dirty
+ */
+static void MarkViewportDirty(const ViewPort *vp, int left, int top, int right, int bottom)
+{
+	right -= vp->virtual_left;
+	if (right <= 0) return;
+
+	bottom -= vp->virtual_top;
+	if (bottom <= 0) return;
+
+	left = max(0, left - vp->virtual_left);
+
+	if (left >= vp->virtual_width) return;
+
+	top = max(0, top - vp->virtual_top);
+
+	if (top >= vp->virtual_height) return;
+
+	SetDirtyBlocks(
+		UnScaleByZoomLower(left, vp->zoom) + vp->left,
+		UnScaleByZoomLower(top, vp->zoom) + vp->top,
+		UnScaleByZoom(right, vp->zoom) + vp->left + 1,
+		UnScaleByZoom(bottom, vp->zoom) + vp->top + 1
+	);
+}
+
+/**
+ * Mark all viewports that display an area as dirty (in need of repaint).
+ * @param left   Left edge of area to repaint
+ * @param top    Top edge of area to repaint
+ * @param right  Right edge of area to repaint
+ * @param bottom Bottom edge of area to repaint
+ * @ingroup dirty
+ */
+void MarkAllViewportsDirty(int left, int top, int right, int bottom)
+{
+	Window *w;
+	FOR_ALL_WINDOWS_FROM_BACK(w) {
+		ViewPort *vp = w->viewport;
+		if (vp != NULL) {
+			assert(vp->width != 0);
+			MarkViewportDirty(vp, left, top, right, bottom);
+		}
+	}
+}
+
+void ConstrainAllViewportsZoom()
+{
+	Window *w;
+	FOR_ALL_WINDOWS_FROM_FRONT(w) {
+		if (w->viewport == NULL) continue;
+
+		ZoomLevel zoom = static_cast<ZoomLevel>(Clamp(w->viewport->zoom, _settings_client.gui.zoom_min, _settings_client.gui.zoom_max));
+		if (zoom != w->viewport->zoom) {
+			while (w->viewport->zoom < zoom) DoZoomInOutWindow(ZOOM_OUT, w);
+			while (w->viewport->zoom > zoom) DoZoomInOutWindow(ZOOM_IN, w);
+		}
+	}
+}
+
+/**
+ * Mark a tile given by its index dirty for repaint.
+ * @param tile The tile to mark dirty.
+ * @ingroup dirty
+ */
+void MarkTileDirtyByTile(TileIndex tile)
+{
+	Point pt = RemapCoords(TileX(tile) * TILE_SIZE, TileY(tile) * TILE_SIZE, GetTilePixelZ(tile));
+	MarkAllViewportsDirty(
+		pt.x - 31  * ZOOM_LVL_BASE,
+		pt.y - 122 * ZOOM_LVL_BASE,
+		pt.x - 31  * ZOOM_LVL_BASE + 67  * ZOOM_LVL_BASE,
+		pt.y - 122 * ZOOM_LVL_BASE + 154 * ZOOM_LVL_BASE
+	);
+}
+
+/**
+ * Marks the selected tiles as dirty.
+ *
+ * This function marks the selected tiles as dirty for repaint
+ *
+ * @ingroup dirty
+ */
+static void SetSelectionTilesDirty()
+{
+	int x_size = _thd.size.x;
+	int y_size = _thd.size.y;
+
+	if (!_thd.diagonal) { // Selecting in a straight rectangle (or a single square)
+		int x_start = _thd.pos.x;
+		int y_start = _thd.pos.y;
+
+		if (_thd.outersize.x != 0) {
+			x_size  += _thd.outersize.x;
+			x_start += _thd.offs.x;
+			y_size  += _thd.outersize.y;
+			y_start += _thd.offs.y;
+		}
+
+		x_size -= TILE_SIZE;
+		y_size -= TILE_SIZE;
+
+		assert(x_size >= 0);
+		assert(y_size >= 0);
+
+		int x_end = Clamp(x_start + x_size, 0, MapSizeX() * TILE_SIZE - TILE_SIZE);
+		int y_end = Clamp(y_start + y_size, 0, MapSizeY() * TILE_SIZE - TILE_SIZE);
+
+		x_start = Clamp(x_start, 0, MapSizeX() * TILE_SIZE - TILE_SIZE);
+		y_start = Clamp(y_start, 0, MapSizeY() * TILE_SIZE - TILE_SIZE);
+
+		/* make sure everything is multiple of TILE_SIZE */
+		assert((x_end | y_end | x_start | y_start) % TILE_SIZE == 0);
+
+		/* How it works:
+		 * Suppose we have to mark dirty rectangle of 3x4 tiles:
+		 *   x
+		 *  xxx
+		 * xxxxx
+		 *  xxxxx
+		 *   xxx
+		 *    x
+		 * This algorithm marks dirty columns of tiles, so it is done in 3+4-1 steps:
+		 * 1)  x     2)  x
+		 *    xxx       Oxx
+		 *   Oxxxx     xOxxx
+		 *    xxxxx     Oxxxx
+		 *     xxx       xxx
+		 *      x         x
+		 * And so forth...
+		 */
+
+		int top_x = x_end; // coordinates of top dirty tile
+		int top_y = y_start;
+		int bot_x = top_x; // coordinates of bottom dirty tile
+		int bot_y = top_y;
+
+		do {
+			/* topmost dirty point */
+			TileIndex top_tile = TileVirtXY(top_x, top_y);
+			Point top = RemapCoords(top_x, top_y, GetTileMaxPixelZ(top_tile));
+
+			/* bottommost point */
+			TileIndex bottom_tile = TileVirtXY(bot_x, bot_y);
+			Point bot = RemapCoords(bot_x + TILE_SIZE, bot_y + TILE_SIZE, GetTilePixelZ(bottom_tile)); // bottommost point
+
+			/* the 'x' coordinate of 'top' and 'bot' is the same (and always in the same distance from tile middle),
+			 * tile height/slope affects only the 'y' on-screen coordinate! */
+
+			int l = top.x - (TILE_PIXELS - 2) * ZOOM_LVL_BASE; // 'x' coordinate of left side of dirty rectangle
+			int t = top.y;                     // 'y' coordinate of top side -//-
+			int r = top.x + (TILE_PIXELS - 2) * ZOOM_LVL_BASE; // right side of dirty rectangle
+			int b = bot.y;                     // bottom -//-
+
+			static const int OVERLAY_WIDTH = 4 * ZOOM_LVL_BASE; // part of selection sprites is drawn outside the selected area
+
+			/* For halftile foundations on SLOPE_STEEP_S the sprite extents some more towards the top */
+			MarkAllViewportsDirty(l - OVERLAY_WIDTH, t - OVERLAY_WIDTH - TILE_HEIGHT * ZOOM_LVL_BASE, r + OVERLAY_WIDTH, b + OVERLAY_WIDTH * ZOOM_LVL_BASE);
+
+			/* haven't we reached the topmost tile yet? */
+			if (top_x != x_start) {
+				top_x -= TILE_SIZE;
+			} else {
+				top_y += TILE_SIZE;
+			}
+
+			/* the way the bottom tile changes is different when we reach the bottommost tile */
+			if (bot_y != y_end) {
+				bot_y += TILE_SIZE;
+			} else {
+				bot_x -= TILE_SIZE;
+			}
+		} while (bot_x >= top_x);
+	} else { // Selecting in a 45 degrees rotated (diagonal) rectangle.
+		/* a_size, b_size describe a rectangle with rotated coordinates */
+		int a_size = x_size + y_size, b_size = x_size - y_size;
+
+		int interval_a = a_size < 0 ? -(int)TILE_SIZE : (int)TILE_SIZE;
+		int interval_b = b_size < 0 ? -(int)TILE_SIZE : (int)TILE_SIZE;
+
+		for (int a = -interval_a; a != a_size + interval_a; a += interval_a) {
+			for (int b = -interval_b; b != b_size + interval_b; b += interval_b) {
+				uint x = (_thd.pos.x + (a + b) / 2) / TILE_SIZE;
+				uint y = (_thd.pos.y + (a - b) / 2) / TILE_SIZE;
+
+				if (x < MapMaxX() && y < MapMaxY()) {
+					MarkTileDirtyByTile(TileXY(x, y));
+				}
+			}
+		}
+	}
+}
+
+
+void SetSelectionRed(bool b)
+{
+	_thd.make_square_red = b;
+	SetSelectionTilesDirty();
+}
+
+/**
+ * Test whether a sign is below the mouse
+ * @param vp the clicked viewport
+ * @param x X position of click
+ * @param y Y position of click
+ * @param sign the sign to check
+ * @return true if the sign was hit
+ */
+static bool CheckClickOnViewportSign(const ViewPort *vp, int x, int y, const ViewportSign *sign)
+{
+	bool small = (vp->zoom >= ZOOM_LVL_OUT_16X);
+	int sign_half_width = ScaleByZoom((small ? sign->width_small : sign->width_normal) / 2, vp->zoom);
+	int sign_height = ScaleByZoom(VPSM_TOP + (small ? FONT_HEIGHT_SMALL : FONT_HEIGHT_NORMAL) + VPSM_BOTTOM, vp->zoom);
+
+	x = ScaleByZoom(x - vp->left, vp->zoom) + vp->virtual_left;
+	y = ScaleByZoom(y - vp->top, vp->zoom) + vp->virtual_top;
+
+	return y >= sign->top && y < sign->top + sign_height &&
+			x >= sign->center - sign_half_width && x < sign->center + sign_half_width;
+}
+
+static bool CheckClickOnTown(const ViewPort *vp, int x, int y)
+{
+	if (!HasBit(_display_opt, DO_SHOW_TOWN_NAMES)) return false;
+
+	const Town *t;
+	FOR_ALL_TOWNS(t) {
+		if (CheckClickOnViewportSign(vp, x, y, &t->cache.sign)) {
+			ShowTownViewWindow(t->index);
+			return true;
+		}
+	}
+
+	return false;
+}
+
+static bool CheckClickOnStation(const ViewPort *vp, int x, int y)
+{
+	if (!(HasBit(_display_opt, DO_SHOW_STATION_NAMES) || HasBit(_display_opt, DO_SHOW_WAYPOINT_NAMES)) || IsInvisibilitySet(TO_SIGNS)) return false;
+
+	const BaseStation *st;
+	FOR_ALL_BASE_STATIONS(st) {
+		/* Check whether the base station is a station or a waypoint */
+		bool is_station = Station::IsExpected(st);
+
+		/* Don't check if the display options are disabled */
+		if (!HasBit(_display_opt, is_station ? DO_SHOW_STATION_NAMES : DO_SHOW_WAYPOINT_NAMES)) continue;
+
+		/* Don't check if competitor signs are not shown and the sign isn't owned by the local company */
+		if (!HasBit(_display_opt, DO_SHOW_COMPETITOR_SIGNS) && _local_company != st->owner && st->owner != OWNER_NONE) continue;
+
+		if (CheckClickOnViewportSign(vp, x, y, &st->sign)) {
+			if (is_station) {
+				ShowStationViewWindow(st->index);
+			} else {
+				ShowWaypointWindow(Waypoint::From(st));
+			}
+			return true;
+		}
+	}
+
+	return false;
+}
+
+
+static bool CheckClickOnSign(const ViewPort *vp, int x, int y)
+{
+	/* Signs are turned off, or they are transparent and invisibility is ON, or company is a spectator */
+	if (!HasBit(_display_opt, DO_SHOW_SIGNS) || IsInvisibilitySet(TO_SIGNS) || _local_company == COMPANY_SPECTATOR) return false;
+
+	const Sign *si;
+	FOR_ALL_SIGNS(si) {
+		/* If competitor signs are hidden, don't check signs that aren't owned by local company */
+		if (!HasBit(_display_opt, DO_SHOW_COMPETITOR_SIGNS) && _local_company != si->owner && si->owner != OWNER_DEITY) continue;
+		if (si->owner == OWNER_DEITY && _game_mode != GM_EDITOR) continue;
+
+		if (CheckClickOnViewportSign(vp, x, y, &si->sign)) {
+			HandleClickOnSign(si);
+			return true;
+		}
+	}
+
+	return false;
+}
+
+
+static bool CheckClickOnLandscape(const ViewPort *vp, int x, int y)
+{
+	Point pt = TranslateXYToTileCoord(vp, x, y);
+
+	if (pt.x != -1) return ClickTile(TileVirtXY(pt.x, pt.y));
+	return true;
+}
+
+static void PlaceObject()
+{
+	Point pt;
+	Window *w;
+
+	pt = GetTileBelowCursor();
+	if (pt.x == -1) return;
+
+	if ((_thd.place_mode & HT_DRAG_MASK) == HT_POINT) {
+		pt.x += TILE_SIZE / 2;
+		pt.y += TILE_SIZE / 2;
+	}
+
+	_tile_fract_coords.x = pt.x & TILE_UNIT_MASK;
+	_tile_fract_coords.y = pt.y & TILE_UNIT_MASK;
+
+	w = _thd.GetCallbackWnd();
+	if (w != NULL) w->OnPlaceObject(pt, TileVirtXY(pt.x, pt.y));
+}
+
+
+bool HandleViewportClicked(const ViewPort *vp, int x, int y)
+{
+	const Vehicle *v = CheckClickOnVehicle(vp, x, y);
+
+	if (_thd.place_mode & HT_VEHICLE) {
+		if (v != NULL && VehicleClicked(v)) return true;
+	}
+
+	/* Vehicle placement mode already handled above. */
+	if ((_thd.place_mode & HT_DRAG_MASK) != HT_NONE) {
+		PlaceObject();
+		return true;
+	}
+
+	if (CheckClickOnTown(vp, x, y)) return true;
+	if (CheckClickOnStation(vp, x, y)) return true;
+	if (CheckClickOnSign(vp, x, y)) return true;
+	bool result = CheckClickOnLandscape(vp, x, y);
+
+	if (v != NULL) {
+		DEBUG(misc, 2, "Vehicle %d (index %d) at %p", v->unitnumber, v->index, v);
+		if (IsCompanyBuildableVehicleType(v)) {
+			v = v->First();
+			if (_ctrl_pressed && v->owner == _local_company) {
+				StartStopVehicle(v, true);
+			} else {
+				ShowVehicleViewWindow(v);
+			}
+		}
+		return true;
+	}
+	return result;
+}
+
+
+/**
+ * Scrolls the viewport in a window to a given location.
+ * @param x       Desired x location of the map to scroll to (world coordinate).
+ * @param y       Desired y location of the map to scroll to (world coordinate).
+ * @param z       Desired z location of the map to scroll to (world coordinate). Use \c -1 to scroll to the height of the map at the \a x, \a y location.
+ * @param w       %Window containing the viewport.
+ * @param instant Jump to the location instead of slowly moving to it.
+ * @return Destination of the viewport was changed (to activate other actions when the viewport is already at the desired position).
+ */
+bool ScrollWindowTo(int x, int y, int z, Window *w, bool instant)
+{
+	/* The slope cannot be acquired outside of the map, so make sure we are always within the map. */
+	if (z == -1) z = GetSlopePixelZ(Clamp(x, 0, MapSizeX() * TILE_SIZE - 1), Clamp(y, 0, MapSizeY() * TILE_SIZE - 1));
+
+	Point pt = MapXYZToViewport(w->viewport, x, y, z);
+	w->viewport->follow_vehicle = INVALID_VEHICLE;
+
+	if (w->viewport->dest_scrollpos_x == pt.x && w->viewport->dest_scrollpos_y == pt.y) return false;
+
+	if (instant) {
+		w->viewport->scrollpos_x = pt.x;
+		w->viewport->scrollpos_y = pt.y;
+	}
+
+	w->viewport->dest_scrollpos_x = pt.x;
+	w->viewport->dest_scrollpos_y = pt.y;
+	return true;
+}
+
+/**
+ * Scrolls the viewport in a window to a given location.
+ * @param tile    Desired tile to center on.
+ * @param w       %Window containing the viewport.
+ * @param instant Jump to the location instead of slowly moving to it.
+ * @return Destination of the viewport was changed (to activate other actions when the viewport is already at the desired position).
+ */
+bool ScrollWindowToTile(TileIndex tile, Window *w, bool instant)
+{
+	return ScrollWindowTo(TileX(tile) * TILE_SIZE, TileY(tile) * TILE_SIZE, -1, w, instant);
+}
+
+/**
+ * Scrolls the viewport of the main window to a given location.
+ * @param tile    Desired tile to center on.
+ * @param instant Jump to the location instead of slowly moving to it.
+ * @return Destination of the viewport was changed (to activate other actions when the viewport is already at the desired position).
+ */
+bool ScrollMainWindowToTile(TileIndex tile, bool instant)
+{
+	return ScrollMainWindowTo(TileX(tile) * TILE_SIZE + TILE_SIZE / 2, TileY(tile) * TILE_SIZE + TILE_SIZE / 2, -1, instant);
+}
+
+/**
+ * Set a tile to display a red error square.
+ * @param tile Tile that should show the red error square.
+ */
+void SetRedErrorSquare(TileIndex tile)
+{
+	TileIndex old;
+
+	old = _thd.redsq;
+	_thd.redsq = tile;
+
+	if (tile != old) {
+		if (tile != INVALID_TILE) MarkTileDirtyByTile(tile);
+		if (old  != INVALID_TILE) MarkTileDirtyByTile(old);
+	}
+}
+
+/**
+ * Highlight \a w by \a h tiles at the cursor.
+ * @param w Width of the highlighted tiles rectangle.
+ * @param h Height of the highlighted tiles rectangle.
+ */
+void SetTileSelectSize(int w, int h)
+{
+	_thd.new_size.x = w * TILE_SIZE;
+	_thd.new_size.y = h * TILE_SIZE;
+	_thd.new_outersize.x = 0;
+	_thd.new_outersize.y = 0;
+}
+
+void SetTileSelectBigSize(int ox, int oy, int sx, int sy)
+{
+	_thd.offs.x = ox * TILE_SIZE;
+	_thd.offs.y = oy * TILE_SIZE;
+	_thd.new_outersize.x = sx * TILE_SIZE;
+	_thd.new_outersize.y = sy * TILE_SIZE;
+}
+
+/** returns the best autorail highlight type from map coordinates */
+static HighLightStyle GetAutorailHT(int x, int y)
+{
+	return HT_RAIL | _autorail_piece[x & TILE_UNIT_MASK][y & TILE_UNIT_MASK];
+}
+
+/**
+ * Reset tile highlighting.
+ */
+void TileHighlightData::Reset()
+{
+	this->pos.x = 0;
+	this->pos.y = 0;
+	this->new_pos.x = 0;
+	this->new_pos.y = 0;
+}
+
+/**
+ * Is the user dragging a 'diagonal rectangle'?
+ * @return User is dragging a rotated rectangle.
+ */
+bool TileHighlightData::IsDraggingDiagonal()
+{
+	return (this->place_mode & HT_DIAGONAL) != 0 && _ctrl_pressed && _left_button_down;
+}
+
+/**
+ * Get the window that started the current highlighting.
+ * @return The window that requested the current tile highlighting, or \c NULL if not available.
+ */
+Window *TileHighlightData::GetCallbackWnd()
+{
+	return FindWindowById(this->window_class, this->window_number);
+}
+
+
+
+/**
+ * Updates tile highlighting for all cases.
+ * Uses _thd.selstart and _thd.selend and _thd.place_mode (set elsewhere) to determine _thd.pos and _thd.size
+ * Also drawstyle is determined. Uses _thd.new.* as a buffer and calls SetSelectionTilesDirty() twice,
+ * Once for the old and once for the new selection.
+ * _thd is TileHighlightData, found in viewport.h
+ */
+void UpdateTileSelection()
+{
+	int x1;
+	int y1;
+
+	HighLightStyle new_drawstyle = HT_NONE;
+	bool new_diagonal = false;
+
+	if ((_thd.place_mode & HT_DRAG_MASK) == HT_SPECIAL) {
+		x1 = _thd.selend.x;
+		y1 = _thd.selend.y;
+		if (x1 != -1) {
+			int x2 = _thd.selstart.x & ~TILE_UNIT_MASK;
+			int y2 = _thd.selstart.y & ~TILE_UNIT_MASK;
+			x1 &= ~TILE_UNIT_MASK;
+			y1 &= ~TILE_UNIT_MASK;
+
+			if (_thd.IsDraggingDiagonal()) {
+				new_diagonal = true;
+			} else {
+				if (x1 >= x2) Swap(x1, x2);
+				if (y1 >= y2) Swap(y1, y2);
+			}
+			_thd.new_pos.x = x1;
+			_thd.new_pos.y = y1;
+			_thd.new_size.x = x2 - x1;
+			_thd.new_size.y = y2 - y1;
+			if (!new_diagonal) {
+				_thd.new_size.x += TILE_SIZE;
+				_thd.new_size.y += TILE_SIZE;
+			}
+			new_drawstyle = _thd.next_drawstyle;
+		}
+	} else if ((_thd.place_mode & HT_DRAG_MASK) != HT_NONE) {
+		Point pt = GetTileBelowCursor();
+		x1 = pt.x;
+		y1 = pt.y;
+		if (x1 != -1) {
+			switch (_thd.place_mode & HT_DRAG_MASK) {
+				case HT_RECT:
+					new_drawstyle = HT_RECT;
+					break;
+				case HT_POINT:
+					new_drawstyle = HT_POINT;
+					x1 += TILE_SIZE / 2;
+					y1 += TILE_SIZE / 2;
+					break;
+				case HT_RAIL:
+					/* Draw one highlighted tile in any direction */
+					new_drawstyle = GetAutorailHT(pt.x, pt.y);
+					break;
+				case HT_LINE:
+					switch (_thd.place_mode & HT_DIR_MASK) {
+						case HT_DIR_X: new_drawstyle = HT_LINE | HT_DIR_X; break;
+						case HT_DIR_Y: new_drawstyle = HT_LINE | HT_DIR_Y; break;
+
+						case HT_DIR_HU:
+						case HT_DIR_HL:
+							new_drawstyle = (pt.x & TILE_UNIT_MASK) + (pt.y & TILE_UNIT_MASK) <= TILE_SIZE ? HT_LINE | HT_DIR_HU : HT_LINE | HT_DIR_HL;
+							break;
+
+						case HT_DIR_VL:
+						case HT_DIR_VR:
+							new_drawstyle = (pt.x & TILE_UNIT_MASK) > (pt.y & TILE_UNIT_MASK) ? HT_LINE | HT_DIR_VL : HT_LINE | HT_DIR_VR;
+							break;
+
+						default: NOT_REACHED();
+					}
+					_thd.selstart.x = x1 & ~TILE_UNIT_MASK;
+					_thd.selstart.y = y1 & ~TILE_UNIT_MASK;
+					break;
+				default:
+					NOT_REACHED();
+					break;
+			}
+			_thd.new_pos.x = x1 & ~TILE_UNIT_MASK;
+			_thd.new_pos.y = y1 & ~TILE_UNIT_MASK;
+		}
+	}
+
+	/* redraw selection */
+	if (_thd.drawstyle != new_drawstyle ||
+			_thd.pos.x != _thd.new_pos.x || _thd.pos.y != _thd.new_pos.y ||
+			_thd.size.x != _thd.new_size.x || _thd.size.y != _thd.new_size.y ||
+			_thd.outersize.x != _thd.new_outersize.x ||
+			_thd.outersize.y != _thd.new_outersize.y ||
+			_thd.diagonal    != new_diagonal) {
+		/* Clear the old tile selection? */
+		if ((_thd.drawstyle & HT_DRAG_MASK) != HT_NONE) SetSelectionTilesDirty();
+
+		_thd.drawstyle = new_drawstyle;
+		_thd.pos = _thd.new_pos;
+		_thd.size = _thd.new_size;
+		_thd.outersize = _thd.new_outersize;
+		_thd.diagonal = new_diagonal;
+		_thd.dirty = 0xff;
+
+		/* Draw the new tile selection? */
+		if ((new_drawstyle & HT_DRAG_MASK) != HT_NONE) SetSelectionTilesDirty();
+	}
+}
+
+/**
+ * Displays the measurement tooltips when selecting multiple tiles
+ * @param str String to be displayed
+ * @param paramcount number of params to deal with
+ * @param params (optional) up to 5 pieces of additional information that may be added to a tooltip
+ * @param close_cond Condition for closing this tooltip.
+ */
+static inline void ShowMeasurementTooltips(StringID str, uint paramcount, const uint64 params[], TooltipCloseCondition close_cond = TCC_LEFT_CLICK)
+{
+	if (!_settings_client.gui.measure_tooltip) return;
+	GuiShowTooltips(_thd.GetCallbackWnd(), str, paramcount, params, close_cond);
+}
+
+/** highlighting tiles while only going over them with the mouse */
+void VpStartPlaceSizing(TileIndex tile, ViewportPlaceMethod method, ViewportDragDropSelectionProcess process)
+{
+	_thd.select_method = method;
+	_thd.select_proc   = process;
+	_thd.selend.x = TileX(tile) * TILE_SIZE;
+	_thd.selstart.x = TileX(tile) * TILE_SIZE;
+	_thd.selend.y = TileY(tile) * TILE_SIZE;
+	_thd.selstart.y = TileY(tile) * TILE_SIZE;
+
+	/* Needed so several things (road, autoroad, bridges, ...) are placed correctly.
+	 * In effect, placement starts from the centre of a tile
+	 */
+	if (method == VPM_X_OR_Y || method == VPM_FIX_X || method == VPM_FIX_Y) {
+		_thd.selend.x += TILE_SIZE / 2;
+		_thd.selend.y += TILE_SIZE / 2;
+		_thd.selstart.x += TILE_SIZE / 2;
+		_thd.selstart.y += TILE_SIZE / 2;
+	}
+
+	HighLightStyle others = _thd.place_mode & ~(HT_DRAG_MASK | HT_DIR_MASK);
+	if ((_thd.place_mode & HT_DRAG_MASK) == HT_RECT) {
+		_thd.place_mode = HT_SPECIAL | others;
+		_thd.next_drawstyle = HT_RECT | others;
+	} else if (_thd.place_mode & (HT_RAIL | HT_LINE)) {
+		_thd.place_mode = HT_SPECIAL | others;
+		_thd.next_drawstyle = _thd.drawstyle | others;
+	} else {
+		_thd.place_mode = HT_SPECIAL | others;
+		_thd.next_drawstyle = HT_POINT | others;
+	}
+	_special_mouse_mode = WSM_SIZING;
+}
+
+void VpSetPlaceSizingLimit(int limit)
+{
+	_thd.sizelimit = limit;
+}
+
+/**
+ * Highlights all tiles between a set of two tiles. Used in dock and tunnel placement
+ * @param from TileIndex of the first tile to highlight
+ * @param to TileIndex of the last tile to highlight
+ */
+void VpSetPresizeRange(TileIndex from, TileIndex to)
+{
+	uint64 distance = DistanceManhattan(from, to) + 1;
+
+	_thd.selend.x = TileX(to) * TILE_SIZE;
+	_thd.selend.y = TileY(to) * TILE_SIZE;
+	_thd.selstart.x = TileX(from) * TILE_SIZE;
+	_thd.selstart.y = TileY(from) * TILE_SIZE;
+	_thd.next_drawstyle = HT_RECT;
+
+	/* show measurement only if there is any length to speak of */
+	if (distance > 1) ShowMeasurementTooltips(STR_MEASURE_LENGTH, 1, &distance, TCC_HOVER);
+}
+
+static void VpStartPreSizing()
+{
+	_thd.selend.x = -1;
+	_special_mouse_mode = WSM_PRESIZE;
+}
+
+/**
+ * returns information about the 2x1 piece to be build.
+ * The lower bits (0-3) are the track type.
+ */
+static HighLightStyle Check2x1AutoRail(int mode)
+{
+	int fxpy = _tile_fract_coords.x + _tile_fract_coords.y;
+	int sxpy = (_thd.selend.x & TILE_UNIT_MASK) + (_thd.selend.y & TILE_UNIT_MASK);
+	int fxmy = _tile_fract_coords.x - _tile_fract_coords.y;
+	int sxmy = (_thd.selend.x & TILE_UNIT_MASK) - (_thd.selend.y & TILE_UNIT_MASK);
+
+	switch (mode) {
+		default: NOT_REACHED();
+		case 0: // end piece is lower right
+			if (fxpy >= 20 && sxpy <= 12) return HT_DIR_HL;
+			if (fxmy < -3 && sxmy > 3) return HT_DIR_VR;
+			return HT_DIR_Y;
+
+		case 1:
+			if (fxmy > 3 && sxmy < -3) return HT_DIR_VL;
+			if (fxpy <= 12 && sxpy >= 20) return HT_DIR_HU;
+			return HT_DIR_Y;
+
+		case 2:
+			if (fxmy > 3 && sxmy < -3) return HT_DIR_VL;
+			if (fxpy >= 20 && sxpy <= 12) return HT_DIR_HL;
+			return HT_DIR_X;
+
+		case 3:
+			if (fxmy < -3 && sxmy > 3) return HT_DIR_VR;
+			if (fxpy <= 12 && sxpy >= 20) return HT_DIR_HU;
+			return HT_DIR_X;
+	}
+}
+
+/**
+ * Check if the direction of start and end tile should be swapped based on
+ * the dragging-style. Default directions are:
+ * in the case of a line (HT_RAIL, HT_LINE):  DIR_NE, DIR_NW, DIR_N, DIR_E
+ * in the case of a rect (HT_RECT, HT_POINT): DIR_S, DIR_E
+ * For example dragging a rectangle area from south to north should be swapped to
+ * north-south (DIR_S) to obtain the same results with less code. This is what
+ * the return value signifies.
+ * @param style HighLightStyle dragging style
+ * @param start_tile start tile of drag
+ * @param end_tile end tile of drag
+ * @return boolean value which when true means start/end should be swapped
+ */
+static bool SwapDirection(HighLightStyle style, TileIndex start_tile, TileIndex end_tile)
+{
+	uint start_x = TileX(start_tile);
+	uint start_y = TileY(start_tile);
+	uint end_x = TileX(end_tile);
+	uint end_y = TileY(end_tile);
+
+	switch (style & HT_DRAG_MASK) {
+		case HT_RAIL:
+		case HT_LINE: return (end_x > start_x || (end_x == start_x && end_y > start_y));
+
+		case HT_RECT:
+		case HT_POINT: return (end_x != start_x && end_y < start_y);
+		default: NOT_REACHED();
+	}
+
+	return false;
+}
+
+/**
+ * Calculates height difference between one tile and another.
+ * Multiplies the result to suit the standard given by #TILE_HEIGHT_STEP.
+ *
+ * To correctly get the height difference we need the direction we are dragging
+ * in, as well as with what kind of tool we are dragging. For example a horizontal
+ * autorail tool that starts in bottom and ends at the top of a tile will need the
+ * maximum of SW, S and SE, N corners respectively. This is handled by the lookup table below
+ * See #_tileoffs_by_dir in map.cpp for the direction enums if you can't figure out the values yourself.
+ * @param style      Highlighting style of the drag. This includes direction and style (autorail, rect, etc.)
+ * @param distance   Number of tiles dragged, important for horizontal/vertical drags, ignored for others.
+ * @param start_tile Start tile of the drag operation.
+ * @param end_tile   End tile of the drag operation.
+ * @return Height difference between two tiles. The tile measurement tool utilizes this value in its tooltip.
+ */
+static int CalcHeightdiff(HighLightStyle style, uint distance, TileIndex start_tile, TileIndex end_tile)
+{
+	bool swap = SwapDirection(style, start_tile, end_tile);
+	uint h0, h1; // Start height and end height.
+
+	if (start_tile == end_tile) return 0;
+	if (swap) Swap(start_tile, end_tile);
+
+	switch (style & HT_DRAG_MASK) {
+		case HT_RECT: {
+			static const TileIndexDiffC heightdiff_area_by_dir[] = {
+				/* Start */ {1, 0}, /* Dragging east */ {0, 0}, // Dragging south
+				/* End   */ {0, 1}, /* Dragging east */ {1, 1}  // Dragging south
+			};
+
+			/* In the case of an area we can determine whether we were dragging south or
+			 * east by checking the X-coordinates of the tiles */
+			byte style_t = (byte)(TileX(end_tile) > TileX(start_tile));
+			start_tile = TILE_ADD(start_tile, ToTileIndexDiff(heightdiff_area_by_dir[style_t]));
+			end_tile   = TILE_ADD(end_tile, ToTileIndexDiff(heightdiff_area_by_dir[2 + style_t]));
+			/* FALL THROUGH */
+		}
+
+		case HT_POINT:
+			h0 = TileHeight(start_tile);
+			h1 = TileHeight(end_tile);
+			break;
+		default: { // All other types, this is mostly only line/autorail
+			static const HighLightStyle flip_style_direction[] = {
+				HT_DIR_X, HT_DIR_Y, HT_DIR_HL, HT_DIR_HU, HT_DIR_VR, HT_DIR_VL
+			};
+			static const TileIndexDiffC heightdiff_line_by_dir[] = {
+				/* Start */ {1, 0}, {1, 1}, /* HT_DIR_X  */ {0, 1}, {1, 1}, // HT_DIR_Y
+				/* Start */ {1, 0}, {0, 0}, /* HT_DIR_HU */ {1, 0}, {1, 1}, // HT_DIR_HL
+				/* Start */ {1, 0}, {1, 1}, /* HT_DIR_VL */ {0, 1}, {1, 1}, // HT_DIR_VR
+
+				/* Start */ {0, 1}, {0, 0}, /* HT_DIR_X  */ {1, 0}, {0, 0}, // HT_DIR_Y
+				/* End   */ {0, 1}, {0, 0}, /* HT_DIR_HU */ {1, 1}, {0, 1}, // HT_DIR_HL
+				/* End   */ {1, 0}, {0, 0}, /* HT_DIR_VL */ {0, 0}, {0, 1}, // HT_DIR_VR
+			};
+
+			distance %= 2; // we're only interested if the distance is even or uneven
+			style &= HT_DIR_MASK;
+
+			/* To handle autorail, we do some magic to be able to use a lookup table.
+			 * Firstly if we drag the other way around, we switch start&end, and if needed
+			 * also flip the drag-position. Eg if it was on the left, and the distance is even
+			 * that means the end, which is now the start is on the right */
+			if (swap && distance == 0) style = flip_style_direction[style];
+
+			/* Use lookup table for start-tile based on HighLightStyle direction */
+			byte style_t = style * 2;
+			assert(style_t < lengthof(heightdiff_line_by_dir) - 13);
+			h0 = TileHeight(TILE_ADD(start_tile, ToTileIndexDiff(heightdiff_line_by_dir[style_t])));
+			uint ht = TileHeight(TILE_ADD(start_tile, ToTileIndexDiff(heightdiff_line_by_dir[style_t + 1])));
+			h0 = max(h0, ht);
+
+			/* Use lookup table for end-tile based on HighLightStyle direction
+			 * flip around side (lower/upper, left/right) based on distance */
+			if (distance == 0) style_t = flip_style_direction[style] * 2;
+			assert(style_t < lengthof(heightdiff_line_by_dir) - 13);
+			h1 = TileHeight(TILE_ADD(end_tile, ToTileIndexDiff(heightdiff_line_by_dir[12 + style_t])));
+			ht = TileHeight(TILE_ADD(end_tile, ToTileIndexDiff(heightdiff_line_by_dir[12 + style_t + 1])));
+			h1 = max(h1, ht);
+			break;
+		}
+	}
+
+	if (swap) Swap(h0, h1);
+	return (int)(h1 - h0) * TILE_HEIGHT_STEP;
+}
+
+static const StringID measure_strings_length[] = {STR_NULL, STR_MEASURE_LENGTH, STR_MEASURE_LENGTH_HEIGHTDIFF};
+
+/**
+ * Check for underflowing the map.
+ * @param test  the variable to test for underflowing
+ * @param other the other variable to update to keep the line
+ * @param mult  the constant to multiply the difference by for \c other
+ */
+static void CheckUnderflow(int &test, int &other, int mult)
+{
+	if (test >= 0) return;
+
+	other += mult * test;
+	test = 0;
+}
+
+/**
+ * Check for overflowing the map.
+ * @param test  the variable to test for overflowing
+ * @param other the other variable to update to keep the line
+ * @param max   the maximum value for the \c test variable
+ * @param mult  the constant to multiply the difference by for \c other
+ */
+static void CheckOverflow(int &test, int &other, int max, int mult)
+{
+	if (test <= max) return;
+
+	other += mult * (test - max);
+	test = max;
+}
+
+/** while dragging */
+static void CalcRaildirsDrawstyle(int x, int y, int method)
+{
+	HighLightStyle b;
+
+	int dx = _thd.selstart.x - (_thd.selend.x & ~TILE_UNIT_MASK);
+	int dy = _thd.selstart.y - (_thd.selend.y & ~TILE_UNIT_MASK);
+	uint w = abs(dx) + TILE_SIZE;
+	uint h = abs(dy) + TILE_SIZE;
+
+	if (method & ~(VPM_RAILDIRS | VPM_SIGNALDIRS)) {
+		/* We 'force' a selection direction; first four rail buttons. */
+		method &= ~(VPM_RAILDIRS | VPM_SIGNALDIRS);
+		int raw_dx = _thd.selstart.x - _thd.selend.x;
+		int raw_dy = _thd.selstart.y - _thd.selend.y;
+		switch (method) {
+			case VPM_FIX_X:
+				b = HT_LINE | HT_DIR_Y;
+				x = _thd.selstart.x;
+				break;
+
+			case VPM_FIX_Y:
+				b = HT_LINE | HT_DIR_X;
+				y = _thd.selstart.y;
+				break;
+
+			case VPM_FIX_HORIZONTAL:
+				if (dx == -dy) {
+					/* We are on a straight horizontal line. Determine the 'rail'
+					 * to build based the sub tile location. */
+					b = (x & TILE_UNIT_MASK) + (y & TILE_UNIT_MASK) >= TILE_SIZE ? HT_LINE | HT_DIR_HL : HT_LINE | HT_DIR_HU;
+				} else {
+					/* We are not on a straight line. Determine the rail to build
+					 * based on whether we are above or below it. */
+					b = dx + dy >= (int)TILE_SIZE ? HT_LINE | HT_DIR_HU : HT_LINE | HT_DIR_HL;
+
+					/* Calculate where a horizontal line through the start point and
+					 * a vertical line from the selected end point intersect and
+					 * use that point as the end point. */
+					int offset = (raw_dx - raw_dy) / 2;
+					x = _thd.selstart.x - (offset & ~TILE_UNIT_MASK);
+					y = _thd.selstart.y + (offset & ~TILE_UNIT_MASK);
+
+					/* 'Build' the last half rail tile if needed */
+					if ((offset & TILE_UNIT_MASK) > (TILE_SIZE / 2)) {
+						if (dx + dy >= (int)TILE_SIZE) {
+							x += (dx + dy < 0) ? (int)TILE_SIZE : -(int)TILE_SIZE;
+						} else {
+							y += (dx + dy < 0) ? (int)TILE_SIZE : -(int)TILE_SIZE;
+						}
+					}
+
+					/* Make sure we do not overflow the map! */
+					CheckUnderflow(x, y, 1);
+					CheckUnderflow(y, x, 1);
+					CheckOverflow(x, y, (MapMaxX() - 1) * TILE_SIZE, 1);
+					CheckOverflow(y, x, (MapMaxY() - 1) * TILE_SIZE, 1);
+					assert(x >= 0 && y >= 0 && x <= (int)(MapMaxX() * TILE_SIZE) && y <= (int)(MapMaxY() * TILE_SIZE));
+				}
+				break;
+
+			case VPM_FIX_VERTICAL:
+				if (dx == dy) {
+					/* We are on a straight vertical line. Determine the 'rail'
+					 * to build based the sub tile location. */
+					b = (x & TILE_UNIT_MASK) > (y & TILE_UNIT_MASK) ? HT_LINE | HT_DIR_VL : HT_LINE | HT_DIR_VR;
+				} else {
+					/* We are not on a straight line. Determine the rail to build
+					 * based on whether we are left or right from it. */
+					b = dx < dy ? HT_LINE | HT_DIR_VL : HT_LINE | HT_DIR_VR;
+
+					/* Calculate where a vertical line through the start point and
+					 * a horizontal line from the selected end point intersect and
+					 * use that point as the end point. */
+					int offset = (raw_dx + raw_dy + (int)TILE_SIZE) / 2;
+					x = _thd.selstart.x - (offset & ~TILE_UNIT_MASK);
+					y = _thd.selstart.y - (offset & ~TILE_UNIT_MASK);
+
+					/* 'Build' the last half rail tile if needed */
+					if ((offset & TILE_UNIT_MASK) > (TILE_SIZE / 2)) {
+						if (dx - dy < 0) {
+							y += (dx > dy) ? (int)TILE_SIZE : -(int)TILE_SIZE;
+						} else {
+							x += (dx < dy) ? (int)TILE_SIZE : -(int)TILE_SIZE;
+						}
+					}
+
+					/* Make sure we do not overflow the map! */
+					CheckUnderflow(x, y, -1);
+					CheckUnderflow(y, x, -1);
+					CheckOverflow(x, y, (MapMaxX() - 1) * TILE_SIZE, -1);
+					CheckOverflow(y, x, (MapMaxY() - 1) * TILE_SIZE, -1);
+					assert(x >= 0 && y >= 0 && x <= (int)(MapMaxX() * TILE_SIZE) && y <= (int)(MapMaxY() * TILE_SIZE));
+				}
+				break;
+
+			default:
+				NOT_REACHED();
+		}
+	} else if (TileVirtXY(_thd.selstart.x, _thd.selstart.y) == TileVirtXY(x, y)) { // check if we're only within one tile
+		if (method & VPM_RAILDIRS) {
+			b = GetAutorailHT(x, y);
+		} else { // rect for autosignals on one tile
+			b = HT_RECT;
+		}
+	} else if (h == TILE_SIZE) { // Is this in X direction?
+		if (dx == (int)TILE_SIZE) { // 2x1 special handling
+			b = (Check2x1AutoRail(3)) | HT_LINE;
+		} else if (dx == -(int)TILE_SIZE) {
+			b = (Check2x1AutoRail(2)) | HT_LINE;
+		} else {
+			b = HT_LINE | HT_DIR_X;
+		}
+		y = _thd.selstart.y;
+	} else if (w == TILE_SIZE) { // Or Y direction?
+		if (dy == (int)TILE_SIZE) { // 2x1 special handling
+			b = (Check2x1AutoRail(1)) | HT_LINE;
+		} else if (dy == -(int)TILE_SIZE) { // 2x1 other direction
+			b = (Check2x1AutoRail(0)) | HT_LINE;
+		} else {
+			b = HT_LINE | HT_DIR_Y;
+		}
+		x = _thd.selstart.x;
+	} else if (w > h * 2) { // still count as x dir?
+		b = HT_LINE | HT_DIR_X;
+		y = _thd.selstart.y;
+	} else if (h > w * 2) { // still count as y dir?
+		b = HT_LINE | HT_DIR_Y;
+		x = _thd.selstart.x;
+	} else { // complicated direction
+		int d = w - h;
+		_thd.selend.x = _thd.selend.x & ~TILE_UNIT_MASK;
+		_thd.selend.y = _thd.selend.y & ~TILE_UNIT_MASK;
+
+		/* four cases. */
+		if (x > _thd.selstart.x) {
+			if (y > _thd.selstart.y) {
+				/* south */
+				if (d == 0) {
+					b = (x & TILE_UNIT_MASK) > (y & TILE_UNIT_MASK) ? HT_LINE | HT_DIR_VL : HT_LINE | HT_DIR_VR;
+				} else if (d >= 0) {
+					x = _thd.selstart.x + h;
+					b = HT_LINE | HT_DIR_VL;
+				} else {
+					y = _thd.selstart.y + w;
+					b = HT_LINE | HT_DIR_VR;
+				}
+			} else {
+				/* west */
+				if (d == 0) {
+					b = (x & TILE_UNIT_MASK) + (y & TILE_UNIT_MASK) >= TILE_SIZE ? HT_LINE | HT_DIR_HL : HT_LINE | HT_DIR_HU;
+				} else if (d >= 0) {
+					x = _thd.selstart.x + h;
+					b = HT_LINE | HT_DIR_HL;
+				} else {
+					y = _thd.selstart.y - w;
+					b = HT_LINE | HT_DIR_HU;
+				}
+			}
+		} else {
+			if (y > _thd.selstart.y) {
+				/* east */
+				if (d == 0) {
+					b = (x & TILE_UNIT_MASK) + (y & TILE_UNIT_MASK) >= TILE_SIZE ? HT_LINE | HT_DIR_HL : HT_LINE | HT_DIR_HU;
+				} else if (d >= 0) {
+					x = _thd.selstart.x - h;
+					b = HT_LINE | HT_DIR_HU;
+				} else {
+					y = _thd.selstart.y + w;
+					b = HT_LINE | HT_DIR_HL;
+				}
+			} else {
+				/* north */
+				if (d == 0) {
+					b = (x & TILE_UNIT_MASK) > (y & TILE_UNIT_MASK) ? HT_LINE | HT_DIR_VL : HT_LINE | HT_DIR_VR;
+				} else if (d >= 0) {
+					x = _thd.selstart.x - h;
+					b = HT_LINE | HT_DIR_VR;
+				} else {
+					y = _thd.selstart.y - w;
+					b = HT_LINE | HT_DIR_VL;
+				}
+			}
+		}
+	}
+
+	if (_settings_client.gui.measure_tooltip) {
+		TileIndex t0 = TileVirtXY(_thd.selstart.x, _thd.selstart.y);
+		TileIndex t1 = TileVirtXY(x, y);
+		uint distance = DistanceManhattan(t0, t1) + 1;
+		byte index = 0;
+		uint64 params[2];
+
+		if (distance != 1) {
+			int heightdiff = CalcHeightdiff(b, distance, t0, t1);
+			/* If we are showing a tooltip for horizontal or vertical drags,
+			 * 2 tiles have a length of 1. To bias towards the ceiling we add
+			 * one before division. It feels more natural to count 3 lengths as 2 */
+			if ((b & HT_DIR_MASK) != HT_DIR_X && (b & HT_DIR_MASK) != HT_DIR_Y) {
+				distance = CeilDiv(distance, 2);
+			}
+
+			params[index++] = distance;
+			if (heightdiff != 0) params[index++] = heightdiff;
+		}
+
+		ShowMeasurementTooltips(measure_strings_length[index], index, params);
+	}
+
+	_thd.selend.x = x;
+	_thd.selend.y = y;
+	_thd.next_drawstyle = b;
+}
+
+/**
+ * Selects tiles while dragging
+ * @param x X coordinate of end of selection
+ * @param y Y coordinate of end of selection
+ * @param method modifies the way tiles are selected. Possible
+ * methods are VPM_* in viewport.h
+ */
+void VpSelectTilesWithMethod(int x, int y, ViewportPlaceMethod method)
+{
+	int sx, sy;
+	HighLightStyle style;
+
+	if (x == -1) {
+		_thd.selend.x = -1;
+		return;
+	}
+
+	/* Special handling of drag in any (8-way) direction */
+	if (method & (VPM_RAILDIRS | VPM_SIGNALDIRS)) {
+		_thd.selend.x = x;
+		_thd.selend.y = y;
+		CalcRaildirsDrawstyle(x, y, method);
+		return;
+	}
+
+	/* Needed so level-land is placed correctly */
+	if ((_thd.next_drawstyle & HT_DRAG_MASK) == HT_POINT) {
+		x += TILE_SIZE / 2;
+		y += TILE_SIZE / 2;
+	}
+
+	sx = _thd.selstart.x;
+	sy = _thd.selstart.y;
+
+	int limit = 0;
+
+	switch (method) {
+		case VPM_X_OR_Y: // drag in X or Y direction
+			if (abs(sy - y) < abs(sx - x)) {
+				y = sy;
+				style = HT_DIR_X;
+			} else {
+				x = sx;
+				style = HT_DIR_Y;
+			}
+			goto calc_heightdiff_single_direction;
+
+		case VPM_X_LIMITED: // Drag in X direction (limited size).
+			limit = (_thd.sizelimit - 1) * TILE_SIZE;
+			/* FALL THROUGH */
+
+		case VPM_FIX_X: // drag in Y direction
+			x = sx;
+			style = HT_DIR_Y;
+			goto calc_heightdiff_single_direction;
+
+		case VPM_Y_LIMITED: // Drag in Y direction (limited size).
+			limit = (_thd.sizelimit - 1) * TILE_SIZE;
+			/* FALL THROUGH */
+
+		case VPM_FIX_Y: // drag in X direction
+			y = sy;
+			style = HT_DIR_X;
+
+calc_heightdiff_single_direction:;
+			if (limit > 0) {
+				x = sx + Clamp(x - sx, -limit, limit);
+				y = sy + Clamp(y - sy, -limit, limit);
+			}
+			if (_settings_client.gui.measure_tooltip) {
+				TileIndex t0 = TileVirtXY(sx, sy);
+				TileIndex t1 = TileVirtXY(x, y);
+				uint distance = DistanceManhattan(t0, t1) + 1;
+				byte index = 0;
+				uint64 params[2];
+
+				if (distance != 1) {
+					/* With current code passing a HT_LINE style to calculate the height
+					 * difference is enough. However if/when a point-tool is created
+					 * with this method, function should be called with new_style (below)
+					 * instead of HT_LINE | style case HT_POINT is handled specially
+					 * new_style := (_thd.next_drawstyle & HT_RECT) ? HT_LINE | style : _thd.next_drawstyle; */
+					int heightdiff = CalcHeightdiff(HT_LINE | style, 0, t0, t1);
+
+					params[index++] = distance;
+					if (heightdiff != 0) params[index++] = heightdiff;
+				}
+
+				ShowMeasurementTooltips(measure_strings_length[index], index, params);
+			}
+			break;
+
+		case VPM_X_AND_Y_LIMITED: // Drag an X by Y constrained rect area.
+			limit = (_thd.sizelimit - 1) * TILE_SIZE;
+			x = sx + Clamp(x - sx, -limit, limit);
+			y = sy + Clamp(y - sy, -limit, limit);
+			/* FALL THROUGH */
+
+		case VPM_X_AND_Y: // drag an X by Y area
+			if (_settings_client.gui.measure_tooltip) {
+				static const StringID measure_strings_area[] = {
+					STR_NULL, STR_NULL, STR_MEASURE_AREA, STR_MEASURE_AREA_HEIGHTDIFF
+				};
+
+				TileIndex t0 = TileVirtXY(sx, sy);
+				TileIndex t1 = TileVirtXY(x, y);
+				uint dx = Delta(TileX(t0), TileX(t1)) + 1;
+				uint dy = Delta(TileY(t0), TileY(t1)) + 1;
+				byte index = 0;
+				uint64 params[3];
+
+				/* If dragging an area (eg dynamite tool) and it is actually a single
+				 * row/column, change the type to 'line' to get proper calculation for height */
+				style = (HighLightStyle)_thd.next_drawstyle;
+				if (_thd.IsDraggingDiagonal()) {
+					/* Determine the "area" of the diagonal dragged selection.
+					 * We assume the area is the number of tiles along the X
+					 * edge and the number of tiles along the Y edge. However,
+					 * multiplying these two numbers does not give the exact
+					 * number of tiles; basically we are counting the black
+					 * squares on a chess board and ignore the white ones to
+					 * make the tile counts at the edges match up. There is no
+					 * other way to make a proper count though.
+					 *
+					 * First convert to the rotated coordinate system. */
+					int dist_x = TileX(t0) - TileX(t1);
+					int dist_y = TileY(t0) - TileY(t1);
+					int a_max = dist_x + dist_y;
+					int b_max = dist_y - dist_x;
+
+					/* Now determine the size along the edge, but due to the
+					 * chess board principle this counts double. */
+					a_max = abs(a_max + (a_max > 0 ? 2 : -2)) / 2;
+					b_max = abs(b_max + (b_max > 0 ? 2 : -2)) / 2;
+
+					/* We get a 1x1 on normal 2x1 rectangles, due to it being
+					 * a seen as two sides. As the result for actual building
+					 * will be the same as non-diagonal dragging revert to that
+					 * behaviour to give it a more normally looking size. */
+					if (a_max != 1 || b_max != 1) {
+						dx = a_max;
+						dy = b_max;
+					}
+				} else if (style & HT_RECT) {
+					if (dx == 1) {
+						style = HT_LINE | HT_DIR_Y;
+					} else if (dy == 1) {
+						style = HT_LINE | HT_DIR_X;
+					}
+				}
+
+				if (dx != 1 || dy != 1) {
+					int heightdiff = CalcHeightdiff(style, 0, t0, t1);
+
+					params[index++] = dx - (style & HT_POINT ? 1 : 0);
+					params[index++] = dy - (style & HT_POINT ? 1 : 0);
+					if (heightdiff != 0) params[index++] = heightdiff;
+				}
+
+				ShowMeasurementTooltips(measure_strings_area[index], index, params);
+			}
+			break;
+
+		default: NOT_REACHED();
+	}
+
+	_thd.selend.x = x;
+	_thd.selend.y = y;
+}
+
+/**
+ * Handle the mouse while dragging for placement/resizing.
+ * @return State of handling the event.
+ */
+EventState VpHandlePlaceSizingDrag()
+{
+	if (_special_mouse_mode != WSM_SIZING) return ES_NOT_HANDLED;
+
+	/* stop drag mode if the window has been closed */
+	Window *w = _thd.GetCallbackWnd();
+	if (w == NULL) {
+		ResetObjectToPlace();
+		return ES_HANDLED;
+	}
+
+	/* while dragging execute the drag procedure of the corresponding window (mostly VpSelectTilesWithMethod() ) */
+	if (_left_button_down) {
+		w->OnPlaceDrag(_thd.select_method, _thd.select_proc, GetTileBelowCursor());
+		return ES_HANDLED;
+	}
+
+	/* mouse button released..
+	 * keep the selected tool, but reset it to the original mode. */
+	_special_mouse_mode = WSM_NONE;
+	HighLightStyle others = _thd.place_mode & ~(HT_DRAG_MASK | HT_DIR_MASK);
+	if ((_thd.next_drawstyle & HT_DRAG_MASK) == HT_RECT) {
+		_thd.place_mode = HT_RECT | others;
+	} else if (_thd.select_method & VPM_SIGNALDIRS) {
+		_thd.place_mode = HT_RECT | others;
+	} else if (_thd.select_method & VPM_RAILDIRS) {
+		_thd.place_mode = (_thd.select_method & ~VPM_RAILDIRS) ? _thd.next_drawstyle : (HT_RAIL | others);
+	} else {
+		_thd.place_mode = HT_POINT | others;
+	}
+	SetTileSelectSize(1, 1);
+
+	w->OnPlaceMouseUp(_thd.select_method, _thd.select_proc, _thd.selend, TileVirtXY(_thd.selstart.x, _thd.selstart.y), TileVirtXY(_thd.selend.x, _thd.selend.y));
+
+	return ES_HANDLED;
+}
+
+void SetObjectToPlaceWnd(CursorID icon, PaletteID pal, HighLightStyle mode, Window *w)
+{
+	SetObjectToPlace(icon, pal, mode, w->window_class, w->window_number);
+}
+
+#include "table/animcursors.h"
+
+void SetObjectToPlace(CursorID icon, PaletteID pal, HighLightStyle mode, WindowClass window_class, WindowNumber window_num)
+{
+	if (_thd.window_class != WC_INVALID) {
+		/* Undo clicking on button and drag & drop */
+		Window *w = _thd.GetCallbackWnd();
+		/* Call the abort function, but set the window class to something
+		 * that will never be used to avoid infinite loops. Setting it to
+		 * the 'next' window class must not be done because recursion into
+		 * this function might in some cases reset the newly set object to
+		 * place or not properly reset the original selection. */
+		_thd.window_class = WC_INVALID;
+		if (w != NULL) w->OnPlaceObjectAbort();
+	}
+
+	/* Mark the old selection dirty, in case the selection shape or colour changes */
+	if ((_thd.drawstyle & HT_DRAG_MASK) != HT_NONE) SetSelectionTilesDirty();
+
+	SetTileSelectSize(1, 1);
+
+	_thd.make_square_red = false;
+
+	if (mode == HT_DRAG) { // HT_DRAG is for dragdropping trains in the depot window
+		mode = HT_NONE;
+		_special_mouse_mode = WSM_DRAGDROP;
+	} else {
+		_special_mouse_mode = WSM_NONE;
+	}
+
+	_thd.place_mode = mode;
+	_thd.window_class = window_class;
+	_thd.window_number = window_num;
+
+	if ((mode & HT_DRAG_MASK) == HT_SPECIAL) { // special tools, like tunnels or docks start with presizing mode
+		VpStartPreSizing();
+	}
+
+	if ((icon & ANIMCURSOR_FLAG) != 0) {
+		SetAnimatedMouseCursor(_animcursors[icon & ~ANIMCURSOR_FLAG]);
+	} else {
+		SetMouseCursor(icon, pal);
+	}
+
+}
+
+void ResetObjectToPlace()
+{
+	SetObjectToPlace(SPR_CURSOR_MOUSE, PAL_NONE, HT_NONE, WC_MAIN_WINDOW, 0);
+}
diff --git a/src/widgets/build_vehicle_widget.h b/src/widgets/build_vehicle_widget.h
index 6acad3f..5e3db92 100644
--- a/src/widgets/build_vehicle_widget.h
+++ b/src/widgets/build_vehicle_widget.h
@@ -24,6 +24,7 @@ enum BuildVehicleWidgets {
 	WID_BV_BUILD,                     ///< Build panel.
 	WID_BV_BUILD_SEL,                 ///< Build button.
 	WID_BV_RENAME,                    ///< Rename button.
+	BUILD_VEHICLE_WIDGET_BUILD,		  /// TODO: own
 };
 
 #endif /* WIDGETS_BUILD_VEHICLE_WIDGET_H */
diff --git a/src/window_type.h b/src/window_type.h
index c69e44c..fec6148 100644
--- a/src/window_type.h
+++ b/src/window_type.h
@@ -664,6 +664,12 @@ enum WindowClass {
 	 */
 	WC_SPRITE_ALIGNER,
 
+	WC_TEMPLATEGUI_MAIN,
+	WC_TEMPLATEGUI_RPLALL,
+	WC_BUILD_VIRTUAL_TRAIN,
+	WC_CREATE_TEMPLATE,
+
+
 	WC_INVALID = 0xFFFF, ///< Invalid window.
 };
 
diff --git a/src/window_type.h.orig b/src/window_type.h.orig
new file mode 100644
index 0000000..c69e44c
--- /dev/null
+++ b/src/window_type.h.orig
@@ -0,0 +1,683 @@
+/* $Id$ */
+
+/*
+ * This file is part of OpenTTD.
+ * OpenTTD is free software; you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, version 2.
+ * OpenTTD is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
+ * See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with OpenTTD. If not, see <http://www.gnu.org/licenses/>.
+ */
+
+/** @file window_type.h Types related to windows */
+
+#ifndef WINDOW_TYPE_H
+#define WINDOW_TYPE_H
+
+/** %Window numbers. */
+enum WindowNumberEnum {
+	WN_GAME_OPTIONS_AI = 0,          ///< AI settings.
+	WN_GAME_OPTIONS_ABOUT,           ///< About window.
+	WN_GAME_OPTIONS_NEWGRF_STATE,    ///< NewGRF settings.
+	WN_GAME_OPTIONS_GAME_OPTIONS,    ///< Game options.
+	WN_GAME_OPTIONS_GAME_SETTINGS,   ///< Game settings.
+
+	WN_QUERY_STRING = 0,  ///< Query string.
+	WN_QUERY_STRING_SIGN, ///< Query string for signs.
+
+	WN_CONFIRM_POPUP_QUERY = 0,       ///< Query popup confirm.
+	WN_CONFIRM_POPUP_QUERY_BOOTSTRAP, ///< Query popup confirm for bootstrap.
+
+	WN_NETWORK_WINDOW_GAME = 0,     ///< Network game window.
+	WN_NETWORK_WINDOW_LOBBY,        ///< Network lobby window.
+	WN_NETWORK_WINDOW_CONTENT_LIST, ///< Network content list.
+	WN_NETWORK_WINDOW_START,        ///< Network start server.
+
+	WN_NETWORK_STATUS_WINDOW_JOIN = 0,         ///< Network join status.
+	WN_NETWORK_STATUS_WINDOW_CONTENT_DOWNLOAD, ///< Network content download status.
+};
+
+/** %Window classes. */
+enum WindowClass {
+	WC_NONE, ///< No window, redirects to WC_MAIN_WINDOW.
+
+	/**
+	 * Main window; %Window numbers:
+	 *   - 0 = #MainWidgets
+	 */
+	WC_MAIN_WINDOW = WC_NONE,
+
+	/**
+	 * Main toolbar (the long bar at the top); %Window numbers:
+	 *   - 0 = #ToolbarNormalWidgets
+	 *   - 0 = #ToolbarEditorWidgets
+	 */
+	WC_MAIN_TOOLBAR,
+
+	/**
+	 * Statusbar (at the bottom of your screen); %Window numbers:
+	 *   - 0 = #StatusbarWidgets
+	 */
+	WC_STATUS_BAR,
+
+	/**
+	 * Build toolbar; %Window numbers:
+	 *   - #TRANSPORT_RAIL = #RailToolbarWidgets
+	 *   - #TRANSPORT_AIR = #AirportToolbarWidgets
+	 *   - #TRANSPORT_WATER = #DockToolbarWidgets
+	 *   - #TRANSPORT_ROAD = #RoadToolbarWidgets
+	 */
+	WC_BUILD_TOOLBAR,
+
+	/**
+	 * Scenario build toolbar; %Window numbers:
+	 *   - #TRANSPORT_WATER = #DockToolbarWidgets
+	 *   - #TRANSPORT_ROAD = #RoadToolbarWidgets
+	 */
+	WC_SCEN_BUILD_TOOLBAR,
+
+	/**
+	 * Build trees toolbar; %Window numbers:
+	 *   - 0 = #BuildTreesWidgets
+	 */
+	WC_BUILD_TREES,
+
+	/**
+	 * Transparency toolbar; %Window numbers:
+	 *   - 0 = #TransparencyToolbarWidgets
+	 */
+	WC_TRANSPARENCY_TOOLBAR,
+
+	/**
+	 * Build signal toolbar; %Window numbers:
+	 *   - #TRANSPORT_RAIL = #BuildSignalWidgets
+	 */
+	WC_BUILD_SIGNAL,
+
+	/**
+	 * Small map; %Window numbers:
+	 *   - 0 = #SmallMapWidgets
+	 */
+	WC_SMALLMAP,
+
+	/**
+	 * Error message; %Window numbers:
+	 *   - 0 = #ErrorMessageWidgets
+	 */
+	WC_ERRMSG,
+
+	/**
+	 * Tooltip window; %Window numbers:
+	 *   - 0 = #ToolTipsWidgets
+	 */
+	WC_TOOLTIPS,
+
+	/**
+	 * Query string window; %Window numbers:
+	 *   - #WN_QUERY_STRING = #QueryStringWidgets
+	 *   - #WN_QUERY_STRING_SIGN = #QueryEditSignWidgets
+	 */
+	WC_QUERY_STRING,
+
+	/**
+	 * Popup with confirm question; %Window numbers:
+	 *   - #WN_CONFIRM_POPUP_QUERY = #QueryWidgets
+	 *   - #WN_CONFIRM_POPUP_QUERY_BOOTSTRAP = #BootstrapAskForDownloadWidgets
+	 */
+	WC_CONFIRM_POPUP_QUERY,
+
+	/**
+	 * Popup with a set of buttons, designed to ask the user a question
+	 *  from a GameScript. %Window numbers:
+	 *   - uniqueid = #GoalQuestionWidgets
+	 */
+	WC_GOAL_QUESTION,
+
+
+	/**
+	 * Saveload window; %Window numbers:
+	 *   - 0 = #SaveLoadWidgets
+	 */
+	WC_SAVELOAD,
+
+	/**
+	 * Land info window; %Window numbers:
+	 *   - 0 = #LandInfoWidgets
+	 */
+	WC_LAND_INFO,
+
+	/**
+	 * Drop down menu; %Window numbers:
+	 *   - 0 = #DropdownMenuWidgets
+	 */
+	WC_DROPDOWN_MENU,
+
+	/**
+	 * On Screen Keyboard; %Window numbers:
+	 *   - 0 = #OnScreenKeyboardWidgets
+	 */
+	WC_OSK,
+
+	/**
+	 * Set date; %Window numbers:
+	 *   - #VehicleID = #SetDateWidgets
+	 */
+	WC_SET_DATE,
+
+
+	/**
+	 * AI settings; %Window numbers:
+	 *   - 0 = #AISettingsWidgets
+	 */
+	WC_AI_SETTINGS,
+
+	/**
+	 * NewGRF parameters; %Window numbers:
+	 *   - 0 = #NewGRFParametersWidgets
+	 */
+	WC_GRF_PARAMETERS,
+
+	/**
+	 * textfile; %Window numbers:
+	 *   - 0 = #TextfileWidgets
+	 */
+	WC_TEXTFILE,
+
+
+	/**
+	 * Town authority; %Window numbers:
+	 *   - #TownID = #TownAuthorityWidgets
+	 */
+	WC_TOWN_AUTHORITY,
+
+	/**
+	 * Vehicle details; %Window numbers:
+	 *   - #VehicleID = #VehicleDetailsWidgets
+	 */
+	WC_VEHICLE_DETAILS,
+
+	/**
+	 * Vehicle refit; %Window numbers:
+	 *   - #VehicleID = #VehicleRefitWidgets
+	 */
+	WC_VEHICLE_REFIT,
+
+	/**
+	 * Vehicle orders; %Window numbers:
+	 *   - #VehicleID = #OrderWidgets
+	 */
+	WC_VEHICLE_ORDERS,
+
+	/**
+	 * Replace vehicle window; %Window numbers:
+	 *   - #VehicleType = #ReplaceVehicleWidgets
+	 */
+	WC_REPLACE_VEHICLE,
+
+	/**
+	 * Vehicle timetable; %Window numbers:
+	 *   - #VehicleID = #VehicleTimetableWidgets
+	 */
+	WC_VEHICLE_TIMETABLE,
+
+	/**
+	 * Company colour selection; %Window numbers:
+	 *   - #CompanyID = #SelectCompanyLiveryWidgets
+	 */
+	WC_COMPANY_COLOUR,
+
+	/**
+	 * Alter company face window; %Window numbers:
+	 *   - #CompanyID = #SelectCompanyManagerFaceWidgets
+	 */
+	WC_COMPANY_MANAGER_FACE,
+
+	/**
+	 * Select station (when joining stations); %Window numbers:
+	 *   - 0 = #JoinStationWidgets
+	 */
+	WC_SELECT_STATION,
+
+	/**
+	 * News window; %Window numbers:
+	 *   - 0 = #NewsWidgets
+	 */
+	WC_NEWS_WINDOW,
+
+	/**
+	 * Town directory; %Window numbers:
+	 *   - 0 = #TownDirectoryWidgets
+	 */
+	WC_TOWN_DIRECTORY,
+
+	/**
+	 * Subsidies list; %Window numbers:
+	 *   - 0 = #SubsidyListWidgets
+	 */
+	WC_SUBSIDIES_LIST,
+
+	/**
+	 * Industry directory; %Window numbers:
+	 *   - 0 = #IndustryDirectoryWidgets
+	 */
+	WC_INDUSTRY_DIRECTORY,
+
+	/**
+	 * News history list; %Window numbers:
+	 *   - 0 = #MessageHistoryWidgets
+	 */
+	WC_MESSAGE_HISTORY,
+
+	/**
+	 * Sign list; %Window numbers:
+	 *   - 0 = #SignListWidgets
+	 */
+	WC_SIGN_LIST,
+
+	/**
+	 * AI list; %Window numbers:
+	 *   - 0 = #AIListWidgets
+	 */
+	WC_AI_LIST,
+
+	/**
+	 * Goals list; %Window numbers:
+	 *   - 0 ; #GoalListWidgets
+	 */
+	WC_GOALS_LIST,
+
+
+	/**
+	 * Station list; %Window numbers:
+	 *   - #CompanyID = #StationListWidgets
+	 */
+	WC_STATION_LIST,
+
+	/**
+	 * Trains list; %Window numbers:
+	 *   - Packed value = #GroupListWidgets / #VehicleListWidgets
+	 */
+	WC_TRAINS_LIST,
+
+	/**
+	 * Road vehicle list; %Window numbers:
+	 *   - Packed value = #GroupListWidgets / #VehicleListWidgets
+	 */
+	WC_ROADVEH_LIST,
+
+	/**
+	 * Ships list; %Window numbers:
+	 *   - Packed value = #GroupListWidgets / #VehicleListWidgets
+	 */
+	WC_SHIPS_LIST,
+
+	/**
+	 * Aircraft list; %Window numbers:
+	 *   - Packed value = #GroupListWidgets / #VehicleListWidgets
+	 */
+	WC_AIRCRAFT_LIST,
+
+
+	/**
+	 * Town view; %Window numbers:
+	 *   - #TownID = #TownViewWidgets
+	 */
+	WC_TOWN_VIEW,
+
+	/**
+	 * Vehicle view; %Window numbers:
+	 *   - #VehicleID = #VehicleViewWidgets
+	 */
+	WC_VEHICLE_VIEW,
+
+	/**
+	 * Station view; %Window numbers:
+	 *   - #StationID = #StationViewWidgets
+	 */
+	WC_STATION_VIEW,
+
+	/**
+	 * Depot view; %Window numbers:
+	 *   - #TileIndex = #DepotWidgets
+	 */
+	WC_VEHICLE_DEPOT,
+
+	/**
+	 * Waypoint view; %Window numbers:
+	 *   - #WaypointID = #WaypointWidgets
+	 */
+	WC_WAYPOINT_VIEW,
+
+	/**
+	 * Industry view; %Window numbers:
+	 *   - #IndustryID = #IndustryViewWidgets
+	 */
+	WC_INDUSTRY_VIEW,
+
+	/**
+	 * Company view; %Window numbers:
+	 *   - #CompanyID = #CompanyWidgets
+	 */
+	WC_COMPANY,
+
+
+	/**
+	 * Build object; %Window numbers:
+	 *   - 0 = #BuildObjectWidgets
+	 */
+	WC_BUILD_OBJECT,
+
+	/**
+	 * Build vehicle; %Window numbers:
+	 *   - #VehicleType = #BuildVehicleWidgets
+	 *   - #TileIndex = #BuildVehicleWidgets
+	 */
+	WC_BUILD_VEHICLE,
+
+	/**
+	 * Build bridge; %Window numbers:
+	 *   - #TransportType = #BuildBridgeSelectionWidgets
+	 */
+	WC_BUILD_BRIDGE,
+
+	/**
+	 * Build station; %Window numbers:
+	 *   - #TRANSPORT_AIR = #AirportPickerWidgets
+	 *   - #TRANSPORT_WATER = #DockToolbarWidgets
+	 *   - #TRANSPORT_RAIL = #BuildRailStationWidgets
+	 */
+	WC_BUILD_STATION,
+
+	/**
+	 * Build bus station; %Window numbers:
+	 *   - #TRANSPORT_ROAD = #BuildRoadStationWidgets
+	 */
+	WC_BUS_STATION,
+
+	/**
+	 * Build truck station; %Window numbers:
+	 *   - #TRANSPORT_ROAD = #BuildRoadStationWidgets
+	 */
+	WC_TRUCK_STATION,
+
+	/**
+	 * Build depot; %Window numbers:
+	 *   - #TRANSPORT_WATER = #BuildDockDepotWidgets
+	 *   - #TRANSPORT_RAIL = #BuildRailDepotWidgets
+	 *   - #TRANSPORT_ROAD = #BuildRoadDepotWidgets
+	 */
+	WC_BUILD_DEPOT,
+
+	/**
+	 * Build waypoint; %Window numbers:
+	 *   - #TRANSPORT_RAIL = #BuildRailWaypointWidgets
+	 */
+	WC_BUILD_WAYPOINT,
+
+	/**
+	 * Found a town; %Window numbers:
+	 *   - 0 = #TownFoundingWidgets
+	 */
+	WC_FOUND_TOWN,
+
+	/**
+	 * Build industry; %Window numbers:
+	 *   - 0 = #DynamicPlaceIndustriesWidgets
+	 */
+	WC_BUILD_INDUSTRY,
+
+
+	/**
+	 * Select game window; %Window numbers:
+	 *   - 0 = #SelectGameIntroWidgets
+	 */
+	WC_SELECT_GAME,
+
+	/**
+	 * Landscape generation (in Scenario Editor); %Window numbers:
+	 *   - 0 = #TerraformToolbarWidgets
+	 *   - 0 = #EditorTerraformToolbarWidgets
+	 */
+	WC_SCEN_LAND_GEN,
+
+	/**
+	 * Generate landscape (newgame); %Window numbers:
+	 *   - GLWM_SCENARIO = #CreateScenarioWidgets
+	 *   - #GenenerateLandscapeWindowMode = #GenerateLandscapeWidgets
+	 */
+	WC_GENERATE_LANDSCAPE,
+
+	/**
+	 * Progress report of landscape generation; %Window numbers:
+	 *   - 0 = #GenerationProgressWidgets
+	 *   - 1 = #ScanProgressWidgets
+	 */
+	WC_MODAL_PROGRESS,
+
+
+	/**
+	 * Network window; %Window numbers:
+	 *   - #WN_NETWORK_WINDOW_GAME = #NetworkGameWidgets
+	 *   - #WN_NETWORK_WINDOW_LOBBY = #NetworkLobbyWidgets
+	 *   - #WN_NETWORK_WINDOW_CONTENT_LIST = #NetworkContentListWidgets
+	 *   - #WN_NETWORK_WINDOW_START = #NetworkStartServerWidgets
+	 */
+	WC_NETWORK_WINDOW,
+
+	/**
+	 * Client list; %Window numbers:
+	 *   - 0 = #ClientListWidgets
+	 */
+	WC_CLIENT_LIST,
+
+	/**
+	 * Popup for the client list; %Window numbers:
+	 *   - #ClientID = #ClientListPopupWidgets
+	 */
+	WC_CLIENT_LIST_POPUP,
+
+	/**
+	 * Network status window; %Window numbers:
+	 *   - #WN_NETWORK_STATUS_WINDOW_JOIN = #NetworkJoinStatusWidgets
+	 *   - #WN_NETWORK_STATUS_WINDOW_CONTENT_DOWNLOAD = #NetworkContentDownloadStatusWidgets
+	 */
+	WC_NETWORK_STATUS_WINDOW,
+
+	/**
+	 * Chatbox; %Window numbers:
+	 *   - #DestType = #NetWorkChatWidgets
+	 */
+	WC_SEND_NETWORK_MSG,
+
+	/**
+	 * Company password query; %Window numbers:
+	 *   - 0 = #NetworkCompanyPasswordWidgets
+	 */
+	WC_COMPANY_PASSWORD_WINDOW,
+
+
+	/**
+	 * Industry cargoes chain; %Window numbers:
+	 *   - 0 = #IndustryCargoesWidgets
+	 */
+	WC_INDUSTRY_CARGOES,
+
+	/**
+	 * Legend for graphs; %Window numbers:
+	 *   - 0 = #GraphLegendWidgets
+	 */
+	WC_GRAPH_LEGEND,
+
+	/**
+	 * Finances of a company; %Window numbers:
+	 *   - #CompanyID = #CompanyWidgets
+	 */
+	WC_FINANCES,
+
+	/**
+	 * Income graph; %Window numbers:
+	 *   - 0 = #CompanyValueWidgets
+	 */
+	WC_INCOME_GRAPH,
+
+	/**
+	 * Operating profit graph; %Window numbers:
+	 *   - 0 = #CompanyValueWidgets
+	 */
+	WC_OPERATING_PROFIT,
+
+	/**
+	 * Delivered cargo graph; %Window numbers:
+	 *   - 0 = #CompanyValueWidgets
+	 */
+	WC_DELIVERED_CARGO,
+
+	/**
+	 * Performance history graph; %Window numbers:
+	 *   - 0 = #PerformanceHistoryGraphWidgets
+	 */
+	WC_PERFORMANCE_HISTORY,
+
+	/**
+	 * Company value graph; %Window numbers:
+	 *   - 0 = #CompanyValueWidgets
+	 */
+	WC_COMPANY_VALUE,
+
+	/**
+	 * Company league window; %Window numbers:
+	 *   - 0 = #CompanyLeagueWidgets
+	 */
+	WC_COMPANY_LEAGUE,
+
+	/**
+	 * Payment rates graph; %Window numbers:
+	 *   - 0 = #CargoPaymentRatesWidgets
+	 */
+	WC_PAYMENT_RATES,
+
+	/**
+	 * Performance detail window; %Window numbers:
+	 *   - 0 = #PerformanceRatingDetailsWidgets
+	 */
+	WC_PERFORMANCE_DETAIL,
+
+	/**
+	 * Company infrastructure overview; %Window numbers:
+	 *   - #CompanyID = #CompanyInfrastructureWidgets
+	 */
+	WC_COMPANY_INFRASTRUCTURE,
+
+
+	/**
+	 * Buyout company (merger); %Window numbers:
+	 *   - #CompanyID = #BuyCompanyWidgets
+	 */
+	WC_BUY_COMPANY,
+
+	/**
+	 * Engine preview window; %Window numbers:
+	 *   - #EngineID = #EnginePreviewWidgets
+	 */
+	WC_ENGINE_PREVIEW,
+
+
+	/**
+	 * Music window; %Window numbers:
+	 *   - 0 = #MusicWidgets
+	 */
+	WC_MUSIC_WINDOW,
+
+	/**
+	 * Music track selection; %Window numbers:
+	 *   - 0 = MusicTrackSelectionWidgets
+	 */
+	WC_MUSIC_TRACK_SELECTION,
+
+	/**
+	 * Game options window; %Window numbers:
+	 *   - #WN_GAME_OPTIONS_AI = #AIConfigWidgets
+	 *   - #WN_GAME_OPTIONS_ABOUT = #AboutWidgets
+	 *   - #WN_GAME_OPTIONS_NEWGRF_STATE = #NewGRFStateWidgets
+	 *   - #WN_GAME_OPTIONS_GAME_OPTIONS = #GameOptionsWidgets
+	 *   - #WN_GAME_OPTIONS_GAME_SETTINGS = #GameSettingsWidgets
+	 */
+	WC_GAME_OPTIONS,
+
+	/**
+	 * Custom currency; %Window numbers:
+	 *   - 0 = #CustomCurrencyWidgets
+	 */
+	WC_CUSTOM_CURRENCY,
+
+	/**
+	 * Cheat window; %Window numbers:
+	 *   - 0 = #CheatWidgets
+	 */
+	WC_CHEATS,
+
+	/**
+	 * Extra viewport; %Window numbers:
+	 *   - Ascending value = #ExtraViewportWidgets
+	 */
+	WC_EXTRA_VIEW_PORT,
+
+
+	/**
+	 * Console; %Window numbers:
+	 *   - 0 = #ConsoleWidgets
+	 */
+	WC_CONSOLE,
+
+	/**
+	 * Bootstrap; %Window numbers:
+	 *   - 0 = #BootstrapBackgroundWidgets
+	 */
+	WC_BOOTSTRAP,
+
+	/**
+	 * Highscore; %Window numbers:
+	 *   - 0 = #HighscoreWidgets
+	 */
+	WC_HIGHSCORE,
+
+	/**
+	 * Endscreen; %Window numbers:
+	 *   - 0 = #HighscoreWidgets
+	 */
+	WC_ENDSCREEN,
+
+
+	/**
+	 * AI debug window; %Window numbers:
+	 *   - 0 = #AIDebugWidgets
+	 */
+	WC_AI_DEBUG,
+
+	/**
+	 * NewGRF inspect (debug); %Window numbers:
+	 *   - Packed value = #NewGRFInspectWidgets
+	 */
+	WC_NEWGRF_INSPECT,
+
+	/**
+	 * Sprite aligner (debug); %Window numbers:
+	 *   - 0 = #SpriteAlignerWidgets
+	 */
+	WC_SPRITE_ALIGNER,
+
+	WC_INVALID = 0xFFFF, ///< Invalid window.
+};
+
+/** Data value for #Window::OnInvalidateData() of windows with class #WC_GAME_OPTIONS. */
+enum GameOptionsInvalidationData {
+	GOID_DEFAULT = 0,
+	GOID_NEWGRF_RESCANNED,     ///< NewGRFs were just rescanned.
+	GOID_NEWGRF_LIST_EDITED,   ///< List of active NewGRFs is being edited.
+	GOID_NEWGRF_PRESET_LOADED, ///< A NewGRF preset was picked.
+};
+
+struct Window;
+
+/** Number to differentiate different windows of the same class */
+typedef int32 WindowNumber;
+
+#endif /* WINDOW_TYPE_H */
