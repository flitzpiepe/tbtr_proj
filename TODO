
updated:    2018-12-19


STACK
	- cache sprite + width for each template, rm unneeded attrs
		! initialization doesn't work from the ctor and during the drawing loop the tv obj is const...
		? why does the order have to be this way
	- create template
		- ensure scrolling for long templates
		- gui components
			- edit selected template or create a new one
			- button: build -> append new template vehicle
			? free drag and drop between existing templates
		- ensure template sanity

OLD STACK
	! fails when calling the new operator
		* but is not a good idea anyways because some extra steps are done in the cmd_build function which would need
		  to be replicated anyway
		? maybe missing necessary steps can be reimplemented for the templates specifically
			- add articulated parts (can be retrieved from the engine obj)
			- img, can be retrieved from the engine
			? how to get the display width for the gui
				? the only thing really unkown is the cached vehicle length in gcache.cached_veh_length
					* train_cmd:450
						return ScaleGUITrad(this->gcache.cached_veh_length * reference_width / VEHICLE_LENGTH);
					* train_cmd:217
						u->gcache.cached_veh_length = veh_len;
						veh_len = VEHICLE_LENGTH - Clamp(veh_len, 0, VEHICLE_LENGTH - 1);
						veh_len = GetVehicleProperty(u, PROP_TRAIN_SHORTEN_FACTOR, CALLBACK_FAILED);
						* newgrf_engine:1094
							return GetEngineProperty(v->engine_type, property, orig_value, v);
							??? needs another f**** vehicle
							-> will need the vehicleresolverobj again
			-> check the spritegroup header
				* engine contains a spritegroup struct or something
	- test
	- new train needs to have the correct engine
	- use a temp train
	- create template
		- keeps a tmpl ptr internally for the new tmpl, which is used to append tmpl veh as long as the window is open
		- tests
			- inherit from veh build gui
				! currently not possible, no header file
				- test: add header for the class
				- test: add boolean member to say whether it should build a train or template
			- draw vehicle engine/template with storing the image given by a train
				! too complicated...
					- test: when a template is created, create a temp train object, get its image + width and delete the train
					again...
					- lots of problems finding the custom sprite id for an engine...
					- draw templates by using DrawVehicleEngine()
					! don't have the spritenum for the engine
			- use a temp train 
				* should fail since too many infos are initialized only during the build command


TODO
	- remove tbtr_debug.h includes


LATER
	- rename all TRW_WIDGET_TMPL_ elements
	- normalize {} convention for switch-case
	- TemplateVehicle::Draw(): refactor params, e.g. 'right' is not even used
	- autoreplacement: it would be better to still do it if tbtr is impossible, e.g. due to current money
		- allow scheduling of both
		- move tbtr before autorpl in callvehticks
		? prevent autorepl for a train if tbtr succeeded
			* e.g. by removing it from the mapping
	- scheduling of tbtr
		- check if group of train has a template
		- check if train already matches the template
		- autoreplace handles start/stop of the vehicle via CmdStartStopVehicle(), l.708
	- the selected group index should be updated to stick with the current group if another group is added or removed
		- same for the templates list
	- clone from existing template
		? what happens right now when doing this
		* could be useful when the editing is available or just to set other options
    ? all header includes into cpp files
	? template options stored in group instead of template
		* in order to configure each template replacement indiviually, without the need of a new template each
		  time
		- display template replacement options in group row
	- show floating money cost numbers after a replacement
	- TemplateVehicle::CalculateCost() might also include the refit cost and maybe more
		? use the command functions to do this simulation
		- cache the total cost in the template itself
			- cached_total_cost
	*** GUI is currently running with this->owner==_local_company
		* watch out for possible side effects because this has never been the case before
	- prevent multiple instances of the tbtr gui
	- check all loops and ifs in this file for {} convention
	- check for unused functions
	- check when group + template list are being rebuilt
		* TbtrGui::OnPaint doesn't rebuild the template list but rebuilds the groups list
		* either both should be rebuilt or none
		- check all occurrences of the rebuild funcs and see if they're needed everywhere
	? is it necessary to have the owner specified in the tbtr gui
		* should be always the _local_company
	! add missing documentation
		- also review the comment for the CmdTemplateReplace function
	- templatevehicle: remove or rename the bool methods (getters)
	- calc # trains that still need replacement + update the main gui accordingly
		* commented code still exists
    ? remove TemplateVehicle::prev
    ? rename all .h -> .hpp
    - remove prev and first from TV
	- impl macro: for all templates from->to
		* e.g.: TbtrGui::DrawTemplates
	- untested: warning string for free-wagon-chains
		* because with cloning we cannot create such a template, will need to wait for the edit function
	- see how ..._TMPLRPL_EX_DIFF_RAILTYPE was used in the old code and either reintegrate it or remove it
	  from the lang file
	- compute the line_height for the tbtr gui, without this being an external param
	? is TemplateVehicle::index really necessary
		* might be defined via PoolItem's index already, the TemplatePool is defined with TemplateID as a template parameter
	? deal with parent groups
	...

FUNCTIONALITIES TO INTEGRATE
    - list templates
    - replace all vehicles in template
    - template replacement
    - list template details
    - test TbtrGui::BuildTemplateList()
        *(this->templates.Append()) = tv;
    - tbtrgui should have the owner as member
        - refactor all methods which get an Owner as parameter
    ? needed, maybe rm
        template_vehicle.h : TemplateID FindTemplateIndexForGroup(GroupID);


PATCH FEATURES

- train gui, extra menu point, manage list -> Template Replacement

- gui: Template Replacement
    - list groups
    - list templates
    - list train details for selected template
    - set selected template options
        - use veh in depot
        - keep rems
        - use refit

- create new template train
- edit existing template train
- delete template train
- replace all vehicles in a template train
- start/stop replacing group's trains -> template train
- select rail type for template replacement


FILES MODIFIED BY THE PATCH 0.701

    ects/openttd_vs100.vcxproj
    ects/openttd_vs100.vcxproj.filters
    ects/openttd_vs80.vcproj
    ects/openttd_vs90.vcproj
    ce.list
    autoreplace_cmd.cpp
    autoreplace_func.h
    command.cpp
    command_type.h
    depot_gui.cpp
    group_cmd.cpp
    group_gui.cpp
    lang/english.txt
    newgrf.h
    newgrf_engine.cpp
    newgrf_spritegroup.cpp
    order_cmd.cpp
    saveload/afterload.cpp
    saveload/saveload.cpp
    saveload/saveload.h
    saveload/saveload_internal.h
    saveload/tbtr_template_replacement_sl.cpp
    saveload/tbtr_template_veh_sl.cpp
    tbtr_template_gui_create.cpp
    tbtr_template_gui_create.h
    tbtr_template_gui_create_virtualtrain.cpp
    tbtr_template_gui_create_virtualtrain.h
    tbtr_template_gui_main.cpp
    tbtr_template_gui_main.h
    tbtr_template_gui_replaceall.cpp
    tbtr_template_gui_replaceall.h
    tbtr_template_vehicle.cpp
    tbtr_template_vehicle.h
    tbtr_template_vehicle_func.cpp
    tbtr_template_vehicle_func.h
    train.h
    train_cmd.cpp
    vehicle.cpp
    vehicle_base.h
    vehicle_cmd.cpp
    vehicle_gui.cpp
    vehicle_gui.h
    vehicle_gui_base.h
    vehiclelist.cpp
    viewport.cpp
    widgets/build_vehicle_widget.h
    window_type.h
